// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum Architecture {
    case arm64
    case armhf
    case x8664
    case sdkUnknown(String)
}

extension Architecture : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Architecture] {
        return [
            .arm64,
            .armhf,
            .x8664,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .arm64: return "ARM64"
        case .armhf: return "ARMHF"
        case .x8664: return "X86_64"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Architecture(rawValue: rawValue) ?? Architecture.sdkUnknown(rawValue)
    }
}

public struct BatchDeleteWorldsInputBodyMiddleware: Middleware {
    public let id: String = "BatchDeleteWorldsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteWorldsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteWorldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteWorldsInput>
    public typealias MOutput = OperationOutput<BatchDeleteWorldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteWorldsOutputError>
}

extension BatchDeleteWorldsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteWorldsInput(worlds: \(String(describing: worlds)))"}
}

extension BatchDeleteWorldsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case worlds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let worlds = worlds {
            var worldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worlds)
            for arns0 in worlds {
                try worldsContainer.encode(arns0)
            }
        }
    }
}

public struct BatchDeleteWorldsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDeleteWorldsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteWorldsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteWorldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteWorldsInput>
    public typealias MOutput = OperationOutput<BatchDeleteWorldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteWorldsOutputError>
}

public struct BatchDeleteWorldsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDeleteWorldsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteWorldsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteWorldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteWorldsInput>
    public typealias MOutput = OperationOutput<BatchDeleteWorldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteWorldsOutputError>
}

public struct BatchDeleteWorldsInput: Equatable {
    /// <p>A list of Amazon Resource Names (arns) that correspond to worlds to delete.</p>
    public let worlds: [String]?

    public init (
        worlds: [String]? = nil
    )
    {
        self.worlds = worlds
    }
}

struct BatchDeleteWorldsInputBody: Equatable {
    public let worlds: [String]?
}

extension BatchDeleteWorldsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case worlds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .worlds)
        var worldsDecoded0:[String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
    }
}

extension BatchDeleteWorldsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteWorldsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteWorldsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteWorldsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteWorldsOutputResponse(unprocessedWorlds: \(String(describing: unprocessedWorlds)))"}
}

extension BatchDeleteWorldsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDeleteWorldsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.unprocessedWorlds = output.unprocessedWorlds
        } else {
            self.unprocessedWorlds = nil
        }
    }
}

public struct BatchDeleteWorldsOutputResponse: Equatable {
    /// <p>A list of unprocessed worlds associated with the call. These worlds were not
    ///          deleted.</p>
    public let unprocessedWorlds: [String]?

    public init (
        unprocessedWorlds: [String]? = nil
    )
    {
        self.unprocessedWorlds = unprocessedWorlds
    }
}

struct BatchDeleteWorldsOutputResponseBody: Equatable {
    public let unprocessedWorlds: [String]?
}

extension BatchDeleteWorldsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedWorlds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedWorldsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .unprocessedWorlds)
        var unprocessedWorldsDecoded0:[String]? = nil
        if let unprocessedWorldsContainer = unprocessedWorldsContainer {
            unprocessedWorldsDecoded0 = [String]()
            for string0 in unprocessedWorldsContainer {
                if let string0 = string0 {
                    unprocessedWorldsDecoded0?.append(string0)
                }
            }
        }
        unprocessedWorlds = unprocessedWorldsDecoded0
    }
}

public struct BatchDescribeSimulationJobInputBodyMiddleware: Middleware {
    public let id: String = "BatchDescribeSimulationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDescribeSimulationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDescribeSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDescribeSimulationJobInput>
    public typealias MOutput = OperationOutput<BatchDescribeSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDescribeSimulationJobOutputError>
}

extension BatchDescribeSimulationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDescribeSimulationJobInput(jobs: \(String(describing: jobs)))"}
}

extension BatchDescribeSimulationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobs
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobs = jobs {
            var jobsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobs)
            for arns0 in jobs {
                try jobsContainer.encode(arns0)
            }
        }
    }
}

public struct BatchDescribeSimulationJobInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDescribeSimulationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDescribeSimulationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDescribeSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDescribeSimulationJobInput>
    public typealias MOutput = OperationOutput<BatchDescribeSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDescribeSimulationJobOutputError>
}

public struct BatchDescribeSimulationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDescribeSimulationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDescribeSimulationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDescribeSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDescribeSimulationJobInput>
    public typealias MOutput = OperationOutput<BatchDescribeSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDescribeSimulationJobOutputError>
}

public struct BatchDescribeSimulationJobInput: Equatable {
    /// <p>A list of Amazon Resource Names (ARNs) of simulation jobs to describe.</p>
    public let jobs: [String]?

    public init (
        jobs: [String]? = nil
    )
    {
        self.jobs = jobs
    }
}

struct BatchDescribeSimulationJobInputBody: Equatable {
    public let jobs: [String]?
}

extension BatchDescribeSimulationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .jobs)
        var jobsDecoded0:[String]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [String]()
            for string0 in jobsContainer {
                if let string0 = string0 {
                    jobsDecoded0?.append(string0)
                }
            }
        }
        jobs = jobsDecoded0
    }
}

extension BatchDescribeSimulationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDescribeSimulationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDescribeSimulationJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDescribeSimulationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDescribeSimulationJobOutputResponse(jobs: \(String(describing: jobs)), unprocessedJobs: \(String(describing: unprocessedJobs)))"}
}

extension BatchDescribeSimulationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDescribeSimulationJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobs = output.jobs
            self.unprocessedJobs = output.unprocessedJobs
        } else {
            self.jobs = nil
            self.unprocessedJobs = nil
        }
    }
}

public struct BatchDescribeSimulationJobOutputResponse: Equatable {
    /// <p>A list of simulation jobs.</p>
    public let jobs: [SimulationJob]?
    /// <p>A list of unprocessed simulation job Amazon Resource Names (ARNs).</p>
    public let unprocessedJobs: [String]?

    public init (
        jobs: [SimulationJob]? = nil,
        unprocessedJobs: [String]? = nil
    )
    {
        self.jobs = jobs
        self.unprocessedJobs = unprocessedJobs
    }
}

struct BatchDescribeSimulationJobOutputResponseBody: Equatable {
    public let jobs: [SimulationJob]?
    public let unprocessedJobs: [String]?
}

extension BatchDescribeSimulationJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs
        case unprocessedJobs
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([SimulationJob?].self, forKey: .jobs)
        var jobsDecoded0:[SimulationJob]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [SimulationJob]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let unprocessedJobsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .unprocessedJobs)
        var unprocessedJobsDecoded0:[String]? = nil
        if let unprocessedJobsContainer = unprocessedJobsContainer {
            unprocessedJobsDecoded0 = [String]()
            for string0 in unprocessedJobsContainer {
                if let string0 = string0 {
                    unprocessedJobsDecoded0?.append(string0)
                }
            }
        }
        unprocessedJobs = unprocessedJobsDecoded0
    }
}

extension BatchPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxConcurrency
        case timeoutInSeconds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let timeoutInSeconds = timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
    }
}

extension BatchPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPolicy(maxConcurrency: \(String(describing: maxConcurrency)), timeoutInSeconds: \(String(describing: timeoutInSeconds)))"}
}

/// <p>Information about the batch policy.</p>
public struct BatchPolicy: Equatable {
    /// <p>The number of active simulation jobs create as part of the batch that can be in an
    ///          active state at the same time. </p>
    ///          <p>Active states include: <code>Pending</code>,<code>Preparing</code>,
    ///          <code>Running</code>, <code>Restarting</code>, <code>RunningFailed</code> and
    ///             <code>Terminating</code>. All other states are terminal states. </p>
    public let maxConcurrency: Int?
    /// <p>The amount of time, in seconds, to wait for the batch to complete.
    ///
    ///       </p>
    ///          <p>If a batch times out, and there are pending requests that were failing due to an
    ///          internal failure (like <code>InternalServiceError</code>), they will be moved to the failed
    ///          list and the batch status will be <code>Failed</code>. If the pending requests were failing
    ///          for any other reason, the failed pending requests will be moved to the failed list and the
    ///          batch status will be <code>TimedOut</code>. </p>
    public let timeoutInSeconds: Int?

    public init (
        maxConcurrency: Int? = nil,
        timeoutInSeconds: Int? = nil
    )
    {
        self.maxConcurrency = maxConcurrency
        self.timeoutInSeconds = timeoutInSeconds
    }
}

public struct CancelDeploymentJobInputBodyMiddleware: Middleware {
    public let id: String = "CancelDeploymentJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelDeploymentJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelDeploymentJobInput>
    public typealias MOutput = OperationOutput<CancelDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelDeploymentJobOutputError>
}

extension CancelDeploymentJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelDeploymentJobInput(job: \(String(describing: job)))"}
}

extension CancelDeploymentJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct CancelDeploymentJobInputHeadersMiddleware: Middleware {
    public let id: String = "CancelDeploymentJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelDeploymentJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelDeploymentJobInput>
    public typealias MOutput = OperationOutput<CancelDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelDeploymentJobOutputError>
}

public struct CancelDeploymentJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelDeploymentJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelDeploymentJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelDeploymentJobInput>
    public typealias MOutput = OperationOutput<CancelDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelDeploymentJobOutputError>
}

public struct CancelDeploymentJobInput: Equatable {
    /// <p>The deployment job ARN to cancel.</p>
    public let job: String?

    public init (
        job: String? = nil
    )
    {
        self.job = job
    }
}

struct CancelDeploymentJobInputBody: Equatable {
    public let job: String?
}

extension CancelDeploymentJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelDeploymentJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelDeploymentJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelDeploymentJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelDeploymentJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelDeploymentJobOutputResponse()"}
}

extension CancelDeploymentJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelDeploymentJobOutputResponse: Equatable {

    public init() {}
}

struct CancelDeploymentJobOutputResponseBody: Equatable {
}

extension CancelDeploymentJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CancelSimulationJobBatchInputBodyMiddleware: Middleware {
    public let id: String = "CancelSimulationJobBatchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelSimulationJobBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelSimulationJobBatchInput>
    public typealias MOutput = OperationOutput<CancelSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelSimulationJobBatchOutputError>
}

extension CancelSimulationJobBatchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelSimulationJobBatchInput(batch: \(String(describing: batch)))"}
}

extension CancelSimulationJobBatchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batch
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batch = batch {
            try encodeContainer.encode(batch, forKey: .batch)
        }
    }
}

public struct CancelSimulationJobBatchInputHeadersMiddleware: Middleware {
    public let id: String = "CancelSimulationJobBatchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelSimulationJobBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelSimulationJobBatchInput>
    public typealias MOutput = OperationOutput<CancelSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelSimulationJobBatchOutputError>
}

public struct CancelSimulationJobBatchInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelSimulationJobBatchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelSimulationJobBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelSimulationJobBatchInput>
    public typealias MOutput = OperationOutput<CancelSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelSimulationJobBatchOutputError>
}

public struct CancelSimulationJobBatchInput: Equatable {
    /// <p>The id of the batch to cancel.</p>
    public let batch: String?

    public init (
        batch: String? = nil
    )
    {
        self.batch = batch
    }
}

struct CancelSimulationJobBatchInputBody: Equatable {
    public let batch: String?
}

extension CancelSimulationJobBatchInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batch
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchDecoded = try containerValues.decodeIfPresent(String.self, forKey: .batch)
        batch = batchDecoded
    }
}

extension CancelSimulationJobBatchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelSimulationJobBatchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelSimulationJobBatchOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelSimulationJobBatchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelSimulationJobBatchOutputResponse()"}
}

extension CancelSimulationJobBatchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelSimulationJobBatchOutputResponse: Equatable {

    public init() {}
}

struct CancelSimulationJobBatchOutputResponseBody: Equatable {
}

extension CancelSimulationJobBatchOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CancelSimulationJobInputBodyMiddleware: Middleware {
    public let id: String = "CancelSimulationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelSimulationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelSimulationJobInput>
    public typealias MOutput = OperationOutput<CancelSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelSimulationJobOutputError>
}

extension CancelSimulationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelSimulationJobInput(job: \(String(describing: job)))"}
}

extension CancelSimulationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct CancelSimulationJobInputHeadersMiddleware: Middleware {
    public let id: String = "CancelSimulationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelSimulationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelSimulationJobInput>
    public typealias MOutput = OperationOutput<CancelSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelSimulationJobOutputError>
}

public struct CancelSimulationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelSimulationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelSimulationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelSimulationJobInput>
    public typealias MOutput = OperationOutput<CancelSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelSimulationJobOutputError>
}

public struct CancelSimulationJobInput: Equatable {
    /// <p>The simulation job ARN to cancel.</p>
    public let job: String?

    public init (
        job: String? = nil
    )
    {
        self.job = job
    }
}

struct CancelSimulationJobInputBody: Equatable {
    public let job: String?
}

extension CancelSimulationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelSimulationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelSimulationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelSimulationJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelSimulationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelSimulationJobOutputResponse()"}
}

extension CancelSimulationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelSimulationJobOutputResponse: Equatable {

    public init() {}
}

struct CancelSimulationJobOutputResponseBody: Equatable {
}

extension CancelSimulationJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CancelWorldExportJobInputBodyMiddleware: Middleware {
    public let id: String = "CancelWorldExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelWorldExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelWorldExportJobInput>
    public typealias MOutput = OperationOutput<CancelWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelWorldExportJobOutputError>
}

extension CancelWorldExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelWorldExportJobInput(job: \(String(describing: job)))"}
}

extension CancelWorldExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct CancelWorldExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "CancelWorldExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelWorldExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelWorldExportJobInput>
    public typealias MOutput = OperationOutput<CancelWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelWorldExportJobOutputError>
}

public struct CancelWorldExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelWorldExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelWorldExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelWorldExportJobInput>
    public typealias MOutput = OperationOutput<CancelWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelWorldExportJobOutputError>
}

public struct CancelWorldExportJobInput: Equatable {
    /// <p>The Amazon Resource Name (arn) of the world export job to cancel.</p>
    public let job: String?

    public init (
        job: String? = nil
    )
    {
        self.job = job
    }
}

struct CancelWorldExportJobInputBody: Equatable {
    public let job: String?
}

extension CancelWorldExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelWorldExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelWorldExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelWorldExportJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelWorldExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelWorldExportJobOutputResponse()"}
}

extension CancelWorldExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelWorldExportJobOutputResponse: Equatable {

    public init() {}
}

struct CancelWorldExportJobOutputResponseBody: Equatable {
}

extension CancelWorldExportJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CancelWorldGenerationJobInputBodyMiddleware: Middleware {
    public let id: String = "CancelWorldGenerationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelWorldGenerationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelWorldGenerationJobInput>
    public typealias MOutput = OperationOutput<CancelWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelWorldGenerationJobOutputError>
}

extension CancelWorldGenerationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelWorldGenerationJobInput(job: \(String(describing: job)))"}
}

extension CancelWorldGenerationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct CancelWorldGenerationJobInputHeadersMiddleware: Middleware {
    public let id: String = "CancelWorldGenerationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelWorldGenerationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelWorldGenerationJobInput>
    public typealias MOutput = OperationOutput<CancelWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelWorldGenerationJobOutputError>
}

public struct CancelWorldGenerationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelWorldGenerationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelWorldGenerationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelWorldGenerationJobInput>
    public typealias MOutput = OperationOutput<CancelWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelWorldGenerationJobOutputError>
}

public struct CancelWorldGenerationJobInput: Equatable {
    /// <p>The Amazon Resource Name (arn) of the world generator job to cancel.</p>
    public let job: String?

    public init (
        job: String? = nil
    )
    {
        self.job = job
    }
}

struct CancelWorldGenerationJobInputBody: Equatable {
    public let job: String?
}

extension CancelWorldGenerationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelWorldGenerationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelWorldGenerationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelWorldGenerationJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelWorldGenerationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelWorldGenerationJobOutputResponse()"}
}

extension CancelWorldGenerationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelWorldGenerationJobOutputResponse: Equatable {

    public init() {}
}

struct CancelWorldGenerationJobOutputResponseBody: Equatable {
}

extension CancelWorldGenerationJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Compute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case simulationUnitLimit
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simulationUnitLimit = simulationUnitLimit {
            try encodeContainer.encode(simulationUnitLimit, forKey: .simulationUnitLimit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationUnitLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .simulationUnitLimit)
        simulationUnitLimit = simulationUnitLimitDecoded
    }
}

extension Compute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Compute(simulationUnitLimit: \(String(describing: simulationUnitLimit)))"}
}

/// <p>Compute information for the simulation job.</p>
public struct Compute: Equatable {
    /// <p>The simulation unit limit. Your simulation is allocated CPU and memory proportional to
    ///          the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are
    ///          only billed for the SU utilization you consume up to the maximim value provided. The
    ///          default is 15. </p>
    public let simulationUnitLimit: Int?

    public init (
        simulationUnitLimit: Int? = nil
    )
    {
        self.simulationUnitLimit = simulationUnitLimit
    }
}

extension ComputeResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case simulationUnitLimit
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simulationUnitLimit = simulationUnitLimit {
            try encodeContainer.encode(simulationUnitLimit, forKey: .simulationUnitLimit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationUnitLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .simulationUnitLimit)
        simulationUnitLimit = simulationUnitLimitDecoded
    }
}

extension ComputeResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComputeResponse(simulationUnitLimit: \(String(describing: simulationUnitLimit)))"}
}

/// <p>Compute information for the simulation job</p>
public struct ComputeResponse: Equatable {
    /// <p>The simulation unit limit. Your simulation is allocated CPU and memory proportional to
    ///          the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are
    ///          only billed for the SU utilization you consume up to the maximim value provided. The
    ///          default is 15. </p>
    public let simulationUnitLimit: Int?

    public init (
        simulationUnitLimit: Int? = nil
    )
    {
        self.simulationUnitLimit = simulationUnitLimit
    }
}

extension ConcurrentDeploymentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentDeploymentException(message: \(String(describing: message)))"}
}

extension ConcurrentDeploymentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentDeploymentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The failure percentage threshold percentage was met.</p>
public struct ConcurrentDeploymentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentDeploymentExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentDeploymentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateDeploymentJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateDeploymentJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentJobInput>
    public typealias MOutput = OperationOutput<CreateDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentJobOutputError>
}

extension CreateDeploymentJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentJobInput(clientRequestToken: \(String(describing: clientRequestToken)), deploymentApplicationConfigs: \(String(describing: deploymentApplicationConfigs)), deploymentConfig: \(String(describing: deploymentConfig)), fleet: \(String(describing: fleet)), tags: \(String(describing: tags)))"}
}

extension CreateDeploymentJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case deploymentApplicationConfigs
        case deploymentConfig
        case fleet
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let deploymentApplicationConfigs = deploymentApplicationConfigs {
            var deploymentApplicationConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deploymentApplicationConfigs)
            for deploymentapplicationconfigs0 in deploymentApplicationConfigs {
                try deploymentApplicationConfigsContainer.encode(deploymentapplicationconfigs0)
            }
        }
        if let deploymentConfig = deploymentConfig {
            try encodeContainer.encode(deploymentConfig, forKey: .deploymentConfig)
        }
        if let fleet = fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDeploymentJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDeploymentJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentJobInput>
    public typealias MOutput = OperationOutput<CreateDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentJobOutputError>
}

public struct CreateDeploymentJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDeploymentJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentJobInput>
    public typealias MOutput = OperationOutput<CreateDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentJobOutputError>
}

public struct CreateDeploymentJobInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public var clientRequestToken: String?
    /// <p>The deployment application configuration.</p>
    public let deploymentApplicationConfigs: [DeploymentApplicationConfig]?
    /// <p>The requested deployment configuration.</p>
    public let deploymentConfig: DeploymentConfig?
    /// <p>The Amazon Resource Name (ARN) of the fleet to deploy.</p>
    public let fleet: String?
    /// <p>A map that contains tag keys and tag values that are attached to the deployment
    ///          job.</p>
    public let tags: [String:String]?

    public init (
        clientRequestToken: String? = nil,
        deploymentApplicationConfigs: [DeploymentApplicationConfig]? = nil,
        deploymentConfig: DeploymentConfig? = nil,
        fleet: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.fleet = fleet
        self.tags = tags
    }
}

struct CreateDeploymentJobInputBody: Equatable {
    public let deploymentConfig: DeploymentConfig?
    public let clientRequestToken: String?
    public let fleet: String?
    public let deploymentApplicationConfigs: [DeploymentApplicationConfig]?
    public let tags: [String:String]?
}

extension CreateDeploymentJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case deploymentApplicationConfigs
        case deploymentConfig
        case fleet
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleet)
        fleet = fleetDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeploymentJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentDeploymentException" : self = .concurrentDeploymentException(try ConcurrentDeploymentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeploymentJobOutputError: Equatable {
    case concurrentDeploymentException(ConcurrentDeploymentException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentJobOutputResponse(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), deploymentApplicationConfigs: \(String(describing: deploymentApplicationConfigs)), deploymentConfig: \(String(describing: deploymentConfig)), failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), fleet: \(String(describing: fleet)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

extension CreateDeploymentJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDeploymentJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.deploymentApplicationConfigs = output.deploymentApplicationConfigs
            self.deploymentConfig = output.deploymentConfig
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.fleet = output.fleet
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.deploymentApplicationConfigs = nil
            self.deploymentConfig = nil
            self.failureCode = nil
            self.failureReason = nil
            self.fleet = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct CreateDeploymentJobOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the deployment job.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the fleet was created.</p>
    public let createdAt: Date?
    /// <p>The deployment application configuration.</p>
    public let deploymentApplicationConfigs: [DeploymentApplicationConfig]?
    /// <p>The deployment configuration.</p>
    public let deploymentConfig: DeploymentConfig?
    /// <p>The failure code of the simulation job if it failed:</p>
    ///          <dl>
    ///             <dt>BadPermissionError</dt>
    ///             <dd>
    ///                <p>AWS Greengrass requires a service-level role permission to access other
    ///                   services. The role must include the <a href="https://console.aws.amazon.com/iam/home?#/policies/arn:aws:iam::aws:policy/service-role/AWSGreengrassResourceAccessRolePolicy$jsonEditor">
    ///                      <code>AWSGreengrassResourceAccessRolePolicy</code> managed policy</a>.
    ///                </p>
    ///             </dd>
    ///             <dt>ExtractingBundleFailure</dt>
    ///             <dd>
    ///                <p>The robot application could not be extracted from the bundle.</p>
    ///             </dd>
    ///             <dt>FailureThresholdBreached</dt>
    ///             <dd>
    ///                <p>The percentage of robots that could not be updated exceeded the percentage set
    ///                   for the deployment.</p>
    ///             </dd>
    ///             <dt>GreengrassDeploymentFailed</dt>
    ///             <dd>
    ///                <p>The robot application could not be deployed to the robot.</p>
    ///             </dd>
    ///             <dt>GreengrassGroupVersionDoesNotExist</dt>
    ///             <dd>
    ///                <p>The AWS Greengrass group or version associated with a robot is missing.</p>
    ///             </dd>
    ///             <dt>InternalServerError</dt>
    ///             <dd>
    ///                <p>An internal error has occurred. Retry your request, but if the problem
    ///                   persists, contact us with details.</p>
    ///             </dd>
    ///             <dt>MissingRobotApplicationArchitecture</dt>
    ///             <dd>
    ///                <p>The robot application does not have a source that matches the architecture of
    ///                   the robot.</p>
    ///             </dd>
    ///             <dt>MissingRobotDeploymentResource</dt>
    ///             <dd>
    ///                <p>One or more of the resources specified for the robot application are missing.
    ///                   For example, does the robot application have the correct launch package and launch
    ///                   file?</p>
    ///             </dd>
    ///             <dt>PostLaunchFileFailure</dt>
    ///             <dd>
    ///                <p>The post-launch script failed.</p>
    ///             </dd>
    ///             <dt>PreLaunchFileFailure</dt>
    ///             <dd>
    ///                <p>The pre-launch script failed.</p>
    ///             </dd>
    ///             <dt>ResourceNotFound</dt>
    ///             <dd>
    ///                <p>One or more deployment resources are missing. For example, do robot application
    ///                   source bundles still exist? </p>
    ///             </dd>
    ///             <dt>RobotDeploymentNoResponse</dt>
    ///             <dd>
    ///                <p>There is no response from the robot. It might not be powered on or connected to
    ///                   the internet.</p>
    ///             </dd>
    ///          </dl>
    public let failureCode: DeploymentJobErrorCode?
    /// <p>The failure reason of the deployment job if it failed.</p>
    public let failureReason: String?
    /// <p>The target fleet for the deployment job.</p>
    public let fleet: String?
    /// <p>The status of the deployment job.</p>
    public let status: DeploymentStatus?
    /// <p>The list of all tags added to the deployment job.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        deploymentApplicationConfigs: [DeploymentApplicationConfig]? = nil,
        deploymentConfig: DeploymentConfig? = nil,
        failureCode: DeploymentJobErrorCode? = nil,
        failureReason: String? = nil,
        fleet: String? = nil,
        status: DeploymentStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.status = status
        self.tags = tags
    }
}

struct CreateDeploymentJobOutputResponseBody: Equatable {
    public let arn: String?
    public let fleet: String?
    public let status: DeploymentStatus?
    public let deploymentApplicationConfigs: [DeploymentApplicationConfig]?
    public let failureReason: String?
    public let failureCode: DeploymentJobErrorCode?
    public let createdAt: Date?
    public let deploymentConfig: DeploymentConfig?
    public let tags: [String:String]?
}

extension CreateDeploymentJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case status
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateFleetInputBodyMiddleware: Middleware {
    public let id: String = "CreateFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFleetInput>
    public typealias MOutput = OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFleetOutputError>
}

extension CreateFleetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFleetInput(name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateFleetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateFleetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFleetInput>
    public typealias MOutput = OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFleetOutputError>
}

public struct CreateFleetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFleetInput>
    public typealias MOutput = OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFleetOutputError>
}

public struct CreateFleetInput: Equatable {
    /// <p>The name of the fleet.</p>
    public let name: String?
    /// <p>A map that contains tag keys and tag values that are attached to the fleet.</p>
    public let tags: [String:String]?

    public init (
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.name = name
        self.tags = tags
    }
}

struct CreateFleetInputBody: Equatable {
    public let name: String?
    public let tags: [String:String]?
}

extension CreateFleetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFleetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFleetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFleetOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFleetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFleetOutputResponse(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateFleetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFleetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct CreateFleetOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the fleet was created.</p>
    public let createdAt: Date?
    /// <p>The name of the fleet.</p>
    public let name: String?
    /// <p>The list of all tags added to the fleet.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.name = name
        self.tags = tags
    }
}

struct CreateFleetOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let createdAt: Date?
    public let tags: [String:String]?
}

extension CreateFleetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateRobotApplicationInputBodyMiddleware: Middleware {
    public let id: String = "CreateRobotApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRobotApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRobotApplicationInput>
    public typealias MOutput = OperationOutput<CreateRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRobotApplicationOutputError>
}

extension CreateRobotApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRobotApplicationInput(name: \(String(describing: name)), robotSoftwareSuite: \(String(describing: robotSoftwareSuite)), sources: \(String(describing: sources)), tags: \(String(describing: tags)))"}
}

extension CreateRobotApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case robotSoftwareSuite
        case sources
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotSoftwareSuite = robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfigs0 in sources {
                try sourcesContainer.encode(sourceconfigs0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRobotApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRobotApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRobotApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRobotApplicationInput>
    public typealias MOutput = OperationOutput<CreateRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRobotApplicationOutputError>
}

public struct CreateRobotApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRobotApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRobotApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRobotApplicationInput>
    public typealias MOutput = OperationOutput<CreateRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRobotApplicationOutputError>
}

public struct CreateRobotApplicationInput: Equatable {
    /// <p>The name of the robot application.</p>
    public let name: String?
    /// <p>The robot software suite (ROS distribuition) used by the robot application.</p>
    public let robotSoftwareSuite: RobotSoftwareSuite?
    /// <p>The sources of the robot application.</p>
    public let sources: [SourceConfig]?
    /// <p>A map that contains tag keys and tag values that are attached to the robot
    ///          application.</p>
    public let tags: [String:String]?

    public init (
        name: String? = nil,
        robotSoftwareSuite: RobotSoftwareSuite? = nil,
        sources: [SourceConfig]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.name = name
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.tags = tags
    }
}

struct CreateRobotApplicationInputBody: Equatable {
    public let name: String?
    public let sources: [SourceConfig]?
    public let robotSoftwareSuite: RobotSoftwareSuite?
    public let tags: [String:String]?
}

extension CreateRobotApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
        case robotSoftwareSuite
        case sources
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRobotApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRobotApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRobotApplicationOutputError: Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRobotApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRobotApplicationOutputResponse(arn: \(String(describing: arn)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)), revisionId: \(String(describing: revisionId)), robotSoftwareSuite: \(String(describing: robotSoftwareSuite)), sources: \(String(describing: sources)), tags: \(String(describing: tags)), version: \(String(describing: version)))"}
}

extension CreateRobotApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRobotApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct CreateRobotApplicationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the robot application.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the robot application was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the robot application.</p>
    public let name: String?
    /// <p>The revision id of the robot application.</p>
    public let revisionId: String?
    /// <p>The robot software suite (ROS distribution) used by the robot application.</p>
    public let robotSoftwareSuite: RobotSoftwareSuite?
    /// <p>The sources of the robot application.</p>
    public let sources: [Source]?
    /// <p>The list of all tags added to the robot application.</p>
    public let tags: [String:String]?
    /// <p>The version of the robot application.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil,
        revisionId: String? = nil,
        robotSoftwareSuite: RobotSoftwareSuite? = nil,
        sources: [Source]? = nil,
        tags: [String:String]? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct CreateRobotApplicationOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let version: String?
    public let sources: [Source]?
    public let robotSoftwareSuite: RobotSoftwareSuite?
    public let lastUpdatedAt: Date?
    public let revisionId: String?
    public let tags: [String:String]?
}

extension CreateRobotApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case tags
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([Source?].self, forKey: .sources)
        var sourcesDecoded0:[Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateRobotApplicationVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateRobotApplicationVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRobotApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRobotApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRobotApplicationVersionInput>
    public typealias MOutput = OperationOutput<CreateRobotApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRobotApplicationVersionOutputError>
}

extension CreateRobotApplicationVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRobotApplicationVersionInput(application: \(String(describing: application)), currentRevisionId: \(String(describing: currentRevisionId)))"}
}

extension CreateRobotApplicationVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case application
        case currentRevisionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
    }
}

public struct CreateRobotApplicationVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRobotApplicationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRobotApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRobotApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRobotApplicationVersionInput>
    public typealias MOutput = OperationOutput<CreateRobotApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRobotApplicationVersionOutputError>
}

public struct CreateRobotApplicationVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRobotApplicationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRobotApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRobotApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRobotApplicationVersionInput>
    public typealias MOutput = OperationOutput<CreateRobotApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRobotApplicationVersionOutputError>
}

public struct CreateRobotApplicationVersionInput: Equatable {
    /// <p>The application information for the robot application.</p>
    public let application: String?
    /// <p>The current revision id for the robot application. If you provide a value and it matches
    ///          the latest revision ID, a new version will be created.</p>
    public let currentRevisionId: String?

    public init (
        application: String? = nil,
        currentRevisionId: String? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
    }
}

struct CreateRobotApplicationVersionInputBody: Equatable {
    public let application: String?
    public let currentRevisionId: String?
}

extension CreateRobotApplicationVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case application
        case currentRevisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .application)
        application = applicationDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
    }
}

extension CreateRobotApplicationVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRobotApplicationVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRobotApplicationVersionOutputError: Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRobotApplicationVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRobotApplicationVersionOutputResponse(arn: \(String(describing: arn)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)), revisionId: \(String(describing: revisionId)), robotSoftwareSuite: \(String(describing: robotSoftwareSuite)), sources: \(String(describing: sources)), version: \(String(describing: version)))"}
}

extension CreateRobotApplicationVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRobotApplicationVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct CreateRobotApplicationVersionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the robot application.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the robot application was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the robot application.</p>
    public let name: String?
    /// <p>The revision id of the robot application.</p>
    public let revisionId: String?
    /// <p>The robot software suite (ROS distribution) used by the robot application.</p>
    public let robotSoftwareSuite: RobotSoftwareSuite?
    /// <p>The sources of the robot application.</p>
    public let sources: [Source]?
    /// <p>The version of the robot application.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil,
        revisionId: String? = nil,
        robotSoftwareSuite: RobotSoftwareSuite? = nil,
        sources: [Source]? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct CreateRobotApplicationVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let version: String?
    public let sources: [Source]?
    public let robotSoftwareSuite: RobotSoftwareSuite?
    public let lastUpdatedAt: Date?
    public let revisionId: String?
}

extension CreateRobotApplicationVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([Source?].self, forKey: .sources)
        var sourcesDecoded0:[Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

public struct CreateRobotInputBodyMiddleware: Middleware {
    public let id: String = "CreateRobotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRobotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRobotInput>
    public typealias MOutput = OperationOutput<CreateRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRobotOutputError>
}

extension CreateRobotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRobotInput(architecture: \(String(describing: architecture)), greengrassGroupId: \(String(describing: greengrassGroupId)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateRobotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case architecture
        case greengrassGroupId
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let greengrassGroupId = greengrassGroupId {
            try encodeContainer.encode(greengrassGroupId, forKey: .greengrassGroupId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRobotInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRobotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRobotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRobotInput>
    public typealias MOutput = OperationOutput<CreateRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRobotOutputError>
}

public struct CreateRobotInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRobotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRobotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRobotInput>
    public typealias MOutput = OperationOutput<CreateRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRobotOutputError>
}

public struct CreateRobotInput: Equatable {
    /// <p>The target architecture of the robot.</p>
    public let architecture: Architecture?
    /// <p>The Greengrass group id.</p>
    public let greengrassGroupId: String?
    /// <p>The name for the robot.</p>
    public let name: String?
    /// <p>A map that contains tag keys and tag values that are attached to the robot.</p>
    public let tags: [String:String]?

    public init (
        architecture: Architecture? = nil,
        greengrassGroupId: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.architecture = architecture
        self.greengrassGroupId = greengrassGroupId
        self.name = name
        self.tags = tags
    }
}

struct CreateRobotInputBody: Equatable {
    public let name: String?
    public let architecture: Architecture?
    public let greengrassGroupId: String?
    public let tags: [String:String]?
}

extension CreateRobotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case architecture
        case greengrassGroupId
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let greengrassGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .greengrassGroupId)
        greengrassGroupId = greengrassGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRobotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRobotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRobotOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRobotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRobotOutputResponse(architecture: \(String(describing: architecture)), arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), greengrassGroupId: \(String(describing: greengrassGroupId)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateRobotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRobotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.architecture = output.architecture
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.greengrassGroupId = output.greengrassGroupId
            self.name = output.name
            self.tags = output.tags
        } else {
            self.architecture = nil
            self.arn = nil
            self.createdAt = nil
            self.greengrassGroupId = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct CreateRobotOutputResponse: Equatable {
    /// <p>The target architecture of the robot.</p>
    public let architecture: Architecture?
    /// <p>The Amazon Resource Name (ARN) of the robot.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the robot was created.</p>
    public let createdAt: Date?
    /// <p>The Amazon Resource Name (ARN) of the Greengrass group associated with the robot.</p>
    public let greengrassGroupId: String?
    /// <p>The name of the robot.</p>
    public let name: String?
    /// <p>The list of all tags added to the robot.</p>
    public let tags: [String:String]?

    public init (
        architecture: Architecture? = nil,
        arn: String? = nil,
        createdAt: Date? = nil,
        greengrassGroupId: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.architecture = architecture
        self.arn = arn
        self.createdAt = createdAt
        self.greengrassGroupId = greengrassGroupId
        self.name = name
        self.tags = tags
    }
}

struct CreateRobotOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let createdAt: Date?
    public let greengrassGroupId: String?
    public let architecture: Architecture?
    public let tags: [String:String]?
}

extension CreateRobotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case architecture
        case arn
        case createdAt
        case greengrassGroupId
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let greengrassGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .greengrassGroupId)
        greengrassGroupId = greengrassGroupIdDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateSimulationApplicationInputBodyMiddleware: Middleware {
    public let id: String = "CreateSimulationApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSimulationApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSimulationApplicationInput>
    public typealias MOutput = OperationOutput<CreateSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSimulationApplicationOutputError>
}

extension CreateSimulationApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSimulationApplicationInput(name: \(String(describing: name)), renderingEngine: \(String(describing: renderingEngine)), robotSoftwareSuite: \(String(describing: robotSoftwareSuite)), simulationSoftwareSuite: \(String(describing: simulationSoftwareSuite)), sources: \(String(describing: sources)), tags: \(String(describing: tags)))"}
}

extension CreateSimulationApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let renderingEngine = renderingEngine {
            try encodeContainer.encode(renderingEngine, forKey: .renderingEngine)
        }
        if let robotSoftwareSuite = robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let simulationSoftwareSuite = simulationSoftwareSuite {
            try encodeContainer.encode(simulationSoftwareSuite, forKey: .simulationSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfigs0 in sources {
                try sourcesContainer.encode(sourceconfigs0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateSimulationApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSimulationApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSimulationApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSimulationApplicationInput>
    public typealias MOutput = OperationOutput<CreateSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSimulationApplicationOutputError>
}

public struct CreateSimulationApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSimulationApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSimulationApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSimulationApplicationInput>
    public typealias MOutput = OperationOutput<CreateSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSimulationApplicationOutputError>
}

public struct CreateSimulationApplicationInput: Equatable {
    /// <p>The name of the simulation application.</p>
    public let name: String?
    /// <p>The rendering engine for the simulation application.</p>
    public let renderingEngine: RenderingEngine?
    /// <p>The robot software suite (ROS distribution) used by the simulation application.</p>
    public let robotSoftwareSuite: RobotSoftwareSuite?
    /// <p>The simulation software suite used by the simulation application.</p>
    public let simulationSoftwareSuite: SimulationSoftwareSuite?
    /// <p>The sources of the simulation application.</p>
    public let sources: [SourceConfig]?
    /// <p>A map that contains tag keys and tag values that are attached to the simulation
    ///          application.</p>
    public let tags: [String:String]?

    public init (
        name: String? = nil,
        renderingEngine: RenderingEngine? = nil,
        robotSoftwareSuite: RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: SimulationSoftwareSuite? = nil,
        sources: [SourceConfig]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.name = name
        self.renderingEngine = renderingEngine
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.tags = tags
    }
}

struct CreateSimulationApplicationInputBody: Equatable {
    public let name: String?
    public let sources: [SourceConfig]?
    public let simulationSoftwareSuite: SimulationSoftwareSuite?
    public let robotSoftwareSuite: RobotSoftwareSuite?
    public let renderingEngine: RenderingEngine?
    public let tags: [String:String]?
}

extension CreateSimulationApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSimulationApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSimulationApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSimulationApplicationOutputError: Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSimulationApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSimulationApplicationOutputResponse(arn: \(String(describing: arn)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)), renderingEngine: \(String(describing: renderingEngine)), revisionId: \(String(describing: revisionId)), robotSoftwareSuite: \(String(describing: robotSoftwareSuite)), simulationSoftwareSuite: \(String(describing: simulationSoftwareSuite)), sources: \(String(describing: sources)), tags: \(String(describing: tags)), version: \(String(describing: version)))"}
}

extension CreateSimulationApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSimulationApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct CreateSimulationApplicationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the simulation application.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the simulation application was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the simulation application.</p>
    public let name: String?
    /// <p>The rendering engine for the simulation application.</p>
    public let renderingEngine: RenderingEngine?
    /// <p>The revision id of the simulation application.</p>
    public let revisionId: String?
    /// <p>Information about the robot software suite (ROS distribution).</p>
    public let robotSoftwareSuite: RobotSoftwareSuite?
    /// <p>The simulation software suite used by the simulation application.</p>
    public let simulationSoftwareSuite: SimulationSoftwareSuite?
    /// <p>The sources of the simulation application.</p>
    public let sources: [Source]?
    /// <p>The list of all tags added to the simulation application.</p>
    public let tags: [String:String]?
    /// <p>The version of the simulation application.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil,
        renderingEngine: RenderingEngine? = nil,
        revisionId: String? = nil,
        robotSoftwareSuite: RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: SimulationSoftwareSuite? = nil,
        sources: [Source]? = nil,
        tags: [String:String]? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct CreateSimulationApplicationOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let version: String?
    public let sources: [Source]?
    public let simulationSoftwareSuite: SimulationSoftwareSuite?
    public let robotSoftwareSuite: RobotSoftwareSuite?
    public let renderingEngine: RenderingEngine?
    public let lastUpdatedAt: Date?
    public let revisionId: String?
    public let tags: [String:String]?
}

extension CreateSimulationApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([Source?].self, forKey: .sources)
        var sourcesDecoded0:[Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateSimulationApplicationVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateSimulationApplicationVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSimulationApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSimulationApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSimulationApplicationVersionInput>
    public typealias MOutput = OperationOutput<CreateSimulationApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSimulationApplicationVersionOutputError>
}

extension CreateSimulationApplicationVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSimulationApplicationVersionInput(application: \(String(describing: application)), currentRevisionId: \(String(describing: currentRevisionId)))"}
}

extension CreateSimulationApplicationVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case application
        case currentRevisionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
    }
}

public struct CreateSimulationApplicationVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSimulationApplicationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSimulationApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSimulationApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSimulationApplicationVersionInput>
    public typealias MOutput = OperationOutput<CreateSimulationApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSimulationApplicationVersionOutputError>
}

public struct CreateSimulationApplicationVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSimulationApplicationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSimulationApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSimulationApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSimulationApplicationVersionInput>
    public typealias MOutput = OperationOutput<CreateSimulationApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSimulationApplicationVersionOutputError>
}

public struct CreateSimulationApplicationVersionInput: Equatable {
    /// <p>The application information for the simulation application.</p>
    public let application: String?
    /// <p>The current revision id for the simulation application. If you provide a value and it
    ///          matches the latest revision ID, a new version will be created.</p>
    public let currentRevisionId: String?

    public init (
        application: String? = nil,
        currentRevisionId: String? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
    }
}

struct CreateSimulationApplicationVersionInputBody: Equatable {
    public let application: String?
    public let currentRevisionId: String?
}

extension CreateSimulationApplicationVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case application
        case currentRevisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .application)
        application = applicationDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
    }
}

extension CreateSimulationApplicationVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSimulationApplicationVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSimulationApplicationVersionOutputError: Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSimulationApplicationVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSimulationApplicationVersionOutputResponse(arn: \(String(describing: arn)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)), renderingEngine: \(String(describing: renderingEngine)), revisionId: \(String(describing: revisionId)), robotSoftwareSuite: \(String(describing: robotSoftwareSuite)), simulationSoftwareSuite: \(String(describing: simulationSoftwareSuite)), sources: \(String(describing: sources)), version: \(String(describing: version)))"}
}

extension CreateSimulationApplicationVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSimulationApplicationVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct CreateSimulationApplicationVersionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the simulation application.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the simulation application was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the simulation application.</p>
    public let name: String?
    /// <p>The rendering engine for the simulation application.</p>
    public let renderingEngine: RenderingEngine?
    /// <p>The revision ID of the simulation application.</p>
    public let revisionId: String?
    /// <p>Information about the robot software suite (ROS distribution).</p>
    public let robotSoftwareSuite: RobotSoftwareSuite?
    /// <p>The simulation software suite used by the simulation application.</p>
    public let simulationSoftwareSuite: SimulationSoftwareSuite?
    /// <p>The sources of the simulation application.</p>
    public let sources: [Source]?
    /// <p>The version of the simulation application.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil,
        renderingEngine: RenderingEngine? = nil,
        revisionId: String? = nil,
        robotSoftwareSuite: RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: SimulationSoftwareSuite? = nil,
        sources: [Source]? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct CreateSimulationApplicationVersionOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let version: String?
    public let sources: [Source]?
    public let simulationSoftwareSuite: SimulationSoftwareSuite?
    public let robotSoftwareSuite: RobotSoftwareSuite?
    public let renderingEngine: RenderingEngine?
    public let lastUpdatedAt: Date?
    public let revisionId: String?
}

extension CreateSimulationApplicationVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([Source?].self, forKey: .sources)
        var sourcesDecoded0:[Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

public struct CreateSimulationJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateSimulationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSimulationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSimulationJobInput>
    public typealias MOutput = OperationOutput<CreateSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSimulationJobOutputError>
}

extension CreateSimulationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSimulationJobInput(clientRequestToken: \(String(describing: clientRequestToken)), compute: \(String(describing: compute)), dataSources: \(String(describing: dataSources)), failureBehavior: \(String(describing: failureBehavior)), iamRole: \(String(describing: iamRole)), loggingConfig: \(String(describing: loggingConfig)), maxJobDurationInSeconds: \(String(describing: maxJobDurationInSeconds)), outputLocation: \(String(describing: outputLocation)), robotApplications: \(String(describing: robotApplications)), simulationApplications: \(String(describing: simulationApplications)), tags: \(String(describing: tags)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension CreateSimulationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case iamRole
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case tags
        case vpcConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let compute = compute {
            try encodeContainer.encode(compute, forKey: .compute)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasourceconfigs0 in dataSources {
                try dataSourcesContainer.encode(datasourceconfigs0)
            }
        }
        if let failureBehavior = failureBehavior {
            try encodeContainer.encode(failureBehavior.rawValue, forKey: .failureBehavior)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let loggingConfig = loggingConfig {
            try encodeContainer.encode(loggingConfig, forKey: .loggingConfig)
        }
        if maxJobDurationInSeconds != 0 {
            try encodeContainer.encode(maxJobDurationInSeconds, forKey: .maxJobDurationInSeconds)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let robotApplications = robotApplications {
            var robotApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplications)
            for robotapplicationconfigs0 in robotApplications {
                try robotApplicationsContainer.encode(robotapplicationconfigs0)
            }
        }
        if let simulationApplications = simulationApplications {
            var simulationApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplications)
            for simulationapplicationconfigs0 in simulationApplications {
                try simulationApplicationsContainer.encode(simulationapplicationconfigs0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct CreateSimulationJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSimulationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSimulationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSimulationJobInput>
    public typealias MOutput = OperationOutput<CreateSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSimulationJobOutputError>
}

public struct CreateSimulationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSimulationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSimulationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSimulationJobInput>
    public typealias MOutput = OperationOutput<CreateSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSimulationJobOutputError>
}

public struct CreateSimulationJobInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public var clientRequestToken: String?
    /// <p>Compute information for the simulation job.</p>
    public let compute: Compute?
    /// <p>Specify data sources to mount read-only files from S3 into your simulation. These files
    ///          are available under <code>/opt/robomaker/datasources/data_source_name</code>. </p>
    ///          <note>
    ///             <p>There is a limit of 100 files and a combined size of 25GB for all
    ///                <code>DataSourceConfig</code> objects. </p>
    ///          </note>
    public let dataSources: [DataSourceConfig]?
    /// <p>The failure behavior the simulation job.</p>
    ///          <dl>
    ///             <dt>Continue</dt>
    ///             <dd>
    ///                <p>Restart the simulation job in the same host instance.</p>
    ///             </dd>
    ///             <dt>Fail</dt>
    ///             <dd>
    ///                <p>Stop the simulation job and terminate the instance.</p>
    ///             </dd>
    ///          </dl>
    public let failureBehavior: FailureBehavior?
    /// <p>The IAM role name that allows the simulation instance to call the AWS APIs that are
    ///          specified in its associated policies on your behalf. This is how credentials are passed in
    ///          to your simulation job. </p>
    public let iamRole: String?
    /// <p>The logging configuration.</p>
    public let loggingConfig: LoggingConfig?
    /// <p>The maximum simulation job duration in seconds (up to 14 days or 1,209,600 seconds. When
    ///             <code>maxJobDurationInSeconds</code> is reached, the simulation job will status will
    ///          transition to <code>Completed</code>.</p>
    public let maxJobDurationInSeconds: Int
    /// <p>Location for output files generated by the simulation job.</p>
    public let outputLocation: OutputLocation?
    /// <p>The robot application to use in the simulation job.</p>
    public let robotApplications: [RobotApplicationConfig]?
    /// <p>The simulation application to use in the simulation job.</p>
    public let simulationApplications: [SimulationApplicationConfig]?
    /// <p>A map that contains tag keys and tag values that are attached to the simulation
    ///          job.</p>
    public let tags: [String:String]?
    /// <p>If your simulation job accesses resources in a VPC, you provide this parameter
    ///          identifying the list of security group IDs and subnet IDs. These must belong to the same
    ///          VPC. You must provide at least one security group and one subnet ID. </p>
    public let vpcConfig: VPCConfig?

    public init (
        clientRequestToken: String? = nil,
        compute: Compute? = nil,
        dataSources: [DataSourceConfig]? = nil,
        failureBehavior: FailureBehavior? = nil,
        iamRole: String? = nil,
        loggingConfig: LoggingConfig? = nil,
        maxJobDurationInSeconds: Int = 0,
        outputLocation: OutputLocation? = nil,
        robotApplications: [RobotApplicationConfig]? = nil,
        simulationApplications: [SimulationApplicationConfig]? = nil,
        tags: [String:String]? = nil,
        vpcConfig: VPCConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.iamRole = iamRole
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateSimulationJobInputBody: Equatable {
    public let clientRequestToken: String?
    public let outputLocation: OutputLocation?
    public let loggingConfig: LoggingConfig?
    public let maxJobDurationInSeconds: Int
    public let iamRole: String?
    public let failureBehavior: FailureBehavior?
    public let robotApplications: [RobotApplicationConfig]?
    public let simulationApplications: [SimulationApplicationConfig]?
    public let dataSources: [DataSourceConfig]?
    public let tags: [String:String]?
    public let vpcConfig: VPCConfig?
    public let compute: Compute?
}

extension CreateSimulationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case iamRole
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case tags
        case vpcConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decode(Int.self, forKey: .maxJobDurationInSeconds)
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([DataSourceConfig?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[DataSourceConfig]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [DataSourceConfig]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VPCConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let computeDecoded = try containerValues.decodeIfPresent(Compute.self, forKey: .compute)
        compute = computeDecoded
    }
}

extension CreateSimulationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSimulationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSimulationJobOutputError: Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSimulationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSimulationJobOutputResponse(arn: \(String(describing: arn)), clientRequestToken: \(String(describing: clientRequestToken)), compute: \(String(describing: compute)), dataSources: \(String(describing: dataSources)), failureBehavior: \(String(describing: failureBehavior)), failureCode: \(String(describing: failureCode)), iamRole: \(String(describing: iamRole)), lastStartedAt: \(String(describing: lastStartedAt)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), loggingConfig: \(String(describing: loggingConfig)), maxJobDurationInSeconds: \(String(describing: maxJobDurationInSeconds)), outputLocation: \(String(describing: outputLocation)), robotApplications: \(String(describing: robotApplications)), simulationApplications: \(String(describing: simulationApplications)), simulationTimeMillis: \(String(describing: simulationTimeMillis)), status: \(String(describing: status)), tags: \(String(describing: tags)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension CreateSimulationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSimulationJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.compute = output.compute
            self.dataSources = output.dataSources
            self.failureBehavior = output.failureBehavior
            self.failureCode = output.failureCode
            self.iamRole = output.iamRole
            self.lastStartedAt = output.lastStartedAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.loggingConfig = output.loggingConfig
            self.maxJobDurationInSeconds = output.maxJobDurationInSeconds
            self.outputLocation = output.outputLocation
            self.robotApplications = output.robotApplications
            self.simulationApplications = output.simulationApplications
            self.simulationTimeMillis = output.simulationTimeMillis
            self.status = output.status
            self.tags = output.tags
            self.vpcConfig = output.vpcConfig
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.compute = nil
            self.dataSources = nil
            self.failureBehavior = nil
            self.failureCode = nil
            self.iamRole = nil
            self.lastStartedAt = nil
            self.lastUpdatedAt = nil
            self.loggingConfig = nil
            self.maxJobDurationInSeconds = 0
            self.outputLocation = nil
            self.robotApplications = nil
            self.simulationApplications = nil
            self.simulationTimeMillis = 0
            self.status = nil
            self.tags = nil
            self.vpcConfig = nil
        }
    }
}

public struct CreateSimulationJobOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the simulation job.</p>
    public let arn: String?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public let clientRequestToken: String?
    /// <p>Compute information for the simulation job.</p>
    public let compute: ComputeResponse?
    /// <p>The data sources for the simulation job.</p>
    public let dataSources: [DataSource]?
    /// <p>the failure behavior for the simulation job.</p>
    public let failureBehavior: FailureBehavior?
    /// <p>The failure code of the simulation job if it failed:</p>
    ///          <dl>
    ///             <dt>InternalServiceError</dt>
    ///             <dd>
    ///                <p>Internal service error.</p>
    ///             </dd>
    ///             <dt>RobotApplicationCrash</dt>
    ///             <dd>
    ///                <p>Robot application exited abnormally.</p>
    ///             </dd>
    ///             <dt>SimulationApplicationCrash</dt>
    ///             <dd>
    ///                <p> Simulation application exited abnormally.</p>
    ///             </dd>
    ///             <dt>BadPermissionsRobotApplication</dt>
    ///             <dd>
    ///                <p>Robot application bundle could not be downloaded.</p>
    ///             </dd>
    ///             <dt>BadPermissionsSimulationApplication</dt>
    ///             <dd>
    ///                <p>Simulation application bundle could not be downloaded.</p>
    ///             </dd>
    ///             <dt>BadPermissionsS3Output</dt>
    ///             <dd>
    ///                <p>Unable to publish outputs to customer-provided S3 bucket.</p>
    ///             </dd>
    ///             <dt>BadPermissionsCloudwatchLogs</dt>
    ///             <dd>
    ///                <p>Unable to publish logs to customer-provided CloudWatch Logs resource.</p>
    ///             </dd>
    ///             <dt>SubnetIpLimitExceeded</dt>
    ///             <dd>
    ///                <p>Subnet IP limit exceeded.</p>
    ///             </dd>
    ///             <dt>ENILimitExceeded</dt>
    ///             <dd>
    ///                <p>ENI limit exceeded.</p>
    ///             </dd>
    ///             <dt>BadPermissionsUserCredentials</dt>
    ///             <dd>
    ///                <p>Unable to use the Role provided.</p>
    ///             </dd>
    ///             <dt>InvalidBundleRobotApplication</dt>
    ///             <dd>
    ///                <p>Robot bundle cannot be extracted (invalid format, bundling error, or other
    ///                   issue).</p>
    ///             </dd>
    ///             <dt>InvalidBundleSimulationApplication</dt>
    ///             <dd>
    ///                <p>Simulation bundle cannot be extracted (invalid format, bundling error, or other
    ///                   issue).</p>
    ///             </dd>
    ///             <dt>RobotApplicationVersionMismatchedEtag</dt>
    ///             <dd>
    ///                <p>Etag for RobotApplication does not match value during version creation.</p>
    ///             </dd>
    ///             <dt>SimulationApplicationVersionMismatchedEtag</dt>
    ///             <dd>
    ///                <p>Etag for SimulationApplication does not match value during version
    ///                   creation.</p>
    ///             </dd>
    ///          </dl>
    public let failureCode: SimulationJobErrorCode?
    /// <p>The IAM role that allows the simulation job to call the AWS APIs that are specified in
    ///          its associated policies on your behalf.</p>
    public let iamRole: String?
    /// <p>The time, in milliseconds since the epoch, when the simulation job was last
    ///          started.</p>
    public let lastStartedAt: Date?
    /// <p>The time, in milliseconds since the epoch, when the simulation job was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The logging configuration.</p>
    public let loggingConfig: LoggingConfig?
    /// <p>The maximum simulation job duration in seconds. </p>
    public let maxJobDurationInSeconds: Int
    /// <p>Simulation job output files location.</p>
    public let outputLocation: OutputLocation?
    /// <p>The robot application used by the simulation job.</p>
    public let robotApplications: [RobotApplicationConfig]?
    /// <p>The simulation application used by the simulation job.</p>
    public let simulationApplications: [SimulationApplicationConfig]?
    /// <p>The simulation job execution duration in milliseconds.</p>
    public let simulationTimeMillis: Int
    /// <p>The status of the simulation job.</p>
    public let status: SimulationJobStatus?
    /// <p>The list of all tags added to the simulation job.</p>
    public let tags: [String:String]?
    /// <p>Information about the vpc configuration.</p>
    public let vpcConfig: VPCConfigResponse?

    public init (
        arn: String? = nil,
        clientRequestToken: String? = nil,
        compute: ComputeResponse? = nil,
        dataSources: [DataSource]? = nil,
        failureBehavior: FailureBehavior? = nil,
        failureCode: SimulationJobErrorCode? = nil,
        iamRole: String? = nil,
        lastStartedAt: Date? = nil,
        lastUpdatedAt: Date? = nil,
        loggingConfig: LoggingConfig? = nil,
        maxJobDurationInSeconds: Int = 0,
        outputLocation: OutputLocation? = nil,
        robotApplications: [RobotApplicationConfig]? = nil,
        simulationApplications: [SimulationApplicationConfig]? = nil,
        simulationTimeMillis: Int = 0,
        status: SimulationJobStatus? = nil,
        tags: [String:String]? = nil,
        vpcConfig: VPCConfigResponse? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.failureCode = failureCode
        self.iamRole = iamRole
        self.lastStartedAt = lastStartedAt
        self.lastUpdatedAt = lastUpdatedAt
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.simulationTimeMillis = simulationTimeMillis
        self.status = status
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateSimulationJobOutputResponseBody: Equatable {
    public let arn: String?
    public let status: SimulationJobStatus?
    public let lastStartedAt: Date?
    public let lastUpdatedAt: Date?
    public let failureBehavior: FailureBehavior?
    public let failureCode: SimulationJobErrorCode?
    public let clientRequestToken: String?
    public let outputLocation: OutputLocation?
    public let loggingConfig: LoggingConfig?
    public let maxJobDurationInSeconds: Int
    public let simulationTimeMillis: Int
    public let iamRole: String?
    public let robotApplications: [RobotApplicationConfig]?
    public let simulationApplications: [SimulationApplicationConfig]?
    public let dataSources: [DataSource]?
    public let tags: [String:String]?
    public let vpcConfig: VPCConfigResponse?
    public let compute: ComputeResponse?
}

extension CreateSimulationJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case failureCode
        case iamRole
        case lastStartedAt
        case lastUpdatedAt
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case simulationTimeMillis
        case status
        case tags
        case vpcConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let lastStartedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastStartedAt)
        lastStartedAt = lastStartedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decode(Int.self, forKey: .maxJobDurationInSeconds)
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let simulationTimeMillisDecoded = try containerValues.decode(Int.self, forKey: .simulationTimeMillis)
        simulationTimeMillis = simulationTimeMillisDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VPCConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let computeDecoded = try containerValues.decodeIfPresent(ComputeResponse.self, forKey: .compute)
        compute = computeDecoded
    }
}

public struct CreateWorldExportJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateWorldExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorldExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorldExportJobInput>
    public typealias MOutput = OperationOutput<CreateWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorldExportJobOutputError>
}

extension CreateWorldExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorldExportJobInput(clientRequestToken: \(String(describing: clientRequestToken)), iamRole: \(String(describing: iamRole)), outputLocation: \(String(describing: outputLocation)), tags: \(String(describing: tags)), worlds: \(String(describing: worlds)))"}
}

extension CreateWorldExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case iamRole
        case outputLocation
        case tags
        case worlds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let worlds = worlds {
            var worldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worlds)
            for arns0 in worlds {
                try worldsContainer.encode(arns0)
            }
        }
    }
}

public struct CreateWorldExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWorldExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorldExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorldExportJobInput>
    public typealias MOutput = OperationOutput<CreateWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorldExportJobOutputError>
}

public struct CreateWorldExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWorldExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorldExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorldExportJobInput>
    public typealias MOutput = OperationOutput<CreateWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorldExportJobOutputError>
}

public struct CreateWorldExportJobInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public var clientRequestToken: String?
    /// <p>The IAM role that the world export process uses to access the Amazon S3 bucket and put
    ///          the export.</p>
    public let iamRole: String?
    /// <p>The output location.</p>
    public let outputLocation: OutputLocation?
    /// <p>A map that contains tag keys and tag values that are attached to the world export
    ///          job.</p>
    public let tags: [String:String]?
    /// <p>A list of Amazon Resource Names (arns) that correspond to worlds to export.</p>
    public let worlds: [String]?

    public init (
        clientRequestToken: String? = nil,
        iamRole: String? = nil,
        outputLocation: OutputLocation? = nil,
        tags: [String:String]? = nil,
        worlds: [String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.iamRole = iamRole
        self.outputLocation = outputLocation
        self.tags = tags
        self.worlds = worlds
    }
}

struct CreateWorldExportJobInputBody: Equatable {
    public let clientRequestToken: String?
    public let worlds: [String]?
    public let outputLocation: OutputLocation?
    public let iamRole: String?
    public let tags: [String:String]?
}

extension CreateWorldExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case iamRole
        case outputLocation
        case tags
        case worlds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let worldsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .worlds)
        var worldsDecoded0:[String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
        let outputLocationDecoded = try containerValues.decodeIfPresent(OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorldExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorldExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorldExportJobOutputError: Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorldExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorldExportJobOutputResponse(arn: \(String(describing: arn)), clientRequestToken: \(String(describing: clientRequestToken)), createdAt: \(String(describing: createdAt)), failureCode: \(String(describing: failureCode)), iamRole: \(String(describing: iamRole)), outputLocation: \(String(describing: outputLocation)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

extension CreateWorldExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWorldExportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.iamRole = output.iamRole
            self.outputLocation = output.outputLocation
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.iamRole = nil
            self.outputLocation = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct CreateWorldExportJobOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the world export job.</p>
    public let arn: String?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public let clientRequestToken: String?
    /// <p>The time, in milliseconds since the epoch, when the world export job was created.</p>
    public let createdAt: Date?
    /// <p>The failure code of the world export job if it failed:</p>
    ///          <dl>
    ///             <dt>InternalServiceError</dt>
    ///             <dd>
    ///                <p>Internal service error.</p>
    ///             </dd>
    ///             <dt>LimitExceeded</dt>
    ///             <dd>
    ///                <p>The requested resource exceeds the maximum number allowed, or the number of
    ///                   concurrent stream requests exceeds the maximum number allowed. </p>
    ///             </dd>
    ///             <dt>ResourceNotFound</dt>
    ///             <dd>
    ///                <p>The specified resource could not be found. </p>
    ///             </dd>
    ///             <dt>RequestThrottled</dt>
    ///             <dd>
    ///                <p>The request was throttled.</p>
    ///             </dd>
    ///             <dt>InvalidInput</dt>
    ///             <dd>
    ///                <p>An input parameter in the request is not valid.</p>
    ///             </dd>
    ///             <dt>AllWorldGenerationFailed</dt>
    ///             <dd>
    ///                <p>All of the worlds in the world generation job failed. This can happen if your
    ///                      <code>worldCount</code> is greater than 50 or less than 1. </p>
    ///             </dd>
    ///          </dl>
    ///          <p>For more information about troubleshooting WorldForge, see <a href="https://docs.aws.amazon.com/robomaker/latest/dg/troubleshooting-worldforge.html">Troubleshooting Simulation WorldForge</a>. </p>
    public let failureCode: WorldExportJobErrorCode?
    /// <p>The IAM role that the world export process uses to access the Amazon S3 bucket and put
    ///          the export. </p>
    public let iamRole: String?
    /// <p>The output location.</p>
    public let outputLocation: OutputLocation?
    /// <p>The status of the world export job.</p>
    ///          <dl>
    ///             <dt>Pending</dt>
    ///             <dd>
    ///                <p>The world export job request is pending.</p>
    ///             </dd>
    ///             <dt>Running</dt>
    ///             <dd>
    ///                <p>The world export job is running. </p>
    ///             </dd>
    ///             <dt>Completed</dt>
    ///             <dd>
    ///                <p>The world export job completed. </p>
    ///             </dd>
    ///             <dt>Failed</dt>
    ///             <dd>
    ///                <p>The world export job failed. See <code>failureCode</code> for more information.
    ///                </p>
    ///             </dd>
    ///             <dt>Canceled</dt>
    ///             <dd>
    ///                <p>The world export job was cancelled.</p>
    ///             </dd>
    ///             <dt>Canceling</dt>
    ///             <dd>
    ///                <p>The world export job is being cancelled.</p>
    ///             </dd>
    ///          </dl>
    public let status: WorldExportJobStatus?
    /// <p>A map that contains tag keys and tag values that are attached to the world export
    ///          job.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        clientRequestToken: String? = nil,
        createdAt: Date? = nil,
        failureCode: WorldExportJobErrorCode? = nil,
        iamRole: String? = nil,
        outputLocation: OutputLocation? = nil,
        status: WorldExportJobStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.iamRole = iamRole
        self.outputLocation = outputLocation
        self.status = status
        self.tags = tags
    }
}

struct CreateWorldExportJobOutputResponseBody: Equatable {
    public let arn: String?
    public let status: WorldExportJobStatus?
    public let createdAt: Date?
    public let failureCode: WorldExportJobErrorCode?
    public let clientRequestToken: String?
    public let outputLocation: OutputLocation?
    public let iamRole: String?
    public let tags: [String:String]?
}

extension CreateWorldExportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case iamRole
        case outputLocation
        case status
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorldExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(WorldExportJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateWorldGenerationJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateWorldGenerationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorldGenerationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorldGenerationJobInput>
    public typealias MOutput = OperationOutput<CreateWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorldGenerationJobOutputError>
}

extension CreateWorldGenerationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorldGenerationJobInput(clientRequestToken: \(String(describing: clientRequestToken)), tags: \(String(describing: tags)), template: \(String(describing: template)), worldCount: \(String(describing: worldCount)), worldTags: \(String(describing: worldTags)))"}
}

extension CreateWorldGenerationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case tags
        case template
        case worldCount
        case worldTags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
        if let worldCount = worldCount {
            try encodeContainer.encode(worldCount, forKey: .worldCount)
        }
        if let worldTags = worldTags {
            var worldTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .worldTags)
            for (dictKey0, tagmap0) in worldTags {
                try worldTagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateWorldGenerationJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWorldGenerationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorldGenerationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorldGenerationJobInput>
    public typealias MOutput = OperationOutput<CreateWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorldGenerationJobOutputError>
}

public struct CreateWorldGenerationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWorldGenerationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorldGenerationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorldGenerationJobInput>
    public typealias MOutput = OperationOutput<CreateWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorldGenerationJobOutputError>
}

public struct CreateWorldGenerationJobInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public var clientRequestToken: String?
    /// <p>A map that contains tag keys and tag values that are attached to the world generator
    ///          job.</p>
    public let tags: [String:String]?
    /// <p>The Amazon Resource Name (arn) of the world template describing the worlds you want to
    ///          create.</p>
    public let template: String?
    /// <p>Information about the world count.</p>
    public let worldCount: WorldCount?
    /// <p>A map that contains tag keys and tag values that are attached to the generated
    ///          worlds.</p>
    public let worldTags: [String:String]?

    public init (
        clientRequestToken: String? = nil,
        tags: [String:String]? = nil,
        template: String? = nil,
        worldCount: WorldCount? = nil,
        worldTags: [String:String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.tags = tags
        self.template = template
        self.worldCount = worldCount
        self.worldTags = worldTags
    }
}

struct CreateWorldGenerationJobInputBody: Equatable {
    public let clientRequestToken: String?
    public let template: String?
    public let worldCount: WorldCount?
    public let tags: [String:String]?
    public let worldTags: [String:String]?
}

extension CreateWorldGenerationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case tags
        case template
        case worldCount
        case worldTags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let templateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .template)
        template = templateDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let worldTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .worldTags)
        var worldTagsDecoded0: [String:String]? = nil
        if let worldTagsContainer = worldTagsContainer {
            worldTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in worldTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    worldTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        worldTags = worldTagsDecoded0
    }
}

extension CreateWorldGenerationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorldGenerationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorldGenerationJobOutputError: Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorldGenerationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorldGenerationJobOutputResponse(arn: \(String(describing: arn)), clientRequestToken: \(String(describing: clientRequestToken)), createdAt: \(String(describing: createdAt)), failureCode: \(String(describing: failureCode)), status: \(String(describing: status)), tags: \(String(describing: tags)), template: \(String(describing: template)), worldCount: \(String(describing: worldCount)), worldTags: \(String(describing: worldTags)))"}
}

extension CreateWorldGenerationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWorldGenerationJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.status = output.status
            self.tags = output.tags
            self.template = output.template
            self.worldCount = output.worldCount
            self.worldTags = output.worldTags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.status = nil
            self.tags = nil
            self.template = nil
            self.worldCount = nil
            self.worldTags = nil
        }
    }
}

public struct CreateWorldGenerationJobOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the world generator job.</p>
    public let arn: String?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public let clientRequestToken: String?
    /// <p>The time, in milliseconds since the epoch, when the world generator job was
    ///          created.</p>
    public let createdAt: Date?
    /// <p>The failure code of the world generator job if it failed:</p>
    ///          <dl>
    ///             <dt>InternalServiceError</dt>
    ///             <dd>
    ///                <p>Internal service error.</p>
    ///             </dd>
    ///             <dt>LimitExceeded</dt>
    ///             <dd>
    ///                <p>The requested resource exceeds the maximum number allowed, or the number of
    ///                   concurrent stream requests exceeds the maximum number allowed. </p>
    ///             </dd>
    ///             <dt>ResourceNotFound</dt>
    ///             <dd>
    ///                <p>The specified resource could not be found. </p>
    ///             </dd>
    ///             <dt>RequestThrottled</dt>
    ///             <dd>
    ///                <p>The request was throttled.</p>
    ///             </dd>
    ///             <dt>InvalidInput</dt>
    ///             <dd>
    ///                <p>An input parameter in the request is not valid.</p>
    ///             </dd>
    ///          </dl>
    public let failureCode: WorldGenerationJobErrorCode?
    /// <p>The status of the world generator job.</p>
    ///          <dl>
    ///             <dt>Pending</dt>
    ///             <dd>
    ///                <p>The world generator job request is pending.</p>
    ///             </dd>
    ///             <dt>Running</dt>
    ///             <dd>
    ///                <p>The world generator job is running. </p>
    ///             </dd>
    ///             <dt>Completed</dt>
    ///             <dd>
    ///                <p>The world generator job completed. </p>
    ///             </dd>
    ///             <dt>Failed</dt>
    ///             <dd>
    ///                <p>The world generator job failed. See <code>failureCode</code> for more
    ///                   information. </p>
    ///             </dd>
    ///             <dt>PartialFailed</dt>
    ///             <dd>
    ///                <p>Some worlds did not generate.</p>
    ///             </dd>
    ///             <dt>Canceled</dt>
    ///             <dd>
    ///                <p>The world generator job was cancelled.</p>
    ///             </dd>
    ///             <dt>Canceling</dt>
    ///             <dd>
    ///                <p>The world generator job is being cancelled.</p>
    ///             </dd>
    ///          </dl>
    public let status: WorldGenerationJobStatus?
    /// <p>A map that contains tag keys and tag values that are attached to the world generator
    ///          job.</p>
    public let tags: [String:String]?
    /// <p>The Amazon Resource Name (arn) of the world template.</p>
    public let template: String?
    /// <p>Information about the world count. </p>
    public let worldCount: WorldCount?
    /// <p>A map that contains tag keys and tag values that are attached to the generated
    ///          worlds.</p>
    public let worldTags: [String:String]?

    public init (
        arn: String? = nil,
        clientRequestToken: String? = nil,
        createdAt: Date? = nil,
        failureCode: WorldGenerationJobErrorCode? = nil,
        status: WorldGenerationJobStatus? = nil,
        tags: [String:String]? = nil,
        template: String? = nil,
        worldCount: WorldCount? = nil,
        worldTags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.status = status
        self.tags = tags
        self.template = template
        self.worldCount = worldCount
        self.worldTags = worldTags
    }
}

struct CreateWorldGenerationJobOutputResponseBody: Equatable {
    public let arn: String?
    public let status: WorldGenerationJobStatus?
    public let createdAt: Date?
    public let failureCode: WorldGenerationJobErrorCode?
    public let clientRequestToken: String?
    public let template: String?
    public let worldCount: WorldCount?
    public let tags: [String:String]?
    public let worldTags: [String:String]?
}

extension CreateWorldGenerationJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case status
        case tags
        case template
        case worldCount
        case worldTags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorldGenerationJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(WorldGenerationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let templateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .template)
        template = templateDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let worldTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .worldTags)
        var worldTagsDecoded0: [String:String]? = nil
        if let worldTagsContainer = worldTagsContainer {
            worldTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in worldTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    worldTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        worldTags = worldTagsDecoded0
    }
}

public struct CreateWorldTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateWorldTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorldTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorldTemplateInput>
    public typealias MOutput = OperationOutput<CreateWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorldTemplateOutputError>
}

extension CreateWorldTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorldTemplateInput(clientRequestToken: \(String(describing: clientRequestToken)), name: \(String(describing: name)), tags: \(String(describing: tags)), templateBody: \(String(describing: templateBody)), templateLocation: \(String(describing: templateLocation)))"}
}

extension CreateWorldTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case name
        case tags
        case templateBody
        case templateLocation
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let templateBody = templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateLocation = templateLocation {
            try encodeContainer.encode(templateLocation, forKey: .templateLocation)
        }
    }
}

public struct CreateWorldTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWorldTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorldTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorldTemplateInput>
    public typealias MOutput = OperationOutput<CreateWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorldTemplateOutputError>
}

public struct CreateWorldTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWorldTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorldTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorldTemplateInput>
    public typealias MOutput = OperationOutput<CreateWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorldTemplateOutputError>
}

public struct CreateWorldTemplateInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public let clientRequestToken: String?
    /// <p>The name of the world template.</p>
    public let name: String?
    /// <p>A map that contains tag keys and tag values that are attached to the world
    ///          template.</p>
    public let tags: [String:String]?
    /// <p>The world template body.</p>
    public let templateBody: String?
    /// <p>The location of the world template.</p>
    public let templateLocation: TemplateLocation?

    public init (
        clientRequestToken: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil,
        templateBody: String? = nil,
        templateLocation: TemplateLocation? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.tags = tags
        self.templateBody = templateBody
        self.templateLocation = templateLocation
    }
}

struct CreateWorldTemplateInputBody: Equatable {
    public let clientRequestToken: String?
    public let name: String?
    public let templateBody: String?
    public let templateLocation: TemplateLocation?
    public let tags: [String:String]?
}

extension CreateWorldTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case name
        case tags
        case templateBody
        case templateLocation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let templateLocationDecoded = try containerValues.decodeIfPresent(TemplateLocation.self, forKey: .templateLocation)
        templateLocation = templateLocationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorldTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorldTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorldTemplateOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorldTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorldTemplateOutputResponse(arn: \(String(describing: arn)), clientRequestToken: \(String(describing: clientRequestToken)), createdAt: \(String(describing: createdAt)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateWorldTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWorldTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct CreateWorldTemplateOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the world template.</p>
    public let arn: String?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public let clientRequestToken: String?
    /// <p>The time, in milliseconds since the epoch, when the world template was created.</p>
    public let createdAt: Date?
    /// <p>The name of the world template.</p>
    public let name: String?
    /// <p>A map that contains tag keys and tag values that are attached to the world
    ///          template.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        clientRequestToken: String? = nil,
        createdAt: Date? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.name = name
        self.tags = tags
    }
}

struct CreateWorldTemplateOutputResponseBody: Equatable {
    public let arn: String?
    public let clientRequestToken: String?
    public let createdAt: Date?
    public let name: String?
    public let tags: [String:String]?
}

extension CreateWorldTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DataSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case s3Bucket
        case s3Keys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Keys = s3Keys {
            var s3KeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Keys)
            for s3keyoutputs0 in s3Keys {
                try s3KeysContainer.encode(s3keyoutputs0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeysContainer = try containerValues.decodeIfPresent([S3KeyOutput?].self, forKey: .s3Keys)
        var s3KeysDecoded0:[S3KeyOutput]? = nil
        if let s3KeysContainer = s3KeysContainer {
            s3KeysDecoded0 = [S3KeyOutput]()
            for structure0 in s3KeysContainer {
                if let structure0 = structure0 {
                    s3KeysDecoded0?.append(structure0)
                }
            }
        }
        s3Keys = s3KeysDecoded0
    }
}

extension DataSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSource(name: \(String(describing: name)), s3Bucket: \(String(describing: s3Bucket)), s3Keys: \(String(describing: s3Keys)))"}
}

/// <p>Information about a data source.</p>
public struct DataSource: Equatable {
    /// <p>The name of the data source.</p>
    public let name: String?
    /// <p>The S3 bucket where the data files are located.</p>
    public let s3Bucket: String?
    /// <p>The list of S3 keys identifying the data source files.</p>
    public let s3Keys: [S3KeyOutput]?

    public init (
        name: String? = nil,
        s3Bucket: String? = nil,
        s3Keys: [S3KeyOutput]? = nil
    )
    {
        self.name = name
        self.s3Bucket = s3Bucket
        self.s3Keys = s3Keys
    }
}

extension DataSourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case s3Bucket
        case s3Keys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Keys = s3Keys {
            var s3KeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Keys)
            for s3keys0 in s3Keys {
                try s3KeysContainer.encode(s3keys0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .s3Keys)
        var s3KeysDecoded0:[String]? = nil
        if let s3KeysContainer = s3KeysContainer {
            s3KeysDecoded0 = [String]()
            for string0 in s3KeysContainer {
                if let string0 = string0 {
                    s3KeysDecoded0?.append(string0)
                }
            }
        }
        s3Keys = s3KeysDecoded0
    }
}

extension DataSourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSourceConfig(name: \(String(describing: name)), s3Bucket: \(String(describing: s3Bucket)), s3Keys: \(String(describing: s3Keys)))"}
}

/// <p>Information about a data source.</p>
public struct DataSourceConfig: Equatable {
    /// <p>The name of the data source.</p>
    public let name: String?
    /// <p>The S3 bucket where the data files are located.</p>
    public let s3Bucket: String?
    /// <p>The list of S3 keys identifying the data source files.</p>
    public let s3Keys: [String]?

    public init (
        name: String? = nil,
        s3Bucket: String? = nil,
        s3Keys: [String]? = nil
    )
    {
        self.name = name
        self.s3Bucket = s3Bucket
        self.s3Keys = s3Keys
    }
}

public struct DeleteFleetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFleetOutputError>
}

extension DeleteFleetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFleetInput(fleet: \(String(describing: fleet)))"}
}

extension DeleteFleetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleet
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
    }
}

public struct DeleteFleetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let fleet: String?

    public init (
        fleet: String? = nil
    )
    {
        self.fleet = fleet
    }
}

struct DeleteFleetInputBody: Equatable {
    public let fleet: String?
}

extension DeleteFleetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleet
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

extension DeleteFleetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFleetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFleetOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFleetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFleetOutputResponse()"}
}

extension DeleteFleetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFleetOutputResponse: Equatable {

    public init() {}
}

struct DeleteFleetOutputResponseBody: Equatable {
}

extension DeleteFleetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRobotApplicationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRobotApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRobotApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRobotApplicationInput>
    public typealias MOutput = OperationOutput<DeleteRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRobotApplicationOutputError>
}

extension DeleteRobotApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRobotApplicationInput(application: \(String(describing: application)), applicationVersion: \(String(describing: applicationVersion)))"}
}

extension DeleteRobotApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

public struct DeleteRobotApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRobotApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRobotApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRobotApplicationInput>
    public typealias MOutput = OperationOutput<DeleteRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRobotApplicationOutputError>
}

public struct DeleteRobotApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRobotApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRobotApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRobotApplicationInput>
    public typealias MOutput = OperationOutput<DeleteRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRobotApplicationOutputError>
}

public struct DeleteRobotApplicationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the the robot application.</p>
    public let application: String?
    /// <p>The version of the robot application to delete.</p>
    public let applicationVersion: String?

    public init (
        application: String? = nil,
        applicationVersion: String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DeleteRobotApplicationInputBody: Equatable {
    public let application: String?
    public let applicationVersion: String?
}

extension DeleteRobotApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case application
        case applicationVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DeleteRobotApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRobotApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRobotApplicationOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRobotApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRobotApplicationOutputResponse()"}
}

extension DeleteRobotApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRobotApplicationOutputResponse: Equatable {

    public init() {}
}

struct DeleteRobotApplicationOutputResponseBody: Equatable {
}

extension DeleteRobotApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRobotInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRobotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRobotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRobotInput>
    public typealias MOutput = OperationOutput<DeleteRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRobotOutputError>
}

extension DeleteRobotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRobotInput(robot: \(String(describing: robot)))"}
}

extension DeleteRobotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case robot
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let robot = robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

public struct DeleteRobotInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRobotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRobotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRobotInput>
    public typealias MOutput = OperationOutput<DeleteRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRobotOutputError>
}

public struct DeleteRobotInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRobotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRobotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRobotInput>
    public typealias MOutput = OperationOutput<DeleteRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRobotOutputError>
}

public struct DeleteRobotInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the robot.</p>
    public let robot: String?

    public init (
        robot: String? = nil
    )
    {
        self.robot = robot
    }
}

struct DeleteRobotInputBody: Equatable {
    public let robot: String?
}

extension DeleteRobotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case robot
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotDecoded = try containerValues.decodeIfPresent(String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension DeleteRobotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRobotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRobotOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRobotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRobotOutputResponse()"}
}

extension DeleteRobotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRobotOutputResponse: Equatable {

    public init() {}
}

struct DeleteRobotOutputResponseBody: Equatable {
}

extension DeleteRobotOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSimulationApplicationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSimulationApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSimulationApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSimulationApplicationInput>
    public typealias MOutput = OperationOutput<DeleteSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSimulationApplicationOutputError>
}

extension DeleteSimulationApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSimulationApplicationInput(application: \(String(describing: application)), applicationVersion: \(String(describing: applicationVersion)))"}
}

extension DeleteSimulationApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

public struct DeleteSimulationApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSimulationApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSimulationApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSimulationApplicationInput>
    public typealias MOutput = OperationOutput<DeleteSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSimulationApplicationOutputError>
}

public struct DeleteSimulationApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSimulationApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSimulationApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSimulationApplicationInput>
    public typealias MOutput = OperationOutput<DeleteSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSimulationApplicationOutputError>
}

public struct DeleteSimulationApplicationInput: Equatable {
    /// <p>The application information for the simulation application to delete.</p>
    public let application: String?
    /// <p>The version of the simulation application to delete.</p>
    public let applicationVersion: String?

    public init (
        application: String? = nil,
        applicationVersion: String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DeleteSimulationApplicationInputBody: Equatable {
    public let application: String?
    public let applicationVersion: String?
}

extension DeleteSimulationApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case application
        case applicationVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DeleteSimulationApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSimulationApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSimulationApplicationOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSimulationApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSimulationApplicationOutputResponse()"}
}

extension DeleteSimulationApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSimulationApplicationOutputResponse: Equatable {

    public init() {}
}

struct DeleteSimulationApplicationOutputResponseBody: Equatable {
}

extension DeleteSimulationApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteWorldTemplateInputBodyMiddleware: Middleware {
    public let id: String = "DeleteWorldTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorldTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorldTemplateInput>
    public typealias MOutput = OperationOutput<DeleteWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorldTemplateOutputError>
}

extension DeleteWorldTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorldTemplateInput(template: \(String(describing: template)))"}
}

extension DeleteWorldTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case template
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }
}

public struct DeleteWorldTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWorldTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorldTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorldTemplateInput>
    public typealias MOutput = OperationOutput<DeleteWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorldTemplateOutputError>
}

public struct DeleteWorldTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWorldTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorldTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorldTemplateInput>
    public typealias MOutput = OperationOutput<DeleteWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorldTemplateOutputError>
}

public struct DeleteWorldTemplateInput: Equatable {
    /// <p>The Amazon Resource Name (arn) of the world template you want to delete.</p>
    public let template: String?

    public init (
        template: String? = nil
    )
    {
        self.template = template
    }
}

struct DeleteWorldTemplateInputBody: Equatable {
    public let template: String?
}

extension DeleteWorldTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case template
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .template)
        template = templateDecoded
    }
}

extension DeleteWorldTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorldTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorldTemplateOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorldTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorldTemplateOutputResponse()"}
}

extension DeleteWorldTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorldTemplateOutputResponse: Equatable {

    public init() {}
}

struct DeleteWorldTemplateOutputResponseBody: Equatable {
}

extension DeleteWorldTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeploymentApplicationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case application
        case applicationVersion
        case launchConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let launchConfig = launchConfig {
            try encodeContainer.encode(launchConfig, forKey: .launchConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let launchConfigDecoded = try containerValues.decodeIfPresent(DeploymentLaunchConfig.self, forKey: .launchConfig)
        launchConfig = launchConfigDecoded
    }
}

extension DeploymentApplicationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploymentApplicationConfig(application: \(String(describing: application)), applicationVersion: \(String(describing: applicationVersion)), launchConfig: \(String(describing: launchConfig)))"}
}

/// <p>Information about a deployment application configuration.</p>
public struct DeploymentApplicationConfig: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the robot application.</p>
    public let application: String?
    /// <p>The version of the application.</p>
    public let applicationVersion: String?
    /// <p>The launch configuration.</p>
    public let launchConfig: DeploymentLaunchConfig?

    public init (
        application: String? = nil,
        applicationVersion: String? = nil,
        launchConfig: DeploymentLaunchConfig? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
        self.launchConfig = launchConfig
    }
}

extension DeploymentConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case concurrentDeploymentPercentage
        case downloadConditionFile
        case failureThresholdPercentage
        case robotDeploymentTimeoutInSeconds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let concurrentDeploymentPercentage = concurrentDeploymentPercentage {
            try encodeContainer.encode(concurrentDeploymentPercentage, forKey: .concurrentDeploymentPercentage)
        }
        if let downloadConditionFile = downloadConditionFile {
            try encodeContainer.encode(downloadConditionFile, forKey: .downloadConditionFile)
        }
        if let failureThresholdPercentage = failureThresholdPercentage {
            try encodeContainer.encode(failureThresholdPercentage, forKey: .failureThresholdPercentage)
        }
        if let robotDeploymentTimeoutInSeconds = robotDeploymentTimeoutInSeconds {
            try encodeContainer.encode(robotDeploymentTimeoutInSeconds, forKey: .robotDeploymentTimeoutInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let concurrentDeploymentPercentageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .concurrentDeploymentPercentage)
        concurrentDeploymentPercentage = concurrentDeploymentPercentageDecoded
        let failureThresholdPercentageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failureThresholdPercentage)
        failureThresholdPercentage = failureThresholdPercentageDecoded
        let robotDeploymentTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .robotDeploymentTimeoutInSeconds)
        robotDeploymentTimeoutInSeconds = robotDeploymentTimeoutInSecondsDecoded
        let downloadConditionFileDecoded = try containerValues.decodeIfPresent(S3Object.self, forKey: .downloadConditionFile)
        downloadConditionFile = downloadConditionFileDecoded
    }
}

extension DeploymentConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploymentConfig(concurrentDeploymentPercentage: \(String(describing: concurrentDeploymentPercentage)), downloadConditionFile: \(String(describing: downloadConditionFile)), failureThresholdPercentage: \(String(describing: failureThresholdPercentage)), robotDeploymentTimeoutInSeconds: \(String(describing: robotDeploymentTimeoutInSeconds)))"}
}

/// <p>Information about a deployment configuration.</p>
public struct DeploymentConfig: Equatable {
    /// <p>The percentage of robots receiving the deployment at the same time.</p>
    public let concurrentDeploymentPercentage: Int?
    /// <p>The download condition file.</p>
    public let downloadConditionFile: S3Object?
    /// <p>The percentage of deployments that need to fail before stopping deployment.</p>
    public let failureThresholdPercentage: Int?
    /// <p>The amount of time, in seconds, to wait for deployment to a single robot to complete.
    ///          Choose a time between 1 minute and 7 days. The default is 5 hours.</p>
    public let robotDeploymentTimeoutInSeconds: Int?

    public init (
        concurrentDeploymentPercentage: Int? = nil,
        downloadConditionFile: S3Object? = nil,
        failureThresholdPercentage: Int? = nil,
        robotDeploymentTimeoutInSeconds: Int? = nil
    )
    {
        self.concurrentDeploymentPercentage = concurrentDeploymentPercentage
        self.downloadConditionFile = downloadConditionFile
        self.failureThresholdPercentage = failureThresholdPercentage
        self.robotDeploymentTimeoutInSeconds = robotDeploymentTimeoutInSeconds
    }
}

extension DeploymentJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let deploymentApplicationConfigs = deploymentApplicationConfigs {
            var deploymentApplicationConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deploymentApplicationConfigs)
            for deploymentapplicationconfigs0 in deploymentApplicationConfigs {
                try deploymentApplicationConfigsContainer.encode(deploymentapplicationconfigs0)
            }
        }
        if let deploymentConfig = deploymentConfig {
            try encodeContainer.encode(deploymentConfig, forKey: .deploymentConfig)
        }
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let fleet = fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension DeploymentJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploymentJob(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), deploymentApplicationConfigs: \(String(describing: deploymentApplicationConfigs)), deploymentConfig: \(String(describing: deploymentConfig)), failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), fleet: \(String(describing: fleet)), status: \(String(describing: status)))"}
}

/// <p>Information about a deployment job.</p>
public struct DeploymentJob: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the deployment job.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the deployment job was created.</p>
    public let createdAt: Date?
    /// <p>The deployment application configuration.</p>
    public let deploymentApplicationConfigs: [DeploymentApplicationConfig]?
    /// <p>The deployment configuration.</p>
    public let deploymentConfig: DeploymentConfig?
    /// <p>The deployment job failure code.</p>
    public let failureCode: DeploymentJobErrorCode?
    /// <p>A short description of the reason why the deployment job failed.</p>
    public let failureReason: String?
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let fleet: String?
    /// <p>The status of the deployment job.</p>
    public let status: DeploymentStatus?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        deploymentApplicationConfigs: [DeploymentApplicationConfig]? = nil,
        deploymentConfig: DeploymentConfig? = nil,
        failureCode: DeploymentJobErrorCode? = nil,
        failureReason: String? = nil,
        fleet: String? = nil,
        status: DeploymentStatus? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.status = status
    }
}

public enum DeploymentJobErrorCode {
    case badlambdaassociated
    case badpermissionerror
    case deploymentfleetdoesnotexist
    case downloadconditionfailed
    case environmentsetuperror
    case etagmismatch
    case extractingbundlefailure
    case failurethresholdbreached
    case fleetdeploymenttimeout
    case greengrassdeploymentfailed
    case greengrassgroupversiondoesnotexist
    case internalservererror
    case invalidgreengrassgroup
    case lambdadeleted
    case missingrobotapplicationarchitecture
    case missingrobotarchitecture
    case missingrobotdeploymentresource
    case postlaunchfilefailure
    case prelaunchfilefailure
    case resourcenotfound
    case robotagentconnectiontimeout
    case robotapplicationdoesnotexist
    case robotdeploymentaborted
    case robotdeploymentnoresponse
    case sdkUnknown(String)
}

extension DeploymentJobErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeploymentJobErrorCode] {
        return [
            .badlambdaassociated,
            .badpermissionerror,
            .deploymentfleetdoesnotexist,
            .downloadconditionfailed,
            .environmentsetuperror,
            .etagmismatch,
            .extractingbundlefailure,
            .failurethresholdbreached,
            .fleetdeploymenttimeout,
            .greengrassdeploymentfailed,
            .greengrassgroupversiondoesnotexist,
            .internalservererror,
            .invalidgreengrassgroup,
            .lambdadeleted,
            .missingrobotapplicationarchitecture,
            .missingrobotarchitecture,
            .missingrobotdeploymentresource,
            .postlaunchfilefailure,
            .prelaunchfilefailure,
            .resourcenotfound,
            .robotagentconnectiontimeout,
            .robotapplicationdoesnotexist,
            .robotdeploymentaborted,
            .robotdeploymentnoresponse,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .badlambdaassociated: return "BadLambdaAssociated"
        case .badpermissionerror: return "BadPermissionError"
        case .deploymentfleetdoesnotexist: return "DeploymentFleetDoesNotExist"
        case .downloadconditionfailed: return "DownloadConditionFailed"
        case .environmentsetuperror: return "EnvironmentSetupError"
        case .etagmismatch: return "EtagMismatch"
        case .extractingbundlefailure: return "ExtractingBundleFailure"
        case .failurethresholdbreached: return "FailureThresholdBreached"
        case .fleetdeploymenttimeout: return "FleetDeploymentTimeout"
        case .greengrassdeploymentfailed: return "GreengrassDeploymentFailed"
        case .greengrassgroupversiondoesnotexist: return "GreengrassGroupVersionDoesNotExist"
        case .internalservererror: return "InternalServerError"
        case .invalidgreengrassgroup: return "InvalidGreengrassGroup"
        case .lambdadeleted: return "LambdaDeleted"
        case .missingrobotapplicationarchitecture: return "MissingRobotApplicationArchitecture"
        case .missingrobotarchitecture: return "MissingRobotArchitecture"
        case .missingrobotdeploymentresource: return "MissingRobotDeploymentResource"
        case .postlaunchfilefailure: return "PostLaunchFileFailure"
        case .prelaunchfilefailure: return "PreLaunchFileFailure"
        case .resourcenotfound: return "ResourceNotFound"
        case .robotagentconnectiontimeout: return "RobotAgentConnectionTimeout"
        case .robotapplicationdoesnotexist: return "RobotApplicationDoesNotExist"
        case .robotdeploymentaborted: return "RobotDeploymentAborted"
        case .robotdeploymentnoresponse: return "RobotDeploymentNoResponse"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeploymentJobErrorCode(rawValue: rawValue) ?? DeploymentJobErrorCode.sdkUnknown(rawValue)
    }
}

extension DeploymentLaunchConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case environmentVariables
        case launchFile
        case packageName
        case postLaunchFile
        case preLaunchFile
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentvariablemap0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariablemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let launchFile = launchFile {
            try encodeContainer.encode(launchFile, forKey: .launchFile)
        }
        if let packageName = packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let postLaunchFile = postLaunchFile {
            try encodeContainer.encode(postLaunchFile, forKey: .postLaunchFile)
        }
        if let preLaunchFile = preLaunchFile {
            try encodeContainer.encode(preLaunchFile, forKey: .preLaunchFile)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let preLaunchFileDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preLaunchFile)
        preLaunchFile = preLaunchFileDecoded
        let launchFileDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchFile)
        launchFile = launchFileDecoded
        let postLaunchFileDecoded = try containerValues.decodeIfPresent(String.self, forKey: .postLaunchFile)
        postLaunchFile = postLaunchFileDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [String:String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [String:String]()
            for (key0, environmentvariablevalue0) in environmentVariablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    environmentVariablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
    }
}

extension DeploymentLaunchConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploymentLaunchConfig(environmentVariables: \(String(describing: environmentVariables)), launchFile: \(String(describing: launchFile)), packageName: \(String(describing: packageName)), postLaunchFile: \(String(describing: postLaunchFile)), preLaunchFile: \(String(describing: preLaunchFile)))"}
}

/// <p>Configuration information for a deployment launch.</p>
public struct DeploymentLaunchConfig: Equatable {
    /// <p>An array of key/value pairs specifying environment variables for the robot
    ///          application</p>
    public let environmentVariables: [String:String]?
    /// <p>The launch file name.</p>
    public let launchFile: String?
    /// <p>The package name.</p>
    public let packageName: String?
    /// <p>The deployment post-launch file. This file will be executed after the launch
    ///          file.</p>
    public let postLaunchFile: String?
    /// <p>The deployment pre-launch file. This file will be executed prior to the launch
    ///          file.</p>
    public let preLaunchFile: String?

    public init (
        environmentVariables: [String:String]? = nil,
        launchFile: String? = nil,
        packageName: String? = nil,
        postLaunchFile: String? = nil,
        preLaunchFile: String? = nil
    )
    {
        self.environmentVariables = environmentVariables
        self.launchFile = launchFile
        self.packageName = packageName
        self.postLaunchFile = postLaunchFile
        self.preLaunchFile = preLaunchFile
    }
}

public enum DeploymentStatus {
    case canceled
    case failed
    case inprogress
    case pending
    case preparing
    case succeeded
    case sdkUnknown(String)
}

extension DeploymentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeploymentStatus] {
        return [
            .canceled,
            .failed,
            .inprogress,
            .pending,
            .preparing,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "Canceled"
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case .pending: return "Pending"
        case .preparing: return "Preparing"
        case .succeeded: return "Succeeded"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
    }
}

public struct DeregisterRobotInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterRobotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterRobotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterRobotInput>
    public typealias MOutput = OperationOutput<DeregisterRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterRobotOutputError>
}

extension DeregisterRobotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterRobotInput(fleet: \(String(describing: fleet)), robot: \(String(describing: robot)))"}
}

extension DeregisterRobotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleet
        case robot
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let robot = robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

public struct DeregisterRobotInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterRobotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterRobotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterRobotInput>
    public typealias MOutput = OperationOutput<DeregisterRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterRobotOutputError>
}

public struct DeregisterRobotInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterRobotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterRobotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterRobotInput>
    public typealias MOutput = OperationOutput<DeregisterRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterRobotOutputError>
}

public struct DeregisterRobotInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let fleet: String?
    /// <p>The Amazon Resource Name (ARN) of the robot.</p>
    public let robot: String?

    public init (
        fleet: String? = nil,
        robot: String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct DeregisterRobotInputBody: Equatable {
    public let fleet: String?
    public let robot: String?
}

extension DeregisterRobotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleet
        case robot
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension DeregisterRobotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterRobotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterRobotOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterRobotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterRobotOutputResponse(fleet: \(String(describing: fleet)), robot: \(String(describing: robot)))"}
}

extension DeregisterRobotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeregisterRobotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fleet = output.fleet
            self.robot = output.robot
        } else {
            self.fleet = nil
            self.robot = nil
        }
    }
}

public struct DeregisterRobotOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let fleet: String?
    /// <p>The Amazon Resource Name (ARN) of the robot.</p>
    public let robot: String?

    public init (
        fleet: String? = nil,
        robot: String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct DeregisterRobotOutputResponseBody: Equatable {
    public let fleet: String?
    public let robot: String?
}

extension DeregisterRobotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleet
        case robot
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(String.self, forKey: .robot)
        robot = robotDecoded
    }
}

public struct DescribeDeploymentJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDeploymentJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDeploymentJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDeploymentJobInput>
    public typealias MOutput = OperationOutput<DescribeDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDeploymentJobOutputError>
}

extension DescribeDeploymentJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDeploymentJobInput(job: \(String(describing: job)))"}
}

extension DescribeDeploymentJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct DescribeDeploymentJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDeploymentJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDeploymentJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDeploymentJobInput>
    public typealias MOutput = OperationOutput<DescribeDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDeploymentJobOutputError>
}

public struct DescribeDeploymentJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDeploymentJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDeploymentJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDeploymentJobInput>
    public typealias MOutput = OperationOutput<DescribeDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDeploymentJobOutputError>
}

public struct DescribeDeploymentJobInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the deployment job.</p>
    public let job: String?

    public init (
        job: String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeDeploymentJobInputBody: Equatable {
    public let job: String?
}

extension DescribeDeploymentJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeDeploymentJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeploymentJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDeploymentJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeploymentJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDeploymentJobOutputResponse(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), deploymentApplicationConfigs: \(String(describing: deploymentApplicationConfigs)), deploymentConfig: \(String(describing: deploymentConfig)), failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), fleet: \(String(describing: fleet)), robotDeploymentSummary: \(String(describing: robotDeploymentSummary)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

extension DescribeDeploymentJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDeploymentJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.deploymentApplicationConfigs = output.deploymentApplicationConfigs
            self.deploymentConfig = output.deploymentConfig
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.fleet = output.fleet
            self.robotDeploymentSummary = output.robotDeploymentSummary
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.deploymentApplicationConfigs = nil
            self.deploymentConfig = nil
            self.failureCode = nil
            self.failureReason = nil
            self.fleet = nil
            self.robotDeploymentSummary = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct DescribeDeploymentJobOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the deployment job.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the deployment job was created.</p>
    public let createdAt: Date?
    /// <p>The deployment application configuration.</p>
    public let deploymentApplicationConfigs: [DeploymentApplicationConfig]?
    /// <p>The deployment configuration.</p>
    public let deploymentConfig: DeploymentConfig?
    /// <p>The deployment job failure code.</p>
    public let failureCode: DeploymentJobErrorCode?
    /// <p>A short description of the reason why the deployment job failed.</p>
    public let failureReason: String?
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let fleet: String?
    /// <p>A list of robot deployment summaries.</p>
    public let robotDeploymentSummary: [RobotDeployment]?
    /// <p>The status of the deployment job.</p>
    public let status: DeploymentStatus?
    /// <p>The list of all tags added to the specified deployment job.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        deploymentApplicationConfigs: [DeploymentApplicationConfig]? = nil,
        deploymentConfig: DeploymentConfig? = nil,
        failureCode: DeploymentJobErrorCode? = nil,
        failureReason: String? = nil,
        fleet: String? = nil,
        robotDeploymentSummary: [RobotDeployment]? = nil,
        status: DeploymentStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.robotDeploymentSummary = robotDeploymentSummary
        self.status = status
        self.tags = tags
    }
}

struct DescribeDeploymentJobOutputResponseBody: Equatable {
    public let arn: String?
    public let fleet: String?
    public let status: DeploymentStatus?
    public let deploymentConfig: DeploymentConfig?
    public let deploymentApplicationConfigs: [DeploymentApplicationConfig]?
    public let failureReason: String?
    public let failureCode: DeploymentJobErrorCode?
    public let createdAt: Date?
    public let robotDeploymentSummary: [RobotDeployment]?
    public let tags: [String:String]?
}

extension DescribeDeploymentJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case robotDeploymentSummary
        case status
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let robotDeploymentSummaryContainer = try containerValues.decodeIfPresent([RobotDeployment?].self, forKey: .robotDeploymentSummary)
        var robotDeploymentSummaryDecoded0:[RobotDeployment]? = nil
        if let robotDeploymentSummaryContainer = robotDeploymentSummaryContainer {
            robotDeploymentSummaryDecoded0 = [RobotDeployment]()
            for structure0 in robotDeploymentSummaryContainer {
                if let structure0 = structure0 {
                    robotDeploymentSummaryDecoded0?.append(structure0)
                }
            }
        }
        robotDeploymentSummary = robotDeploymentSummaryDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeFleetInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFleetInput>
    public typealias MOutput = OperationOutput<DescribeFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFleetOutputError>
}

extension DescribeFleetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFleetInput(fleet: \(String(describing: fleet)))"}
}

extension DescribeFleetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleet
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
    }
}

public struct DescribeFleetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFleetInput>
    public typealias MOutput = OperationOutput<DescribeFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFleetOutputError>
}

public struct DescribeFleetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFleetInput>
    public typealias MOutput = OperationOutput<DescribeFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFleetOutputError>
}

public struct DescribeFleetInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let fleet: String?

    public init (
        fleet: String? = nil
    )
    {
        self.fleet = fleet
    }
}

struct DescribeFleetInputBody: Equatable {
    public let fleet: String?
}

extension DescribeFleetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleet
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

extension DescribeFleetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFleetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFleetOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFleetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFleetOutputResponse(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), lastDeploymentJob: \(String(describing: lastDeploymentJob)), lastDeploymentStatus: \(String(describing: lastDeploymentStatus)), lastDeploymentTime: \(String(describing: lastDeploymentTime)), name: \(String(describing: name)), robots: \(String(describing: robots)), tags: \(String(describing: tags)))"}
}

extension DescribeFleetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFleetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.lastDeploymentJob = output.lastDeploymentJob
            self.lastDeploymentStatus = output.lastDeploymentStatus
            self.lastDeploymentTime = output.lastDeploymentTime
            self.name = output.name
            self.robots = output.robots
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.lastDeploymentJob = nil
            self.lastDeploymentStatus = nil
            self.lastDeploymentTime = nil
            self.name = nil
            self.robots = nil
            self.tags = nil
        }
    }
}

public struct DescribeFleetOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the fleet was created.</p>
    public let createdAt: Date?
    /// <p>The Amazon Resource Name (ARN) of the last deployment job.</p>
    public let lastDeploymentJob: String?
    /// <p>The status of the last deployment.</p>
    public let lastDeploymentStatus: DeploymentStatus?
    /// <p>The time of the last deployment.</p>
    public let lastDeploymentTime: Date?
    /// <p>The name of the fleet.</p>
    public let name: String?
    /// <p>A list of robots.</p>
    public let robots: [Robot]?
    /// <p>The list of all tags added to the specified fleet.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        lastDeploymentJob: String? = nil,
        lastDeploymentStatus: DeploymentStatus? = nil,
        lastDeploymentTime: Date? = nil,
        name: String? = nil,
        robots: [Robot]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastDeploymentJob = lastDeploymentJob
        self.lastDeploymentStatus = lastDeploymentStatus
        self.lastDeploymentTime = lastDeploymentTime
        self.name = name
        self.robots = robots
        self.tags = tags
    }
}

struct DescribeFleetOutputResponseBody: Equatable {
    public let name: String?
    public let arn: String?
    public let robots: [Robot]?
    public let createdAt: Date?
    public let lastDeploymentStatus: DeploymentStatus?
    public let lastDeploymentJob: String?
    public let lastDeploymentTime: Date?
    public let tags: [String:String]?
}

extension DescribeFleetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case lastDeploymentJob
        case lastDeploymentStatus
        case lastDeploymentTime
        case name
        case robots
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let robotsContainer = try containerValues.decodeIfPresent([Robot?].self, forKey: .robots)
        var robotsDecoded0:[Robot]? = nil
        if let robotsContainer = robotsContainer {
            robotsDecoded0 = [Robot]()
            for structure0 in robotsContainer {
                if let structure0 = structure0 {
                    robotsDecoded0?.append(structure0)
                }
            }
        }
        robots = robotsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentStatusDecoded = try containerValues.decodeIfPresent(DeploymentStatus.self, forKey: .lastDeploymentStatus)
        lastDeploymentStatus = lastDeploymentStatusDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeRobotApplicationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRobotApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRobotApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRobotApplicationInput>
    public typealias MOutput = OperationOutput<DescribeRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRobotApplicationOutputError>
}

extension DescribeRobotApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRobotApplicationInput(application: \(String(describing: application)), applicationVersion: \(String(describing: applicationVersion)))"}
}

extension DescribeRobotApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

public struct DescribeRobotApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRobotApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRobotApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRobotApplicationInput>
    public typealias MOutput = OperationOutput<DescribeRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRobotApplicationOutputError>
}

public struct DescribeRobotApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRobotApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRobotApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRobotApplicationInput>
    public typealias MOutput = OperationOutput<DescribeRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRobotApplicationOutputError>
}

public struct DescribeRobotApplicationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the robot application.</p>
    public let application: String?
    /// <p>The version of the robot application to describe.</p>
    public let applicationVersion: String?

    public init (
        application: String? = nil,
        applicationVersion: String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DescribeRobotApplicationInputBody: Equatable {
    public let application: String?
    public let applicationVersion: String?
}

extension DescribeRobotApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case application
        case applicationVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DescribeRobotApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRobotApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRobotApplicationOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRobotApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRobotApplicationOutputResponse(arn: \(String(describing: arn)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)), revisionId: \(String(describing: revisionId)), robotSoftwareSuite: \(String(describing: robotSoftwareSuite)), sources: \(String(describing: sources)), tags: \(String(describing: tags)), version: \(String(describing: version)))"}
}

extension DescribeRobotApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRobotApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct DescribeRobotApplicationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the robot application.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the robot application was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the robot application.</p>
    public let name: String?
    /// <p>The revision id of the robot application.</p>
    public let revisionId: String?
    /// <p>The robot software suite (ROS distribution) used by the robot application.</p>
    public let robotSoftwareSuite: RobotSoftwareSuite?
    /// <p>The sources of the robot application.</p>
    public let sources: [Source]?
    /// <p>The list of all tags added to the specified robot application.</p>
    public let tags: [String:String]?
    /// <p>The version of the robot application.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil,
        revisionId: String? = nil,
        robotSoftwareSuite: RobotSoftwareSuite? = nil,
        sources: [Source]? = nil,
        tags: [String:String]? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct DescribeRobotApplicationOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let version: String?
    public let sources: [Source]?
    public let robotSoftwareSuite: RobotSoftwareSuite?
    public let revisionId: String?
    public let lastUpdatedAt: Date?
    public let tags: [String:String]?
}

extension DescribeRobotApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case tags
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([Source?].self, forKey: .sources)
        var sourcesDecoded0:[Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeRobotInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRobotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRobotInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRobotInput>
    public typealias MOutput = OperationOutput<DescribeRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRobotOutputError>
}

extension DescribeRobotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRobotInput(robot: \(String(describing: robot)))"}
}

extension DescribeRobotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case robot
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let robot = robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

public struct DescribeRobotInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRobotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRobotInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRobotInput>
    public typealias MOutput = OperationOutput<DescribeRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRobotOutputError>
}

public struct DescribeRobotInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRobotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRobotInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRobotInput>
    public typealias MOutput = OperationOutput<DescribeRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRobotOutputError>
}

public struct DescribeRobotInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the robot to be described.</p>
    public let robot: String?

    public init (
        robot: String? = nil
    )
    {
        self.robot = robot
    }
}

struct DescribeRobotInputBody: Equatable {
    public let robot: String?
}

extension DescribeRobotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case robot
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotDecoded = try containerValues.decodeIfPresent(String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension DescribeRobotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRobotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRobotOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRobotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRobotOutputResponse(architecture: \(String(describing: architecture)), arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), fleetArn: \(String(describing: fleetArn)), greengrassGroupId: \(String(describing: greengrassGroupId)), lastDeploymentJob: \(String(describing: lastDeploymentJob)), lastDeploymentTime: \(String(describing: lastDeploymentTime)), name: \(String(describing: name)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

extension DescribeRobotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRobotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.architecture = output.architecture
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.fleetArn = output.fleetArn
            self.greengrassGroupId = output.greengrassGroupId
            self.lastDeploymentJob = output.lastDeploymentJob
            self.lastDeploymentTime = output.lastDeploymentTime
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.architecture = nil
            self.arn = nil
            self.createdAt = nil
            self.fleetArn = nil
            self.greengrassGroupId = nil
            self.lastDeploymentJob = nil
            self.lastDeploymentTime = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct DescribeRobotOutputResponse: Equatable {
    /// <p>The target architecture of the robot application.</p>
    public let architecture: Architecture?
    /// <p>The Amazon Resource Name (ARN) of the robot.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the robot was created.</p>
    public let createdAt: Date?
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let fleetArn: String?
    /// <p>The Greengrass group id.</p>
    public let greengrassGroupId: String?
    /// <p>The Amazon Resource Name (ARN) of the last deployment job.</p>
    public let lastDeploymentJob: String?
    /// <p>The time of the last deployment job.</p>
    public let lastDeploymentTime: Date?
    /// <p>The name of the robot.</p>
    public let name: String?
    /// <p>The status of the fleet.</p>
    public let status: RobotStatus?
    /// <p>The list of all tags added to the specified robot.</p>
    public let tags: [String:String]?

    public init (
        architecture: Architecture? = nil,
        arn: String? = nil,
        createdAt: Date? = nil,
        fleetArn: String? = nil,
        greengrassGroupId: String? = nil,
        lastDeploymentJob: String? = nil,
        lastDeploymentTime: Date? = nil,
        name: String? = nil,
        status: RobotStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.architecture = architecture
        self.arn = arn
        self.createdAt = createdAt
        self.fleetArn = fleetArn
        self.greengrassGroupId = greengrassGroupId
        self.lastDeploymentJob = lastDeploymentJob
        self.lastDeploymentTime = lastDeploymentTime
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct DescribeRobotOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let fleetArn: String?
    public let status: RobotStatus?
    public let greengrassGroupId: String?
    public let createdAt: Date?
    public let architecture: Architecture?
    public let lastDeploymentJob: String?
    public let lastDeploymentTime: Date?
    public let tags: [String:String]?
}

extension DescribeRobotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case architecture
        case arn
        case createdAt
        case fleetArn
        case greengrassGroupId
        case lastDeploymentJob
        case lastDeploymentTime
        case name
        case status
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RobotStatus.self, forKey: .status)
        status = statusDecoded
        let greengrassGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .greengrassGroupId)
        greengrassGroupId = greengrassGroupIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeSimulationApplicationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSimulationApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSimulationApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSimulationApplicationInput>
    public typealias MOutput = OperationOutput<DescribeSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSimulationApplicationOutputError>
}

extension DescribeSimulationApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSimulationApplicationInput(application: \(String(describing: application)), applicationVersion: \(String(describing: applicationVersion)))"}
}

extension DescribeSimulationApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

public struct DescribeSimulationApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSimulationApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSimulationApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSimulationApplicationInput>
    public typealias MOutput = OperationOutput<DescribeSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSimulationApplicationOutputError>
}

public struct DescribeSimulationApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSimulationApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSimulationApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSimulationApplicationInput>
    public typealias MOutput = OperationOutput<DescribeSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSimulationApplicationOutputError>
}

public struct DescribeSimulationApplicationInput: Equatable {
    /// <p>The application information for the simulation application.</p>
    public let application: String?
    /// <p>The version of the simulation application to describe.</p>
    public let applicationVersion: String?

    public init (
        application: String? = nil,
        applicationVersion: String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DescribeSimulationApplicationInputBody: Equatable {
    public let application: String?
    public let applicationVersion: String?
}

extension DescribeSimulationApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case application
        case applicationVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DescribeSimulationApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSimulationApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSimulationApplicationOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSimulationApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSimulationApplicationOutputResponse(arn: \(String(describing: arn)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)), renderingEngine: \(String(describing: renderingEngine)), revisionId: \(String(describing: revisionId)), robotSoftwareSuite: \(String(describing: robotSoftwareSuite)), simulationSoftwareSuite: \(String(describing: simulationSoftwareSuite)), sources: \(String(describing: sources)), tags: \(String(describing: tags)), version: \(String(describing: version)))"}
}

extension DescribeSimulationApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSimulationApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct DescribeSimulationApplicationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the robot simulation application.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the simulation application was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the simulation application.</p>
    public let name: String?
    /// <p>The rendering engine for the simulation application.</p>
    public let renderingEngine: RenderingEngine?
    /// <p>The revision id of the simulation application.</p>
    public let revisionId: String?
    /// <p>Information about the robot software suite (ROS distribution).</p>
    public let robotSoftwareSuite: RobotSoftwareSuite?
    /// <p>The simulation software suite used by the simulation application.</p>
    public let simulationSoftwareSuite: SimulationSoftwareSuite?
    /// <p>The sources of the simulation application.</p>
    public let sources: [Source]?
    /// <p>The list of all tags added to the specified simulation application.</p>
    public let tags: [String:String]?
    /// <p>The version of the simulation application.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil,
        renderingEngine: RenderingEngine? = nil,
        revisionId: String? = nil,
        robotSoftwareSuite: RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: SimulationSoftwareSuite? = nil,
        sources: [Source]? = nil,
        tags: [String:String]? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct DescribeSimulationApplicationOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let version: String?
    public let sources: [Source]?
    public let simulationSoftwareSuite: SimulationSoftwareSuite?
    public let robotSoftwareSuite: RobotSoftwareSuite?
    public let renderingEngine: RenderingEngine?
    public let revisionId: String?
    public let lastUpdatedAt: Date?
    public let tags: [String:String]?
}

extension DescribeSimulationApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([Source?].self, forKey: .sources)
        var sourcesDecoded0:[Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeSimulationJobBatchInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSimulationJobBatchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSimulationJobBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSimulationJobBatchInput>
    public typealias MOutput = OperationOutput<DescribeSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSimulationJobBatchOutputError>
}

extension DescribeSimulationJobBatchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSimulationJobBatchInput(batch: \(String(describing: batch)))"}
}

extension DescribeSimulationJobBatchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batch
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batch = batch {
            try encodeContainer.encode(batch, forKey: .batch)
        }
    }
}

public struct DescribeSimulationJobBatchInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSimulationJobBatchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSimulationJobBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSimulationJobBatchInput>
    public typealias MOutput = OperationOutput<DescribeSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSimulationJobBatchOutputError>
}

public struct DescribeSimulationJobBatchInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSimulationJobBatchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSimulationJobBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSimulationJobBatchInput>
    public typealias MOutput = OperationOutput<DescribeSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSimulationJobBatchOutputError>
}

public struct DescribeSimulationJobBatchInput: Equatable {
    /// <p>The id of the batch to describe.</p>
    public let batch: String?

    public init (
        batch: String? = nil
    )
    {
        self.batch = batch
    }
}

struct DescribeSimulationJobBatchInputBody: Equatable {
    public let batch: String?
}

extension DescribeSimulationJobBatchInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batch
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchDecoded = try containerValues.decodeIfPresent(String.self, forKey: .batch)
        batch = batchDecoded
    }
}

extension DescribeSimulationJobBatchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSimulationJobBatchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSimulationJobBatchOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSimulationJobBatchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSimulationJobBatchOutputResponse(arn: \(String(describing: arn)), batchPolicy: \(String(describing: batchPolicy)), clientRequestToken: \(String(describing: clientRequestToken)), createdAt: \(String(describing: createdAt)), createdRequests: \(String(describing: createdRequests)), failedRequests: \(String(describing: failedRequests)), failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), pendingRequests: \(String(describing: pendingRequests)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

extension DescribeSimulationJobBatchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSimulationJobBatchOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.batchPolicy = output.batchPolicy
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.createdRequests = output.createdRequests
            self.failedRequests = output.failedRequests
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.lastUpdatedAt = output.lastUpdatedAt
            self.pendingRequests = output.pendingRequests
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.batchPolicy = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.createdRequests = nil
            self.failedRequests = nil
            self.failureCode = nil
            self.failureReason = nil
            self.lastUpdatedAt = nil
            self.pendingRequests = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct DescribeSimulationJobBatchOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the batch.</p>
    public let arn: String?
    /// <p>The batch policy.</p>
    public let batchPolicy: BatchPolicy?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public let clientRequestToken: String?
    /// <p>The time, in milliseconds since the epoch, when the simulation job batch was
    ///          created.</p>
    public let createdAt: Date?
    /// <p>A list of created simulation job summaries.</p>
    public let createdRequests: [SimulationJobSummary]?
    /// <p>A list of failed create simulation job requests. The request failed to be created into a
    ///          simulation job. Failed requests do not have a simulation job ID. </p>
    public let failedRequests: [FailedCreateSimulationJobRequest]?
    /// <p>The failure code of the simulation job batch.</p>
    public let failureCode: SimulationJobBatchErrorCode?
    /// <p>The reason the simulation job batch failed.</p>
    public let failureReason: String?
    /// <p>The time, in milliseconds since the epoch, when the simulation job batch was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>A list of pending simulation job requests. These requests have not yet been created into
    ///          simulation jobs.</p>
    public let pendingRequests: [SimulationJobRequest]?
    /// <p>The status of the batch.</p>
    ///          <dl>
    ///             <dt>Pending</dt>
    ///             <dd>
    ///                <p>The simulation job batch request is pending.</p>
    ///             </dd>
    ///             <dt>InProgress</dt>
    ///             <dd>
    ///                <p>The simulation job batch is in progress. </p>
    ///             </dd>
    ///             <dt>Failed</dt>
    ///             <dd>
    ///                <p>The simulation job batch failed. One or more simulation job requests could not
    ///                   be completed due to an internal failure (like <code>InternalServiceError</code>).
    ///                   See <code>failureCode</code> and <code>failureReason</code> for more
    ///                   information.</p>
    ///             </dd>
    ///             <dt>Completed</dt>
    ///             <dd>
    ///                <p>The simulation batch job completed. A batch is complete when (1) there are no
    ///                   pending simulation job requests in the batch and none of the failed simulation job
    ///                   requests are due to <code>InternalServiceError</code> and (2) when all created
    ///                   simulation jobs have reached a terminal state (for example, <code>Completed</code>
    ///                   or <code>Failed</code>). </p>
    ///             </dd>
    ///             <dt>Canceled</dt>
    ///             <dd>
    ///                <p>The simulation batch job was cancelled.</p>
    ///             </dd>
    ///             <dt>Canceling</dt>
    ///             <dd>
    ///                <p>The simulation batch job is being cancelled.</p>
    ///             </dd>
    ///             <dt>Completing</dt>
    ///             <dd>
    ///                <p>The simulation batch job is completing.</p>
    ///             </dd>
    ///             <dt>TimingOut</dt>
    ///             <dd>
    ///                <p>The simulation job batch is timing out.</p>
    ///                <p>If a batch timing out, and there are pending requests that were failing due to
    ///                   an internal failure (like <code>InternalServiceError</code>), the batch status
    ///                   will be <code>Failed</code>. If there are no such failing request, the batch
    ///                   status will be <code>TimedOut</code>. </p>
    ///             </dd>
    ///             <dt>TimedOut</dt>
    ///             <dd>
    ///                <p>The simulation batch job timed out.</p>
    ///             </dd>
    ///          </dl>
    public let status: SimulationJobBatchStatus?
    /// <p>A map that contains tag keys and tag values that are attached to the simulation job
    ///          batch.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        batchPolicy: BatchPolicy? = nil,
        clientRequestToken: String? = nil,
        createdAt: Date? = nil,
        createdRequests: [SimulationJobSummary]? = nil,
        failedRequests: [FailedCreateSimulationJobRequest]? = nil,
        failureCode: SimulationJobBatchErrorCode? = nil,
        failureReason: String? = nil,
        lastUpdatedAt: Date? = nil,
        pendingRequests: [SimulationJobRequest]? = nil,
        status: SimulationJobBatchStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.batchPolicy = batchPolicy
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.createdRequests = createdRequests
        self.failedRequests = failedRequests
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.lastUpdatedAt = lastUpdatedAt
        self.pendingRequests = pendingRequests
        self.status = status
        self.tags = tags
    }
}

struct DescribeSimulationJobBatchOutputResponseBody: Equatable {
    public let arn: String?
    public let status: SimulationJobBatchStatus?
    public let lastUpdatedAt: Date?
    public let createdAt: Date?
    public let clientRequestToken: String?
    public let batchPolicy: BatchPolicy?
    public let failureCode: SimulationJobBatchErrorCode?
    public let failureReason: String?
    public let failedRequests: [FailedCreateSimulationJobRequest]?
    public let pendingRequests: [SimulationJobRequest]?
    public let createdRequests: [SimulationJobSummary]?
    public let tags: [String:String]?
}

extension DescribeSimulationJobBatchOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case batchPolicy
        case clientRequestToken
        case createdAt
        case createdRequests
        case failedRequests
        case failureCode
        case failureReason
        case lastUpdatedAt
        case pendingRequests
        case status
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SimulationJobBatchStatus.self, forKey: .status)
        status = statusDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let batchPolicyDecoded = try containerValues.decodeIfPresent(BatchPolicy.self, forKey: .batchPolicy)
        batchPolicy = batchPolicyDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(SimulationJobBatchErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failedRequestsContainer = try containerValues.decodeIfPresent([FailedCreateSimulationJobRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[FailedCreateSimulationJobRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [FailedCreateSimulationJobRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
        let pendingRequestsContainer = try containerValues.decodeIfPresent([SimulationJobRequest?].self, forKey: .pendingRequests)
        var pendingRequestsDecoded0:[SimulationJobRequest]? = nil
        if let pendingRequestsContainer = pendingRequestsContainer {
            pendingRequestsDecoded0 = [SimulationJobRequest]()
            for structure0 in pendingRequestsContainer {
                if let structure0 = structure0 {
                    pendingRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingRequests = pendingRequestsDecoded0
        let createdRequestsContainer = try containerValues.decodeIfPresent([SimulationJobSummary?].self, forKey: .createdRequests)
        var createdRequestsDecoded0:[SimulationJobSummary]? = nil
        if let createdRequestsContainer = createdRequestsContainer {
            createdRequestsDecoded0 = [SimulationJobSummary]()
            for structure0 in createdRequestsContainer {
                if let structure0 = structure0 {
                    createdRequestsDecoded0?.append(structure0)
                }
            }
        }
        createdRequests = createdRequestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeSimulationJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSimulationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSimulationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSimulationJobInput>
    public typealias MOutput = OperationOutput<DescribeSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSimulationJobOutputError>
}

extension DescribeSimulationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSimulationJobInput(job: \(String(describing: job)))"}
}

extension DescribeSimulationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct DescribeSimulationJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSimulationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSimulationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSimulationJobInput>
    public typealias MOutput = OperationOutput<DescribeSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSimulationJobOutputError>
}

public struct DescribeSimulationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSimulationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSimulationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSimulationJobInput>
    public typealias MOutput = OperationOutput<DescribeSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSimulationJobOutputError>
}

public struct DescribeSimulationJobInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the simulation job to be described.</p>
    public let job: String?

    public init (
        job: String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeSimulationJobInputBody: Equatable {
    public let job: String?
}

extension DescribeSimulationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeSimulationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSimulationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSimulationJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSimulationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSimulationJobOutputResponse(arn: \(String(describing: arn)), clientRequestToken: \(String(describing: clientRequestToken)), compute: \(String(describing: compute)), dataSources: \(String(describing: dataSources)), failureBehavior: \(String(describing: failureBehavior)), failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), iamRole: \(String(describing: iamRole)), lastStartedAt: \(String(describing: lastStartedAt)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), loggingConfig: \(String(describing: loggingConfig)), maxJobDurationInSeconds: \(String(describing: maxJobDurationInSeconds)), name: \(String(describing: name)), networkInterface: \(String(describing: networkInterface)), outputLocation: \(String(describing: outputLocation)), robotApplications: \(String(describing: robotApplications)), simulationApplications: \(String(describing: simulationApplications)), simulationTimeMillis: \(String(describing: simulationTimeMillis)), status: \(String(describing: status)), tags: \(String(describing: tags)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension DescribeSimulationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSimulationJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.compute = output.compute
            self.dataSources = output.dataSources
            self.failureBehavior = output.failureBehavior
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.iamRole = output.iamRole
            self.lastStartedAt = output.lastStartedAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.loggingConfig = output.loggingConfig
            self.maxJobDurationInSeconds = output.maxJobDurationInSeconds
            self.name = output.name
            self.networkInterface = output.networkInterface
            self.outputLocation = output.outputLocation
            self.robotApplications = output.robotApplications
            self.simulationApplications = output.simulationApplications
            self.simulationTimeMillis = output.simulationTimeMillis
            self.status = output.status
            self.tags = output.tags
            self.vpcConfig = output.vpcConfig
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.compute = nil
            self.dataSources = nil
            self.failureBehavior = nil
            self.failureCode = nil
            self.failureReason = nil
            self.iamRole = nil
            self.lastStartedAt = nil
            self.lastUpdatedAt = nil
            self.loggingConfig = nil
            self.maxJobDurationInSeconds = 0
            self.name = nil
            self.networkInterface = nil
            self.outputLocation = nil
            self.robotApplications = nil
            self.simulationApplications = nil
            self.simulationTimeMillis = 0
            self.status = nil
            self.tags = nil
            self.vpcConfig = nil
        }
    }
}

public struct DescribeSimulationJobOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the simulation job.</p>
    public let arn: String?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public let clientRequestToken: String?
    /// <p>Compute information for the simulation job.</p>
    public let compute: ComputeResponse?
    /// <p>The data sources for the simulation job.</p>
    public let dataSources: [DataSource]?
    /// <p>The failure behavior for the simulation job.</p>
    public let failureBehavior: FailureBehavior?
    /// <p>The failure code of the simulation job if it failed:</p>
    ///          <dl>
    ///             <dt>InternalServiceError</dt>
    ///             <dd>
    ///                <p>Internal service error.</p>
    ///             </dd>
    ///             <dt>RobotApplicationCrash</dt>
    ///             <dd>
    ///                <p>Robot application exited abnormally.</p>
    ///             </dd>
    ///             <dt>SimulationApplicationCrash</dt>
    ///             <dd>
    ///                <p> Simulation application exited abnormally.</p>
    ///             </dd>
    ///             <dt>BadPermissionsRobotApplication</dt>
    ///             <dd>
    ///                <p>Robot application bundle could not be downloaded.</p>
    ///             </dd>
    ///             <dt>BadPermissionsSimulationApplication</dt>
    ///             <dd>
    ///                <p>Simulation application bundle could not be downloaded.</p>
    ///             </dd>
    ///             <dt>BadPermissionsS3Output</dt>
    ///             <dd>
    ///                <p>Unable to publish outputs to customer-provided S3 bucket.</p>
    ///             </dd>
    ///             <dt>BadPermissionsCloudwatchLogs</dt>
    ///             <dd>
    ///                <p>Unable to publish logs to customer-provided CloudWatch Logs resource.</p>
    ///             </dd>
    ///             <dt>SubnetIpLimitExceeded</dt>
    ///             <dd>
    ///                <p>Subnet IP limit exceeded.</p>
    ///             </dd>
    ///             <dt>ENILimitExceeded</dt>
    ///             <dd>
    ///                <p>ENI limit exceeded.</p>
    ///             </dd>
    ///             <dt>BadPermissionsUserCredentials</dt>
    ///             <dd>
    ///                <p>Unable to use the Role provided.</p>
    ///             </dd>
    ///             <dt>InvalidBundleRobotApplication</dt>
    ///             <dd>
    ///                <p>Robot bundle cannot be extracted (invalid format, bundling error, or other
    ///                   issue).</p>
    ///             </dd>
    ///             <dt>InvalidBundleSimulationApplication</dt>
    ///             <dd>
    ///                <p>Simulation bundle cannot be extracted (invalid format, bundling error, or other
    ///                   issue).</p>
    ///             </dd>
    ///             <dt>RobotApplicationVersionMismatchedEtag</dt>
    ///             <dd>
    ///                <p>Etag for RobotApplication does not match value during version creation.</p>
    ///             </dd>
    ///             <dt>SimulationApplicationVersionMismatchedEtag</dt>
    ///             <dd>
    ///                <p>Etag for SimulationApplication does not match value during version
    ///                   creation.</p>
    ///             </dd>
    ///          </dl>
    public let failureCode: SimulationJobErrorCode?
    /// <p>Details about why the simulation job failed. For more information about troubleshooting,
    ///          see <a href="https://docs.aws.amazon.com/robomaker/latest/dg/troubleshooting.html">Troubleshooting</a>.</p>
    public let failureReason: String?
    /// <p>The IAM role that allows the simulation instance to call the AWS APIs that are specified
    ///          in its associated policies on your behalf.</p>
    public let iamRole: String?
    /// <p>The time, in milliseconds since the epoch, when the simulation job was last
    ///          started.</p>
    public let lastStartedAt: Date?
    /// <p>The time, in milliseconds since the epoch, when the simulation job was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The logging configuration.</p>
    public let loggingConfig: LoggingConfig?
    /// <p>The maximum job duration in seconds. The value must be 8 days (691,200 seconds) or
    ///          less.</p>
    public let maxJobDurationInSeconds: Int
    /// <p>The name of the simulation job.</p>
    public let name: String?
    /// <p>The network interface information for the simulation job.</p>
    public let networkInterface: NetworkInterface?
    /// <p>Location for output files generated by the simulation job.</p>
    public let outputLocation: OutputLocation?
    /// <p>A list of robot applications.</p>
    public let robotApplications: [RobotApplicationConfig]?
    /// <p>A list of simulation applications.</p>
    public let simulationApplications: [SimulationApplicationConfig]?
    /// <p>The simulation job execution duration in milliseconds.</p>
    public let simulationTimeMillis: Int
    /// <p>The status of the simulation job.</p>
    public let status: SimulationJobStatus?
    /// <p>The list of all tags added to the specified simulation job.</p>
    public let tags: [String:String]?
    /// <p>The VPC configuration.</p>
    public let vpcConfig: VPCConfigResponse?

    public init (
        arn: String? = nil,
        clientRequestToken: String? = nil,
        compute: ComputeResponse? = nil,
        dataSources: [DataSource]? = nil,
        failureBehavior: FailureBehavior? = nil,
        failureCode: SimulationJobErrorCode? = nil,
        failureReason: String? = nil,
        iamRole: String? = nil,
        lastStartedAt: Date? = nil,
        lastUpdatedAt: Date? = nil,
        loggingConfig: LoggingConfig? = nil,
        maxJobDurationInSeconds: Int = 0,
        name: String? = nil,
        networkInterface: NetworkInterface? = nil,
        outputLocation: OutputLocation? = nil,
        robotApplications: [RobotApplicationConfig]? = nil,
        simulationApplications: [SimulationApplicationConfig]? = nil,
        simulationTimeMillis: Int = 0,
        status: SimulationJobStatus? = nil,
        tags: [String:String]? = nil,
        vpcConfig: VPCConfigResponse? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.iamRole = iamRole
        self.lastStartedAt = lastStartedAt
        self.lastUpdatedAt = lastUpdatedAt
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.name = name
        self.networkInterface = networkInterface
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.simulationTimeMillis = simulationTimeMillis
        self.status = status
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct DescribeSimulationJobOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let status: SimulationJobStatus?
    public let lastStartedAt: Date?
    public let lastUpdatedAt: Date?
    public let failureBehavior: FailureBehavior?
    public let failureCode: SimulationJobErrorCode?
    public let failureReason: String?
    public let clientRequestToken: String?
    public let outputLocation: OutputLocation?
    public let loggingConfig: LoggingConfig?
    public let maxJobDurationInSeconds: Int
    public let simulationTimeMillis: Int
    public let iamRole: String?
    public let robotApplications: [RobotApplicationConfig]?
    public let simulationApplications: [SimulationApplicationConfig]?
    public let dataSources: [DataSource]?
    public let tags: [String:String]?
    public let vpcConfig: VPCConfigResponse?
    public let networkInterface: NetworkInterface?
    public let compute: ComputeResponse?
}

extension DescribeSimulationJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case failureCode
        case failureReason
        case iamRole
        case lastStartedAt
        case lastUpdatedAt
        case loggingConfig
        case maxJobDurationInSeconds
        case name
        case networkInterface
        case outputLocation
        case robotApplications
        case simulationApplications
        case simulationTimeMillis
        case status
        case tags
        case vpcConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let lastStartedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastStartedAt)
        lastStartedAt = lastStartedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decode(Int.self, forKey: .maxJobDurationInSeconds)
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let simulationTimeMillisDecoded = try containerValues.decode(Int.self, forKey: .simulationTimeMillis)
        simulationTimeMillis = simulationTimeMillisDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VPCConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let networkInterfaceDecoded = try containerValues.decodeIfPresent(NetworkInterface.self, forKey: .networkInterface)
        networkInterface = networkInterfaceDecoded
        let computeDecoded = try containerValues.decodeIfPresent(ComputeResponse.self, forKey: .compute)
        compute = computeDecoded
    }
}

public struct DescribeWorldExportJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeWorldExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorldExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorldExportJobInput>
    public typealias MOutput = OperationOutput<DescribeWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorldExportJobOutputError>
}

extension DescribeWorldExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorldExportJobInput(job: \(String(describing: job)))"}
}

extension DescribeWorldExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct DescribeWorldExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeWorldExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorldExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorldExportJobInput>
    public typealias MOutput = OperationOutput<DescribeWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorldExportJobOutputError>
}

public struct DescribeWorldExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeWorldExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorldExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorldExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorldExportJobInput>
    public typealias MOutput = OperationOutput<DescribeWorldExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorldExportJobOutputError>
}

public struct DescribeWorldExportJobInput: Equatable {
    /// <p>The Amazon Resource Name (arn) of the world export job to describe.</p>
    public let job: String?

    public init (
        job: String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeWorldExportJobInputBody: Equatable {
    public let job: String?
}

extension DescribeWorldExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeWorldExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorldExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorldExportJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorldExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorldExportJobOutputResponse(arn: \(String(describing: arn)), clientRequestToken: \(String(describing: clientRequestToken)), createdAt: \(String(describing: createdAt)), failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), iamRole: \(String(describing: iamRole)), outputLocation: \(String(describing: outputLocation)), status: \(String(describing: status)), tags: \(String(describing: tags)), worlds: \(String(describing: worlds)))"}
}

extension DescribeWorldExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeWorldExportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.iamRole = output.iamRole
            self.outputLocation = output.outputLocation
            self.status = output.status
            self.tags = output.tags
            self.worlds = output.worlds
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.failureReason = nil
            self.iamRole = nil
            self.outputLocation = nil
            self.status = nil
            self.tags = nil
            self.worlds = nil
        }
    }
}

public struct DescribeWorldExportJobOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the world export job.</p>
    public let arn: String?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public let clientRequestToken: String?
    /// <p>The time, in milliseconds since the epoch, when the world export job was created.</p>
    public let createdAt: Date?
    /// <p>The failure code of the world export job if it failed:</p>
    ///          <dl>
    ///             <dt>InternalServiceError</dt>
    ///             <dd>
    ///                <p>Internal service error.</p>
    ///             </dd>
    ///             <dt>LimitExceeded</dt>
    ///             <dd>
    ///                <p>The requested resource exceeds the maximum number allowed, or the number of
    ///                   concurrent stream requests exceeds the maximum number allowed. </p>
    ///             </dd>
    ///             <dt>ResourceNotFound</dt>
    ///             <dd>
    ///                <p>The specified resource could not be found. </p>
    ///             </dd>
    ///             <dt>RequestThrottled</dt>
    ///             <dd>
    ///                <p>The request was throttled.</p>
    ///             </dd>
    ///             <dt>InvalidInput</dt>
    ///             <dd>
    ///                <p>An input parameter in the request is not valid.</p>
    ///             </dd>
    ///          </dl>
    public let failureCode: WorldExportJobErrorCode?
    /// <p>The reason why the world export job failed.</p>
    public let failureReason: String?
    /// <p>The IAM role that the world export process uses to access the Amazon S3 bucket and put
    ///          the export.</p>
    public let iamRole: String?
    /// <p>The output location.</p>
    public let outputLocation: OutputLocation?
    /// <p>The status of the world export job.</p>
    ///          <dl>
    ///             <dt>Pending</dt>
    ///             <dd>
    ///                <p>The world export job request is pending.</p>
    ///             </dd>
    ///             <dt>Running</dt>
    ///             <dd>
    ///                <p>The world export job is running. </p>
    ///             </dd>
    ///             <dt>Completed</dt>
    ///             <dd>
    ///                <p>The world export job completed. </p>
    ///             </dd>
    ///             <dt>Failed</dt>
    ///             <dd>
    ///                <p>The world export job failed. See <code>failureCode</code> and
    ///                      <code>failureReason</code> for more information. </p>
    ///             </dd>
    ///             <dt>Canceled</dt>
    ///             <dd>
    ///                <p>The world export job was cancelled.</p>
    ///             </dd>
    ///             <dt>Canceling</dt>
    ///             <dd>
    ///                <p>The world export job is being cancelled.</p>
    ///             </dd>
    ///          </dl>
    public let status: WorldExportJobStatus?
    /// <p>A map that contains tag keys and tag values that are attached to the world export
    ///          job.</p>
    public let tags: [String:String]?
    /// <p>A list of Amazon Resource Names (arns) that correspond to worlds to be exported.</p>
    public let worlds: [String]?

    public init (
        arn: String? = nil,
        clientRequestToken: String? = nil,
        createdAt: Date? = nil,
        failureCode: WorldExportJobErrorCode? = nil,
        failureReason: String? = nil,
        iamRole: String? = nil,
        outputLocation: OutputLocation? = nil,
        status: WorldExportJobStatus? = nil,
        tags: [String:String]? = nil,
        worlds: [String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.iamRole = iamRole
        self.outputLocation = outputLocation
        self.status = status
        self.tags = tags
        self.worlds = worlds
    }
}

struct DescribeWorldExportJobOutputResponseBody: Equatable {
    public let arn: String?
    public let status: WorldExportJobStatus?
    public let createdAt: Date?
    public let failureCode: WorldExportJobErrorCode?
    public let failureReason: String?
    public let clientRequestToken: String?
    public let worlds: [String]?
    public let outputLocation: OutputLocation?
    public let iamRole: String?
    public let tags: [String:String]?
}

extension DescribeWorldExportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case failureReason
        case iamRole
        case outputLocation
        case status
        case tags
        case worlds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorldExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(WorldExportJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let worldsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .worlds)
        var worldsDecoded0:[String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
        let outputLocationDecoded = try containerValues.decodeIfPresent(OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeWorldGenerationJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeWorldGenerationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorldGenerationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorldGenerationJobInput>
    public typealias MOutput = OperationOutput<DescribeWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorldGenerationJobOutputError>
}

extension DescribeWorldGenerationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorldGenerationJobInput(job: \(String(describing: job)))"}
}

extension DescribeWorldGenerationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct DescribeWorldGenerationJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeWorldGenerationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorldGenerationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorldGenerationJobInput>
    public typealias MOutput = OperationOutput<DescribeWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorldGenerationJobOutputError>
}

public struct DescribeWorldGenerationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeWorldGenerationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorldGenerationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorldGenerationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorldGenerationJobInput>
    public typealias MOutput = OperationOutput<DescribeWorldGenerationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorldGenerationJobOutputError>
}

public struct DescribeWorldGenerationJobInput: Equatable {
    /// <p>The Amazon Resource Name (arn) of the world generation job to describe.</p>
    public let job: String?

    public init (
        job: String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeWorldGenerationJobInputBody: Equatable {
    public let job: String?
}

extension DescribeWorldGenerationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeWorldGenerationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorldGenerationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorldGenerationJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorldGenerationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorldGenerationJobOutputResponse(arn: \(String(describing: arn)), clientRequestToken: \(String(describing: clientRequestToken)), createdAt: \(String(describing: createdAt)), failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), finishedWorldsSummary: \(String(describing: finishedWorldsSummary)), status: \(String(describing: status)), tags: \(String(describing: tags)), template: \(String(describing: template)), worldCount: \(String(describing: worldCount)), worldTags: \(String(describing: worldTags)))"}
}

extension DescribeWorldGenerationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeWorldGenerationJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.finishedWorldsSummary = output.finishedWorldsSummary
            self.status = output.status
            self.tags = output.tags
            self.template = output.template
            self.worldCount = output.worldCount
            self.worldTags = output.worldTags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.failureReason = nil
            self.finishedWorldsSummary = nil
            self.status = nil
            self.tags = nil
            self.template = nil
            self.worldCount = nil
            self.worldTags = nil
        }
    }
}

public struct DescribeWorldGenerationJobOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the world generation job.</p>
    public let arn: String?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public let clientRequestToken: String?
    /// <p>The time, in milliseconds since the epoch, when the world generation job was
    ///          created.</p>
    public let createdAt: Date?
    /// <p>The failure code of the world generation job if it failed:</p>
    ///          <dl>
    ///             <dt>InternalServiceError</dt>
    ///             <dd>
    ///                <p>Internal service error.</p>
    ///             </dd>
    ///             <dt>LimitExceeded</dt>
    ///             <dd>
    ///                <p>The requested resource exceeds the maximum number allowed, or the number of
    ///                   concurrent stream requests exceeds the maximum number allowed. </p>
    ///             </dd>
    ///             <dt>ResourceNotFound</dt>
    ///             <dd>
    ///                <p>The specified resource could not be found. </p>
    ///             </dd>
    ///             <dt>RequestThrottled</dt>
    ///             <dd>
    ///                <p>The request was throttled.</p>
    ///             </dd>
    ///             <dt>InvalidInput</dt>
    ///             <dd>
    ///                <p>An input parameter in the request is not valid.</p>
    ///             </dd>
    ///          </dl>
    public let failureCode: WorldGenerationJobErrorCode?
    /// <p>The reason why the world generation job failed.</p>
    public let failureReason: String?
    /// <p>Summary information about finished worlds.</p>
    public let finishedWorldsSummary: FinishedWorldsSummary?
    /// <p>The status of the world generation job:</p>
    ///          <dl>
    ///             <dt>Pending</dt>
    ///             <dd>
    ///                <p>The world generation job request is pending.</p>
    ///             </dd>
    ///             <dt>Running</dt>
    ///             <dd>
    ///                <p>The world generation job is running. </p>
    ///             </dd>
    ///             <dt>Completed</dt>
    ///             <dd>
    ///                <p>The world generation job completed. </p>
    ///             </dd>
    ///             <dt>Failed</dt>
    ///             <dd>
    ///                <p>The world generation job failed. See <code>failureCode</code> for more
    ///                   information. </p>
    ///             </dd>
    ///             <dt>PartialFailed</dt>
    ///             <dd>
    ///                <p>Some worlds did not generate.</p>
    ///             </dd>
    ///             <dt>Canceled</dt>
    ///             <dd>
    ///                <p>The world generation job was cancelled.</p>
    ///             </dd>
    ///             <dt>Canceling</dt>
    ///             <dd>
    ///                <p>The world generation job is being cancelled.</p>
    ///             </dd>
    ///          </dl>
    public let status: WorldGenerationJobStatus?
    /// <p>A map that contains tag keys and tag values that are attached to the world generation
    ///          job.</p>
    public let tags: [String:String]?
    /// <p>The Amazon Resource Name (arn) of the world template.</p>
    public let template: String?
    /// <p>Information about the world count.</p>
    public let worldCount: WorldCount?
    /// <p>A map that contains tag keys and tag values that are attached to the generated
    ///          worlds.</p>
    public let worldTags: [String:String]?

    public init (
        arn: String? = nil,
        clientRequestToken: String? = nil,
        createdAt: Date? = nil,
        failureCode: WorldGenerationJobErrorCode? = nil,
        failureReason: String? = nil,
        finishedWorldsSummary: FinishedWorldsSummary? = nil,
        status: WorldGenerationJobStatus? = nil,
        tags: [String:String]? = nil,
        template: String? = nil,
        worldCount: WorldCount? = nil,
        worldTags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.finishedWorldsSummary = finishedWorldsSummary
        self.status = status
        self.tags = tags
        self.template = template
        self.worldCount = worldCount
        self.worldTags = worldTags
    }
}

struct DescribeWorldGenerationJobOutputResponseBody: Equatable {
    public let arn: String?
    public let status: WorldGenerationJobStatus?
    public let createdAt: Date?
    public let failureCode: WorldGenerationJobErrorCode?
    public let failureReason: String?
    public let clientRequestToken: String?
    public let template: String?
    public let worldCount: WorldCount?
    public let finishedWorldsSummary: FinishedWorldsSummary?
    public let tags: [String:String]?
    public let worldTags: [String:String]?
}

extension DescribeWorldGenerationJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case failureReason
        case finishedWorldsSummary
        case status
        case tags
        case template
        case worldCount
        case worldTags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorldGenerationJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(WorldGenerationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let templateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .template)
        template = templateDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let finishedWorldsSummaryDecoded = try containerValues.decodeIfPresent(FinishedWorldsSummary.self, forKey: .finishedWorldsSummary)
        finishedWorldsSummary = finishedWorldsSummaryDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let worldTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .worldTags)
        var worldTagsDecoded0: [String:String]? = nil
        if let worldTagsContainer = worldTagsContainer {
            worldTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in worldTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    worldTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        worldTags = worldTagsDecoded0
    }
}

public struct DescribeWorldInputBodyMiddleware: Middleware {
    public let id: String = "DescribeWorldInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorldInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorldInput>
    public typealias MOutput = OperationOutput<DescribeWorldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorldOutputError>
}

extension DescribeWorldInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorldInput(world: \(String(describing: world)))"}
}

extension DescribeWorldInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case world
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let world = world {
            try encodeContainer.encode(world, forKey: .world)
        }
    }
}

public struct DescribeWorldInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeWorldInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorldInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorldInput>
    public typealias MOutput = OperationOutput<DescribeWorldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorldOutputError>
}

public struct DescribeWorldInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeWorldInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorldInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorldInput>
    public typealias MOutput = OperationOutput<DescribeWorldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorldOutputError>
}

public struct DescribeWorldInput: Equatable {
    /// <p>The Amazon Resource Name (arn) of the world you want to describe.</p>
    public let world: String?

    public init (
        world: String? = nil
    )
    {
        self.world = world
    }
}

struct DescribeWorldInputBody: Equatable {
    public let world: String?
}

extension DescribeWorldInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case world
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .world)
        world = worldDecoded
    }
}

extension DescribeWorldOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorldOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorldOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorldOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorldOutputResponse(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), generationJob: \(String(describing: generationJob)), tags: \(String(describing: tags)), template: \(String(describing: template)))"}
}

extension DescribeWorldOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeWorldOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.generationJob = output.generationJob
            self.tags = output.tags
            self.template = output.template
        } else {
            self.arn = nil
            self.createdAt = nil
            self.generationJob = nil
            self.tags = nil
            self.template = nil
        }
    }
}

public struct DescribeWorldOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (arn) of the world.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the world was created.</p>
    public let createdAt: Date?
    /// <p>The Amazon Resource Name (arn) of the world generation job that generated the
    ///          world.</p>
    public let generationJob: String?
    /// <p>A map that contains tag keys and tag values that are attached to the world.</p>
    public let tags: [String:String]?
    /// <p>The world template.</p>
    public let template: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        generationJob: String? = nil,
        tags: [String:String]? = nil,
        template: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.generationJob = generationJob
        self.tags = tags
        self.template = template
    }
}

struct DescribeWorldOutputResponseBody: Equatable {
    public let arn: String?
    public let generationJob: String?
    public let template: String?
    public let createdAt: Date?
    public let tags: [String:String]?
}

extension DescribeWorldOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case generationJob
        case tags
        case template
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let generationJobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .generationJob)
        generationJob = generationJobDecoded
        let templateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .template)
        template = templateDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeWorldTemplateInputBodyMiddleware: Middleware {
    public let id: String = "DescribeWorldTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorldTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorldTemplateInput>
    public typealias MOutput = OperationOutput<DescribeWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorldTemplateOutputError>
}

extension DescribeWorldTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorldTemplateInput(template: \(String(describing: template)))"}
}

extension DescribeWorldTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case template
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }
}

public struct DescribeWorldTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeWorldTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorldTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorldTemplateInput>
    public typealias MOutput = OperationOutput<DescribeWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorldTemplateOutputError>
}

public struct DescribeWorldTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeWorldTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorldTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorldTemplateInput>
    public typealias MOutput = OperationOutput<DescribeWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorldTemplateOutputError>
}

public struct DescribeWorldTemplateInput: Equatable {
    /// <p>The Amazon Resource Name (arn) of the world template you want to describe.</p>
    public let template: String?

    public init (
        template: String? = nil
    )
    {
        self.template = template
    }
}

struct DescribeWorldTemplateInputBody: Equatable {
    public let template: String?
}

extension DescribeWorldTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case template
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .template)
        template = templateDecoded
    }
}

extension DescribeWorldTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorldTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorldTemplateOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorldTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorldTemplateOutputResponse(arn: \(String(describing: arn)), clientRequestToken: \(String(describing: clientRequestToken)), createdAt: \(String(describing: createdAt)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension DescribeWorldTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeWorldTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct DescribeWorldTemplateOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the world template.</p>
    public let arn: String?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public let clientRequestToken: String?
    /// <p>The time, in milliseconds since the epoch, when the world template was created.</p>
    public let createdAt: Date?
    /// <p>The time, in milliseconds since the epoch, when the world template was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the world template.</p>
    public let name: String?
    /// <p>A map that contains tag keys and tag values that are attached to the world
    ///          template.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        clientRequestToken: String? = nil,
        createdAt: Date? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.tags = tags
    }
}

struct DescribeWorldTemplateOutputResponseBody: Equatable {
    public let arn: String?
    public let clientRequestToken: String?
    public let name: String?
    public let createdAt: Date?
    public let lastUpdatedAt: Date?
    public let tags: [String:String]?
}

extension DescribeWorldTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case lastUpdatedAt
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum ExitBehavior {
    case fail
    case restart
    case sdkUnknown(String)
}

extension ExitBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExitBehavior] {
        return [
            .fail,
            .restart,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fail: return "FAIL"
        case .restart: return "RESTART"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExitBehavior(rawValue: rawValue) ?? ExitBehavior.sdkUnknown(rawValue)
    }
}

extension FailedCreateSimulationJobRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failedAt
        case failureCode
        case failureReason
        case request
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failedAt = failedAt {
            try encodeContainer.encode(failedAt.timeIntervalSince1970, forKey: .failedAt)
        }
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let request = request {
            try encodeContainer.encode(request, forKey: .request)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestDecoded = try containerValues.decodeIfPresent(SimulationJobRequest.self, forKey: .request)
        request = requestDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .failedAt)
        failedAt = failedAtDecoded
    }
}

extension FailedCreateSimulationJobRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailedCreateSimulationJobRequest(failedAt: \(String(describing: failedAt)), failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), request: \(String(describing: request)))"}
}

/// <p>Information about a failed create simulation job request.</p>
public struct FailedCreateSimulationJobRequest: Equatable {
    /// <p>The time, in milliseconds since the epoch, when the simulation job batch failed.</p>
    public let failedAt: Date?
    /// <p>The failure code.</p>
    public let failureCode: SimulationJobErrorCode?
    /// <p>The failure reason of the simulation job request.</p>
    public let failureReason: String?
    /// <p>The simulation job request.</p>
    public let request: SimulationJobRequest?

    public init (
        failedAt: Date? = nil,
        failureCode: SimulationJobErrorCode? = nil,
        failureReason: String? = nil,
        request: SimulationJobRequest? = nil
    )
    {
        self.failedAt = failedAt
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.request = request
    }
}

public enum FailureBehavior {
    case `continue`
    case fail
    case sdkUnknown(String)
}

extension FailureBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FailureBehavior] {
        return [
            .continue,
            .fail,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .continue: return "Continue"
        case .fail: return "Fail"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FailureBehavior(rawValue: rawValue) ?? FailureBehavior.sdkUnknown(rawValue)
    }
}

extension FailureSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failures
        case totalFailureCount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failures = failures {
            var failuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failures)
            for worldfailures0 in failures {
                try failuresContainer.encode(worldfailures0)
            }
        }
        if totalFailureCount != 0 {
            try encodeContainer.encode(totalFailureCount, forKey: .totalFailureCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalFailureCountDecoded = try containerValues.decode(Int.self, forKey: .totalFailureCount)
        totalFailureCount = totalFailureCountDecoded
        let failuresContainer = try containerValues.decodeIfPresent([WorldFailure?].self, forKey: .failures)
        var failuresDecoded0:[WorldFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [WorldFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

extension FailureSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailureSummary(failures: \(String(describing: failures)), totalFailureCount: \(String(describing: totalFailureCount)))"}
}

/// <p>Information about worlds that failed.</p>
public struct FailureSummary: Equatable {
    /// <p>The worlds that failed.</p>
    public let failures: [WorldFailure]?
    /// <p>The total number of failures.</p>
    public let totalFailureCount: Int

    public init (
        failures: [WorldFailure]? = nil,
        totalFailureCount: Int = 0
    )
    {
        self.failures = failures
        self.totalFailureCount = totalFailureCount
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>Information about a filter.</p>
public struct Filter: Equatable {
    /// <p>The name of the filter.</p>
    public let name: String?
    /// <p>A list of values.</p>
    public let values: [String]?

    public init (
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension FinishedWorldsSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureSummary
        case finishedCount
        case succeededWorlds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureSummary = failureSummary {
            try encodeContainer.encode(failureSummary, forKey: .failureSummary)
        }
        if finishedCount != 0 {
            try encodeContainer.encode(finishedCount, forKey: .finishedCount)
        }
        if let succeededWorlds = succeededWorlds {
            var succeededWorldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .succeededWorlds)
            for arns0 in succeededWorlds {
                try succeededWorldsContainer.encode(arns0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let finishedCountDecoded = try containerValues.decode(Int.self, forKey: .finishedCount)
        finishedCount = finishedCountDecoded
        let succeededWorldsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .succeededWorlds)
        var succeededWorldsDecoded0:[String]? = nil
        if let succeededWorldsContainer = succeededWorldsContainer {
            succeededWorldsDecoded0 = [String]()
            for string0 in succeededWorldsContainer {
                if let string0 = string0 {
                    succeededWorldsDecoded0?.append(string0)
                }
            }
        }
        succeededWorlds = succeededWorldsDecoded0
        let failureSummaryDecoded = try containerValues.decodeIfPresent(FailureSummary.self, forKey: .failureSummary)
        failureSummary = failureSummaryDecoded
    }
}

extension FinishedWorldsSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FinishedWorldsSummary(failureSummary: \(String(describing: failureSummary)), finishedCount: \(String(describing: finishedCount)), succeededWorlds: \(String(describing: succeededWorlds)))"}
}

/// <p>Information about worlds that finished.</p>
public struct FinishedWorldsSummary: Equatable {
    /// <p>Information about worlds that failed.</p>
    public let failureSummary: FailureSummary?
    /// <p>The total number of finished worlds.</p>
    public let finishedCount: Int
    /// <p>A list of worlds that succeeded.</p>
    public let succeededWorlds: [String]?

    public init (
        failureSummary: FailureSummary? = nil,
        finishedCount: Int = 0,
        succeededWorlds: [String]? = nil
    )
    {
        self.failureSummary = failureSummary
        self.finishedCount = finishedCount
        self.succeededWorlds = succeededWorlds
    }
}

extension Fleet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case lastDeploymentJob
        case lastDeploymentStatus
        case lastDeploymentTime
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let lastDeploymentJob = lastDeploymentJob {
            try encodeContainer.encode(lastDeploymentJob, forKey: .lastDeploymentJob)
        }
        if let lastDeploymentStatus = lastDeploymentStatus {
            try encodeContainer.encode(lastDeploymentStatus.rawValue, forKey: .lastDeploymentStatus)
        }
        if let lastDeploymentTime = lastDeploymentTime {
            try encodeContainer.encode(lastDeploymentTime.timeIntervalSince1970, forKey: .lastDeploymentTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentStatusDecoded = try containerValues.decodeIfPresent(DeploymentStatus.self, forKey: .lastDeploymentStatus)
        lastDeploymentStatus = lastDeploymentStatusDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
    }
}

extension Fleet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Fleet(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), lastDeploymentJob: \(String(describing: lastDeploymentJob)), lastDeploymentStatus: \(String(describing: lastDeploymentStatus)), lastDeploymentTime: \(String(describing: lastDeploymentTime)), name: \(String(describing: name)))"}
}

/// <p>Information about a fleet.</p>
public struct Fleet: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the fleet was created.</p>
    public let createdAt: Date?
    /// <p>The Amazon Resource Name (ARN) of the last deployment job.</p>
    public let lastDeploymentJob: String?
    /// <p>The status of the last fleet deployment.</p>
    public let lastDeploymentStatus: DeploymentStatus?
    /// <p>The time of the last deployment.</p>
    public let lastDeploymentTime: Date?
    /// <p>The name of the fleet.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        lastDeploymentJob: String? = nil,
        lastDeploymentStatus: DeploymentStatus? = nil,
        lastDeploymentTime: Date? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastDeploymentJob = lastDeploymentJob
        self.lastDeploymentStatus = lastDeploymentStatus
        self.lastDeploymentTime = lastDeploymentTime
        self.name = name
    }
}

public struct GetWorldTemplateBodyInputBodyMiddleware: Middleware {
    public let id: String = "GetWorldTemplateBodyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorldTemplateBodyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorldTemplateBodyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorldTemplateBodyInput>
    public typealias MOutput = OperationOutput<GetWorldTemplateBodyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorldTemplateBodyOutputError>
}

extension GetWorldTemplateBodyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorldTemplateBodyInput(generationJob: \(String(describing: generationJob)), template: \(String(describing: template)))"}
}

extension GetWorldTemplateBodyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case generationJob
        case template
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generationJob = generationJob {
            try encodeContainer.encode(generationJob, forKey: .generationJob)
        }
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }
}

public struct GetWorldTemplateBodyInputHeadersMiddleware: Middleware {
    public let id: String = "GetWorldTemplateBodyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorldTemplateBodyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorldTemplateBodyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorldTemplateBodyInput>
    public typealias MOutput = OperationOutput<GetWorldTemplateBodyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorldTemplateBodyOutputError>
}

public struct GetWorldTemplateBodyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWorldTemplateBodyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorldTemplateBodyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorldTemplateBodyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorldTemplateBodyInput>
    public typealias MOutput = OperationOutput<GetWorldTemplateBodyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorldTemplateBodyOutputError>
}

public struct GetWorldTemplateBodyInput: Equatable {
    /// <p>The Amazon Resource Name (arn) of the world generator job.</p>
    public let generationJob: String?
    /// <p>The Amazon Resource Name (arn) of the world template.</p>
    public let template: String?

    public init (
        generationJob: String? = nil,
        template: String? = nil
    )
    {
        self.generationJob = generationJob
        self.template = template
    }
}

struct GetWorldTemplateBodyInputBody: Equatable {
    public let template: String?
    public let generationJob: String?
}

extension GetWorldTemplateBodyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case generationJob
        case template
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .template)
        template = templateDecoded
        let generationJobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .generationJob)
        generationJob = generationJobDecoded
    }
}

extension GetWorldTemplateBodyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorldTemplateBodyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWorldTemplateBodyOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorldTemplateBodyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorldTemplateBodyOutputResponse(templateBody: \(String(describing: templateBody)))"}
}

extension GetWorldTemplateBodyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWorldTemplateBodyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.templateBody = output.templateBody
        } else {
            self.templateBody = nil
        }
    }
}

public struct GetWorldTemplateBodyOutputResponse: Equatable {
    /// <p>The world template body.</p>
    public let templateBody: String?

    public init (
        templateBody: String? = nil
    )
    {
        self.templateBody = templateBody
    }
}

struct GetWorldTemplateBodyOutputResponseBody: Equatable {
    public let templateBody: String?
}

extension GetWorldTemplateBodyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case templateBody
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
    }
}

extension IdempotentParameterMismatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdempotentParameterMismatchException(message: \(String(describing: message)))"}
}

extension IdempotentParameterMismatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request uses the same client token as a previous, but non-identical request. Do not
///          reuse a client token with different requests, unless the requests are identical. </p>
public struct IdempotentParameterMismatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Equatable {
    public let message: String?
}

extension IdempotentParameterMismatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS RoboMaker experienced a service issue. Try your call again.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A parameter specified in a request is not valid, is unsupported, or cannot be used. The
///          returned message provides an explanation of the error value.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LaunchConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case environmentVariables
        case launchFile
        case packageName
        case portForwardingConfig
        case streamUI
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentvariablemap0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariablemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let launchFile = launchFile {
            try encodeContainer.encode(launchFile, forKey: .launchFile)
        }
        if let packageName = packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let portForwardingConfig = portForwardingConfig {
            try encodeContainer.encode(portForwardingConfig, forKey: .portForwardingConfig)
        }
        if streamUI != false {
            try encodeContainer.encode(streamUI, forKey: .streamUI)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let launchFileDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchFile)
        launchFile = launchFileDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [String:String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [String:String]()
            for (key0, environmentvariablevalue0) in environmentVariablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    environmentVariablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let portForwardingConfigDecoded = try containerValues.decodeIfPresent(PortForwardingConfig.self, forKey: .portForwardingConfig)
        portForwardingConfig = portForwardingConfigDecoded
        let streamUIDecoded = try containerValues.decode(Bool.self, forKey: .streamUI)
        streamUI = streamUIDecoded
    }
}

extension LaunchConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchConfig(environmentVariables: \(String(describing: environmentVariables)), launchFile: \(String(describing: launchFile)), packageName: \(String(describing: packageName)), portForwardingConfig: \(String(describing: portForwardingConfig)), streamUI: \(String(describing: streamUI)))"}
}

/// <p>Information about a launch configuration.</p>
public struct LaunchConfig: Equatable {
    /// <p>The environment variables for the application launch.</p>
    public let environmentVariables: [String:String]?
    /// <p>The launch file name.</p>
    public let launchFile: String?
    /// <p>The package name.</p>
    public let packageName: String?
    /// <p>The port forwarding configuration.</p>
    public let portForwardingConfig: PortForwardingConfig?
    /// <p>Boolean indicating whether a streaming session will be configured for the application.
    ///          If <code>True</code>, AWS RoboMaker will configure a connection so you can interact with
    ///          your application as it is running in the simulation. You must configure and launch the
    ///          component. It must have a graphical user interface. </p>
    public let streamUI: Bool

    public init (
        environmentVariables: [String:String]? = nil,
        launchFile: String? = nil,
        packageName: String? = nil,
        portForwardingConfig: PortForwardingConfig? = nil,
        streamUI: Bool = false
    )
    {
        self.environmentVariables = environmentVariables
        self.launchFile = launchFile
        self.packageName = packageName
        self.portForwardingConfig = portForwardingConfig
        self.streamUI = streamUI
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource exceeds the maximum number allowed, or the number of concurrent
///          stream requests exceeds the maximum number allowed. </p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListDeploymentJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListDeploymentJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeploymentJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeploymentJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeploymentJobsInput>
    public typealias MOutput = OperationOutput<ListDeploymentJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeploymentJobsOutputError>
}

extension ListDeploymentJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeploymentJobsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeploymentJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDeploymentJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDeploymentJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeploymentJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeploymentJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeploymentJobsInput>
    public typealias MOutput = OperationOutput<ListDeploymentJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeploymentJobsOutputError>
}

public struct ListDeploymentJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDeploymentJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeploymentJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeploymentJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeploymentJobsInput>
    public typealias MOutput = OperationOutput<ListDeploymentJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeploymentJobsOutputError>
}

public struct ListDeploymentJobsInput: Equatable {
    /// <p>Optional filters to limit results.</p>
    ///          <p>The filter names <code>status</code> and <code>fleetName</code> are supported. When
    ///          filtering, you must use the complete value of the filtered item. You can use up to three
    ///          filters, but they must be for the same named item. For example, if you are looking for
    ///          items with the status <code>InProgress</code> or the status <code>Pending</code>.</p>
    public let filters: [Filter]?
    /// <p>When this parameter is used, <code>ListDeploymentJobs</code> only returns
    ///             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another <code>ListDeploymentJobs</code> request with the returned <code>nextToken</code>
    ///          value. This value can be between 1 and 200. If this parameter is not used, then
    ///             <code>ListDeploymentJobs</code> returns up to 200 results and a <code>nextToken</code>
    ///          value if applicable. </p>
    public let maxResults: Int?
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListDeploymentJobs</code> again and assign that token to
    ///          the request object's <code>nextToken</code> parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentJobsInputBody: Equatable {
    public let filters: [Filter]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDeploymentJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDeploymentJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeploymentJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeploymentJobsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeploymentJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeploymentJobsOutputResponse(deploymentJobs: \(String(describing: deploymentJobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeploymentJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDeploymentJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deploymentJobs = output.deploymentJobs
            self.nextToken = output.nextToken
        } else {
            self.deploymentJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentJobsOutputResponse: Equatable {
    /// <p>A list of deployment jobs that meet the criteria of the request.</p>
    public let deploymentJobs: [DeploymentJob]?
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListDeploymentJobs</code> again and assign that token to
    ///          the request object's <code>nextToken</code> parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?

    public init (
        deploymentJobs: [DeploymentJob]? = nil,
        nextToken: String? = nil
    )
    {
        self.deploymentJobs = deploymentJobs
        self.nextToken = nextToken
    }
}

struct ListDeploymentJobsOutputResponseBody: Equatable {
    public let deploymentJobs: [DeploymentJob]?
    public let nextToken: String?
}

extension ListDeploymentJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deploymentJobs
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentJobsContainer = try containerValues.decodeIfPresent([DeploymentJob?].self, forKey: .deploymentJobs)
        var deploymentJobsDecoded0:[DeploymentJob]? = nil
        if let deploymentJobsContainer = deploymentJobsContainer {
            deploymentJobsDecoded0 = [DeploymentJob]()
            for structure0 in deploymentJobsContainer {
                if let structure0 = structure0 {
                    deploymentJobsDecoded0?.append(structure0)
                }
            }
        }
        deploymentJobs = deploymentJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFleetsInputBodyMiddleware: Middleware {
    public let id: String = "ListFleetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFleetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFleetsInput>
    public typealias MOutput = OperationOutput<ListFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFleetsOutputError>
}

extension ListFleetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFleetsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFleetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFleetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFleetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFleetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFleetsInput>
    public typealias MOutput = OperationOutput<ListFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFleetsOutputError>
}

public struct ListFleetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFleetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFleetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFleetsInput>
    public typealias MOutput = OperationOutput<ListFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFleetsOutputError>
}

public struct ListFleetsInput: Equatable {
    /// <p>Optional filters to limit results.</p>
    ///          <p>The filter name <code>name</code> is supported. When filtering, you must use the
    ///          complete value of the filtered item. You can use up to three filters.</p>
    public let filters: [Filter]?
    /// <p>When this parameter is used, <code>ListFleets</code> only returns
    ///             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another <code>ListFleets</code> request with the returned <code>nextToken</code> value.
    ///          This value can be between 1 and 200. If this parameter is not used, then
    ///             <code>ListFleets</code> returns up to 200 results and a <code>nextToken</code> value if
    ///          applicable. </p>
    public let maxResults: Int?
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListFleets</code> again and assign that token to the
    ///          request object's <code>nextToken</code> parameter. If there are no remaining results, the
    ///          previous response object's NextToken parameter is set to null. </p>
    ///          <note>
    ///             <p>This token should be treated as an opaque identifier that is only used to retrieve
    ///             the next items in a list and not for other programmatic purposes.</p>
    ///          </note>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFleetsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
}

extension ListFleetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListFleetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFleetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFleetsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFleetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFleetsOutputResponse(fleetDetails: \(String(describing: fleetDetails)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFleetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFleetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fleetDetails = output.fleetDetails
            self.nextToken = output.nextToken
        } else {
            self.fleetDetails = nil
            self.nextToken = nil
        }
    }
}

public struct ListFleetsOutputResponse: Equatable {
    /// <p>A list of fleet details meeting the request criteria.</p>
    public let fleetDetails: [Fleet]?
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListFleets</code> again and assign that token to the
    ///          request object's <code>nextToken</code> parameter. If there are no remaining results, the
    ///          previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?

    public init (
        fleetDetails: [Fleet]? = nil,
        nextToken: String? = nil
    )
    {
        self.fleetDetails = fleetDetails
        self.nextToken = nextToken
    }
}

struct ListFleetsOutputResponseBody: Equatable {
    public let fleetDetails: [Fleet]?
    public let nextToken: String?
}

extension ListFleetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetDetails
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDetailsContainer = try containerValues.decodeIfPresent([Fleet?].self, forKey: .fleetDetails)
        var fleetDetailsDecoded0:[Fleet]? = nil
        if let fleetDetailsContainer = fleetDetailsContainer {
            fleetDetailsDecoded0 = [Fleet]()
            for structure0 in fleetDetailsContainer {
                if let structure0 = structure0 {
                    fleetDetailsDecoded0?.append(structure0)
                }
            }
        }
        fleetDetails = fleetDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRobotApplicationsInputBodyMiddleware: Middleware {
    public let id: String = "ListRobotApplicationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRobotApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRobotApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRobotApplicationsInput>
    public typealias MOutput = OperationOutput<ListRobotApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRobotApplicationsOutputError>
}

extension ListRobotApplicationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRobotApplicationsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), versionQualifier: \(String(describing: versionQualifier)))"}
}

extension ListRobotApplicationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let versionQualifier = versionQualifier {
            try encodeContainer.encode(versionQualifier, forKey: .versionQualifier)
        }
    }
}

public struct ListRobotApplicationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRobotApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRobotApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRobotApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRobotApplicationsInput>
    public typealias MOutput = OperationOutput<ListRobotApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRobotApplicationsOutputError>
}

public struct ListRobotApplicationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRobotApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRobotApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRobotApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRobotApplicationsInput>
    public typealias MOutput = OperationOutput<ListRobotApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRobotApplicationsOutputError>
}

public struct ListRobotApplicationsInput: Equatable {
    /// <p>Optional filters to limit results.</p>
    ///          <p>The filter name <code>name</code> is supported. When filtering, you must use the
    ///          complete value of the filtered item. You can use up to three filters.</p>
    public let filters: [Filter]?
    /// <p>When this parameter is used, <code>ListRobotApplications</code> only returns
    ///             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another <code>ListRobotApplications</code> request with the returned <code>nextToken</code>
    ///          value. This value can be between 1 and 100. If this parameter is not used, then
    ///             <code>ListRobotApplications</code> returns up to 100 results and a
    ///             <code>nextToken</code> value if applicable. </p>
    public let maxResults: Int?
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListRobotApplications</code> again and assign that token to
    ///          the request object's <code>nextToken</code> parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?
    /// <p>The version qualifier of the robot application.</p>
    public let versionQualifier: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        versionQualifier: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.versionQualifier = versionQualifier
    }
}

struct ListRobotApplicationsInputBody: Equatable {
    public let versionQualifier: String?
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
}

extension ListRobotApplicationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionQualifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionQualifier)
        versionQualifier = versionQualifierDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListRobotApplicationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRobotApplicationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRobotApplicationsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRobotApplicationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRobotApplicationsOutputResponse(nextToken: \(String(describing: nextToken)), robotApplicationSummaries: \(String(describing: robotApplicationSummaries)))"}
}

extension ListRobotApplicationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRobotApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.robotApplicationSummaries = output.robotApplicationSummaries
        } else {
            self.nextToken = nil
            self.robotApplicationSummaries = nil
        }
    }
}

public struct ListRobotApplicationsOutputResponse: Equatable {
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListRobotApplications</code> again and assign that token to
    ///          the request object's <code>nextToken</code> parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?
    /// <p>A list of robot application summaries that meet the criteria of the request.</p>
    public let robotApplicationSummaries: [RobotApplicationSummary]?

    public init (
        nextToken: String? = nil,
        robotApplicationSummaries: [RobotApplicationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.robotApplicationSummaries = robotApplicationSummaries
    }
}

struct ListRobotApplicationsOutputResponseBody: Equatable {
    public let robotApplicationSummaries: [RobotApplicationSummary]?
    public let nextToken: String?
}

extension ListRobotApplicationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case robotApplicationSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotApplicationSummariesContainer = try containerValues.decodeIfPresent([RobotApplicationSummary?].self, forKey: .robotApplicationSummaries)
        var robotApplicationSummariesDecoded0:[RobotApplicationSummary]? = nil
        if let robotApplicationSummariesContainer = robotApplicationSummariesContainer {
            robotApplicationSummariesDecoded0 = [RobotApplicationSummary]()
            for structure0 in robotApplicationSummariesContainer {
                if let structure0 = structure0 {
                    robotApplicationSummariesDecoded0?.append(structure0)
                }
            }
        }
        robotApplicationSummaries = robotApplicationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRobotsInputBodyMiddleware: Middleware {
    public let id: String = "ListRobotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRobotsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRobotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRobotsInput>
    public typealias MOutput = OperationOutput<ListRobotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRobotsOutputError>
}

extension ListRobotsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRobotsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRobotsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRobotsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRobotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRobotsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRobotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRobotsInput>
    public typealias MOutput = OperationOutput<ListRobotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRobotsOutputError>
}

public struct ListRobotsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRobotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRobotsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRobotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRobotsInput>
    public typealias MOutput = OperationOutput<ListRobotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRobotsOutputError>
}

public struct ListRobotsInput: Equatable {
    /// <p>Optional filters to limit results.</p>
    ///          <p>The filter names <code>status</code> and <code>fleetName</code> are supported. When
    ///          filtering, you must use the complete value of the filtered item. You can use up to three
    ///          filters, but they must be for the same named item. For example, if you are looking for
    ///          items with the status <code>Registered</code> or the status <code>Available</code>.</p>
    public let filters: [Filter]?
    /// <p>When this parameter is used, <code>ListRobots</code> only returns
    ///             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another <code>ListRobots</code> request with the returned <code>nextToken</code> value.
    ///          This value can be between 1 and 200. If this parameter is not used, then
    ///             <code>ListRobots</code> returns up to 200 results and a <code>nextToken</code> value if
    ///          applicable. </p>
    public let maxResults: Int?
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListRobots</code> again and assign that token to the
    ///          request object's <code>nextToken</code> parameter. If there are no remaining results, the
    ///          previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRobotsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
}

extension ListRobotsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListRobotsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRobotsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRobotsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRobotsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRobotsOutputResponse(nextToken: \(String(describing: nextToken)), robots: \(String(describing: robots)))"}
}

extension ListRobotsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRobotsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.robots = output.robots
        } else {
            self.nextToken = nil
            self.robots = nil
        }
    }
}

public struct ListRobotsOutputResponse: Equatable {
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListRobots</code> again and assign that token to the
    ///          request object's <code>nextToken</code> parameter. If there are no remaining results, the
    ///          previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?
    /// <p>A list of robots that meet the criteria of the request.</p>
    public let robots: [Robot]?

    public init (
        nextToken: String? = nil,
        robots: [Robot]? = nil
    )
    {
        self.nextToken = nextToken
        self.robots = robots
    }
}

struct ListRobotsOutputResponseBody: Equatable {
    public let robots: [Robot]?
    public let nextToken: String?
}

extension ListRobotsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case robots
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotsContainer = try containerValues.decodeIfPresent([Robot?].self, forKey: .robots)
        var robotsDecoded0:[Robot]? = nil
        if let robotsContainer = robotsContainer {
            robotsDecoded0 = [Robot]()
            for structure0 in robotsContainer {
                if let structure0 = structure0 {
                    robotsDecoded0?.append(structure0)
                }
            }
        }
        robots = robotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSimulationApplicationsInputBodyMiddleware: Middleware {
    public let id: String = "ListSimulationApplicationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSimulationApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSimulationApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSimulationApplicationsInput>
    public typealias MOutput = OperationOutput<ListSimulationApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSimulationApplicationsOutputError>
}

extension ListSimulationApplicationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSimulationApplicationsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), versionQualifier: \(String(describing: versionQualifier)))"}
}

extension ListSimulationApplicationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let versionQualifier = versionQualifier {
            try encodeContainer.encode(versionQualifier, forKey: .versionQualifier)
        }
    }
}

public struct ListSimulationApplicationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSimulationApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSimulationApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSimulationApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSimulationApplicationsInput>
    public typealias MOutput = OperationOutput<ListSimulationApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSimulationApplicationsOutputError>
}

public struct ListSimulationApplicationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSimulationApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSimulationApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSimulationApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSimulationApplicationsInput>
    public typealias MOutput = OperationOutput<ListSimulationApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSimulationApplicationsOutputError>
}

public struct ListSimulationApplicationsInput: Equatable {
    /// <p>Optional list of filters to limit results.</p>
    ///          <p>The filter name <code>name</code> is supported. When filtering, you must use the
    ///          complete value of the filtered item. You can use up to three filters.</p>
    public let filters: [Filter]?
    /// <p>When this parameter is used, <code>ListSimulationApplications</code> only returns
    ///             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another <code>ListSimulationApplications</code> request with the returned
    ///             <code>nextToken</code> value. This value can be between 1 and 100. If this parameter is
    ///          not used, then <code>ListSimulationApplications</code> returns up to 100 results and a
    ///             <code>nextToken</code> value if applicable. </p>
    public let maxResults: Int?
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListSimulationApplications</code> again and assign that
    ///          token to the request object's <code>nextToken</code> parameter. If there are no remaining
    ///          results, the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?
    /// <p>The version qualifier of the simulation application.</p>
    public let versionQualifier: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        versionQualifier: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.versionQualifier = versionQualifier
    }
}

struct ListSimulationApplicationsInputBody: Equatable {
    public let versionQualifier: String?
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
}

extension ListSimulationApplicationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionQualifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionQualifier)
        versionQualifier = versionQualifierDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListSimulationApplicationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSimulationApplicationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSimulationApplicationsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSimulationApplicationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSimulationApplicationsOutputResponse(nextToken: \(String(describing: nextToken)), simulationApplicationSummaries: \(String(describing: simulationApplicationSummaries)))"}
}

extension ListSimulationApplicationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSimulationApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.simulationApplicationSummaries = output.simulationApplicationSummaries
        } else {
            self.nextToken = nil
            self.simulationApplicationSummaries = nil
        }
    }
}

public struct ListSimulationApplicationsOutputResponse: Equatable {
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListSimulationApplications</code> again and assign that
    ///          token to the request object's <code>nextToken</code> parameter. If there are no remaining
    ///          results, the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?
    /// <p>A list of simulation application summaries that meet the criteria of the request.</p>
    public let simulationApplicationSummaries: [SimulationApplicationSummary]?

    public init (
        nextToken: String? = nil,
        simulationApplicationSummaries: [SimulationApplicationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulationApplicationSummaries = simulationApplicationSummaries
    }
}

struct ListSimulationApplicationsOutputResponseBody: Equatable {
    public let simulationApplicationSummaries: [SimulationApplicationSummary]?
    public let nextToken: String?
}

extension ListSimulationApplicationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case simulationApplicationSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationApplicationSummariesContainer = try containerValues.decodeIfPresent([SimulationApplicationSummary?].self, forKey: .simulationApplicationSummaries)
        var simulationApplicationSummariesDecoded0:[SimulationApplicationSummary]? = nil
        if let simulationApplicationSummariesContainer = simulationApplicationSummariesContainer {
            simulationApplicationSummariesDecoded0 = [SimulationApplicationSummary]()
            for structure0 in simulationApplicationSummariesContainer {
                if let structure0 = structure0 {
                    simulationApplicationSummariesDecoded0?.append(structure0)
                }
            }
        }
        simulationApplicationSummaries = simulationApplicationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSimulationJobBatchesInputBodyMiddleware: Middleware {
    public let id: String = "ListSimulationJobBatchesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSimulationJobBatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSimulationJobBatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSimulationJobBatchesInput>
    public typealias MOutput = OperationOutput<ListSimulationJobBatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSimulationJobBatchesOutputError>
}

extension ListSimulationJobBatchesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSimulationJobBatchesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSimulationJobBatchesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSimulationJobBatchesInputHeadersMiddleware: Middleware {
    public let id: String = "ListSimulationJobBatchesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSimulationJobBatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSimulationJobBatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSimulationJobBatchesInput>
    public typealias MOutput = OperationOutput<ListSimulationJobBatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSimulationJobBatchesOutputError>
}

public struct ListSimulationJobBatchesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSimulationJobBatchesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSimulationJobBatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSimulationJobBatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSimulationJobBatchesInput>
    public typealias MOutput = OperationOutput<ListSimulationJobBatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSimulationJobBatchesOutputError>
}

public struct ListSimulationJobBatchesInput: Equatable {
    /// <p>Optional filters to limit results.</p>
    public let filters: [Filter]?
    /// <p>When this parameter is used, <code>ListSimulationJobBatches</code> only returns
    ///             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another <code>ListSimulationJobBatches</code> request with the returned
    ///             <code>nextToken</code> value. </p>
    public let maxResults: Int?
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListSimulationJobBatches</code> again and assign that token
    ///          to the request object's <code>nextToken</code> parameter. If there are no remaining
    ///          results, the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSimulationJobBatchesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
}

extension ListSimulationJobBatchesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListSimulationJobBatchesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSimulationJobBatchesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSimulationJobBatchesOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSimulationJobBatchesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSimulationJobBatchesOutputResponse(nextToken: \(String(describing: nextToken)), simulationJobBatchSummaries: \(String(describing: simulationJobBatchSummaries)))"}
}

extension ListSimulationJobBatchesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSimulationJobBatchesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.simulationJobBatchSummaries = output.simulationJobBatchSummaries
        } else {
            self.nextToken = nil
            self.simulationJobBatchSummaries = nil
        }
    }
}

public struct ListSimulationJobBatchesOutputResponse: Equatable {
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListSimulationJobBatches</code> again and assign that token
    ///          to the request object's <code>nextToken</code> parameter. If there are no remaining
    ///          results, the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?
    /// <p>A list of simulation job batch summaries.</p>
    public let simulationJobBatchSummaries: [SimulationJobBatchSummary]?

    public init (
        nextToken: String? = nil,
        simulationJobBatchSummaries: [SimulationJobBatchSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulationJobBatchSummaries = simulationJobBatchSummaries
    }
}

struct ListSimulationJobBatchesOutputResponseBody: Equatable {
    public let simulationJobBatchSummaries: [SimulationJobBatchSummary]?
    public let nextToken: String?
}

extension ListSimulationJobBatchesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case simulationJobBatchSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationJobBatchSummariesContainer = try containerValues.decodeIfPresent([SimulationJobBatchSummary?].self, forKey: .simulationJobBatchSummaries)
        var simulationJobBatchSummariesDecoded0:[SimulationJobBatchSummary]? = nil
        if let simulationJobBatchSummariesContainer = simulationJobBatchSummariesContainer {
            simulationJobBatchSummariesDecoded0 = [SimulationJobBatchSummary]()
            for structure0 in simulationJobBatchSummariesContainer {
                if let structure0 = structure0 {
                    simulationJobBatchSummariesDecoded0?.append(structure0)
                }
            }
        }
        simulationJobBatchSummaries = simulationJobBatchSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSimulationJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListSimulationJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSimulationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSimulationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSimulationJobsInput>
    public typealias MOutput = OperationOutput<ListSimulationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSimulationJobsOutputError>
}

extension ListSimulationJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSimulationJobsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSimulationJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSimulationJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSimulationJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSimulationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSimulationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSimulationJobsInput>
    public typealias MOutput = OperationOutput<ListSimulationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSimulationJobsOutputError>
}

public struct ListSimulationJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSimulationJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSimulationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSimulationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSimulationJobsInput>
    public typealias MOutput = OperationOutput<ListSimulationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSimulationJobsOutputError>
}

public struct ListSimulationJobsInput: Equatable {
    /// <p>Optional filters to limit results.</p>
    ///          <p>The filter names <code>status</code> and <code>simulationApplicationName</code> and
    ///             <code>robotApplicationName</code> are supported. When filtering, you must use the
    ///          complete value of the filtered item. You can use up to three filters, but they must be for
    ///          the same named item. For example, if you are looking for items with the status
    ///             <code>Preparing</code> or the status <code>Running</code>.</p>
    public let filters: [Filter]?
    /// <p>When this parameter is used, <code>ListSimulationJobs</code> only returns
    ///             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another <code>ListSimulationJobs</code> request with the returned <code>nextToken</code>
    ///          value. This value can be between 1 and 1000. If this parameter is not used, then
    ///             <code>ListSimulationJobs</code> returns up to 1000 results and a <code>nextToken</code>
    ///          value if applicable. </p>
    public let maxResults: Int?
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListSimulationJobs</code> again and assign that token to
    ///          the request object's <code>nextToken</code> parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSimulationJobsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
}

extension ListSimulationJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListSimulationJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSimulationJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSimulationJobsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSimulationJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSimulationJobsOutputResponse(nextToken: \(String(describing: nextToken)), simulationJobSummaries: \(String(describing: simulationJobSummaries)))"}
}

extension ListSimulationJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSimulationJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.simulationJobSummaries = output.simulationJobSummaries
        } else {
            self.nextToken = nil
            self.simulationJobSummaries = nil
        }
    }
}

public struct ListSimulationJobsOutputResponse: Equatable {
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListSimulationJobs</code> again and assign that token to
    ///          the request object's <code>nextToken</code> parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?
    /// <p>A list of simulation job summaries that meet the criteria of the request.</p>
    public let simulationJobSummaries: [SimulationJobSummary]?

    public init (
        nextToken: String? = nil,
        simulationJobSummaries: [SimulationJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulationJobSummaries = simulationJobSummaries
    }
}

struct ListSimulationJobsOutputResponseBody: Equatable {
    public let simulationJobSummaries: [SimulationJobSummary]?
    public let nextToken: String?
}

extension ListSimulationJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case simulationJobSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationJobSummariesContainer = try containerValues.decodeIfPresent([SimulationJobSummary?].self, forKey: .simulationJobSummaries)
        var simulationJobSummariesDecoded0:[SimulationJobSummary]? = nil
        if let simulationJobSummariesContainer = simulationJobSummariesContainer {
            simulationJobSummariesDecoded0 = [SimulationJobSummary]()
            for structure0 in simulationJobSummariesContainer {
                if let structure0 = structure0 {
                    simulationJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        simulationJobSummaries = simulationJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The AWS RoboMaker Amazon Resource Name (ARN) with tags to be listed.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The list of all tags added to the specified resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListWorldExportJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListWorldExportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorldExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorldExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorldExportJobsInput>
    public typealias MOutput = OperationOutput<ListWorldExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorldExportJobsOutputError>
}

extension ListWorldExportJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorldExportJobsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListWorldExportJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWorldExportJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListWorldExportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorldExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorldExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorldExportJobsInput>
    public typealias MOutput = OperationOutput<ListWorldExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorldExportJobsOutputError>
}

public struct ListWorldExportJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWorldExportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorldExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorldExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorldExportJobsInput>
    public typealias MOutput = OperationOutput<ListWorldExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorldExportJobsOutputError>
}

public struct ListWorldExportJobsInput: Equatable {
    /// <p>Optional filters to limit results. You can use <code>generationJobId</code> and
    ///             <code>templateId</code>.</p>
    public let filters: [Filter]?
    /// <p>When this parameter is used, <code>ListWorldExportJobs</code> only returns
    ///             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another <code>ListWorldExportJobs</code> request with the returned <code>nextToken</code>
    ///          value. This value can be between 1 and 100. If this parameter is not used, then
    ///             <code>ListWorldExportJobs</code> returns up to 100 results and a <code>nextToken</code>
    ///          value if applicable. </p>
    public let maxResults: Int?
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListWorldExportJobs</code> again and assign that token to
    ///          the request object's <code>nextToken</code> parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldExportJobsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
}

extension ListWorldExportJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWorldExportJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorldExportJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorldExportJobsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorldExportJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorldExportJobsOutputResponse(nextToken: \(String(describing: nextToken)), worldExportJobSummaries: \(String(describing: worldExportJobSummaries)))"}
}

extension ListWorldExportJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWorldExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.worldExportJobSummaries = output.worldExportJobSummaries
        } else {
            self.nextToken = nil
            self.worldExportJobSummaries = nil
        }
    }
}

public struct ListWorldExportJobsOutputResponse: Equatable {
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListWorldExportJobsRequest</code> again and assign that
    ///          token to the request object's <code>nextToken</code> parameter. If there are no remaining
    ///          results, the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?
    /// <p>Summary information for world export jobs.</p>
    public let worldExportJobSummaries: [WorldExportJobSummary]?

    public init (
        nextToken: String? = nil,
        worldExportJobSummaries: [WorldExportJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.worldExportJobSummaries = worldExportJobSummaries
    }
}

struct ListWorldExportJobsOutputResponseBody: Equatable {
    public let worldExportJobSummaries: [WorldExportJobSummary]?
    public let nextToken: String?
}

extension ListWorldExportJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case worldExportJobSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldExportJobSummariesContainer = try containerValues.decodeIfPresent([WorldExportJobSummary?].self, forKey: .worldExportJobSummaries)
        var worldExportJobSummariesDecoded0:[WorldExportJobSummary]? = nil
        if let worldExportJobSummariesContainer = worldExportJobSummariesContainer {
            worldExportJobSummariesDecoded0 = [WorldExportJobSummary]()
            for structure0 in worldExportJobSummariesContainer {
                if let structure0 = structure0 {
                    worldExportJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        worldExportJobSummaries = worldExportJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListWorldGenerationJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListWorldGenerationJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorldGenerationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorldGenerationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorldGenerationJobsInput>
    public typealias MOutput = OperationOutput<ListWorldGenerationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorldGenerationJobsOutputError>
}

extension ListWorldGenerationJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorldGenerationJobsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListWorldGenerationJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWorldGenerationJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListWorldGenerationJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorldGenerationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorldGenerationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorldGenerationJobsInput>
    public typealias MOutput = OperationOutput<ListWorldGenerationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorldGenerationJobsOutputError>
}

public struct ListWorldGenerationJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWorldGenerationJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorldGenerationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorldGenerationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorldGenerationJobsInput>
    public typealias MOutput = OperationOutput<ListWorldGenerationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorldGenerationJobsOutputError>
}

public struct ListWorldGenerationJobsInput: Equatable {
    /// <p>Optional filters to limit results. You can use <code>status</code> and
    ///             <code>templateId</code>.</p>
    public let filters: [Filter]?
    /// <p>When this parameter is used, <code>ListWorldGeneratorJobs</code> only returns
    ///             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another <code>ListWorldGeneratorJobs</code> request with the returned
    ///             <code>nextToken</code> value. This value can be between 1 and 100. If this parameter is
    ///          not used, then <code>ListWorldGeneratorJobs</code> returns up to 100 results and a
    ///             <code>nextToken</code> value if applicable. </p>
    public let maxResults: Int?
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListWorldGenerationJobsRequest</code> again and assign that
    ///          token to the request object's <code>nextToken</code> parameter. If there are no remaining
    ///          results, the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldGenerationJobsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
}

extension ListWorldGenerationJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWorldGenerationJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorldGenerationJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorldGenerationJobsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorldGenerationJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorldGenerationJobsOutputResponse(nextToken: \(String(describing: nextToken)), worldGenerationJobSummaries: \(String(describing: worldGenerationJobSummaries)))"}
}

extension ListWorldGenerationJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWorldGenerationJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.worldGenerationJobSummaries = output.worldGenerationJobSummaries
        } else {
            self.nextToken = nil
            self.worldGenerationJobSummaries = nil
        }
    }
}

public struct ListWorldGenerationJobsOutputResponse: Equatable {
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListWorldGeneratorJobsRequest</code> again and assign that
    ///          token to the request object's <code>nextToken</code> parameter. If there are no remaining
    ///          results, the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?
    /// <p>Summary information for world generator jobs.</p>
    public let worldGenerationJobSummaries: [WorldGenerationJobSummary]?

    public init (
        nextToken: String? = nil,
        worldGenerationJobSummaries: [WorldGenerationJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.worldGenerationJobSummaries = worldGenerationJobSummaries
    }
}

struct ListWorldGenerationJobsOutputResponseBody: Equatable {
    public let worldGenerationJobSummaries: [WorldGenerationJobSummary]?
    public let nextToken: String?
}

extension ListWorldGenerationJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case worldGenerationJobSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldGenerationJobSummariesContainer = try containerValues.decodeIfPresent([WorldGenerationJobSummary?].self, forKey: .worldGenerationJobSummaries)
        var worldGenerationJobSummariesDecoded0:[WorldGenerationJobSummary]? = nil
        if let worldGenerationJobSummariesContainer = worldGenerationJobSummariesContainer {
            worldGenerationJobSummariesDecoded0 = [WorldGenerationJobSummary]()
            for structure0 in worldGenerationJobSummariesContainer {
                if let structure0 = structure0 {
                    worldGenerationJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        worldGenerationJobSummaries = worldGenerationJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListWorldTemplatesInputBodyMiddleware: Middleware {
    public let id: String = "ListWorldTemplatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorldTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorldTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorldTemplatesInput>
    public typealias MOutput = OperationOutput<ListWorldTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorldTemplatesOutputError>
}

extension ListWorldTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorldTemplatesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListWorldTemplatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWorldTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListWorldTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorldTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorldTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorldTemplatesInput>
    public typealias MOutput = OperationOutput<ListWorldTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorldTemplatesOutputError>
}

public struct ListWorldTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWorldTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorldTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorldTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorldTemplatesInput>
    public typealias MOutput = OperationOutput<ListWorldTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorldTemplatesOutputError>
}

public struct ListWorldTemplatesInput: Equatable {
    /// <p>When this parameter is used, <code>ListWorldTemplates</code> only returns
    ///             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another <code>ListWorldTemplates</code> request with the returned <code>nextToken</code>
    ///          value. This value can be between 1 and 100. If this parameter is not used, then
    ///             <code>ListWorldTemplates</code> returns up to 100 results and a <code>nextToken</code>
    ///          value if applicable. </p>
    public let maxResults: Int?
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListWorldTemplates</code> again and assign that token to
    ///          the request object's <code>nextToken</code> parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldTemplatesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListWorldTemplatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorldTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorldTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorldTemplatesOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorldTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorldTemplatesOutputResponse(nextToken: \(String(describing: nextToken)), templateSummaries: \(String(describing: templateSummaries)))"}
}

extension ListWorldTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWorldTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.templateSummaries = output.templateSummaries
        } else {
            self.nextToken = nil
            self.templateSummaries = nil
        }
    }
}

public struct ListWorldTemplatesOutputResponse: Equatable {
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListWorldTemplates</code> again and assign that token to
    ///          the request object's <code>nextToken</code> parameter. If there are no remaining results,
    ///          the previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?
    /// <p>Summary information for templates.</p>
    public let templateSummaries: [TemplateSummary]?

    public init (
        nextToken: String? = nil,
        templateSummaries: [TemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateSummaries = templateSummaries
    }
}

struct ListWorldTemplatesOutputResponseBody: Equatable {
    public let templateSummaries: [TemplateSummary]?
    public let nextToken: String?
}

extension ListWorldTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case templateSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateSummariesContainer = try containerValues.decodeIfPresent([TemplateSummary?].self, forKey: .templateSummaries)
        var templateSummariesDecoded0:[TemplateSummary]? = nil
        if let templateSummariesContainer = templateSummariesContainer {
            templateSummariesDecoded0 = [TemplateSummary]()
            for structure0 in templateSummariesContainer {
                if let structure0 = structure0 {
                    templateSummariesDecoded0?.append(structure0)
                }
            }
        }
        templateSummaries = templateSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListWorldsInputBodyMiddleware: Middleware {
    public let id: String = "ListWorldsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorldsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorldsInput>
    public typealias MOutput = OperationOutput<ListWorldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorldsOutputError>
}

extension ListWorldsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorldsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListWorldsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWorldsInputHeadersMiddleware: Middleware {
    public let id: String = "ListWorldsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorldsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorldsInput>
    public typealias MOutput = OperationOutput<ListWorldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorldsOutputError>
}

public struct ListWorldsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWorldsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorldsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorldsInput>
    public typealias MOutput = OperationOutput<ListWorldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorldsOutputError>
}

public struct ListWorldsInput: Equatable {
    /// <p>Optional filters to limit results. You can use <code>status</code>.</p>
    public let filters: [Filter]?
    /// <p>When this parameter is used, <code>ListWorlds</code> only returns
    ///             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another <code>ListWorlds</code> request with the returned <code>nextToken</code> value.
    ///          This value can be between 1 and 100. If this parameter is not used, then
    ///             <code>ListWorlds</code> returns up to 100 results and a <code>nextToken</code> value if
    ///          applicable. </p>
    public let maxResults: Int?
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListWorlds</code> again and assign that token to the
    ///          request object's <code>nextToken</code> parameter. If there are no remaining results, the
    ///          previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
}

extension ListWorldsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWorldsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorldsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorldsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorldsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorldsOutputResponse(nextToken: \(String(describing: nextToken)), worldSummaries: \(String(describing: worldSummaries)))"}
}

extension ListWorldsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWorldsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.worldSummaries = output.worldSummaries
        } else {
            self.nextToken = nil
            self.worldSummaries = nil
        }
    }
}

public struct ListWorldsOutputResponse: Equatable {
    /// <p>If the previous paginated request did not return all of the remaining results, the
    ///          response object's <code>nextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListWorlds</code> again and assign that token to the
    ///          request object's <code>nextToken</code> parameter. If there are no remaining results, the
    ///          previous response object's NextToken parameter is set to null. </p>
    public let nextToken: String?
    /// <p>Summary information for worlds.</p>
    public let worldSummaries: [WorldSummary]?

    public init (
        nextToken: String? = nil,
        worldSummaries: [WorldSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.worldSummaries = worldSummaries
    }
}

struct ListWorldsOutputResponseBody: Equatable {
    public let worldSummaries: [WorldSummary]?
    public let nextToken: String?
}

extension ListWorldsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case worldSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldSummariesContainer = try containerValues.decodeIfPresent([WorldSummary?].self, forKey: .worldSummaries)
        var worldSummariesDecoded0:[WorldSummary]? = nil
        if let worldSummariesContainer = worldSummariesContainer {
            worldSummariesDecoded0 = [WorldSummary]()
            for structure0 in worldSummariesContainer {
                if let structure0 = structure0 {
                    worldSummariesDecoded0?.append(structure0)
                }
            }
        }
        worldSummaries = worldSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LoggingConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recordAllRosTopics
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordAllRosTopics = recordAllRosTopics {
            try encodeContainer.encode(recordAllRosTopics, forKey: .recordAllRosTopics)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordAllRosTopicsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .recordAllRosTopics)
        recordAllRosTopics = recordAllRosTopicsDecoded
    }
}

extension LoggingConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingConfig(recordAllRosTopics: \(String(describing: recordAllRosTopics)))"}
}

/// <p>The logging configuration.</p>
public struct LoggingConfig: Equatable {
    /// <p>A boolean indicating whether to record all ROS topics.</p>
    public let recordAllRosTopics: Bool?

    public init (
        recordAllRosTopics: Bool? = nil
    )
    {
        self.recordAllRosTopics = recordAllRosTopics
    }
}

extension NetworkInterface: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case networkInterfaceId
        case privateIpAddress
        case publicIpAddress
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateIpAddress = privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let publicIpAddress = publicIpAddress {
            try encodeContainer.encode(publicIpAddress, forKey: .publicIpAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let publicIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicIpAddress)
        publicIpAddress = publicIpAddressDecoded
    }
}

extension NetworkInterface: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkInterface(networkInterfaceId: \(String(describing: networkInterfaceId)), privateIpAddress: \(String(describing: privateIpAddress)), publicIpAddress: \(String(describing: publicIpAddress)))"}
}

/// <p>Describes a network interface.</p>
public struct NetworkInterface: Equatable {
    /// <p>The ID of the network interface.</p>
    public let networkInterfaceId: String?
    /// <p>The IPv4 address of the network interface within the subnet.</p>
    public let privateIpAddress: String?
    /// <p>The IPv4 public address of the network interface.</p>
    public let publicIpAddress: String?

    public init (
        networkInterfaceId: String? = nil,
        privateIpAddress: String? = nil,
        publicIpAddress: String? = nil
    )
    {
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddress = privateIpAddress
        self.publicIpAddress = publicIpAddress
    }
}

extension OutputLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Bucket
        case s3Prefix
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Prefix = s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
    }
}

extension OutputLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputLocation(s3Bucket: \(String(describing: s3Bucket)), s3Prefix: \(String(describing: s3Prefix)))"}
}

/// <p>The output location.</p>
public struct OutputLocation: Equatable {
    /// <p>The S3 bucket for output.</p>
    public let s3Bucket: String?
    /// <p>The S3 folder in the <code>s3Bucket</code> where output files will be placed.</p>
    public let s3Prefix: String?

    public init (
        s3Bucket: String? = nil,
        s3Prefix: String? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
    }
}

extension PortForwardingConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case portMappings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let portMappings = portMappings {
            var portMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portMappings)
            for portmappinglist0 in portMappings {
                try portMappingsContainer.encode(portmappinglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portMappingsContainer = try containerValues.decodeIfPresent([PortMapping?].self, forKey: .portMappings)
        var portMappingsDecoded0:[PortMapping]? = nil
        if let portMappingsContainer = portMappingsContainer {
            portMappingsDecoded0 = [PortMapping]()
            for structure0 in portMappingsContainer {
                if let structure0 = structure0 {
                    portMappingsDecoded0?.append(structure0)
                }
            }
        }
        portMappings = portMappingsDecoded0
    }
}

extension PortForwardingConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortForwardingConfig(portMappings: \(String(describing: portMappings)))"}
}

/// <p>Configuration information for port forwarding.</p>
public struct PortForwardingConfig: Equatable {
    /// <p>The port mappings for the configuration.</p>
    public let portMappings: [PortMapping]?

    public init (
        portMappings: [PortMapping]? = nil
    )
    {
        self.portMappings = portMappings
    }
}

extension PortMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationPort
        case enableOnPublicIp
        case jobPort
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applicationPort != 0 {
            try encodeContainer.encode(applicationPort, forKey: .applicationPort)
        }
        if enableOnPublicIp != false {
            try encodeContainer.encode(enableOnPublicIp, forKey: .enableOnPublicIp)
        }
        if jobPort != 0 {
            try encodeContainer.encode(jobPort, forKey: .jobPort)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobPortDecoded = try containerValues.decode(Int.self, forKey: .jobPort)
        jobPort = jobPortDecoded
        let applicationPortDecoded = try containerValues.decode(Int.self, forKey: .applicationPort)
        applicationPort = applicationPortDecoded
        let enableOnPublicIpDecoded = try containerValues.decode(Bool.self, forKey: .enableOnPublicIp)
        enableOnPublicIp = enableOnPublicIpDecoded
    }
}

extension PortMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortMapping(applicationPort: \(String(describing: applicationPort)), enableOnPublicIp: \(String(describing: enableOnPublicIp)), jobPort: \(String(describing: jobPort)))"}
}

/// <p>An object representing a port mapping.</p>
public struct PortMapping: Equatable {
    /// <p>The port number on the application.</p>
    public let applicationPort: Int
    /// <p>A Boolean indicating whether to enable this port mapping on public IP.</p>
    public let enableOnPublicIp: Bool
    /// <p>The port number on the simulation job instance to use as a remote connection point.
    ///          </p>
    public let jobPort: Int

    public init (
        applicationPort: Int = 0,
        enableOnPublicIp: Bool = false,
        jobPort: Int = 0
    )
    {
        self.applicationPort = applicationPort
        self.enableOnPublicIp = enableOnPublicIp
        self.jobPort = jobPort
    }
}

extension ProgressDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentProgress
        case estimatedTimeRemainingSeconds
        case percentDone
        case targetResource
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentProgress = currentProgress {
            try encodeContainer.encode(currentProgress.rawValue, forKey: .currentProgress)
        }
        if let estimatedTimeRemainingSeconds = estimatedTimeRemainingSeconds {
            try encodeContainer.encode(estimatedTimeRemainingSeconds, forKey: .estimatedTimeRemainingSeconds)
        }
        if let percentDone = percentDone {
            try encodeContainer.encode(percentDone, forKey: .percentDone)
        }
        if let targetResource = targetResource {
            try encodeContainer.encode(targetResource, forKey: .targetResource)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentProgressDecoded = try containerValues.decodeIfPresent(RobotDeploymentStep.self, forKey: .currentProgress)
        currentProgress = currentProgressDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let estimatedTimeRemainingSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .estimatedTimeRemainingSeconds)
        estimatedTimeRemainingSeconds = estimatedTimeRemainingSecondsDecoded
        let targetResourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetResource)
        targetResource = targetResourceDecoded
    }
}

extension ProgressDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProgressDetail(currentProgress: \(String(describing: currentProgress)), estimatedTimeRemainingSeconds: \(String(describing: estimatedTimeRemainingSeconds)), percentDone: \(String(describing: percentDone)), targetResource: \(String(describing: targetResource)))"}
}

/// <p>Information about the progress of a deployment job.</p>
public struct ProgressDetail: Equatable {
    /// <p>The current progress status.</p>
    ///          <dl>
    ///             <dt>Validating</dt>
    ///             <dd>
    ///                <p>Validating the deployment.</p>
    ///             </dd>
    ///             <dt>DownloadingExtracting</dt>
    ///             <dd>
    ///                <p>Downloading and extracting the bundle on the robot.</p>
    ///             </dd>
    ///             <dt>ExecutingPreLaunch</dt>
    ///             <dd>
    ///                <p>Executing pre-launch script(s) if provided.</p>
    ///             </dd>
    ///             <dt>Launching</dt>
    ///             <dd>
    ///                <p>Launching the robot application.</p>
    ///             </dd>
    ///             <dt>ExecutingPostLaunch</dt>
    ///             <dd>
    ///                <p>Executing post-launch script(s) if provided.</p>
    ///             </dd>
    ///             <dt>Finished</dt>
    ///             <dd>
    ///                <p>Deployment is complete.</p>
    ///             </dd>
    ///          </dl>
    public let currentProgress: RobotDeploymentStep?
    /// <p>Estimated amount of time in seconds remaining in the step. This currently only applies
    ///          to the <code>Downloading/Extracting</code> step of the deployment. It is empty for other
    ///          steps.</p>
    public let estimatedTimeRemainingSeconds: Int?
    /// <p>Precentage of the step that is done. This currently only applies to the
    ///             <code>Downloading/Extracting</code> step of the deployment. It is empty for other
    ///          steps.</p>
    public let percentDone: Float?
    /// <p>The Amazon Resource Name (ARN) of the deployment job.</p>
    public let targetResource: String?

    public init (
        currentProgress: RobotDeploymentStep? = nil,
        estimatedTimeRemainingSeconds: Int? = nil,
        percentDone: Float? = nil,
        targetResource: String? = nil
    )
    {
        self.currentProgress = currentProgress
        self.estimatedTimeRemainingSeconds = estimatedTimeRemainingSeconds
        self.percentDone = percentDone
        self.targetResource = targetResource
    }
}

public struct RegisterRobotInputBodyMiddleware: Middleware {
    public let id: String = "RegisterRobotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterRobotInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterRobotInput>
    public typealias MOutput = OperationOutput<RegisterRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterRobotOutputError>
}

extension RegisterRobotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterRobotInput(fleet: \(String(describing: fleet)), robot: \(String(describing: robot)))"}
}

extension RegisterRobotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleet
        case robot
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let robot = robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

public struct RegisterRobotInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterRobotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterRobotInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterRobotInput>
    public typealias MOutput = OperationOutput<RegisterRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterRobotOutputError>
}

public struct RegisterRobotInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterRobotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterRobotInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterRobotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterRobotInput>
    public typealias MOutput = OperationOutput<RegisterRobotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterRobotOutputError>
}

public struct RegisterRobotInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let fleet: String?
    /// <p>The Amazon Resource Name (ARN) of the robot.</p>
    public let robot: String?

    public init (
        fleet: String? = nil,
        robot: String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct RegisterRobotInputBody: Equatable {
    public let fleet: String?
    public let robot: String?
}

extension RegisterRobotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleet
        case robot
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension RegisterRobotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterRobotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterRobotOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterRobotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterRobotOutputResponse(fleet: \(String(describing: fleet)), robot: \(String(describing: robot)))"}
}

extension RegisterRobotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterRobotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fleet = output.fleet
            self.robot = output.robot
        } else {
            self.fleet = nil
            self.robot = nil
        }
    }
}

public struct RegisterRobotOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the fleet that the robot will join.</p>
    public let fleet: String?
    /// <p>Information about the robot registration.</p>
    public let robot: String?

    public init (
        fleet: String? = nil,
        robot: String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct RegisterRobotOutputResponseBody: Equatable {
    public let fleet: String?
    public let robot: String?
}

extension RegisterRobotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleet
        case robot
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension RenderingEngine: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(RenderingEngineType.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension RenderingEngine: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RenderingEngine(name: \(String(describing: name)), version: \(String(describing: version)))"}
}

/// <p>Information about a rendering engine.</p>
public struct RenderingEngine: Equatable {
    /// <p>The name of the rendering engine.</p>
    public let name: RenderingEngineType?
    /// <p>The version of the rendering engine.</p>
    public let version: String?

    public init (
        name: RenderingEngineType? = nil,
        version: String? = nil
    )
    {
        self.name = name
        self.version = version
    }
}

public enum RenderingEngineType {
    case ogre
    case sdkUnknown(String)
}

extension RenderingEngineType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RenderingEngineType] {
        return [
            .ogre,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ogre: return "OGRE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RenderingEngineType(rawValue: rawValue) ?? RenderingEngineType.sdkUnknown(rawValue)
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RestartSimulationJobInputBodyMiddleware: Middleware {
    public let id: String = "RestartSimulationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestartSimulationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<RestartSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestartSimulationJobInput>
    public typealias MOutput = OperationOutput<RestartSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestartSimulationJobOutputError>
}

extension RestartSimulationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestartSimulationJobInput(job: \(String(describing: job)))"}
}

extension RestartSimulationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

public struct RestartSimulationJobInputHeadersMiddleware: Middleware {
    public let id: String = "RestartSimulationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestartSimulationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<RestartSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestartSimulationJobInput>
    public typealias MOutput = OperationOutput<RestartSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestartSimulationJobOutputError>
}

public struct RestartSimulationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "RestartSimulationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestartSimulationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<RestartSimulationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestartSimulationJobInput>
    public typealias MOutput = OperationOutput<RestartSimulationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestartSimulationJobOutputError>
}

public struct RestartSimulationJobInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the simulation job.</p>
    public let job: String?

    public init (
        job: String? = nil
    )
    {
        self.job = job
    }
}

struct RestartSimulationJobInputBody: Equatable {
    public let job: String?
}

extension RestartSimulationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .job)
        job = jobDecoded
    }
}

extension RestartSimulationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestartSimulationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestartSimulationJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestartSimulationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestartSimulationJobOutputResponse()"}
}

extension RestartSimulationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RestartSimulationJobOutputResponse: Equatable {

    public init() {}
}

struct RestartSimulationJobOutputResponseBody: Equatable {
}

extension RestartSimulationJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Robot: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case architecture
        case arn
        case createdAt
        case fleetArn
        case greenGrassGroupId
        case lastDeploymentJob
        case lastDeploymentTime
        case name
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let greenGrassGroupId = greenGrassGroupId {
            try encodeContainer.encode(greenGrassGroupId, forKey: .greenGrassGroupId)
        }
        if let lastDeploymentJob = lastDeploymentJob {
            try encodeContainer.encode(lastDeploymentJob, forKey: .lastDeploymentJob)
        }
        if let lastDeploymentTime = lastDeploymentTime {
            try encodeContainer.encode(lastDeploymentTime.timeIntervalSince1970, forKey: .lastDeploymentTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RobotStatus.self, forKey: .status)
        status = statusDecoded
        let greenGrassGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .greenGrassGroupId)
        greenGrassGroupId = greenGrassGroupIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
    }
}

extension Robot: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Robot(architecture: \(String(describing: architecture)), arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), fleetArn: \(String(describing: fleetArn)), greenGrassGroupId: \(String(describing: greenGrassGroupId)), lastDeploymentJob: \(String(describing: lastDeploymentJob)), lastDeploymentTime: \(String(describing: lastDeploymentTime)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>Information about a robot.</p>
public struct Robot: Equatable {
    /// <p>The architecture of the robot.</p>
    public let architecture: Architecture?
    /// <p>The Amazon Resource Name (ARN) of the robot.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the robot was created.</p>
    public let createdAt: Date?
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let fleetArn: String?
    /// <p>The Greengrass group associated with the robot.</p>
    public let greenGrassGroupId: String?
    /// <p>The Amazon Resource Name (ARN) of the last deployment job.</p>
    public let lastDeploymentJob: String?
    /// <p>The time of the last deployment.</p>
    public let lastDeploymentTime: Date?
    /// <p>The name of the robot.</p>
    public let name: String?
    /// <p>The status of the robot.</p>
    public let status: RobotStatus?

    public init (
        architecture: Architecture? = nil,
        arn: String? = nil,
        createdAt: Date? = nil,
        fleetArn: String? = nil,
        greenGrassGroupId: String? = nil,
        lastDeploymentJob: String? = nil,
        lastDeploymentTime: Date? = nil,
        name: String? = nil,
        status: RobotStatus? = nil
    )
    {
        self.architecture = architecture
        self.arn = arn
        self.createdAt = createdAt
        self.fleetArn = fleetArn
        self.greenGrassGroupId = greenGrassGroupId
        self.lastDeploymentJob = lastDeploymentJob
        self.lastDeploymentTime = lastDeploymentTime
        self.name = name
        self.status = status
    }
}

extension RobotApplicationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case application
        case applicationVersion
        case launchConfig
        case tools
        case uploadConfigurations
        case useDefaultTools
        case useDefaultUploadConfigurations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let launchConfig = launchConfig {
            try encodeContainer.encode(launchConfig, forKey: .launchConfig)
        }
        if let tools = tools {
            var toolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tools)
            for tools0 in tools {
                try toolsContainer.encode(tools0)
            }
        }
        if let uploadConfigurations = uploadConfigurations {
            var uploadConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .uploadConfigurations)
            for uploadconfigurations0 in uploadConfigurations {
                try uploadConfigurationsContainer.encode(uploadconfigurations0)
            }
        }
        if let useDefaultTools = useDefaultTools {
            try encodeContainer.encode(useDefaultTools, forKey: .useDefaultTools)
        }
        if let useDefaultUploadConfigurations = useDefaultUploadConfigurations {
            try encodeContainer.encode(useDefaultUploadConfigurations, forKey: .useDefaultUploadConfigurations)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let launchConfigDecoded = try containerValues.decodeIfPresent(LaunchConfig.self, forKey: .launchConfig)
        launchConfig = launchConfigDecoded
        let uploadConfigurationsContainer = try containerValues.decodeIfPresent([UploadConfiguration?].self, forKey: .uploadConfigurations)
        var uploadConfigurationsDecoded0:[UploadConfiguration]? = nil
        if let uploadConfigurationsContainer = uploadConfigurationsContainer {
            uploadConfigurationsDecoded0 = [UploadConfiguration]()
            for structure0 in uploadConfigurationsContainer {
                if let structure0 = structure0 {
                    uploadConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        uploadConfigurations = uploadConfigurationsDecoded0
        let useDefaultUploadConfigurationsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDefaultUploadConfigurations)
        useDefaultUploadConfigurations = useDefaultUploadConfigurationsDecoded
        let toolsContainer = try containerValues.decodeIfPresent([Tool?].self, forKey: .tools)
        var toolsDecoded0:[Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let useDefaultToolsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDefaultTools)
        useDefaultTools = useDefaultToolsDecoded
    }
}

extension RobotApplicationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RobotApplicationConfig(application: \(String(describing: application)), applicationVersion: \(String(describing: applicationVersion)), launchConfig: \(String(describing: launchConfig)), tools: \(String(describing: tools)), uploadConfigurations: \(String(describing: uploadConfigurations)), useDefaultTools: \(String(describing: useDefaultTools)), useDefaultUploadConfigurations: \(String(describing: useDefaultUploadConfigurations)))"}
}

/// <p>Application configuration information for a robot.</p>
public struct RobotApplicationConfig: Equatable {
    /// <p>The application information for the robot application.</p>
    public let application: String?
    /// <p>The version of the robot application.</p>
    public let applicationVersion: String?
    /// <p>The launch configuration for the robot application.</p>
    public let launchConfig: LaunchConfig?
    /// <p>Information about tools configured for the robot application.</p>
    public let tools: [Tool]?
    /// <p>The upload configurations for the robot application.</p>
    public let uploadConfigurations: [UploadConfiguration]?
    /// <p>A Boolean indicating whether to use default robot application tools.
    ///         The default tools are rviz, rqt, terminal and rosbag record.
    ///         The default is <code>False</code>.
    ///       </p>
    public let useDefaultTools: Bool?
    /// <p>A Boolean indicating whether to use default upload configurations. By default,
    ///             <code>.ros</code> and <code>.gazebo</code> files are uploaded when the application
    ///          terminates and all ROS topics will be recorded.</p>
    ///          <p>If you set this value, you must specify an <code>outputLocation</code>. </p>
    public let useDefaultUploadConfigurations: Bool?

    public init (
        application: String? = nil,
        applicationVersion: String? = nil,
        launchConfig: LaunchConfig? = nil,
        tools: [Tool]? = nil,
        uploadConfigurations: [UploadConfiguration]? = nil,
        useDefaultTools: Bool? = nil,
        useDefaultUploadConfigurations: Bool? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
        self.launchConfig = launchConfig
        self.tools = tools
        self.uploadConfigurations = uploadConfigurations
        self.useDefaultTools = useDefaultTools
        self.useDefaultUploadConfigurations = useDefaultUploadConfigurations
    }
}

extension RobotApplicationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case robotSoftwareSuite
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotSoftwareSuite = robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
    }
}

extension RobotApplicationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RobotApplicationSummary(arn: \(String(describing: arn)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)), robotSoftwareSuite: \(String(describing: robotSoftwareSuite)), version: \(String(describing: version)))"}
}

/// <p>Summary information for a robot application.</p>
public struct RobotApplicationSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the robot.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the robot application was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the robot application.</p>
    public let name: String?
    /// <p>Information about a robot software suite (ROS distribution).</p>
    public let robotSoftwareSuite: RobotSoftwareSuite?
    /// <p>The version of the robot application.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil,
        robotSoftwareSuite: RobotSoftwareSuite? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.robotSoftwareSuite = robotSoftwareSuite
        self.version = version
    }
}

extension RobotDeployment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case deploymentFinishTime
        case deploymentStartTime
        case failureCode
        case failureReason
        case progressDetail
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let deploymentFinishTime = deploymentFinishTime {
            try encodeContainer.encode(deploymentFinishTime.timeIntervalSince1970, forKey: .deploymentFinishTime)
        }
        if let deploymentStartTime = deploymentStartTime {
            try encodeContainer.encode(deploymentStartTime.timeIntervalSince1970, forKey: .deploymentStartTime)
        }
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let progressDetail = progressDetail {
            try encodeContainer.encode(progressDetail, forKey: .progressDetail)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let deploymentStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deploymentStartTime)
        deploymentStartTime = deploymentStartTimeDecoded
        let deploymentFinishTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deploymentFinishTime)
        deploymentFinishTime = deploymentFinishTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RobotStatus.self, forKey: .status)
        status = statusDecoded
        let progressDetailDecoded = try containerValues.decodeIfPresent(ProgressDetail.self, forKey: .progressDetail)
        progressDetail = progressDetailDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
    }
}

extension RobotDeployment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RobotDeployment(arn: \(String(describing: arn)), deploymentFinishTime: \(String(describing: deploymentFinishTime)), deploymentStartTime: \(String(describing: deploymentStartTime)), failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), progressDetail: \(String(describing: progressDetail)), status: \(String(describing: status)))"}
}

/// <p>Information about a robot deployment.</p>
public struct RobotDeployment: Equatable {
    /// <p>The robot deployment Amazon Resource Name (ARN).</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the deployment finished.</p>
    public let deploymentFinishTime: Date?
    /// <p>The time, in milliseconds since the epoch, when the deployment was started.</p>
    public let deploymentStartTime: Date?
    /// <p>The robot deployment failure code.</p>
    public let failureCode: DeploymentJobErrorCode?
    /// <p>A short description of the reason why the robot deployment failed.</p>
    public let failureReason: String?
    /// <p>Information about how the deployment is progressing.</p>
    public let progressDetail: ProgressDetail?
    /// <p>The status of the robot deployment.</p>
    public let status: RobotStatus?

    public init (
        arn: String? = nil,
        deploymentFinishTime: Date? = nil,
        deploymentStartTime: Date? = nil,
        failureCode: DeploymentJobErrorCode? = nil,
        failureReason: String? = nil,
        progressDetail: ProgressDetail? = nil,
        status: RobotStatus? = nil
    )
    {
        self.arn = arn
        self.deploymentFinishTime = deploymentFinishTime
        self.deploymentStartTime = deploymentStartTime
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.progressDetail = progressDetail
        self.status = status
    }
}

public enum RobotDeploymentStep {
    case downloadingextractingstep
    case executingdownloadcondition
    case finishedstep
    case launchingstep
    case postlaunchstep
    case prelaunchstep
    case validatingstep
    case sdkUnknown(String)
}

extension RobotDeploymentStep : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RobotDeploymentStep] {
        return [
            .downloadingextractingstep,
            .executingdownloadcondition,
            .finishedstep,
            .launchingstep,
            .postlaunchstep,
            .prelaunchstep,
            .validatingstep,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .downloadingextractingstep: return "DownloadingExtracting"
        case .executingdownloadcondition: return "ExecutingDownloadCondition"
        case .finishedstep: return "Finished"
        case .launchingstep: return "Launching"
        case .postlaunchstep: return "ExecutingPostLaunch"
        case .prelaunchstep: return "ExecutingPreLaunch"
        case .validatingstep: return "Validating"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RobotDeploymentStep(rawValue: rawValue) ?? RobotDeploymentStep.sdkUnknown(rawValue)
    }
}

extension RobotSoftwareSuite: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version.rawValue, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuiteType.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuiteVersionType.self, forKey: .version)
        version = versionDecoded
    }
}

extension RobotSoftwareSuite: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RobotSoftwareSuite(name: \(String(describing: name)), version: \(String(describing: version)))"}
}

/// <p>Information about a robot software suite (ROS distribution).</p>
public struct RobotSoftwareSuite: Equatable {
    /// <p>The name of the robot software suite (ROS distribution).</p>
    public let name: RobotSoftwareSuiteType?
    /// <p>The version of the robot software suite (ROS distribution).</p>
    public let version: RobotSoftwareSuiteVersionType?

    public init (
        name: RobotSoftwareSuiteType? = nil,
        version: RobotSoftwareSuiteVersionType? = nil
    )
    {
        self.name = name
        self.version = version
    }
}

public enum RobotSoftwareSuiteType {
    case ros
    case ros2
    case sdkUnknown(String)
}

extension RobotSoftwareSuiteType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RobotSoftwareSuiteType] {
        return [
            .ros,
            .ros2,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ros: return "ROS"
        case .ros2: return "ROS2"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RobotSoftwareSuiteType(rawValue: rawValue) ?? RobotSoftwareSuiteType.sdkUnknown(rawValue)
    }
}

public enum RobotSoftwareSuiteVersionType {
    case dashing
    case foxy
    case kinetic
    case melodic
    case sdkUnknown(String)
}

extension RobotSoftwareSuiteVersionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RobotSoftwareSuiteVersionType] {
        return [
            .dashing,
            .foxy,
            .kinetic,
            .melodic,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dashing: return "Dashing"
        case .foxy: return "Foxy"
        case .kinetic: return "Kinetic"
        case .melodic: return "Melodic"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RobotSoftwareSuiteVersionType(rawValue: rawValue) ?? RobotSoftwareSuiteVersionType.sdkUnknown(rawValue)
    }
}

public enum RobotStatus {
    case available
    case deploying
    case failed
    case insync
    case noresponse
    case pendingnewdeployment
    case registered
    case sdkUnknown(String)
}

extension RobotStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RobotStatus] {
        return [
            .available,
            .deploying,
            .failed,
            .insync,
            .noresponse,
            .pendingnewdeployment,
            .registered,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "Available"
        case .deploying: return "Deploying"
        case .failed: return "Failed"
        case .insync: return "InSync"
        case .noresponse: return "NoResponse"
        case .pendingnewdeployment: return "PendingNewDeployment"
        case .registered: return "Registered"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RobotStatus(rawValue: rawValue) ?? RobotStatus.sdkUnknown(rawValue)
    }
}

extension S3KeyOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case etag
        case s3Key
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let etag = etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3KeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let etagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .etag)
        etag = etagDecoded
    }
}

extension S3KeyOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3KeyOutput(etag: \(String(describing: etag)), s3Key: \(String(describing: s3Key)))"}
}

/// <p>Information about S3 keys.</p>
public struct S3KeyOutput: Equatable {
    /// <p>The etag for the object.</p>
    public let etag: String?
    /// <p>The S3 key.</p>
    public let s3Key: String?

    public init (
        etag: String? = nil,
        s3Key: String? = nil
    )
    {
        self.etag = etag
        self.s3Key = s3Key
    }
}

extension S3Object: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case etag
        case key
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let etag = etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let etagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .etag)
        etag = etagDecoded
    }
}

extension S3Object: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Object(bucket: \(String(describing: bucket)), etag: \(String(describing: etag)), key: \(String(describing: key)))"}
}

/// <p>Information about an S3 object.</p>
public struct S3Object: Equatable {
    /// <p>The bucket containing the object.</p>
    public let bucket: String?
    /// <p>The etag of the object.</p>
    public let etag: String?
    /// <p>The key of the object.</p>
    public let key: String?

    public init (
        bucket: String? = nil,
        etag: String? = nil,
        key: String? = nil
    )
    {
        self.bucket = bucket
        self.etag = etag
        self.key = key
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request has failed due to a temporary failure of the server.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SimulationApplicationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case application
        case applicationVersion
        case launchConfig
        case tools
        case uploadConfigurations
        case useDefaultTools
        case useDefaultUploadConfigurations
        case worldConfigs
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let launchConfig = launchConfig {
            try encodeContainer.encode(launchConfig, forKey: .launchConfig)
        }
        if let tools = tools {
            var toolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tools)
            for tools0 in tools {
                try toolsContainer.encode(tools0)
            }
        }
        if let uploadConfigurations = uploadConfigurations {
            var uploadConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .uploadConfigurations)
            for uploadconfigurations0 in uploadConfigurations {
                try uploadConfigurationsContainer.encode(uploadconfigurations0)
            }
        }
        if let useDefaultTools = useDefaultTools {
            try encodeContainer.encode(useDefaultTools, forKey: .useDefaultTools)
        }
        if let useDefaultUploadConfigurations = useDefaultUploadConfigurations {
            try encodeContainer.encode(useDefaultUploadConfigurations, forKey: .useDefaultUploadConfigurations)
        }
        if let worldConfigs = worldConfigs {
            var worldConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worldConfigs)
            for worldconfigs0 in worldConfigs {
                try worldConfigsContainer.encode(worldconfigs0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let launchConfigDecoded = try containerValues.decodeIfPresent(LaunchConfig.self, forKey: .launchConfig)
        launchConfig = launchConfigDecoded
        let uploadConfigurationsContainer = try containerValues.decodeIfPresent([UploadConfiguration?].self, forKey: .uploadConfigurations)
        var uploadConfigurationsDecoded0:[UploadConfiguration]? = nil
        if let uploadConfigurationsContainer = uploadConfigurationsContainer {
            uploadConfigurationsDecoded0 = [UploadConfiguration]()
            for structure0 in uploadConfigurationsContainer {
                if let structure0 = structure0 {
                    uploadConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        uploadConfigurations = uploadConfigurationsDecoded0
        let worldConfigsContainer = try containerValues.decodeIfPresent([WorldConfig?].self, forKey: .worldConfigs)
        var worldConfigsDecoded0:[WorldConfig]? = nil
        if let worldConfigsContainer = worldConfigsContainer {
            worldConfigsDecoded0 = [WorldConfig]()
            for structure0 in worldConfigsContainer {
                if let structure0 = structure0 {
                    worldConfigsDecoded0?.append(structure0)
                }
            }
        }
        worldConfigs = worldConfigsDecoded0
        let useDefaultUploadConfigurationsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDefaultUploadConfigurations)
        useDefaultUploadConfigurations = useDefaultUploadConfigurationsDecoded
        let toolsContainer = try containerValues.decodeIfPresent([Tool?].self, forKey: .tools)
        var toolsDecoded0:[Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let useDefaultToolsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDefaultTools)
        useDefaultTools = useDefaultToolsDecoded
    }
}

extension SimulationApplicationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimulationApplicationConfig(application: \(String(describing: application)), applicationVersion: \(String(describing: applicationVersion)), launchConfig: \(String(describing: launchConfig)), tools: \(String(describing: tools)), uploadConfigurations: \(String(describing: uploadConfigurations)), useDefaultTools: \(String(describing: useDefaultTools)), useDefaultUploadConfigurations: \(String(describing: useDefaultUploadConfigurations)), worldConfigs: \(String(describing: worldConfigs)))"}
}

/// <p>Information about a simulation application configuration.</p>
public struct SimulationApplicationConfig: Equatable {
    /// <p>The application information for the simulation application.</p>
    public let application: String?
    /// <p>The version of the simulation application.</p>
    public let applicationVersion: String?
    /// <p>The launch configuration for the simulation application.</p>
    public let launchConfig: LaunchConfig?
    /// <p>Information about tools configured for the simulation application.</p>
    public let tools: [Tool]?
    /// <p>Information about upload configurations for the simulation application.</p>
    public let uploadConfigurations: [UploadConfiguration]?
    /// <p>A Boolean indicating whether to use default simulation application tools.
    ///         The default tools are rviz, rqt, terminal and rosbag record.
    ///         The default is <code>False</code>.
    ///       </p>
    public let useDefaultTools: Bool?
    /// <p>A Boolean indicating whether to use default upload configurations. By default,
    ///             <code>.ros</code> and <code>.gazebo</code> files are uploaded when the application
    ///          terminates and all ROS topics will be recorded.</p>
    ///          <p>If you set this value, you must specify an <code>outputLocation</code>. </p>
    public let useDefaultUploadConfigurations: Bool?
    /// <p>A list of world configurations.</p>
    public let worldConfigs: [WorldConfig]?

    public init (
        application: String? = nil,
        applicationVersion: String? = nil,
        launchConfig: LaunchConfig? = nil,
        tools: [Tool]? = nil,
        uploadConfigurations: [UploadConfiguration]? = nil,
        useDefaultTools: Bool? = nil,
        useDefaultUploadConfigurations: Bool? = nil,
        worldConfigs: [WorldConfig]? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
        self.launchConfig = launchConfig
        self.tools = tools
        self.uploadConfigurations = uploadConfigurations
        self.useDefaultTools = useDefaultTools
        self.useDefaultUploadConfigurations = useDefaultUploadConfigurations
        self.worldConfigs = worldConfigs
    }
}

extension SimulationApplicationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotSoftwareSuite = robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let simulationSoftwareSuite = simulationSoftwareSuite {
            try encodeContainer.encode(simulationSoftwareSuite, forKey: .simulationSoftwareSuite)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
    }
}

extension SimulationApplicationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimulationApplicationSummary(arn: \(String(describing: arn)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)), robotSoftwareSuite: \(String(describing: robotSoftwareSuite)), simulationSoftwareSuite: \(String(describing: simulationSoftwareSuite)), version: \(String(describing: version)))"}
}

/// <p>Summary information for a simulation application.</p>
public struct SimulationApplicationSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the simulation application.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the simulation application was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the simulation application.</p>
    public let name: String?
    /// <p>Information about a robot software suite (ROS distribution).</p>
    public let robotSoftwareSuite: RobotSoftwareSuite?
    /// <p>Information about a simulation software suite.</p>
    public let simulationSoftwareSuite: SimulationSoftwareSuite?
    /// <p>The version of the simulation application.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil,
        robotSoftwareSuite: RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: SimulationSoftwareSuite? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.version = version
    }
}

extension SimulationJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case failureCode
        case failureReason
        case iamRole
        case lastStartedAt
        case lastUpdatedAt
        case loggingConfig
        case maxJobDurationInSeconds
        case name
        case networkInterface
        case outputLocation
        case robotApplications
        case simulationApplications
        case simulationTimeMillis
        case status
        case tags
        case vpcConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let compute = compute {
            try encodeContainer.encode(compute, forKey: .compute)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasources0 in dataSources {
                try dataSourcesContainer.encode(datasources0)
            }
        }
        if let failureBehavior = failureBehavior {
            try encodeContainer.encode(failureBehavior.rawValue, forKey: .failureBehavior)
        }
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let lastStartedAt = lastStartedAt {
            try encodeContainer.encode(lastStartedAt.timeIntervalSince1970, forKey: .lastStartedAt)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let loggingConfig = loggingConfig {
            try encodeContainer.encode(loggingConfig, forKey: .loggingConfig)
        }
        if maxJobDurationInSeconds != 0 {
            try encodeContainer.encode(maxJobDurationInSeconds, forKey: .maxJobDurationInSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkInterface = networkInterface {
            try encodeContainer.encode(networkInterface, forKey: .networkInterface)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let robotApplications = robotApplications {
            var robotApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplications)
            for robotapplicationconfigs0 in robotApplications {
                try robotApplicationsContainer.encode(robotapplicationconfigs0)
            }
        }
        if let simulationApplications = simulationApplications {
            var simulationApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplications)
            for simulationapplicationconfigs0 in simulationApplications {
                try simulationApplicationsContainer.encode(simulationapplicationconfigs0)
            }
        }
        if simulationTimeMillis != 0 {
            try encodeContainer.encode(simulationTimeMillis, forKey: .simulationTimeMillis)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let lastStartedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastStartedAt)
        lastStartedAt = lastStartedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decode(Int.self, forKey: .maxJobDurationInSeconds)
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let simulationTimeMillisDecoded = try containerValues.decode(Int.self, forKey: .simulationTimeMillis)
        simulationTimeMillis = simulationTimeMillisDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VPCConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let networkInterfaceDecoded = try containerValues.decodeIfPresent(NetworkInterface.self, forKey: .networkInterface)
        networkInterface = networkInterfaceDecoded
        let computeDecoded = try containerValues.decodeIfPresent(ComputeResponse.self, forKey: .compute)
        compute = computeDecoded
    }
}

extension SimulationJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimulationJob(arn: \(String(describing: arn)), clientRequestToken: \(String(describing: clientRequestToken)), compute: \(String(describing: compute)), dataSources: \(String(describing: dataSources)), failureBehavior: \(String(describing: failureBehavior)), failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), iamRole: \(String(describing: iamRole)), lastStartedAt: \(String(describing: lastStartedAt)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), loggingConfig: \(String(describing: loggingConfig)), maxJobDurationInSeconds: \(String(describing: maxJobDurationInSeconds)), name: \(String(describing: name)), networkInterface: \(String(describing: networkInterface)), outputLocation: \(String(describing: outputLocation)), robotApplications: \(String(describing: robotApplications)), simulationApplications: \(String(describing: simulationApplications)), simulationTimeMillis: \(String(describing: simulationTimeMillis)), status: \(String(describing: status)), tags: \(String(describing: tags)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Information about a simulation job.</p>
public struct SimulationJob: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the simulation job.</p>
    public let arn: String?
    /// <p>A unique identifier for this <code>SimulationJob</code> request.</p>
    public let clientRequestToken: String?
    /// <p>Compute information for the simulation job</p>
    public let compute: ComputeResponse?
    /// <p>The data sources for the simulation job.</p>
    public let dataSources: [DataSource]?
    /// <p>The failure behavior the simulation job.</p>
    ///          <dl>
    ///             <dt>Continue</dt>
    ///             <dd>
    ///                <p>Restart the simulation job in the same host instance.</p>
    ///             </dd>
    ///             <dt>Fail</dt>
    ///             <dd>
    ///                <p>Stop the simulation job and terminate the instance.</p>
    ///             </dd>
    ///          </dl>
    public let failureBehavior: FailureBehavior?
    /// <p>The failure code of the simulation job if it failed.</p>
    public let failureCode: SimulationJobErrorCode?
    /// <p>The reason why the simulation job failed.</p>
    public let failureReason: String?
    /// <p>The IAM role that allows the simulation instance to call the AWS APIs that are specified
    ///          in its associated policies on your behalf. This is how credentials are passed in to your
    ///          simulation job. </p>
    public let iamRole: String?
    /// <p>The time, in milliseconds since the epoch, when the simulation job was last
    ///          started.</p>
    public let lastStartedAt: Date?
    /// <p>The time, in milliseconds since the epoch, when the simulation job was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The logging configuration.</p>
    public let loggingConfig: LoggingConfig?
    /// <p>The maximum simulation job duration in seconds. The value must be 8 days (691,200
    ///          seconds) or less.</p>
    public let maxJobDurationInSeconds: Int
    /// <p>The name of the simulation job.</p>
    public let name: String?
    /// <p>Information about a network interface.</p>
    public let networkInterface: NetworkInterface?
    /// <p>Location for output files generated by the simulation job.</p>
    public let outputLocation: OutputLocation?
    /// <p>A list of robot applications.</p>
    public let robotApplications: [RobotApplicationConfig]?
    /// <p>A list of simulation applications.</p>
    public let simulationApplications: [SimulationApplicationConfig]?
    /// <p>The simulation job execution duration in milliseconds.</p>
    public let simulationTimeMillis: Int
    /// <p>Status of the simulation job.</p>
    public let status: SimulationJobStatus?
    /// <p>A map that contains tag keys and tag values that are attached to the simulation
    ///          job.</p>
    public let tags: [String:String]?
    /// <p>VPC configuration information.</p>
    public let vpcConfig: VPCConfigResponse?

    public init (
        arn: String? = nil,
        clientRequestToken: String? = nil,
        compute: ComputeResponse? = nil,
        dataSources: [DataSource]? = nil,
        failureBehavior: FailureBehavior? = nil,
        failureCode: SimulationJobErrorCode? = nil,
        failureReason: String? = nil,
        iamRole: String? = nil,
        lastStartedAt: Date? = nil,
        lastUpdatedAt: Date? = nil,
        loggingConfig: LoggingConfig? = nil,
        maxJobDurationInSeconds: Int = 0,
        name: String? = nil,
        networkInterface: NetworkInterface? = nil,
        outputLocation: OutputLocation? = nil,
        robotApplications: [RobotApplicationConfig]? = nil,
        simulationApplications: [SimulationApplicationConfig]? = nil,
        simulationTimeMillis: Int = 0,
        status: SimulationJobStatus? = nil,
        tags: [String:String]? = nil,
        vpcConfig: VPCConfigResponse? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.iamRole = iamRole
        self.lastStartedAt = lastStartedAt
        self.lastUpdatedAt = lastUpdatedAt
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.name = name
        self.networkInterface = networkInterface
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.simulationTimeMillis = simulationTimeMillis
        self.status = status
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

public enum SimulationJobBatchErrorCode {
    case internalserviceerror
    case sdkUnknown(String)
}

extension SimulationJobBatchErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SimulationJobBatchErrorCode] {
        return [
            .internalserviceerror,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internalserviceerror: return "InternalServiceError"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SimulationJobBatchErrorCode(rawValue: rawValue) ?? SimulationJobBatchErrorCode.sdkUnknown(rawValue)
    }
}

public enum SimulationJobBatchStatus {
    case canceled
    case canceling
    case completed
    case completing
    case failed
    case inprogress
    case pending
    case timedout
    case timingout
    case sdkUnknown(String)
}

extension SimulationJobBatchStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SimulationJobBatchStatus] {
        return [
            .canceled,
            .canceling,
            .completed,
            .completing,
            .failed,
            .inprogress,
            .pending,
            .timedout,
            .timingout,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "Canceled"
        case .canceling: return "Canceling"
        case .completed: return "Completed"
        case .completing: return "Completing"
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case .pending: return "Pending"
        case .timedout: return "TimedOut"
        case .timingout: return "TimingOut"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SimulationJobBatchStatus(rawValue: rawValue) ?? SimulationJobBatchStatus.sdkUnknown(rawValue)
    }
}

extension SimulationJobBatchSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case createdRequestCount
        case failedRequestCount
        case lastUpdatedAt
        case pendingRequestCount
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if createdRequestCount != 0 {
            try encodeContainer.encode(createdRequestCount, forKey: .createdRequestCount)
        }
        if failedRequestCount != 0 {
            try encodeContainer.encode(failedRequestCount, forKey: .failedRequestCount)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if pendingRequestCount != 0 {
            try encodeContainer.encode(pendingRequestCount, forKey: .pendingRequestCount)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SimulationJobBatchStatus.self, forKey: .status)
        status = statusDecoded
        let failedRequestCountDecoded = try containerValues.decode(Int.self, forKey: .failedRequestCount)
        failedRequestCount = failedRequestCountDecoded
        let pendingRequestCountDecoded = try containerValues.decode(Int.self, forKey: .pendingRequestCount)
        pendingRequestCount = pendingRequestCountDecoded
        let createdRequestCountDecoded = try containerValues.decode(Int.self, forKey: .createdRequestCount)
        createdRequestCount = createdRequestCountDecoded
    }
}

extension SimulationJobBatchSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimulationJobBatchSummary(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), createdRequestCount: \(String(describing: createdRequestCount)), failedRequestCount: \(String(describing: failedRequestCount)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), pendingRequestCount: \(String(describing: pendingRequestCount)), status: \(String(describing: status)))"}
}

/// <p>Information about a simulation job batch.</p>
public struct SimulationJobBatchSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the batch.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the simulation job batch was
    ///          created.</p>
    public let createdAt: Date?
    /// <p>The number of created simulation job requests.</p>
    public let createdRequestCount: Int
    /// <p>The number of failed simulation job requests.</p>
    public let failedRequestCount: Int
    /// <p>The time, in milliseconds since the epoch, when the simulation job batch was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The number of pending simulation job requests.</p>
    public let pendingRequestCount: Int
    /// <p>The status of the simulation job batch.</p>
    ///          <dl>
    ///             <dt>Pending</dt>
    ///             <dd>
    ///                <p>The simulation job batch request is pending.</p>
    ///             </dd>
    ///             <dt>InProgress</dt>
    ///             <dd>
    ///                <p>The simulation job batch is in progress. </p>
    ///             </dd>
    ///             <dt>Failed</dt>
    ///             <dd>
    ///                <p>The simulation job batch failed. One or more simulation job requests could not
    ///                   be completed due to an internal failure (like <code>InternalServiceError</code>).
    ///                   See <code>failureCode</code> and <code>failureReason</code> for more
    ///                   information.</p>
    ///             </dd>
    ///             <dt>Completed</dt>
    ///             <dd>
    ///                <p>The simulation batch job completed. A batch is complete when (1) there are no
    ///                   pending simulation job requests in the batch and none of the failed simulation job
    ///                   requests are due to <code>InternalServiceError</code> and (2) when all created
    ///                   simulation jobs have reached a terminal state (for example, <code>Completed</code>
    ///                   or <code>Failed</code>). </p>
    ///             </dd>
    ///             <dt>Canceled</dt>
    ///             <dd>
    ///                <p>The simulation batch job was cancelled.</p>
    ///             </dd>
    ///             <dt>Canceling</dt>
    ///             <dd>
    ///                <p>The simulation batch job is being cancelled.</p>
    ///             </dd>
    ///             <dt>Completing</dt>
    ///             <dd>
    ///                <p>The simulation batch job is completing.</p>
    ///             </dd>
    ///             <dt>TimingOut</dt>
    ///             <dd>
    ///                <p>The simulation job batch is timing out.</p>
    ///                <p>If a batch timing out, and there are pending requests that were failing due to
    ///                   an internal failure (like <code>InternalServiceError</code>), the batch status
    ///                   will be <code>Failed</code>. If there are no such failing request, the batch
    ///                   status will be <code>TimedOut</code>. </p>
    ///             </dd>
    ///             <dt>TimedOut</dt>
    ///             <dd>
    ///                <p>The simulation batch job timed out.</p>
    ///             </dd>
    ///          </dl>
    public let status: SimulationJobBatchStatus?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        createdRequestCount: Int = 0,
        failedRequestCount: Int = 0,
        lastUpdatedAt: Date? = nil,
        pendingRequestCount: Int = 0,
        status: SimulationJobBatchStatus? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.createdRequestCount = createdRequestCount
        self.failedRequestCount = failedRequestCount
        self.lastUpdatedAt = lastUpdatedAt
        self.pendingRequestCount = pendingRequestCount
        self.status = status
    }
}

public enum SimulationJobErrorCode {
    case badpermissionscloudwatchlogs
    case badpermissionsrobotapplication
    case badpermissionss3object
    case badpermissionss3output
    case badpermissionssimulationapplication
    case badpermissionsusercredentials
    case batchcanceled
    case batchtimedout
    case enilimitexceeded
    case internalserviceerror
    case invalidbundlerobotapplication
    case invalidbundlesimulationapplication
    case invalidinput
    case invalids3resource
    case limitexceeded
    case mismatchedetag
    case requestthrottled
    case resourcenotfound
    case robotapplicationcrash
    case robotapplicationhealthcheckfailure
    case robotapplicationversionmismatchedetag
    case simulationapplicationcrash
    case simulationapplicationhealthcheckfailure
    case simulationapplicationversionmismatchedetag
    case subnetiplimitexceeded
    case throttlingerror
    case uploadcontentmismatcherror
    case wrongregionrobotapplication
    case wrongregions3bucket
    case wrongregions3output
    case wrongregionsimulationapplication
    case sdkUnknown(String)
}

extension SimulationJobErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SimulationJobErrorCode] {
        return [
            .badpermissionscloudwatchlogs,
            .badpermissionsrobotapplication,
            .badpermissionss3object,
            .badpermissionss3output,
            .badpermissionssimulationapplication,
            .badpermissionsusercredentials,
            .batchcanceled,
            .batchtimedout,
            .enilimitexceeded,
            .internalserviceerror,
            .invalidbundlerobotapplication,
            .invalidbundlesimulationapplication,
            .invalidinput,
            .invalids3resource,
            .limitexceeded,
            .mismatchedetag,
            .requestthrottled,
            .resourcenotfound,
            .robotapplicationcrash,
            .robotapplicationhealthcheckfailure,
            .robotapplicationversionmismatchedetag,
            .simulationapplicationcrash,
            .simulationapplicationhealthcheckfailure,
            .simulationapplicationversionmismatchedetag,
            .subnetiplimitexceeded,
            .throttlingerror,
            .uploadcontentmismatcherror,
            .wrongregionrobotapplication,
            .wrongregions3bucket,
            .wrongregions3output,
            .wrongregionsimulationapplication,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .badpermissionscloudwatchlogs: return "BadPermissionsCloudwatchLogs"
        case .badpermissionsrobotapplication: return "BadPermissionsRobotApplication"
        case .badpermissionss3object: return "BadPermissionsS3Object"
        case .badpermissionss3output: return "BadPermissionsS3Output"
        case .badpermissionssimulationapplication: return "BadPermissionsSimulationApplication"
        case .badpermissionsusercredentials: return "BadPermissionsUserCredentials"
        case .batchcanceled: return "BatchCanceled"
        case .batchtimedout: return "BatchTimedOut"
        case .enilimitexceeded: return "ENILimitExceeded"
        case .internalserviceerror: return "InternalServiceError"
        case .invalidbundlerobotapplication: return "InvalidBundleRobotApplication"
        case .invalidbundlesimulationapplication: return "InvalidBundleSimulationApplication"
        case .invalidinput: return "InvalidInput"
        case .invalids3resource: return "InvalidS3Resource"
        case .limitexceeded: return "LimitExceeded"
        case .mismatchedetag: return "MismatchedEtag"
        case .requestthrottled: return "RequestThrottled"
        case .resourcenotfound: return "ResourceNotFound"
        case .robotapplicationcrash: return "RobotApplicationCrash"
        case .robotapplicationhealthcheckfailure: return "RobotApplicationHealthCheckFailure"
        case .robotapplicationversionmismatchedetag: return "RobotApplicationVersionMismatchedEtag"
        case .simulationapplicationcrash: return "SimulationApplicationCrash"
        case .simulationapplicationhealthcheckfailure: return "SimulationApplicationHealthCheckFailure"
        case .simulationapplicationversionmismatchedetag: return "SimulationApplicationVersionMismatchedEtag"
        case .subnetiplimitexceeded: return "SubnetIpLimitExceeded"
        case .throttlingerror: return "ThrottlingError"
        case .uploadcontentmismatcherror: return "UploadContentMismatchError"
        case .wrongregionrobotapplication: return "WrongRegionRobotApplication"
        case .wrongregions3bucket: return "WrongRegionS3Bucket"
        case .wrongregions3output: return "WrongRegionS3Output"
        case .wrongregionsimulationapplication: return "WrongRegionSimulationApplication"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SimulationJobErrorCode(rawValue: rawValue) ?? SimulationJobErrorCode.sdkUnknown(rawValue)
    }
}

extension SimulationJobRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compute
        case dataSources
        case failureBehavior
        case iamRole
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case tags
        case useDefaultApplications
        case vpcConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compute = compute {
            try encodeContainer.encode(compute, forKey: .compute)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasourceconfigs0 in dataSources {
                try dataSourcesContainer.encode(datasourceconfigs0)
            }
        }
        if let failureBehavior = failureBehavior {
            try encodeContainer.encode(failureBehavior.rawValue, forKey: .failureBehavior)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let loggingConfig = loggingConfig {
            try encodeContainer.encode(loggingConfig, forKey: .loggingConfig)
        }
        if maxJobDurationInSeconds != 0 {
            try encodeContainer.encode(maxJobDurationInSeconds, forKey: .maxJobDurationInSeconds)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let robotApplications = robotApplications {
            var robotApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplications)
            for robotapplicationconfigs0 in robotApplications {
                try robotApplicationsContainer.encode(robotapplicationconfigs0)
            }
        }
        if let simulationApplications = simulationApplications {
            var simulationApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplications)
            for simulationapplicationconfigs0 in simulationApplications {
                try simulationApplicationsContainer.encode(simulationapplicationconfigs0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let useDefaultApplications = useDefaultApplications {
            try encodeContainer.encode(useDefaultApplications, forKey: .useDefaultApplications)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputLocationDecoded = try containerValues.decodeIfPresent(OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decode(Int.self, forKey: .maxJobDurationInSeconds)
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let useDefaultApplicationsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDefaultApplications)
        useDefaultApplications = useDefaultApplicationsDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([DataSourceConfig?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[DataSourceConfig]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [DataSourceConfig]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VPCConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let computeDecoded = try containerValues.decodeIfPresent(Compute.self, forKey: .compute)
        compute = computeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SimulationJobRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimulationJobRequest(compute: \(String(describing: compute)), dataSources: \(String(describing: dataSources)), failureBehavior: \(String(describing: failureBehavior)), iamRole: \(String(describing: iamRole)), loggingConfig: \(String(describing: loggingConfig)), maxJobDurationInSeconds: \(String(describing: maxJobDurationInSeconds)), outputLocation: \(String(describing: outputLocation)), robotApplications: \(String(describing: robotApplications)), simulationApplications: \(String(describing: simulationApplications)), tags: \(String(describing: tags)), useDefaultApplications: \(String(describing: useDefaultApplications)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Information about a simulation job request.</p>
public struct SimulationJobRequest: Equatable {
    /// <p>Compute information for the simulation job</p>
    public let compute: Compute?
    /// <p>Specify data sources to mount read-only files from S3 into your simulation. These files
    ///          are available under <code>/opt/robomaker/datasources/data_source_name</code>. </p>
    ///          <note>
    ///             <p>There is a limit of 100 files and a combined size of 25GB for all
    ///                <code>DataSourceConfig</code> objects. </p>
    ///          </note>
    public let dataSources: [DataSourceConfig]?
    /// <p>The failure behavior the simulation job.</p>
    ///          <dl>
    ///             <dt>Continue</dt>
    ///             <dd>
    ///                <p>Restart the simulation job in the same host instance.</p>
    ///             </dd>
    ///             <dt>Fail</dt>
    ///             <dd>
    ///                <p>Stop the simulation job and terminate the instance.</p>
    ///             </dd>
    ///          </dl>
    public let failureBehavior: FailureBehavior?
    /// <p>The IAM role name that allows the simulation instance to call the AWS APIs that are
    ///          specified in its associated policies on your behalf. This is how credentials are passed in
    ///          to your simulation job. </p>
    public let iamRole: String?
    /// <p>The logging configuration.</p>
    public let loggingConfig: LoggingConfig?
    /// <p>The maximum simulation job duration in seconds. The value must be 8 days (691,200
    ///          seconds) or less.</p>
    public let maxJobDurationInSeconds: Int
    /// <p>The output location.</p>
    public let outputLocation: OutputLocation?
    /// <p>The robot applications to use in the simulation job.</p>
    public let robotApplications: [RobotApplicationConfig]?
    /// <p>The simulation applications to use in the simulation job.</p>
    public let simulationApplications: [SimulationApplicationConfig]?
    /// <p>A map that contains tag keys and tag values that are attached to the simulation job
    ///          request.</p>
    public let tags: [String:String]?
    /// <p>A Boolean indicating whether to use default applications in the simulation job. Default
    ///          applications include Gazebo, rqt, rviz and terminal access. </p>
    public let useDefaultApplications: Bool?
    /// <p>If your simulation job accesses resources in a VPC, you provide this parameter
    ///          identifying the list of security group IDs and subnet IDs. These must belong to the same
    ///          VPC. You must provide at least one security group and two subnet IDs.</p>
    public let vpcConfig: VPCConfig?

    public init (
        compute: Compute? = nil,
        dataSources: [DataSourceConfig]? = nil,
        failureBehavior: FailureBehavior? = nil,
        iamRole: String? = nil,
        loggingConfig: LoggingConfig? = nil,
        maxJobDurationInSeconds: Int = 0,
        outputLocation: OutputLocation? = nil,
        robotApplications: [RobotApplicationConfig]? = nil,
        simulationApplications: [SimulationApplicationConfig]? = nil,
        tags: [String:String]? = nil,
        useDefaultApplications: Bool? = nil,
        vpcConfig: VPCConfig? = nil
    )
    {
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.iamRole = iamRole
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.tags = tags
        self.useDefaultApplications = useDefaultApplications
        self.vpcConfig = vpcConfig
    }
}

public enum SimulationJobStatus {
    case canceled
    case completed
    case failed
    case pending
    case preparing
    case restarting
    case running
    case runningfailed
    case terminated
    case terminating
    case sdkUnknown(String)
}

extension SimulationJobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SimulationJobStatus] {
        return [
            .canceled,
            .completed,
            .failed,
            .pending,
            .preparing,
            .restarting,
            .running,
            .runningfailed,
            .terminated,
            .terminating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "Canceled"
        case .completed: return "Completed"
        case .failed: return "Failed"
        case .pending: return "Pending"
        case .preparing: return "Preparing"
        case .restarting: return "Restarting"
        case .running: return "Running"
        case .runningfailed: return "RunningFailed"
        case .terminated: return "Terminated"
        case .terminating: return "Terminating"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SimulationJobStatus(rawValue: rawValue) ?? SimulationJobStatus.sdkUnknown(rawValue)
    }
}

extension SimulationJobSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case dataSourceNames
        case lastUpdatedAt
        case name
        case robotApplicationNames
        case simulationApplicationNames
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataSourceNames = dataSourceNames {
            var dataSourceNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSourceNames)
            for datasourcenames0 in dataSourceNames {
                try dataSourceNamesContainer.encode(datasourcenames0)
            }
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotApplicationNames = robotApplicationNames {
            var robotApplicationNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplicationNames)
            for robotapplicationnames0 in robotApplicationNames {
                try robotApplicationNamesContainer.encode(robotapplicationnames0)
            }
        }
        if let simulationApplicationNames = simulationApplicationNames {
            var simulationApplicationNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplicationNames)
            for simulationapplicationnames0 in simulationApplicationNames {
                try simulationApplicationNamesContainer.encode(simulationapplicationnames0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let simulationApplicationNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .simulationApplicationNames)
        var simulationApplicationNamesDecoded0:[String]? = nil
        if let simulationApplicationNamesContainer = simulationApplicationNamesContainer {
            simulationApplicationNamesDecoded0 = [String]()
            for string0 in simulationApplicationNamesContainer {
                if let string0 = string0 {
                    simulationApplicationNamesDecoded0?.append(string0)
                }
            }
        }
        simulationApplicationNames = simulationApplicationNamesDecoded0
        let robotApplicationNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .robotApplicationNames)
        var robotApplicationNamesDecoded0:[String]? = nil
        if let robotApplicationNamesContainer = robotApplicationNamesContainer {
            robotApplicationNamesDecoded0 = [String]()
            for string0 in robotApplicationNamesContainer {
                if let string0 = string0 {
                    robotApplicationNamesDecoded0?.append(string0)
                }
            }
        }
        robotApplicationNames = robotApplicationNamesDecoded0
        let dataSourceNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dataSourceNames)
        var dataSourceNamesDecoded0:[String]? = nil
        if let dataSourceNamesContainer = dataSourceNamesContainer {
            dataSourceNamesDecoded0 = [String]()
            for string0 in dataSourceNamesContainer {
                if let string0 = string0 {
                    dataSourceNamesDecoded0?.append(string0)
                }
            }
        }
        dataSourceNames = dataSourceNamesDecoded0
    }
}

extension SimulationJobSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimulationJobSummary(arn: \(String(describing: arn)), dataSourceNames: \(String(describing: dataSourceNames)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)), robotApplicationNames: \(String(describing: robotApplicationNames)), simulationApplicationNames: \(String(describing: simulationApplicationNames)), status: \(String(describing: status)))"}
}

/// <p>Summary information for a simulation job.</p>
public struct SimulationJobSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the simulation job.</p>
    public let arn: String?
    /// <p>The names of the data sources.</p>
    public let dataSourceNames: [String]?
    /// <p>The time, in milliseconds since the epoch, when the simulation job was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the simulation job.</p>
    public let name: String?
    /// <p>A list of simulation job robot application names.</p>
    public let robotApplicationNames: [String]?
    /// <p>A list of simulation job simulation application names.</p>
    public let simulationApplicationNames: [String]?
    /// <p>The status of the simulation job.</p>
    public let status: SimulationJobStatus?

    public init (
        arn: String? = nil,
        dataSourceNames: [String]? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil,
        robotApplicationNames: [String]? = nil,
        simulationApplicationNames: [String]? = nil,
        status: SimulationJobStatus? = nil
    )
    {
        self.arn = arn
        self.dataSourceNames = dataSourceNames
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.robotApplicationNames = robotApplicationNames
        self.simulationApplicationNames = simulationApplicationNames
        self.status = status
    }
}

extension SimulationSoftwareSuite: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SimulationSoftwareSuiteType.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension SimulationSoftwareSuite: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimulationSoftwareSuite(name: \(String(describing: name)), version: \(String(describing: version)))"}
}

/// <p>Information about a simulation software suite.</p>
public struct SimulationSoftwareSuite: Equatable {
    /// <p>The name of the simulation software suite.</p>
    public let name: SimulationSoftwareSuiteType?
    /// <p>The version of the simulation software suite.</p>
    public let version: String?

    public init (
        name: SimulationSoftwareSuiteType? = nil,
        version: String? = nil
    )
    {
        self.name = name
        self.version = version
    }
}

public enum SimulationSoftwareSuiteType {
    case gazebo
    case rosbagplay
    case sdkUnknown(String)
}

extension SimulationSoftwareSuiteType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SimulationSoftwareSuiteType] {
        return [
            .gazebo,
            .rosbagplay,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .gazebo: return "Gazebo"
        case .rosbagplay: return "RosbagPlay"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SimulationSoftwareSuiteType(rawValue: rawValue) ?? SimulationSoftwareSuiteType.sdkUnknown(rawValue)
    }
}

extension Source: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case architecture
        case etag
        case s3Bucket
        case s3Key
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let etag = etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let etagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .etag)
        etag = etagDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
    }
}

extension Source: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Source(architecture: \(String(describing: architecture)), etag: \(String(describing: etag)), s3Bucket: \(String(describing: s3Bucket)), s3Key: \(String(describing: s3Key)))"}
}

/// <p>Information about a source.</p>
public struct Source: Equatable {
    /// <p>The taget processor architecture for the application.</p>
    public let architecture: Architecture?
    /// <p>A hash of the object specified by <code>s3Bucket</code> and <code>s3Key</code>.</p>
    public let etag: String?
    /// <p>The s3 bucket name.</p>
    public let s3Bucket: String?
    /// <p>The s3 object key.</p>
    public let s3Key: String?

    public init (
        architecture: Architecture? = nil,
        etag: String? = nil,
        s3Bucket: String? = nil,
        s3Key: String? = nil
    )
    {
        self.architecture = architecture
        self.etag = etag
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
    }
}

extension SourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case architecture
        case s3Bucket
        case s3Key
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
    }
}

extension SourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceConfig(architecture: \(String(describing: architecture)), s3Bucket: \(String(describing: s3Bucket)), s3Key: \(String(describing: s3Key)))"}
}

/// <p>Information about a source configuration.</p>
public struct SourceConfig: Equatable {
    /// <p>The target processor architecture for the application.</p>
    public let architecture: Architecture?
    /// <p>The Amazon S3 bucket name.</p>
    public let s3Bucket: String?
    /// <p>The s3 object key.</p>
    public let s3Key: String?

    public init (
        architecture: Architecture? = nil,
        s3Bucket: String? = nil,
        s3Key: String? = nil
    )
    {
        self.architecture = architecture
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
    }
}

public struct StartSimulationJobBatchInputBodyMiddleware: Middleware {
    public let id: String = "StartSimulationJobBatchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSimulationJobBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSimulationJobBatchInput>
    public typealias MOutput = OperationOutput<StartSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSimulationJobBatchOutputError>
}

extension StartSimulationJobBatchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSimulationJobBatchInput(batchPolicy: \(String(describing: batchPolicy)), clientRequestToken: \(String(describing: clientRequestToken)), createSimulationJobRequests: \(String(describing: createSimulationJobRequests)), tags: \(String(describing: tags)))"}
}

extension StartSimulationJobBatchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchPolicy
        case clientRequestToken
        case createSimulationJobRequests
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchPolicy = batchPolicy {
            try encodeContainer.encode(batchPolicy, forKey: .batchPolicy)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let createSimulationJobRequests = createSimulationJobRequests {
            var createSimulationJobRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .createSimulationJobRequests)
            for createsimulationjobrequests0 in createSimulationJobRequests {
                try createSimulationJobRequestsContainer.encode(createsimulationjobrequests0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StartSimulationJobBatchInputHeadersMiddleware: Middleware {
    public let id: String = "StartSimulationJobBatchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSimulationJobBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSimulationJobBatchInput>
    public typealias MOutput = OperationOutput<StartSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSimulationJobBatchOutputError>
}

public struct StartSimulationJobBatchInputQueryItemMiddleware: Middleware {
    public let id: String = "StartSimulationJobBatchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSimulationJobBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSimulationJobBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSimulationJobBatchInput>
    public typealias MOutput = OperationOutput<StartSimulationJobBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSimulationJobBatchOutputError>
}

public struct StartSimulationJobBatchInput: Equatable {
    /// <p>The batch policy.</p>
    public let batchPolicy: BatchPolicy?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public var clientRequestToken: String?
    /// <p>A list of simulation job requests to create in the batch.</p>
    public let createSimulationJobRequests: [SimulationJobRequest]?
    /// <p>A map that contains tag keys and tag values that are attached to the deployment job
    ///          batch.</p>
    public let tags: [String:String]?

    public init (
        batchPolicy: BatchPolicy? = nil,
        clientRequestToken: String? = nil,
        createSimulationJobRequests: [SimulationJobRequest]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.batchPolicy = batchPolicy
        self.clientRequestToken = clientRequestToken
        self.createSimulationJobRequests = createSimulationJobRequests
        self.tags = tags
    }
}

struct StartSimulationJobBatchInputBody: Equatable {
    public let clientRequestToken: String?
    public let batchPolicy: BatchPolicy?
    public let createSimulationJobRequests: [SimulationJobRequest]?
    public let tags: [String:String]?
}

extension StartSimulationJobBatchInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchPolicy
        case clientRequestToken
        case createSimulationJobRequests
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let batchPolicyDecoded = try containerValues.decodeIfPresent(BatchPolicy.self, forKey: .batchPolicy)
        batchPolicy = batchPolicyDecoded
        let createSimulationJobRequestsContainer = try containerValues.decodeIfPresent([SimulationJobRequest?].self, forKey: .createSimulationJobRequests)
        var createSimulationJobRequestsDecoded0:[SimulationJobRequest]? = nil
        if let createSimulationJobRequestsContainer = createSimulationJobRequestsContainer {
            createSimulationJobRequestsDecoded0 = [SimulationJobRequest]()
            for structure0 in createSimulationJobRequestsContainer {
                if let structure0 = structure0 {
                    createSimulationJobRequestsDecoded0?.append(structure0)
                }
            }
        }
        createSimulationJobRequests = createSimulationJobRequestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartSimulationJobBatchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSimulationJobBatchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSimulationJobBatchOutputError: Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSimulationJobBatchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSimulationJobBatchOutputResponse(arn: \(String(describing: arn)), batchPolicy: \(String(describing: batchPolicy)), clientRequestToken: \(String(describing: clientRequestToken)), createdAt: \(String(describing: createdAt)), createdRequests: \(String(describing: createdRequests)), failedRequests: \(String(describing: failedRequests)), failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), pendingRequests: \(String(describing: pendingRequests)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

extension StartSimulationJobBatchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartSimulationJobBatchOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.batchPolicy = output.batchPolicy
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.createdRequests = output.createdRequests
            self.failedRequests = output.failedRequests
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.pendingRequests = output.pendingRequests
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.batchPolicy = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.createdRequests = nil
            self.failedRequests = nil
            self.failureCode = nil
            self.failureReason = nil
            self.pendingRequests = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct StartSimulationJobBatchOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (arn) of the batch.</p>
    public let arn: String?
    /// <p>The batch policy.</p>
    public let batchPolicy: BatchPolicy?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public let clientRequestToken: String?
    /// <p>The time, in milliseconds since the epoch, when the simulation job batch was
    ///          created.</p>
    public let createdAt: Date?
    /// <p>A list of created simulation job request summaries.</p>
    public let createdRequests: [SimulationJobSummary]?
    /// <p>A list of failed simulation job requests. The request failed to be created into a
    ///          simulation job. Failed requests do not have a simulation job ID. </p>
    public let failedRequests: [FailedCreateSimulationJobRequest]?
    /// <p>The failure code if the simulation job batch failed.</p>
    public let failureCode: SimulationJobBatchErrorCode?
    /// <p>The reason the simulation job batch failed.</p>
    public let failureReason: String?
    /// <p>A list of pending simulation job requests. These requests have not yet been created into
    ///          simulation jobs.</p>
    public let pendingRequests: [SimulationJobRequest]?
    /// <p>The status of the simulation job batch.</p>
    ///          <dl>
    ///             <dt>Pending</dt>
    ///             <dd>
    ///                <p>The simulation job batch request is pending.</p>
    ///             </dd>
    ///             <dt>InProgress</dt>
    ///             <dd>
    ///                <p>The simulation job batch is in progress. </p>
    ///             </dd>
    ///             <dt>Failed</dt>
    ///             <dd>
    ///                <p>The simulation job batch failed. One or more simulation job requests could not
    ///                   be completed due to an internal failure (like <code>InternalServiceError</code>).
    ///                   See <code>failureCode</code> and <code>failureReason</code> for more
    ///                   information.</p>
    ///             </dd>
    ///             <dt>Completed</dt>
    ///             <dd>
    ///                <p>The simulation batch job completed. A batch is complete when (1) there are no
    ///                   pending simulation job requests in the batch and none of the failed simulation job
    ///                   requests are due to <code>InternalServiceError</code> and (2) when all created
    ///                   simulation jobs have reached a terminal state (for example, <code>Completed</code>
    ///                   or <code>Failed</code>). </p>
    ///             </dd>
    ///             <dt>Canceled</dt>
    ///             <dd>
    ///                <p>The simulation batch job was cancelled.</p>
    ///             </dd>
    ///             <dt>Canceling</dt>
    ///             <dd>
    ///                <p>The simulation batch job is being cancelled.</p>
    ///             </dd>
    ///             <dt>Completing</dt>
    ///             <dd>
    ///                <p>The simulation batch job is completing.</p>
    ///             </dd>
    ///             <dt>TimingOut</dt>
    ///             <dd>
    ///                <p>The simulation job batch is timing out.</p>
    ///                <p>If a batch timing out, and there are pending requests that were failing due to
    ///                   an internal failure (like <code>InternalServiceError</code>), the batch status
    ///                   will be <code>Failed</code>. If there are no such failing request, the batch
    ///                   status will be <code>TimedOut</code>. </p>
    ///             </dd>
    ///             <dt>TimedOut</dt>
    ///             <dd>
    ///                <p>The simulation batch job timed out.</p>
    ///             </dd>
    ///          </dl>
    public let status: SimulationJobBatchStatus?
    /// <p>A map that contains tag keys and tag values that are attached to the deployment job
    ///          batch.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        batchPolicy: BatchPolicy? = nil,
        clientRequestToken: String? = nil,
        createdAt: Date? = nil,
        createdRequests: [SimulationJobSummary]? = nil,
        failedRequests: [FailedCreateSimulationJobRequest]? = nil,
        failureCode: SimulationJobBatchErrorCode? = nil,
        failureReason: String? = nil,
        pendingRequests: [SimulationJobRequest]? = nil,
        status: SimulationJobBatchStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.batchPolicy = batchPolicy
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.createdRequests = createdRequests
        self.failedRequests = failedRequests
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.pendingRequests = pendingRequests
        self.status = status
        self.tags = tags
    }
}

struct StartSimulationJobBatchOutputResponseBody: Equatable {
    public let arn: String?
    public let status: SimulationJobBatchStatus?
    public let createdAt: Date?
    public let clientRequestToken: String?
    public let batchPolicy: BatchPolicy?
    public let failureCode: SimulationJobBatchErrorCode?
    public let failureReason: String?
    public let failedRequests: [FailedCreateSimulationJobRequest]?
    public let pendingRequests: [SimulationJobRequest]?
    public let createdRequests: [SimulationJobSummary]?
    public let tags: [String:String]?
}

extension StartSimulationJobBatchOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case batchPolicy
        case clientRequestToken
        case createdAt
        case createdRequests
        case failedRequests
        case failureCode
        case failureReason
        case pendingRequests
        case status
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SimulationJobBatchStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let batchPolicyDecoded = try containerValues.decodeIfPresent(BatchPolicy.self, forKey: .batchPolicy)
        batchPolicy = batchPolicyDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(SimulationJobBatchErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failedRequestsContainer = try containerValues.decodeIfPresent([FailedCreateSimulationJobRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[FailedCreateSimulationJobRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [FailedCreateSimulationJobRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
        let pendingRequestsContainer = try containerValues.decodeIfPresent([SimulationJobRequest?].self, forKey: .pendingRequests)
        var pendingRequestsDecoded0:[SimulationJobRequest]? = nil
        if let pendingRequestsContainer = pendingRequestsContainer {
            pendingRequestsDecoded0 = [SimulationJobRequest]()
            for structure0 in pendingRequestsContainer {
                if let structure0 = structure0 {
                    pendingRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingRequests = pendingRequestsDecoded0
        let createdRequestsContainer = try containerValues.decodeIfPresent([SimulationJobSummary?].self, forKey: .createdRequests)
        var createdRequestsDecoded0:[SimulationJobSummary]? = nil
        if let createdRequestsContainer = createdRequestsContainer {
            createdRequestsDecoded0 = [SimulationJobSummary]()
            for structure0 in createdRequestsContainer {
                if let structure0 = structure0 {
                    createdRequestsDecoded0?.append(structure0)
                }
            }
        }
        createdRequests = createdRequestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct SyncDeploymentJobInputBodyMiddleware: Middleware {
    public let id: String = "SyncDeploymentJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SyncDeploymentJobInput>,
                  next: H) -> Swift.Result<OperationOutput<SyncDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SyncDeploymentJobInput>
    public typealias MOutput = OperationOutput<SyncDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SyncDeploymentJobOutputError>
}

extension SyncDeploymentJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SyncDeploymentJobInput(clientRequestToken: \(String(describing: clientRequestToken)), fleet: \(String(describing: fleet)))"}
}

extension SyncDeploymentJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case fleet
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fleet = fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
    }
}

public struct SyncDeploymentJobInputHeadersMiddleware: Middleware {
    public let id: String = "SyncDeploymentJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SyncDeploymentJobInput>,
                  next: H) -> Swift.Result<OperationOutput<SyncDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SyncDeploymentJobInput>
    public typealias MOutput = OperationOutput<SyncDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SyncDeploymentJobOutputError>
}

public struct SyncDeploymentJobInputQueryItemMiddleware: Middleware {
    public let id: String = "SyncDeploymentJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SyncDeploymentJobInput>,
                  next: H) -> Swift.Result<OperationOutput<SyncDeploymentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SyncDeploymentJobInput>
    public typealias MOutput = OperationOutput<SyncDeploymentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SyncDeploymentJobOutputError>
}

public struct SyncDeploymentJobInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request.</p>
    public var clientRequestToken: String?
    /// <p>The target fleet for the synchronization.</p>
    public let fleet: String?

    public init (
        clientRequestToken: String? = nil,
        fleet: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fleet = fleet
    }
}

struct SyncDeploymentJobInputBody: Equatable {
    public let clientRequestToken: String?
    public let fleet: String?
}

extension SyncDeploymentJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case fleet
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

extension SyncDeploymentJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SyncDeploymentJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentDeploymentException" : self = .concurrentDeploymentException(try ConcurrentDeploymentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SyncDeploymentJobOutputError: Equatable {
    case concurrentDeploymentException(ConcurrentDeploymentException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SyncDeploymentJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SyncDeploymentJobOutputResponse(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), deploymentApplicationConfigs: \(String(describing: deploymentApplicationConfigs)), deploymentConfig: \(String(describing: deploymentConfig)), failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), fleet: \(String(describing: fleet)), status: \(String(describing: status)))"}
}

extension SyncDeploymentJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SyncDeploymentJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.deploymentApplicationConfigs = output.deploymentApplicationConfigs
            self.deploymentConfig = output.deploymentConfig
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.fleet = output.fleet
            self.status = output.status
        } else {
            self.arn = nil
            self.createdAt = nil
            self.deploymentApplicationConfigs = nil
            self.deploymentConfig = nil
            self.failureCode = nil
            self.failureReason = nil
            self.fleet = nil
            self.status = nil
        }
    }
}

public struct SyncDeploymentJobOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the synchronization request.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the fleet was created.</p>
    public let createdAt: Date?
    /// <p>Information about the deployment application configurations.</p>
    public let deploymentApplicationConfigs: [DeploymentApplicationConfig]?
    /// <p>Information about the deployment configuration.</p>
    public let deploymentConfig: DeploymentConfig?
    /// <p>The failure code if the job fails:</p>
    ///          <dl>
    ///             <dt>InternalServiceError</dt>
    ///             <dd>
    ///                <p>Internal service error.</p>
    ///             </dd>
    ///             <dt>RobotApplicationCrash</dt>
    ///             <dd>
    ///                <p>Robot application exited abnormally.</p>
    ///             </dd>
    ///             <dt>SimulationApplicationCrash</dt>
    ///             <dd>
    ///                <p> Simulation application exited abnormally.</p>
    ///             </dd>
    ///             <dt>BadPermissionsRobotApplication</dt>
    ///             <dd>
    ///                <p>Robot application bundle could not be downloaded.</p>
    ///             </dd>
    ///             <dt>BadPermissionsSimulationApplication</dt>
    ///             <dd>
    ///                <p>Simulation application bundle could not be downloaded.</p>
    ///             </dd>
    ///             <dt>BadPermissionsS3Output</dt>
    ///             <dd>
    ///                <p>Unable to publish outputs to customer-provided S3 bucket.</p>
    ///             </dd>
    ///             <dt>BadPermissionsCloudwatchLogs</dt>
    ///             <dd>
    ///                <p>Unable to publish logs to customer-provided CloudWatch Logs resource.</p>
    ///             </dd>
    ///             <dt>SubnetIpLimitExceeded</dt>
    ///             <dd>
    ///                <p>Subnet IP limit exceeded.</p>
    ///             </dd>
    ///             <dt>ENILimitExceeded</dt>
    ///             <dd>
    ///                <p>ENI limit exceeded.</p>
    ///             </dd>
    ///             <dt>BadPermissionsUserCredentials</dt>
    ///             <dd>
    ///                <p>Unable to use the Role provided.</p>
    ///             </dd>
    ///             <dt>InvalidBundleRobotApplication</dt>
    ///             <dd>
    ///                <p>Robot bundle cannot be extracted (invalid format, bundling error, or other
    ///                   issue).</p>
    ///             </dd>
    ///             <dt>InvalidBundleSimulationApplication</dt>
    ///             <dd>
    ///                <p>Simulation bundle cannot be extracted (invalid format, bundling error, or other
    ///                   issue).</p>
    ///             </dd>
    ///             <dt>RobotApplicationVersionMismatchedEtag</dt>
    ///             <dd>
    ///                <p>Etag for RobotApplication does not match value during version creation.</p>
    ///             </dd>
    ///             <dt>SimulationApplicationVersionMismatchedEtag</dt>
    ///             <dd>
    ///                <p>Etag for SimulationApplication does not match value during version
    ///                   creation.</p>
    ///             </dd>
    ///          </dl>
    public let failureCode: DeploymentJobErrorCode?
    /// <p>The failure reason if the job fails.</p>
    public let failureReason: String?
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let fleet: String?
    /// <p>The status of the synchronization job.</p>
    public let status: DeploymentStatus?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        deploymentApplicationConfigs: [DeploymentApplicationConfig]? = nil,
        deploymentConfig: DeploymentConfig? = nil,
        failureCode: DeploymentJobErrorCode? = nil,
        failureReason: String? = nil,
        fleet: String? = nil,
        status: DeploymentStatus? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.status = status
    }
}

struct SyncDeploymentJobOutputResponseBody: Equatable {
    public let arn: String?
    public let fleet: String?
    public let status: DeploymentStatus?
    public let deploymentConfig: DeploymentConfig?
    public let deploymentApplicationConfigs: [DeploymentApplicationConfig]?
    public let failureReason: String?
    public let failureCode: DeploymentJobErrorCode?
    public let createdAt: Date?
}

extension SyncDeploymentJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS RoboMaker resource you are tagging.</p>
    public let resourceArn: String?
    /// <p>A map that contains tag keys and tag values that are attached to the resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TemplateLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Bucket
        case s3Key
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension TemplateLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateLocation(s3Bucket: \(String(describing: s3Bucket)), s3Key: \(String(describing: s3Key)))"}
}

/// <p>Information about a template location.</p>
public struct TemplateLocation: Equatable {
    /// <p>The Amazon S3 bucket name.</p>
    public let s3Bucket: String?
    /// <p>The list of S3 keys identifying the data source files.</p>
    public let s3Key: String?

    public init (
        s3Bucket: String? = nil,
        s3Key: String? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
    }
}

extension TemplateSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension TemplateSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateSummary(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)))"}
}

/// <p>Summary information for a template.</p>
public struct TemplateSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the template.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the template was created.</p>
    public let createdAt: Date?
    /// <p>The time, in milliseconds since the epoch, when the template was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the template.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS RoboMaker is temporarily unable to process the request. Try your call again.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tool: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case command
        case exitBehavior
        case name
        case streamOutputToCloudWatch
        case streamUI
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let exitBehavior = exitBehavior {
            try encodeContainer.encode(exitBehavior.rawValue, forKey: .exitBehavior)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamOutputToCloudWatch = streamOutputToCloudWatch {
            try encodeContainer.encode(streamOutputToCloudWatch, forKey: .streamOutputToCloudWatch)
        }
        if let streamUI = streamUI {
            try encodeContainer.encode(streamUI, forKey: .streamUI)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamUIDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .streamUI)
        streamUI = streamUIDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let commandDecoded = try containerValues.decodeIfPresent(String.self, forKey: .command)
        command = commandDecoded
        let streamOutputToCloudWatchDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .streamOutputToCloudWatch)
        streamOutputToCloudWatch = streamOutputToCloudWatchDecoded
        let exitBehaviorDecoded = try containerValues.decodeIfPresent(ExitBehavior.self, forKey: .exitBehavior)
        exitBehavior = exitBehaviorDecoded
    }
}

extension Tool: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tool(command: \(String(describing: command)), exitBehavior: \(String(describing: exitBehavior)), name: \(String(describing: name)), streamOutputToCloudWatch: \(String(describing: streamOutputToCloudWatch)), streamUI: \(String(describing: streamUI)))"}
}

/// <p>Information about a tool. Tools are used in a simulation job.</p>
public struct Tool: Equatable {
    /// <p>Command-line arguments for the tool. It must include the tool executable name.</p>
    public let command: String?
    /// <p>Exit behavior determines what happens when your tool quits running.
    ///         <code>RESTART</code> will cause your tool to be restarted. <code>FAIL</code>
    ///         will cause your job to exit. The default is <code>RESTART</code>.
    ///       </p>
    public let exitBehavior: ExitBehavior?
    /// <p>The name of the tool.</p>
    public let name: String?
    /// <p>Boolean indicating whether logs will be recorded in CloudWatch for the tool.
    ///       The default is <code>False</code>.
    ///       </p>
    public let streamOutputToCloudWatch: Bool?
    /// <p>Boolean indicating whether a streaming session will be configured for the tool.
    ///          If <code>True</code>, AWS RoboMaker will configure a connection so you can interact with
    ///          the tool as it is running in the simulation. It must have a graphical user interface.
    ///          The default is <code>False</code>.
    ///       </p>
    public let streamUI: Bool?

    public init (
        command: String? = nil,
        exitBehavior: ExitBehavior? = nil,
        name: String? = nil,
        streamOutputToCloudWatch: Bool? = nil,
        streamUI: Bool? = nil
    )
    {
        self.command = command
        self.exitBehavior = exitBehavior
        self.name = name
        self.streamOutputToCloudWatch = streamOutputToCloudWatch
        self.streamUI = streamUI
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS RoboMaker resource you are removing
    ///          tags.</p>
    public let resourceArn: String?
    /// <p>A map that contains tag keys and tag values that will be unattached from the
    ///          resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRobotApplicationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRobotApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRobotApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRobotApplicationInput>
    public typealias MOutput = OperationOutput<UpdateRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRobotApplicationOutputError>
}

extension UpdateRobotApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRobotApplicationInput(application: \(String(describing: application)), currentRevisionId: \(String(describing: currentRevisionId)), robotSoftwareSuite: \(String(describing: robotSoftwareSuite)), sources: \(String(describing: sources)))"}
}

extension UpdateRobotApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case application
        case currentRevisionId
        case robotSoftwareSuite
        case sources
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
        if let robotSoftwareSuite = robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfigs0 in sources {
                try sourcesContainer.encode(sourceconfigs0)
            }
        }
    }
}

public struct UpdateRobotApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRobotApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRobotApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRobotApplicationInput>
    public typealias MOutput = OperationOutput<UpdateRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRobotApplicationOutputError>
}

public struct UpdateRobotApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRobotApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRobotApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRobotApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRobotApplicationInput>
    public typealias MOutput = OperationOutput<UpdateRobotApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRobotApplicationOutputError>
}

public struct UpdateRobotApplicationInput: Equatable {
    /// <p>The application information for the robot application.</p>
    public let application: String?
    /// <p>The revision id for the robot application.</p>
    public let currentRevisionId: String?
    /// <p>The robot software suite (ROS distribution) used by the robot application.</p>
    public let robotSoftwareSuite: RobotSoftwareSuite?
    /// <p>The sources of the robot application.</p>
    public let sources: [SourceConfig]?

    public init (
        application: String? = nil,
        currentRevisionId: String? = nil,
        robotSoftwareSuite: RobotSoftwareSuite? = nil,
        sources: [SourceConfig]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
    }
}

struct UpdateRobotApplicationInputBody: Equatable {
    public let application: String?
    public let sources: [SourceConfig]?
    public let robotSoftwareSuite: RobotSoftwareSuite?
    public let currentRevisionId: String?
}

extension UpdateRobotApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case application
        case currentRevisionId
        case robotSoftwareSuite
        case sources
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .application)
        application = applicationDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
    }
}

extension UpdateRobotApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRobotApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRobotApplicationOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRobotApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRobotApplicationOutputResponse(arn: \(String(describing: arn)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)), revisionId: \(String(describing: revisionId)), robotSoftwareSuite: \(String(describing: robotSoftwareSuite)), sources: \(String(describing: sources)), version: \(String(describing: version)))"}
}

extension UpdateRobotApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRobotApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct UpdateRobotApplicationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the updated robot application.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the robot application was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the robot application.</p>
    public let name: String?
    /// <p>The revision id of the robot application.</p>
    public let revisionId: String?
    /// <p>The robot software suite (ROS distribution) used by the robot application.</p>
    public let robotSoftwareSuite: RobotSoftwareSuite?
    /// <p>The sources of the robot application.</p>
    public let sources: [Source]?
    /// <p>The version of the robot application.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil,
        revisionId: String? = nil,
        robotSoftwareSuite: RobotSoftwareSuite? = nil,
        sources: [Source]? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct UpdateRobotApplicationOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let version: String?
    public let sources: [Source]?
    public let robotSoftwareSuite: RobotSoftwareSuite?
    public let lastUpdatedAt: Date?
    public let revisionId: String?
}

extension UpdateRobotApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([Source?].self, forKey: .sources)
        var sourcesDecoded0:[Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

public struct UpdateSimulationApplicationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSimulationApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSimulationApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSimulationApplicationInput>
    public typealias MOutput = OperationOutput<UpdateSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSimulationApplicationOutputError>
}

extension UpdateSimulationApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSimulationApplicationInput(application: \(String(describing: application)), currentRevisionId: \(String(describing: currentRevisionId)), renderingEngine: \(String(describing: renderingEngine)), robotSoftwareSuite: \(String(describing: robotSoftwareSuite)), simulationSoftwareSuite: \(String(describing: simulationSoftwareSuite)), sources: \(String(describing: sources)))"}
}

extension UpdateSimulationApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case application
        case currentRevisionId
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
        if let renderingEngine = renderingEngine {
            try encodeContainer.encode(renderingEngine, forKey: .renderingEngine)
        }
        if let robotSoftwareSuite = robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let simulationSoftwareSuite = simulationSoftwareSuite {
            try encodeContainer.encode(simulationSoftwareSuite, forKey: .simulationSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfigs0 in sources {
                try sourcesContainer.encode(sourceconfigs0)
            }
        }
    }
}

public struct UpdateSimulationApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSimulationApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSimulationApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSimulationApplicationInput>
    public typealias MOutput = OperationOutput<UpdateSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSimulationApplicationOutputError>
}

public struct UpdateSimulationApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSimulationApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSimulationApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSimulationApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSimulationApplicationInput>
    public typealias MOutput = OperationOutput<UpdateSimulationApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSimulationApplicationOutputError>
}

public struct UpdateSimulationApplicationInput: Equatable {
    /// <p>The application information for the simulation application.</p>
    public let application: String?
    /// <p>The revision id for the robot application.</p>
    public let currentRevisionId: String?
    /// <p>The rendering engine for the simulation application.</p>
    public let renderingEngine: RenderingEngine?
    /// <p>Information about the robot software suite (ROS distribution).</p>
    public let robotSoftwareSuite: RobotSoftwareSuite?
    /// <p>The simulation software suite used by the simulation application.</p>
    public let simulationSoftwareSuite: SimulationSoftwareSuite?
    /// <p>The sources of the simulation application.</p>
    public let sources: [SourceConfig]?

    public init (
        application: String? = nil,
        currentRevisionId: String? = nil,
        renderingEngine: RenderingEngine? = nil,
        robotSoftwareSuite: RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: SimulationSoftwareSuite? = nil,
        sources: [SourceConfig]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.renderingEngine = renderingEngine
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
    }
}

struct UpdateSimulationApplicationInputBody: Equatable {
    public let application: String?
    public let sources: [SourceConfig]?
    public let simulationSoftwareSuite: SimulationSoftwareSuite?
    public let robotSoftwareSuite: RobotSoftwareSuite?
    public let renderingEngine: RenderingEngine?
    public let currentRevisionId: String?
}

extension UpdateSimulationApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case application
        case currentRevisionId
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .application)
        application = applicationDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
    }
}

extension UpdateSimulationApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSimulationApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSimulationApplicationOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSimulationApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSimulationApplicationOutputResponse(arn: \(String(describing: arn)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)), renderingEngine: \(String(describing: renderingEngine)), revisionId: \(String(describing: revisionId)), robotSoftwareSuite: \(String(describing: robotSoftwareSuite)), simulationSoftwareSuite: \(String(describing: simulationSoftwareSuite)), sources: \(String(describing: sources)), version: \(String(describing: version)))"}
}

extension UpdateSimulationApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSimulationApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct UpdateSimulationApplicationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the updated simulation application.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the simulation application was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the simulation application.</p>
    public let name: String?
    /// <p>The rendering engine for the simulation application.</p>
    public let renderingEngine: RenderingEngine?
    /// <p>The revision id of the simulation application.</p>
    public let revisionId: String?
    /// <p>Information about the robot software suite (ROS distribution).</p>
    public let robotSoftwareSuite: RobotSoftwareSuite?
    /// <p>The simulation software suite used by the simulation application.</p>
    public let simulationSoftwareSuite: SimulationSoftwareSuite?
    /// <p>The sources of the simulation application.</p>
    public let sources: [Source]?
    /// <p>The version of the robot application.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil,
        renderingEngine: RenderingEngine? = nil,
        revisionId: String? = nil,
        robotSoftwareSuite: RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: SimulationSoftwareSuite? = nil,
        sources: [Source]? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct UpdateSimulationApplicationOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let version: String?
    public let sources: [Source]?
    public let simulationSoftwareSuite: SimulationSoftwareSuite?
    public let robotSoftwareSuite: RobotSoftwareSuite?
    public let renderingEngine: RenderingEngine?
    public let lastUpdatedAt: Date?
    public let revisionId: String?
}

extension UpdateSimulationApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([Source?].self, forKey: .sources)
        var sourcesDecoded0:[Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

public struct UpdateWorldTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateWorldTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorldTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorldTemplateInput>
    public typealias MOutput = OperationOutput<UpdateWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorldTemplateOutputError>
}

extension UpdateWorldTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorldTemplateInput(name: \(String(describing: name)), template: \(String(describing: template)), templateBody: \(String(describing: templateBody)), templateLocation: \(String(describing: templateLocation)))"}
}

extension UpdateWorldTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case template
        case templateBody
        case templateLocation
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
        if let templateBody = templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateLocation = templateLocation {
            try encodeContainer.encode(templateLocation, forKey: .templateLocation)
        }
    }
}

public struct UpdateWorldTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateWorldTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorldTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorldTemplateInput>
    public typealias MOutput = OperationOutput<UpdateWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorldTemplateOutputError>
}

public struct UpdateWorldTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateWorldTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorldTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorldTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorldTemplateInput>
    public typealias MOutput = OperationOutput<UpdateWorldTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorldTemplateOutputError>
}

public struct UpdateWorldTemplateInput: Equatable {
    /// <p>The name of the template.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (arn) of the world template to update.</p>
    public let template: String?
    /// <p>The world template body.</p>
    public let templateBody: String?
    /// <p>The location of the world template.</p>
    public let templateLocation: TemplateLocation?

    public init (
        name: String? = nil,
        template: String? = nil,
        templateBody: String? = nil,
        templateLocation: TemplateLocation? = nil
    )
    {
        self.name = name
        self.template = template
        self.templateBody = templateBody
        self.templateLocation = templateLocation
    }
}

struct UpdateWorldTemplateInputBody: Equatable {
    public let template: String?
    public let name: String?
    public let templateBody: String?
    public let templateLocation: TemplateLocation?
}

extension UpdateWorldTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
        case template
        case templateBody
        case templateLocation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .template)
        template = templateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let templateLocationDecoded = try containerValues.decodeIfPresent(TemplateLocation.self, forKey: .templateLocation)
        templateLocation = templateLocationDecoded
    }
}

extension UpdateWorldTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorldTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorldTemplateOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorldTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorldTemplateOutputResponse(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)))"}
}

extension UpdateWorldTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateWorldTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
        } else {
            self.arn = nil
            self.createdAt = nil
            self.lastUpdatedAt = nil
            self.name = nil
        }
    }
}

public struct UpdateWorldTemplateOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (arn) of the world template.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the world template was created.</p>
    public let createdAt: Date?
    /// <p>The time, in milliseconds since the epoch, when the world template was last
    ///          updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the world template.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
    }
}

struct UpdateWorldTemplateOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let createdAt: Date?
    public let lastUpdatedAt: Date?
}

extension UpdateWorldTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

public enum UploadBehavior {
    case uploadOnTerminate
    case uploadRollingAutoRemove
    case sdkUnknown(String)
}

extension UploadBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UploadBehavior] {
        return [
            .uploadOnTerminate,
            .uploadRollingAutoRemove,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .uploadOnTerminate: return "UPLOAD_ON_TERMINATE"
        case .uploadRollingAutoRemove: return "UPLOAD_ROLLING_AUTO_REMOVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UploadBehavior(rawValue: rawValue) ?? UploadBehavior.sdkUnknown(rawValue)
    }
}

extension UploadConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case path
        case uploadBehavior
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let uploadBehavior = uploadBehavior {
            try encodeContainer.encode(uploadBehavior.rawValue, forKey: .uploadBehavior)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let uploadBehaviorDecoded = try containerValues.decodeIfPresent(UploadBehavior.self, forKey: .uploadBehavior)
        uploadBehavior = uploadBehaviorDecoded
    }
}

extension UploadConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadConfiguration(name: \(String(describing: name)), path: \(String(describing: path)), uploadBehavior: \(String(describing: uploadBehavior)))"}
}

/// <p>Provides upload configuration information. Files are uploaded from the simulation job to
///          a location you specify. </p>
public struct UploadConfiguration: Equatable {
    /// <p>A prefix that specifies where files will be uploaded in Amazon S3.
    ///         It is appended to the simulation output location to determine the final path.
    ///        </p>
    ///          <p>
    ///         For example, if your simulation output location is <code>s3://my-bucket</code> and your upload
    ///         configuration name is <code>robot-test</code>, your files will be uploaded to
    ///         <code>s3://my-bucket/<simid>/<runid>/robot-test</code>.
    ///       </p>
    public let name: String?
    /// <p> Specifies the path of the file(s) to upload. Standard Unix glob matching rules are
    ///          accepted, with the addition of <code>**</code> as a <i>super asterisk</i>.
    ///          For example, specifying <code>/var/log/**.log</code> causes all .log files in the
    ///             <code>/var/log</code> directory tree to be collected. For more examples, see <a href="https://github.com/gobwas/glob">Glob Library</a>. </p>
    public let path: String?
    /// <p>Specifies when to upload the files:</p>
    ///          <dl>
    ///             <dt>UPLOAD_ON_TERMINATE</dt>
    ///             <dd>
    ///                <p>Matching files are uploaded once the simulation enters the
    ///                      <code>TERMINATING</code> state. Matching files are not uploaded until all of
    ///                   your code (including tools) have stopped. </p>
    ///                <p>If there is a problem uploading a file, the upload is retried. If problems
    ///                   persist, no further upload attempts will be made.</p>
    ///             </dd>
    ///             <dt>UPLOAD_ROLLING_AUTO_REMOVE</dt>
    ///             <dd>
    ///                <p>Matching files are uploaded as they are created. They are deleted after they
    ///                   are uploaded. The specified path is checked every 5 seconds. A final check is made
    ///                   when all of your code (including tools) have stopped. </p>
    ///             </dd>
    ///          </dl>
    public let uploadBehavior: UploadBehavior?

    public init (
        name: String? = nil,
        path: String? = nil,
        uploadBehavior: UploadBehavior? = nil
    )
    {
        self.name = name
        self.path = path
        self.uploadBehavior = uploadBehavior
    }
}

extension VPCConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignPublicIp
        case securityGroups
        case subnets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if assignPublicIp != false {
            try encodeContainer.encode(assignPublicIp, forKey: .assignPublicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroups0 in securityGroups {
                try securityGroupsContainer.encode(securitygroups0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnets0 in subnets {
                try subnetsContainer.encode(subnets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnets)
        var subnetsDecoded0:[String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let assignPublicIpDecoded = try containerValues.decode(Bool.self, forKey: .assignPublicIp)
        assignPublicIp = assignPublicIpDecoded
    }
}

extension VPCConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VPCConfig(assignPublicIp: \(String(describing: assignPublicIp)), securityGroups: \(String(describing: securityGroups)), subnets: \(String(describing: subnets)))"}
}

/// <p>If your simulation job accesses resources in a VPC, you provide this parameter
///          identifying the list of security group IDs and subnet IDs. These must belong to the same
///          VPC. You must provide at least one security group and two subnet IDs.</p>
public struct VPCConfig: Equatable {
    /// <p>A boolean indicating whether to assign a public IP address.</p>
    public let assignPublicIp: Bool
    /// <p>A list of one or more security groups IDs in your VPC.</p>
    public let securityGroups: [String]?
    /// <p>A list of one or more subnet IDs in your VPC.</p>
    public let subnets: [String]?

    public init (
        assignPublicIp: Bool = false,
        securityGroups: [String]? = nil,
        subnets: [String]? = nil
    )
    {
        self.assignPublicIp = assignPublicIp
        self.securityGroups = securityGroups
        self.subnets = subnets
    }
}

extension VPCConfigResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignPublicIp
        case securityGroups
        case subnets
        case vpcId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if assignPublicIp != false {
            try encodeContainer.encode(assignPublicIp, forKey: .assignPublicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroups0 in securityGroups {
                try securityGroupsContainer.encode(securitygroups0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnets0 in subnets {
                try subnetsContainer.encode(subnets0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnets)
        var subnetsDecoded0:[String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let assignPublicIpDecoded = try containerValues.decode(Bool.self, forKey: .assignPublicIp)
        assignPublicIp = assignPublicIpDecoded
    }
}

extension VPCConfigResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VPCConfigResponse(assignPublicIp: \(String(describing: assignPublicIp)), securityGroups: \(String(describing: securityGroups)), subnets: \(String(describing: subnets)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>VPC configuration associated with your simulation job.</p>
public struct VPCConfigResponse: Equatable {
    /// <p>A boolean indicating if a public IP was assigned.</p>
    public let assignPublicIp: Bool
    /// <p>A list of security group IDs associated with the simulation job.</p>
    public let securityGroups: [String]?
    /// <p>A list of subnet IDs associated with the simulation job.</p>
    public let subnets: [String]?
    /// <p>The VPC ID associated with your simulation job.</p>
    public let vpcId: String?

    public init (
        assignPublicIp: Bool = false,
        securityGroups: [String]? = nil,
        subnets: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.assignPublicIp = assignPublicIp
        self.securityGroups = securityGroups
        self.subnets = subnets
        self.vpcId = vpcId
    }
}

extension WorldConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case world
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let world = world {
            try encodeContainer.encode(world, forKey: .world)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .world)
        world = worldDecoded
    }
}

extension WorldConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorldConfig(world: \(String(describing: world)))"}
}

/// <p>Configuration information for a world.</p>
public struct WorldConfig: Equatable {
    /// <p>The world generated by Simulation WorldForge.</p>
    public let world: String?

    public init (
        world: String? = nil
    )
    {
        self.world = world
    }
}

extension WorldCount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case floorplanCount
        case interiorCountPerFloorplan
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let floorplanCount = floorplanCount {
            try encodeContainer.encode(floorplanCount, forKey: .floorplanCount)
        }
        if let interiorCountPerFloorplan = interiorCountPerFloorplan {
            try encodeContainer.encode(interiorCountPerFloorplan, forKey: .interiorCountPerFloorplan)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let floorplanCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .floorplanCount)
        floorplanCount = floorplanCountDecoded
        let interiorCountPerFloorplanDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .interiorCountPerFloorplan)
        interiorCountPerFloorplan = interiorCountPerFloorplanDecoded
    }
}

extension WorldCount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorldCount(floorplanCount: \(String(describing: floorplanCount)), interiorCountPerFloorplan: \(String(describing: interiorCountPerFloorplan)))"}
}

/// <p>The number of worlds that will be created. You can configure the number of unique
///          floorplans and the number of unique interiors for each floor plan. For example, if you want
///          1 world with 20 unique interiors, you set <code>floorplanCount = 1</code> and
///             <code>interiorCountPerFloorplan = 20</code>. This will result in 20 worlds
///             (<code>floorplanCount</code> * <code>interiorCountPerFloorplan)</code>. </p>
///          <p>If you set <code>floorplanCount = 4</code> and <code>interiorCountPerFloorplan =
///             5</code>, there will be 20 worlds with 5 unique floor plans. </p>
public struct WorldCount: Equatable {
    /// <p>The number of unique floorplans.</p>
    public let floorplanCount: Int?
    /// <p>The number of unique interiors per floorplan.</p>
    public let interiorCountPerFloorplan: Int?

    public init (
        floorplanCount: Int? = nil,
        interiorCountPerFloorplan: Int? = nil
    )
    {
        self.floorplanCount = floorplanCount
        self.interiorCountPerFloorplan = interiorCountPerFloorplan
    }
}

public enum WorldExportJobErrorCode {
    case accessdenied
    case internalserviceerror
    case invalidinput
    case limitexceeded
    case requestthrottled
    case resourcenotfound
    case sdkUnknown(String)
}

extension WorldExportJobErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorldExportJobErrorCode] {
        return [
            .accessdenied,
            .internalserviceerror,
            .invalidinput,
            .limitexceeded,
            .requestthrottled,
            .resourcenotfound,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessdenied: return "AccessDenied"
        case .internalserviceerror: return "InternalServiceError"
        case .invalidinput: return "InvalidInput"
        case .limitexceeded: return "LimitExceeded"
        case .requestthrottled: return "RequestThrottled"
        case .resourcenotfound: return "ResourceNotFound"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorldExportJobErrorCode(rawValue: rawValue) ?? WorldExportJobErrorCode.sdkUnknown(rawValue)
    }
}

public enum WorldExportJobStatus {
    case canceled
    case canceling
    case completed
    case failed
    case pending
    case running
    case sdkUnknown(String)
}

extension WorldExportJobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorldExportJobStatus] {
        return [
            .canceled,
            .canceling,
            .completed,
            .failed,
            .pending,
            .running,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "Canceled"
        case .canceling: return "Canceling"
        case .completed: return "Completed"
        case .failed: return "Failed"
        case .pending: return "Pending"
        case .running: return "Running"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorldExportJobStatus(rawValue: rawValue) ?? WorldExportJobStatus.sdkUnknown(rawValue)
    }
}

extension WorldExportJobSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case status
        case worlds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let worlds = worlds {
            var worldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worlds)
            for arns0 in worlds {
                try worldsContainer.encode(arns0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorldExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let worldsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .worlds)
        var worldsDecoded0:[String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
    }
}

extension WorldExportJobSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorldExportJobSummary(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), status: \(String(describing: status)), worlds: \(String(describing: worlds)))"}
}

/// <p>Information about a world export job.</p>
public struct WorldExportJobSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the world export job.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the world export job was created.</p>
    public let createdAt: Date?
    /// <p>The status of the world export job.</p>
    ///          <dl>
    ///             <dt>Pending</dt>
    ///             <dd>
    ///                <p>The world export job request is pending.</p>
    ///             </dd>
    ///             <dt>Running</dt>
    ///             <dd>
    ///                <p>The world export job is running. </p>
    ///             </dd>
    ///             <dt>Completed</dt>
    ///             <dd>
    ///                <p>The world export job completed. </p>
    ///             </dd>
    ///             <dt>Failed</dt>
    ///             <dd>
    ///                <p>The world export job failed. See <code>failureCode</code> for more information.
    ///                </p>
    ///             </dd>
    ///             <dt>Canceled</dt>
    ///             <dd>
    ///                <p>The world export job was cancelled.</p>
    ///             </dd>
    ///             <dt>Canceling</dt>
    ///             <dd>
    ///                <p>The world export job is being cancelled.</p>
    ///             </dd>
    ///          </dl>
    public let status: WorldExportJobStatus?
    /// <p>A list of worlds.</p>
    public let worlds: [String]?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        status: WorldExportJobStatus? = nil,
        worlds: [String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.status = status
        self.worlds = worlds
    }
}

extension WorldFailure: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureCode
        case failureCount
        case sampleFailureReason
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if failureCount != 0 {
            try encodeContainer.encode(failureCount, forKey: .failureCount)
        }
        if let sampleFailureReason = sampleFailureReason {
            try encodeContainer.encode(sampleFailureReason, forKey: .sampleFailureReason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureCodeDecoded = try containerValues.decodeIfPresent(WorldGenerationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let sampleFailureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sampleFailureReason)
        sampleFailureReason = sampleFailureReasonDecoded
        let failureCountDecoded = try containerValues.decode(Int.self, forKey: .failureCount)
        failureCount = failureCountDecoded
    }
}

extension WorldFailure: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorldFailure(failureCode: \(String(describing: failureCode)), failureCount: \(String(describing: failureCount)), sampleFailureReason: \(String(describing: sampleFailureReason)))"}
}

/// <p>Information about a failed world.</p>
public struct WorldFailure: Equatable {
    /// <p>The failure code of the world export job if it failed:</p>
    ///          <dl>
    ///             <dt>InternalServiceError</dt>
    ///             <dd>
    ///                <p>Internal service error.</p>
    ///             </dd>
    ///             <dt>LimitExceeded</dt>
    ///             <dd>
    ///                <p>The requested resource exceeds the maximum number allowed, or the number of
    ///                   concurrent stream requests exceeds the maximum number allowed. </p>
    ///             </dd>
    ///             <dt>ResourceNotFound</dt>
    ///             <dd>
    ///                <p>The specified resource could not be found. </p>
    ///             </dd>
    ///             <dt>RequestThrottled</dt>
    ///             <dd>
    ///                <p>The request was throttled.</p>
    ///             </dd>
    ///             <dt>InvalidInput</dt>
    ///             <dd>
    ///                <p>An input parameter in the request is not valid.</p>
    ///             </dd>
    ///          </dl>
    public let failureCode: WorldGenerationJobErrorCode?
    /// <p>The number of failed worlds.</p>
    public let failureCount: Int
    /// <p>The sample reason why the world failed. World errors are aggregated. A sample is used as
    ///          the <code>sampleFailureReason</code>. </p>
    public let sampleFailureReason: String?

    public init (
        failureCode: WorldGenerationJobErrorCode? = nil,
        failureCount: Int = 0,
        sampleFailureReason: String? = nil
    )
    {
        self.failureCode = failureCode
        self.failureCount = failureCount
        self.sampleFailureReason = sampleFailureReason
    }
}

public enum WorldGenerationJobErrorCode {
    case allworldgenerationfailed
    case internalserviceerror
    case invalidinput
    case limitexceeded
    case requestthrottled
    case resourcenotfound
    case sdkUnknown(String)
}

extension WorldGenerationJobErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorldGenerationJobErrorCode] {
        return [
            .allworldgenerationfailed,
            .internalserviceerror,
            .invalidinput,
            .limitexceeded,
            .requestthrottled,
            .resourcenotfound,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allworldgenerationfailed: return "AllWorldGenerationFailed"
        case .internalserviceerror: return "InternalServiceError"
        case .invalidinput: return "InvalidInput"
        case .limitexceeded: return "LimitExceeded"
        case .requestthrottled: return "RequestThrottled"
        case .resourcenotfound: return "ResourceNotFound"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorldGenerationJobErrorCode(rawValue: rawValue) ?? WorldGenerationJobErrorCode.sdkUnknown(rawValue)
    }
}

public enum WorldGenerationJobStatus {
    case canceled
    case canceling
    case completed
    case failed
    case partialfailed
    case pending
    case running
    case sdkUnknown(String)
}

extension WorldGenerationJobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorldGenerationJobStatus] {
        return [
            .canceled,
            .canceling,
            .completed,
            .failed,
            .partialfailed,
            .pending,
            .running,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "Canceled"
        case .canceling: return "Canceling"
        case .completed: return "Completed"
        case .failed: return "Failed"
        case .partialfailed: return "PartialFailed"
        case .pending: return "Pending"
        case .running: return "Running"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorldGenerationJobStatus(rawValue: rawValue) ?? WorldGenerationJobStatus.sdkUnknown(rawValue)
    }
}

extension WorldGenerationJobSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case failedWorldCount
        case status
        case succeededWorldCount
        case template
        case worldCount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if failedWorldCount != 0 {
            try encodeContainer.encode(failedWorldCount, forKey: .failedWorldCount)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if succeededWorldCount != 0 {
            try encodeContainer.encode(succeededWorldCount, forKey: .succeededWorldCount)
        }
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
        if let worldCount = worldCount {
            try encodeContainer.encode(worldCount, forKey: .worldCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let templateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .template)
        template = templateDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorldGenerationJobStatus.self, forKey: .status)
        status = statusDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let succeededWorldCountDecoded = try containerValues.decode(Int.self, forKey: .succeededWorldCount)
        succeededWorldCount = succeededWorldCountDecoded
        let failedWorldCountDecoded = try containerValues.decode(Int.self, forKey: .failedWorldCount)
        failedWorldCount = failedWorldCountDecoded
    }
}

extension WorldGenerationJobSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorldGenerationJobSummary(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), failedWorldCount: \(String(describing: failedWorldCount)), status: \(String(describing: status)), succeededWorldCount: \(String(describing: succeededWorldCount)), template: \(String(describing: template)), worldCount: \(String(describing: worldCount)))"}
}

/// <p>Information about a world generator job.</p>
public struct WorldGenerationJobSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the world generator job.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the world generator job was
    ///          created.</p>
    public let createdAt: Date?
    /// <p>The number of worlds that failed.</p>
    public let failedWorldCount: Int
    /// <p>The status of the world generator job:</p>
    ///          <dl>
    ///             <dt>Pending</dt>
    ///             <dd>
    ///                <p>The world generator job request is pending.</p>
    ///             </dd>
    ///             <dt>Running</dt>
    ///             <dd>
    ///                <p>The world generator job is running. </p>
    ///             </dd>
    ///             <dt>Completed</dt>
    ///             <dd>
    ///                <p>The world generator job completed. </p>
    ///             </dd>
    ///             <dt>Failed</dt>
    ///             <dd>
    ///                <p>The world generator job failed. See <code>failureCode</code> for more
    ///                   information. </p>
    ///             </dd>
    ///             <dt>PartialFailed</dt>
    ///             <dd>
    ///                <p>Some worlds did not generate.</p>
    ///             </dd>
    ///             <dt>Canceled</dt>
    ///             <dd>
    ///                <p>The world generator job was cancelled.</p>
    ///             </dd>
    ///             <dt>Canceling</dt>
    ///             <dd>
    ///                <p>The world generator job is being cancelled.</p>
    ///             </dd>
    ///          </dl>
    public let status: WorldGenerationJobStatus?
    /// <p>The number of worlds that were generated.</p>
    public let succeededWorldCount: Int
    /// <p>The Amazon Resource Name (arn) of the world template.</p>
    public let template: String?
    /// <p>Information about the world count.</p>
    public let worldCount: WorldCount?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        failedWorldCount: Int = 0,
        status: WorldGenerationJobStatus? = nil,
        succeededWorldCount: Int = 0,
        template: String? = nil,
        worldCount: WorldCount? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.failedWorldCount = failedWorldCount
        self.status = status
        self.succeededWorldCount = succeededWorldCount
        self.template = template
        self.worldCount = worldCount
    }
}

extension WorldSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case generationJob
        case template
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let generationJob = generationJob {
            try encodeContainer.encode(generationJob, forKey: .generationJob)
        }
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let generationJobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .generationJob)
        generationJob = generationJobDecoded
        let templateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .template)
        template = templateDecoded
    }
}

extension WorldSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorldSummary(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), generationJob: \(String(describing: generationJob)), template: \(String(describing: template)))"}
}

/// <p>Information about a world.</p>
public struct WorldSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the world.</p>
    public let arn: String?
    /// <p>The time, in milliseconds since the epoch, when the world was created.</p>
    public let createdAt: Date?
    /// <p>The Amazon Resource Name (arn) of the world generation job.</p>
    public let generationJob: String?
    /// <p>The Amazon Resource Name (arn) of the world template.</p>
    public let template: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        generationJob: String? = nil,
        template: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.generationJob = generationJob
        self.template = template
    }
}
