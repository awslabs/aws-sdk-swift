// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation
import Logging

public class WellArchitectedClient {
    let client: SdkHttpClient
    let config: WellArchitectedClientConfiguration
    let serviceName = "WellArchitected"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: WellArchitectedClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    deinit {
        client.close()
    }

    public class WellArchitectedClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public let clientLogMode: ClientLogMode
        public let logger: LogAgent

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String,
            clientLogMode: ClientLogMode = .request,
            logger: LogAgent? = nil
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
            self.clientLogMode = clientLogMode
            self.logger = logger ?? SwiftLogger(label: "WellArchitectedClient")
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> WellArchitectedClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try WellArchitectedClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

public struct WellArchitectedClientLogHandlerFactory: SDKLogHandlerFactory {
    public var label = "WellArchitectedClient"
    let logLevel: SDKLogLevel
    public func construct(label: String) -> LogHandler {
        var handler = StreamLogHandler.standardOutput(label: label)
        handler.logLevel = logLevel.toLoggerType()
        return handler
    }
    public init(logLevel: SDKLogLevel) {
        self.logLevel = logLevel
    }
}

extension WellArchitectedClient: WellArchitectedClientProtocol {
    /// <p>Associate a lens to a workload.</p>
    public func associateLenses(input: AssociateLensesInput, completion: @escaping (SdkResult<AssociateLensesOutputResponse, AssociateLensesOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/associateLenses"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateLenses")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateLensesInput, AssociateLensesOutputResponse, AssociateLensesOutputError>(id: "associateLenses")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateLensesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateLensesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateLensesInput, AssociateLensesOutputResponse, AssociateLensesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateLensesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create a milestone for an existing workload.</p>
    public func createMilestone(input: CreateMilestoneInput, completion: @escaping (SdkResult<CreateMilestoneOutputResponse, CreateMilestoneOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/milestones"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createMilestone")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateMilestoneInput, CreateMilestoneOutputResponse, CreateMilestoneOutputError>(id: "createMilestone")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateMilestoneOutputResponse>, SdkError<CreateMilestoneOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateMilestoneInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateMilestoneInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateMilestoneInput, CreateMilestoneOutputResponse, CreateMilestoneOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateMilestoneInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create a new workload.</p>
    ///         <p>The owner of a workload can share the workload with other AWS accounts and IAM users
    ///             in the same AWS Region. Only the owner of a workload can delete it.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/wellarchitected/latest/userguide/define-workload.html">Defining a Workload</a> in the
    ///                 <i>AWS Well-Architected Tool User Guide</i>.</p>
    public func createWorkload(input: CreateWorkloadInput, completion: @escaping (SdkResult<CreateWorkloadOutputResponse, CreateWorkloadOutputError>) -> Void)
    {
        let urlPath = "/workloads"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createWorkload")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateWorkloadInput, CreateWorkloadOutputResponse, CreateWorkloadOutputError>(id: "createWorkload")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateWorkloadOutputResponse>, SdkError<CreateWorkloadOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateWorkloadInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateWorkloadInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateWorkloadInput, CreateWorkloadOutputResponse, CreateWorkloadOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateWorkloadInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create a workload share.</p>
    ///         <p>The owner of a workload can share it with other AWS accounts and IAM users in the same
    ///             AWS Region. Shared access to a workload is not removed until the workload invitation is
    ///             deleted.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/wellarchitected/latest/userguide/workloads-sharing.html">Sharing a Workload</a> in the
    ///                 <i>AWS Well-Architected Tool User Guide</i>.</p>
    public func createWorkloadShare(input: CreateWorkloadShareInput, completion: @escaping (SdkResult<CreateWorkloadShareOutputResponse, CreateWorkloadShareOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/shares"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createWorkloadShare")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateWorkloadShareInput, CreateWorkloadShareOutputResponse, CreateWorkloadShareOutputError>(id: "createWorkloadShare")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateWorkloadShareOutputResponse>, SdkError<CreateWorkloadShareOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateWorkloadShareInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateWorkloadShareInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateWorkloadShareInput, CreateWorkloadShareOutputResponse, CreateWorkloadShareOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateWorkloadShareInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Delete an existing workload.</p>
    public func deleteWorkload(input: DeleteWorkloadInput, completion: @escaping (SdkResult<DeleteWorkloadOutputResponse, DeleteWorkloadOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteWorkload")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteWorkloadInput, DeleteWorkloadOutputResponse, DeleteWorkloadOutputError>(id: "deleteWorkload")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<DeleteWorkloadOutputResponse>, SdkError<DeleteWorkloadOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: DeleteWorkloadInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteWorkloadInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteWorkloadInput, DeleteWorkloadOutputResponse, DeleteWorkloadOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Delete a workload share.</p>
    public func deleteWorkloadShare(input: DeleteWorkloadShareInput, completion: @escaping (SdkResult<DeleteWorkloadShareOutputResponse, DeleteWorkloadShareOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        guard let shareId = input.shareId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component shareId unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/shares/\(shareId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteWorkloadShare")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteWorkloadShareInput, DeleteWorkloadShareOutputResponse, DeleteWorkloadShareOutputError>(id: "deleteWorkloadShare")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<DeleteWorkloadShareOutputResponse>, SdkError<DeleteWorkloadShareOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: DeleteWorkloadShareInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteWorkloadShareInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteWorkloadShareInput, DeleteWorkloadShareOutputResponse, DeleteWorkloadShareOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Disassociate a lens from a workload.</p>
    ///         <note>
    ///             <p>The AWS Well-Architected Framework lens (<code>wellarchitected</code>) cannot be
    ///                 removed from a workload.</p>
    ///         </note>
    public func disassociateLenses(input: DisassociateLensesInput, completion: @escaping (SdkResult<DisassociateLensesOutputResponse, DisassociateLensesOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/disassociateLenses"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateLenses")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateLensesInput, DisassociateLensesOutputResponse, DisassociateLensesOutputError>(id: "disassociateLenses")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateLensesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateLensesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateLensesInput, DisassociateLensesOutputResponse, DisassociateLensesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DisassociateLensesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get lens review.</p>
    public func getAnswer(input: GetAnswerInput, completion: @escaping (SdkResult<GetAnswerOutputResponse, GetAnswerOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        guard let lensAlias = input.lensAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component lensAlias unexpectedly nil"))))
            return
        }
        guard let questionId = input.questionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component questionId unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/lensReviews/\(lensAlias)/answers/\(questionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAnswer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAnswerInput, GetAnswerOutputResponse, GetAnswerOutputError>(id: "getAnswer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAnswerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAnswerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetAnswerInput, GetAnswerOutputResponse, GetAnswerOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get lens review.</p>
    public func getLensReview(input: GetLensReviewInput, completion: @escaping (SdkResult<GetLensReviewOutputResponse, GetLensReviewOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        guard let lensAlias = input.lensAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component lensAlias unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/lensReviews/\(lensAlias)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getLensReview")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetLensReviewInput, GetLensReviewOutputResponse, GetLensReviewOutputError>(id: "getLensReview")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetLensReviewInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetLensReviewInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetLensReviewInput, GetLensReviewOutputResponse, GetLensReviewOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get lens review report.</p>
    public func getLensReviewReport(input: GetLensReviewReportInput, completion: @escaping (SdkResult<GetLensReviewReportOutputResponse, GetLensReviewReportOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        guard let lensAlias = input.lensAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component lensAlias unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/lensReviews/\(lensAlias)/report"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getLensReviewReport")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetLensReviewReportInput, GetLensReviewReportOutputResponse, GetLensReviewReportOutputError>(id: "getLensReviewReport")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetLensReviewReportInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetLensReviewReportInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetLensReviewReportInput, GetLensReviewReportOutputResponse, GetLensReviewReportOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get lens version differences.</p>
    public func getLensVersionDifference(input: GetLensVersionDifferenceInput, completion: @escaping (SdkResult<GetLensVersionDifferenceOutputResponse, GetLensVersionDifferenceOutputError>) -> Void)
    {
        guard let lensAlias = input.lensAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component lensAlias unexpectedly nil"))))
            return
        }
        let urlPath = "/lenses/\(lensAlias)/versionDifference"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getLensVersionDifference")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetLensVersionDifferenceInput, GetLensVersionDifferenceOutputResponse, GetLensVersionDifferenceOutputError>(id: "getLensVersionDifference")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetLensVersionDifferenceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetLensVersionDifferenceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetLensVersionDifferenceInput, GetLensVersionDifferenceOutputResponse, GetLensVersionDifferenceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get a milestone for an existing workload.</p>
    public func getMilestone(input: GetMilestoneInput, completion: @escaping (SdkResult<GetMilestoneOutputResponse, GetMilestoneOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        let milestoneNumber = input.milestoneNumber
        let urlPath = "/workloads/\(workloadId)/milestones/\(milestoneNumber)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getMilestone")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetMilestoneInput, GetMilestoneOutputResponse, GetMilestoneOutputError>(id: "getMilestone")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetMilestoneInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetMilestoneInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetMilestoneInput, GetMilestoneOutputResponse, GetMilestoneOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get an existing workload.</p>
    public func getWorkload(input: GetWorkloadInput, completion: @escaping (SdkResult<GetWorkloadOutputResponse, GetWorkloadOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getWorkload")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetWorkloadInput, GetWorkloadOutputResponse, GetWorkloadOutputError>(id: "getWorkload")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetWorkloadInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetWorkloadInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetWorkloadInput, GetWorkloadOutputResponse, GetWorkloadOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List of answers.</p>
    public func listAnswers(input: ListAnswersInput, completion: @escaping (SdkResult<ListAnswersOutputResponse, ListAnswersOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        guard let lensAlias = input.lensAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component lensAlias unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/lensReviews/\(lensAlias)/answers"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAnswers")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAnswersInput, ListAnswersOutputResponse, ListAnswersOutputError>(id: "listAnswers")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAnswersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAnswersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAnswersInput, ListAnswersOutputResponse, ListAnswersOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List lens review improvements.</p>
    public func listLensReviewImprovements(input: ListLensReviewImprovementsInput, completion: @escaping (SdkResult<ListLensReviewImprovementsOutputResponse, ListLensReviewImprovementsOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        guard let lensAlias = input.lensAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component lensAlias unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/lensReviews/\(lensAlias)/improvements"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listLensReviewImprovements")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListLensReviewImprovementsInput, ListLensReviewImprovementsOutputResponse, ListLensReviewImprovementsOutputError>(id: "listLensReviewImprovements")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListLensReviewImprovementsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListLensReviewImprovementsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListLensReviewImprovementsInput, ListLensReviewImprovementsOutputResponse, ListLensReviewImprovementsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List lens reviews.</p>
    public func listLensReviews(input: ListLensReviewsInput, completion: @escaping (SdkResult<ListLensReviewsOutputResponse, ListLensReviewsOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/lensReviews"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listLensReviews")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListLensReviewsInput, ListLensReviewsOutputResponse, ListLensReviewsOutputError>(id: "listLensReviews")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListLensReviewsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListLensReviewsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListLensReviewsInput, ListLensReviewsOutputResponse, ListLensReviewsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the available lenses.</p>
    public func listLenses(input: ListLensesInput, completion: @escaping (SdkResult<ListLensesOutputResponse, ListLensesOutputError>) -> Void)
    {
        let urlPath = "/lenses"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listLenses")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListLensesInput, ListLensesOutputResponse, ListLensesOutputError>(id: "listLenses")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListLensesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListLensesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListLensesInput, ListLensesOutputResponse, ListLensesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List all milestones for an existing workload.</p>
    public func listMilestones(input: ListMilestonesInput, completion: @escaping (SdkResult<ListMilestonesOutputResponse, ListMilestonesOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/milestonesSummaries"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listMilestones")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListMilestonesInput, ListMilestonesOutputResponse, ListMilestonesOutputError>(id: "listMilestones")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListMilestonesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListMilestonesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListMilestonesInput, ListMilestonesOutputResponse, ListMilestonesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListMilestonesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List lens notifications.</p>
    public func listNotifications(input: ListNotificationsInput, completion: @escaping (SdkResult<ListNotificationsOutputResponse, ListNotificationsOutputError>) -> Void)
    {
        let urlPath = "/notifications"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listNotifications")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListNotificationsInput, ListNotificationsOutputResponse, ListNotificationsOutputError>(id: "listNotifications")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListNotificationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListNotificationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListNotificationsInput, ListNotificationsOutputResponse, ListNotificationsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListNotificationsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List  the workload invitations.</p>
    public func listShareInvitations(input: ListShareInvitationsInput, completion: @escaping (SdkResult<ListShareInvitationsOutputResponse, ListShareInvitationsOutputError>) -> Void)
    {
        let urlPath = "/shareInvitations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listShareInvitations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListShareInvitationsInput, ListShareInvitationsOutputResponse, ListShareInvitationsOutputError>(id: "listShareInvitations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListShareInvitationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListShareInvitationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListShareInvitationsInput, ListShareInvitationsOutputResponse, ListShareInvitationsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the tags for a resource.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        guard let workloadArn = input.workloadArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(workloadArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the workload shares associated with the workload.</p>
    public func listWorkloadShares(input: ListWorkloadSharesInput, completion: @escaping (SdkResult<ListWorkloadSharesOutputResponse, ListWorkloadSharesOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/shares"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listWorkloadShares")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListWorkloadSharesInput, ListWorkloadSharesOutputResponse, ListWorkloadSharesOutputError>(id: "listWorkloadShares")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListWorkloadSharesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListWorkloadSharesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListWorkloadSharesInput, ListWorkloadSharesOutputResponse, ListWorkloadSharesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List workloads. Paginated.</p>
    public func listWorkloads(input: ListWorkloadsInput, completion: @escaping (SdkResult<ListWorkloadsOutputResponse, ListWorkloadsOutputError>) -> Void)
    {
        let urlPath = "/workloadsSummaries"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listWorkloads")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListWorkloadsInput, ListWorkloadsOutputResponse, ListWorkloadsOutputError>(id: "listWorkloads")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListWorkloadsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListWorkloadsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListWorkloadsInput, ListWorkloadsOutputResponse, ListWorkloadsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListWorkloadsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds one or more tags to the specified resource.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        guard let workloadArn = input.workloadArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(workloadArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes specified tags from a resource.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        guard let workloadArn = input.workloadArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(workloadArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Update the answer to a specific question in a workload review.</p>
    public func updateAnswer(input: UpdateAnswerInput, completion: @escaping (SdkResult<UpdateAnswerOutputResponse, UpdateAnswerOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        guard let lensAlias = input.lensAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component lensAlias unexpectedly nil"))))
            return
        }
        guard let questionId = input.questionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component questionId unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/lensReviews/\(lensAlias)/answers/\(questionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateAnswer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateAnswerInput, UpdateAnswerOutputResponse, UpdateAnswerOutputError>(id: "updateAnswer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateAnswerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateAnswerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateAnswerInput, UpdateAnswerOutputResponse, UpdateAnswerOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateAnswerInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Update lens review.</p>
    public func updateLensReview(input: UpdateLensReviewInput, completion: @escaping (SdkResult<UpdateLensReviewOutputResponse, UpdateLensReviewOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        guard let lensAlias = input.lensAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component lensAlias unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/lensReviews/\(lensAlias)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateLensReview")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateLensReviewInput, UpdateLensReviewOutputResponse, UpdateLensReviewOutputError>(id: "updateLensReview")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateLensReviewInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateLensReviewInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateLensReviewInput, UpdateLensReviewOutputResponse, UpdateLensReviewOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateLensReviewInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Update a workload invitation.</p>
    public func updateShareInvitation(input: UpdateShareInvitationInput, completion: @escaping (SdkResult<UpdateShareInvitationOutputResponse, UpdateShareInvitationOutputError>) -> Void)
    {
        guard let shareInvitationId = input.shareInvitationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component shareInvitationId unexpectedly nil"))))
            return
        }
        let urlPath = "/shareInvitations/\(shareInvitationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateShareInvitation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateShareInvitationInput, UpdateShareInvitationOutputResponse, UpdateShareInvitationOutputError>(id: "updateShareInvitation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateShareInvitationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateShareInvitationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateShareInvitationInput, UpdateShareInvitationOutputResponse, UpdateShareInvitationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateShareInvitationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Update an existing workload.</p>
    public func updateWorkload(input: UpdateWorkloadInput, completion: @escaping (SdkResult<UpdateWorkloadOutputResponse, UpdateWorkloadOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateWorkload")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateWorkloadInput, UpdateWorkloadOutputResponse, UpdateWorkloadOutputError>(id: "updateWorkload")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateWorkloadInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateWorkloadInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateWorkloadInput, UpdateWorkloadOutputResponse, UpdateWorkloadOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateWorkloadInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Update a workload share.</p>
    public func updateWorkloadShare(input: UpdateWorkloadShareInput, completion: @escaping (SdkResult<UpdateWorkloadShareOutputResponse, UpdateWorkloadShareOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        guard let shareId = input.shareId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component shareId unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/shares/\(shareId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateWorkloadShare")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateWorkloadShareInput, UpdateWorkloadShareOutputResponse, UpdateWorkloadShareOutputError>(id: "updateWorkloadShare")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateWorkloadShareInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateWorkloadShareInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateWorkloadShareInput, UpdateWorkloadShareOutputResponse, UpdateWorkloadShareOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateWorkloadShareInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Upgrade lens review.</p>
    public func upgradeLensReview(input: UpgradeLensReviewInput, completion: @escaping (SdkResult<UpgradeLensReviewOutputResponse, UpgradeLensReviewOutputError>) -> Void)
    {
        guard let workloadId = input.workloadId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component workloadId unexpectedly nil"))))
            return
        }
        guard let lensAlias = input.lensAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component lensAlias unexpectedly nil"))))
            return
        }
        let urlPath = "/workloads/\(workloadId)/lensReviews/\(lensAlias)/upgrade"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "upgradeLensReview")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "wellarchitected.\(config.region).amazonaws.com")
                      .withSigningName(value: "wellarchitected")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpgradeLensReviewInput, UpgradeLensReviewOutputResponse, UpgradeLensReviewOutputError>(id: "upgradeLensReview")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpgradeLensReviewInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpgradeLensReviewInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpgradeLensReviewInput, UpgradeLensReviewOutputResponse, UpgradeLensReviewOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpgradeLensReviewInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
