// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>User does not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Description of the error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Answer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case choices = "Choices"
        case helpfulResourceUrl = "HelpfulResourceUrl"
        case improvementPlanUrl = "ImprovementPlanUrl"
        case isApplicable = "IsApplicable"
        case notes = "Notes"
        case pillarId = "PillarId"
        case questionDescription = "QuestionDescription"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case risk = "Risk"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choices = choices {
            var choicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choices)
            for choices0 in choices {
                try choicesContainer.encode(choices0)
            }
        }
        if let helpfulResourceUrl = helpfulResourceUrl {
            try encodeContainer.encode(helpfulResourceUrl, forKey: .helpfulResourceUrl)
        }
        if let improvementPlanUrl = improvementPlanUrl {
            try encodeContainer.encode(improvementPlanUrl, forKey: .improvementPlanUrl)
        }
        if isApplicable != false {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarId = pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionDescription = questionDescription {
            try encodeContainer.encode(questionDescription, forKey: .questionDescription)
        }
        if let questionId = questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let risk = risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for selectedchoices0 in selectedChoices {
                try selectedChoicesContainer.encode(selectedchoices0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let questionDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .questionDescription)
        questionDescription = questionDescriptionDecoded
        let improvementPlanUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .improvementPlanUrl)
        improvementPlanUrl = improvementPlanUrlDecoded
        let helpfulResourceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .helpfulResourceUrl)
        helpfulResourceUrl = helpfulResourceUrlDecoded
        let choicesContainer = try containerValues.decodeIfPresent([Choice?].self, forKey: .choices)
        var choicesDecoded0:[Choice]? = nil
        if let choicesContainer = choicesContainer {
            choicesDecoded0 = [Choice]()
            for structure0 in choicesContainer {
                if let structure0 = structure0 {
                    choicesDecoded0?.append(structure0)
                }
            }
        }
        choices = choicesDecoded0
        let selectedChoicesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let isApplicableDecoded = try containerValues.decode(Bool.self, forKey: .isApplicable)
        isApplicable = isApplicableDecoded
        let riskDecoded = try containerValues.decodeIfPresent(Risk.self, forKey: .risk)
        risk = riskDecoded
        let notesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notes)
        notes = notesDecoded
    }
}

extension Answer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Answer(choices: \(String(describing: choices)), helpfulResourceUrl: \(String(describing: helpfulResourceUrl)), improvementPlanUrl: \(String(describing: improvementPlanUrl)), isApplicable: \(String(describing: isApplicable)), notes: \(String(describing: notes)), pillarId: \(String(describing: pillarId)), questionDescription: \(String(describing: questionDescription)), questionId: \(String(describing: questionId)), questionTitle: \(String(describing: questionTitle)), risk: \(String(describing: risk)), selectedChoices: \(String(describing: selectedChoices)))"}
}

/// <p>An answer of the question.</p>
public struct Answer: Equatable {
    /// <p>List of choices available for a question.</p>
    public let choices: [Choice]?
    /// <p>The helpful resource URL for a question.</p>
    public let helpfulResourceUrl: String?
    /// <p>The improvement plan URL for a question.</p>
    public let improvementPlanUrl: String?
    /// <p>Defines whether this question is applicable to a lens review.</p>
    public let isApplicable: Bool
    /// <p>The notes associated with the workload.</p>
    public let notes: String?
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    ///         <p>A pillar is identified by its <a>PillarReviewSummary$PillarId</a>.</p>
    public let pillarId: String?
    /// <p>The description of the question.</p>
    public let questionDescription: String?
    /// <p>The ID of the question.</p>
    public let questionId: String?
    /// <p>The title of the question.</p>
    public let questionTitle: String?
    /// <p>The risk for a given workload, lens review, pillar, or question.</p>
    public let risk: Risk?
    /// <p>List of selected choice IDs in a question answer.</p>
    ///         <p>The values entered replace the previously selected choices.</p>
    public let selectedChoices: [String]?

    public init (
        choices: [Choice]? = nil,
        helpfulResourceUrl: String? = nil,
        improvementPlanUrl: String? = nil,
        isApplicable: Bool = false,
        notes: String? = nil,
        pillarId: String? = nil,
        questionDescription: String? = nil,
        questionId: String? = nil,
        questionTitle: String? = nil,
        risk: Risk? = nil,
        selectedChoices: [String]? = nil
    )
    {
        self.choices = choices
        self.helpfulResourceUrl = helpfulResourceUrl
        self.improvementPlanUrl = improvementPlanUrl
        self.isApplicable = isApplicable
        self.notes = notes
        self.pillarId = pillarId
        self.questionDescription = questionDescription
        self.questionId = questionId
        self.questionTitle = questionTitle
        self.risk = risk
        self.selectedChoices = selectedChoices
    }
}

extension AnswerSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case choices = "Choices"
        case isApplicable = "IsApplicable"
        case pillarId = "PillarId"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case risk = "Risk"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choices = choices {
            var choicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choices)
            for choices0 in choices {
                try choicesContainer.encode(choices0)
            }
        }
        if isApplicable != false {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let pillarId = pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionId = questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let risk = risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for selectedchoices0 in selectedChoices {
                try selectedChoicesContainer.encode(selectedchoices0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let choicesContainer = try containerValues.decodeIfPresent([Choice?].self, forKey: .choices)
        var choicesDecoded0:[Choice]? = nil
        if let choicesContainer = choicesContainer {
            choicesDecoded0 = [Choice]()
            for structure0 in choicesContainer {
                if let structure0 = structure0 {
                    choicesDecoded0?.append(structure0)
                }
            }
        }
        choices = choicesDecoded0
        let selectedChoicesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let isApplicableDecoded = try containerValues.decode(Bool.self, forKey: .isApplicable)
        isApplicable = isApplicableDecoded
        let riskDecoded = try containerValues.decodeIfPresent(Risk.self, forKey: .risk)
        risk = riskDecoded
    }
}

extension AnswerSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnswerSummary(choices: \(String(describing: choices)), isApplicable: \(String(describing: isApplicable)), pillarId: \(String(describing: pillarId)), questionId: \(String(describing: questionId)), questionTitle: \(String(describing: questionTitle)), risk: \(String(describing: risk)), selectedChoices: \(String(describing: selectedChoices)))"}
}

/// <p>An answer summary of a lens review in a workload.</p>
public struct AnswerSummary: Equatable {
    /// <p>List of choices available for a question.</p>
    public let choices: [Choice]?
    /// <p>Defines whether this question is applicable to a lens review.</p>
    public let isApplicable: Bool
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    ///         <p>A pillar is identified by its <a>PillarReviewSummary$PillarId</a>.</p>
    public let pillarId: String?
    /// <p>The ID of the question.</p>
    public let questionId: String?
    /// <p>The title of the question.</p>
    public let questionTitle: String?
    /// <p>The risk for a given workload, lens review, pillar, or question.</p>
    public let risk: Risk?
    /// <p>List of selected choice IDs in a question answer.</p>
    ///         <p>The values entered replace the previously selected choices.</p>
    public let selectedChoices: [String]?

    public init (
        choices: [Choice]? = nil,
        isApplicable: Bool = false,
        pillarId: String? = nil,
        questionId: String? = nil,
        questionTitle: String? = nil,
        risk: Risk? = nil,
        selectedChoices: [String]? = nil
    )
    {
        self.choices = choices
        self.isApplicable = isApplicable
        self.pillarId = pillarId
        self.questionId = questionId
        self.questionTitle = questionTitle
        self.risk = risk
        self.selectedChoices = selectedChoices
    }
}

public struct AssociateLensesInputBodyMiddleware: Middleware {
    public let id: String = "AssociateLensesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateLensesInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateLensesInput>
    public typealias MOutput = OperationOutput<AssociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateLensesOutputError>
}

extension AssociateLensesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateLensesInput(lensAliases: \(String(describing: lensAliases)), workloadId: \(String(describing: workloadId)))"}
}

extension AssociateLensesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lensAliases = "LensAliases"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAliases = lensAliases {
            var lensAliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lensAliases)
            for lensaliases0 in lensAliases {
                try lensAliasesContainer.encode(lensaliases0)
            }
        }
    }
}

public struct AssociateLensesInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateLensesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateLensesInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateLensesInput>
    public typealias MOutput = OperationOutput<AssociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateLensesOutputError>
}

public struct AssociateLensesInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateLensesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateLensesInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateLensesInput>
    public typealias MOutput = OperationOutput<AssociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateLensesOutputError>
}

/// <p>Input to associate lens reviews.</p>
public struct AssociateLensesInput: Equatable {
    /// <p>List of lens aliases to associate or disassociate with a workload.</p>
    ///         <p>Identify a lens using its <a>LensSummary$LensAlias</a>.</p>
    public let lensAliases: [String]?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        lensAliases: [String]? = nil,
        workloadId: String? = nil
    )
    {
        self.lensAliases = lensAliases
        self.workloadId = workloadId
    }
}

struct AssociateLensesInputBody: Equatable {
    public let lensAliases: [String]?
}

extension AssociateLensesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lensAliases = "LensAliases"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .lensAliases)
        var lensAliasesDecoded0:[String]? = nil
        if let lensAliasesContainer = lensAliasesContainer {
            lensAliasesDecoded0 = [String]()
            for string0 in lensAliasesContainer {
                if let string0 = string0 {
                    lensAliasesDecoded0?.append(string0)
                }
            }
        }
        lensAliases = lensAliasesDecoded0
    }
}

extension AssociateLensesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateLensesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateLensesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateLensesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateLensesOutputResponse()"}
}

extension AssociateLensesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateLensesOutputResponse: Equatable {

    public init() {}
}

struct AssociateLensesOutputResponseBody: Equatable {
}

extension AssociateLensesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Choice: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case choiceId = "ChoiceId"
        case description = "Description"
        case title = "Title"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceId = choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension Choice: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Choice(choiceId: \(String(describing: choiceId)), description: \(String(describing: description)), title: \(String(describing: title)))"}
}

/// <p>A choice available to answer question.</p>
public struct Choice: Equatable {
    /// <p>The ID of a choice.</p>
    public let choiceId: String?
    /// <p>The description of a choice.</p>
    public let description: String?
    /// <p>The title of a choice.</p>
    public let title: String?

    public init (
        choiceId: String? = nil,
        description: String? = nil,
        title: String? = nil
    )
    {
        self.choiceId = choiceId
        self.description = description
        self.title = title
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource already exists.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Description of the error.</p>
    public var message: String?
    /// <p>Identifier of the resource affected.</p>
    public var resourceId: String?
    /// <p>Type of the resource affected.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CreateMilestoneInputBodyMiddleware: Middleware {
    public let id: String = "CreateMilestoneInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMilestoneInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMilestoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMilestoneInput>
    public typealias MOutput = OperationOutput<CreateMilestoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMilestoneOutputError>
}

extension CreateMilestoneInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMilestoneInput(clientRequestToken: \(String(describing: clientRequestToken)), milestoneName: \(String(describing: milestoneName)), workloadId: \(String(describing: workloadId)))"}
}

extension CreateMilestoneInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let milestoneName = milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
    }
}

public struct CreateMilestoneInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMilestoneInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMilestoneInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMilestoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMilestoneInput>
    public typealias MOutput = OperationOutput<CreateMilestoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMilestoneOutputError>
}

public struct CreateMilestoneInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMilestoneInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMilestoneInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMilestoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMilestoneInput>
    public typealias MOutput = OperationOutput<CreateMilestoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMilestoneOutputError>
}

/// <p>Input for milestone creation.</p>
public struct CreateMilestoneInput: Equatable {
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent
    ///             (executes only once).</p>
    ///         <p>You should not reuse the same token for other requests. If you retry a request with
    ///             the same client request token and the same parameters after it has completed
    ///             successfully, the result of the original request is returned. </p>
    ///         <important>
    ///             <p>This token is listed as required, however, if you do not specify it, the AWS SDKs
    ///                 automatically generate one for you. If you are not using the AWS SDK or the AWS CLI,
    ///                 you must provide this token or the request will fail.</p>
    ///         </important>
    public var clientRequestToken: String?
    /// <p>The name of the milestone in a workload.</p>
    ///         <p>Milestone names must be unique within a workload.</p>
    public let milestoneName: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        clientRequestToken: String? = nil,
        milestoneName: String? = nil,
        workloadId: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.milestoneName = milestoneName
        self.workloadId = workloadId
    }
}

struct CreateMilestoneInputBody: Equatable {
    public let milestoneName: String?
    public let clientRequestToken: String?
}

extension CreateMilestoneInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateMilestoneOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMilestoneOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMilestoneOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMilestoneOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMilestoneOutputResponse(milestoneNumber: \(String(describing: milestoneNumber)), workloadId: \(String(describing: workloadId)))"}
}

extension CreateMilestoneOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateMilestoneOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.milestoneNumber = 0
            self.workloadId = nil
        }
    }
}

/// <p>Output of a create milestone call.</p>
public struct CreateMilestoneOutputResponse: Equatable {
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        milestoneNumber: Int = 0,
        workloadId: String? = nil
    )
    {
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct CreateMilestoneOutputResponseBody: Equatable {
    public let workloadId: String?
    public let milestoneNumber: Int
}

extension CreateMilestoneOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
    }
}

public struct CreateWorkloadInputBodyMiddleware: Middleware {
    public let id: String = "CreateWorkloadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkloadInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkloadInput>
    public typealias MOutput = OperationOutput<CreateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkloadOutputError>
}

extension CreateWorkloadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkloadInput(accountIds: \(String(describing: accountIds)), architecturalDesign: \(String(describing: architecturalDesign)), awsRegions: \(String(describing: awsRegions)), clientRequestToken: \(String(describing: clientRequestToken)), description: \(String(describing: description)), environment: \(String(describing: environment)), industry: \(String(describing: industry)), industryType: \(String(describing: industryType)), lenses: \(String(describing: lenses)), nonAwsRegions: \(String(describing: nonAwsRegions)), notes: \(String(describing: notes)), pillarPriorities: \(String(describing: pillarPriorities)), reviewOwner: \(String(describing: reviewOwner)), tags: \(String(describing: tags)), workloadName: \(String(describing: workloadName)))"}
}

extension CreateWorkloadInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case environment = "Environment"
        case industry = "Industry"
        case industryType = "IndustryType"
        case lenses = "Lenses"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case tags = "Tags"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for workloadaccountids0 in accountIds {
                try accountIdsContainer.encode(workloadaccountids0)
            }
        }
        if let architecturalDesign = architecturalDesign {
            try encodeContainer.encode(architecturalDesign, forKey: .architecturalDesign)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for workloadawsregions0 in awsRegions {
                try awsRegionsContainer.encode(workloadawsregions0)
            }
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment.rawValue, forKey: .environment)
        }
        if let industry = industry {
            try encodeContainer.encode(industry, forKey: .industry)
        }
        if let industryType = industryType {
            try encodeContainer.encode(industryType, forKey: .industryType)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for workloadlenses0 in lenses {
                try lensesContainer.encode(workloadlenses0)
            }
        }
        if let nonAwsRegions = nonAwsRegions {
            var nonAwsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nonAwsRegions)
            for workloadnonawsregions0 in nonAwsRegions {
                try nonAwsRegionsContainer.encode(workloadnonawsregions0)
            }
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarPriorities = pillarPriorities {
            var pillarPrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarPriorities)
            for workloadpillarpriorities0 in pillarPriorities {
                try pillarPrioritiesContainer.encode(workloadpillarpriorities0)
            }
        }
        if let reviewOwner = reviewOwner {
            try encodeContainer.encode(reviewOwner, forKey: .reviewOwner)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }
}

public struct CreateWorkloadInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWorkloadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkloadInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkloadInput>
    public typealias MOutput = OperationOutput<CreateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkloadOutputError>
}

public struct CreateWorkloadInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWorkloadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkloadInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkloadInput>
    public typealias MOutput = OperationOutput<CreateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkloadOutputError>
}

/// <p>Input for workload creation.</p>
public struct CreateWorkloadInput: Equatable {
    /// <p>The list of AWS account IDs associated with the workload.</p>
    public let accountIds: [String]?
    /// <p>The URL of the architectural design for the workload.</p>
    public let architecturalDesign: String?
    /// <p>The list of AWS Regions associated with the workload, for example,
    ///                 <code>us-east-2</code>, or <code>ca-central-1</code>.</p>
    public let awsRegions: [String]?
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent
    ///             (executes only once).</p>
    ///         <p>You should not reuse the same token for other requests. If you retry a request with
    ///             the same client request token and the same parameters after it has completed
    ///             successfully, the result of the original request is returned. </p>
    ///         <important>
    ///             <p>This token is listed as required, however, if you do not specify it, the AWS SDKs
    ///                 automatically generate one for you. If you are not using the AWS SDK or the AWS CLI,
    ///                 you must provide this token or the request will fail.</p>
    ///         </important>
    public var clientRequestToken: String?
    /// <p>The description for the workload.</p>
    public let description: String?
    /// <p>The environment for the workload.</p>
    public let environment: WorkloadEnvironment?
    /// <p>The industry for the workload.</p>
    public let industry: String?
    /// <p>The industry type for the workload.</p>
    ///         <p>If specified, must be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>Agriculture</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Automobile</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Defense</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Design and Engineering</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Digital Advertising</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Education</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Environmental Protection</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Financial Services</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Gaming</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>General Public Services</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Healthcare</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Hospitality</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>InfoTech</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Justice and Public Safety</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Life Sciences</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Manufacturing</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Media & Entertainment</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Mining & Resources</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Oil & Gas</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Power & Utilities</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Professional Services</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Real Estate & Construction</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Retail & Wholesale</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Social Protection</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Telecommunications</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Travel, Transportation & Logistics</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Other</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let industryType: String?
    /// <p>The list of lenses associated with the workload. Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lenses: [String]?
    /// <p> The list of non-AWS Regions associated with the workload.</p>
    public let nonAwsRegions: [String]?
    /// <p>The notes associated with the workload.</p>
    public let notes: String?
    /// <p>The priorities of the pillars, which are used to order items in the improvement plan.
    ///             Each pillar is represented by its <a>PillarReviewSummary$PillarId</a>.</p>
    public let pillarPriorities: [String]?
    /// <p>The review owner of the workload. The name, email address, or identifier for the
    ///             primary group or individual that owns the workload review process.</p>
    public let reviewOwner: String?
    /// <p>The tags to be associated with the workload.</p>
    public let tags: [String:String]?
    /// <p>The name of the workload.</p>
    ///         <p>The name must be unique within an account within a Region. Spaces and capitalization
    ///             are ignored when checking for uniqueness.</p>
    public let workloadName: String?

    public init (
        accountIds: [String]? = nil,
        architecturalDesign: String? = nil,
        awsRegions: [String]? = nil,
        clientRequestToken: String? = nil,
        description: String? = nil,
        environment: WorkloadEnvironment? = nil,
        industry: String? = nil,
        industryType: String? = nil,
        lenses: [String]? = nil,
        nonAwsRegions: [String]? = nil,
        notes: String? = nil,
        pillarPriorities: [String]? = nil,
        reviewOwner: String? = nil,
        tags: [String:String]? = nil,
        workloadName: String? = nil
    )
    {
        self.accountIds = accountIds
        self.architecturalDesign = architecturalDesign
        self.awsRegions = awsRegions
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.environment = environment
        self.industry = industry
        self.industryType = industryType
        self.lenses = lenses
        self.nonAwsRegions = nonAwsRegions
        self.notes = notes
        self.pillarPriorities = pillarPriorities
        self.reviewOwner = reviewOwner
        self.tags = tags
        self.workloadName = workloadName
    }
}

struct CreateWorkloadInputBody: Equatable {
    public let workloadName: String?
    public let description: String?
    public let environment: WorkloadEnvironment?
    public let accountIds: [String]?
    public let awsRegions: [String]?
    public let nonAwsRegions: [String]?
    public let pillarPriorities: [String]?
    public let architecturalDesign: String?
    public let reviewOwner: String?
    public let industryType: String?
    public let industry: String?
    public let lenses: [String]?
    public let notes: String?
    public let clientRequestToken: String?
    public let tags: [String:String]?
}

extension CreateWorkloadInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case environment = "Environment"
        case industry = "Industry"
        case industryType = "IndustryType"
        case lenses = "Lenses"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case tags = "Tags"
        case workloadName = "WorkloadName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(WorkloadEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let awsRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
        let nonAwsRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .nonAwsRegions)
        var nonAwsRegionsDecoded0:[String]? = nil
        if let nonAwsRegionsContainer = nonAwsRegionsContainer {
            nonAwsRegionsDecoded0 = [String]()
            for string0 in nonAwsRegionsContainer {
                if let string0 = string0 {
                    nonAwsRegionsDecoded0?.append(string0)
                }
            }
        }
        nonAwsRegions = nonAwsRegionsDecoded0
        let pillarPrioritiesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .pillarPriorities)
        var pillarPrioritiesDecoded0:[String]? = nil
        if let pillarPrioritiesContainer = pillarPrioritiesContainer {
            pillarPrioritiesDecoded0 = [String]()
            for string0 in pillarPrioritiesContainer {
                if let string0 = string0 {
                    pillarPrioritiesDecoded0?.append(string0)
                }
            }
        }
        pillarPriorities = pillarPrioritiesDecoded0
        let architecturalDesignDecoded = try containerValues.decodeIfPresent(String.self, forKey: .architecturalDesign)
        architecturalDesign = architecturalDesignDecoded
        let reviewOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reviewOwner)
        reviewOwner = reviewOwnerDecoded
        let industryTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .industryType)
        industryType = industryTypeDecoded
        let industryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .industry)
        industry = industryDecoded
        let lensesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .lenses)
        var lensesDecoded0:[String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let notesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notes)
        notes = notesDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkloadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkloadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkloadOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkloadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkloadOutputResponse(workloadArn: \(String(describing: workloadArn)), workloadId: \(String(describing: workloadId)))"}
}

extension CreateWorkloadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWorkloadOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.workloadArn = output.workloadArn
            self.workloadId = output.workloadId
        } else {
            self.workloadArn = nil
            self.workloadId = nil
        }
    }
}

/// <p>Output of a create workload call.</p>
public struct CreateWorkloadOutputResponse: Equatable {
    /// <p>The ARN for the workload.</p>
    public let workloadArn: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        workloadArn: String? = nil,
        workloadId: String? = nil
    )
    {
        self.workloadArn = workloadArn
        self.workloadId = workloadId
    }
}

struct CreateWorkloadOutputResponseBody: Equatable {
    public let workloadId: String?
    public let workloadArn: String?
}

extension CreateWorkloadOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case workloadArn = "WorkloadArn"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadArn)
        workloadArn = workloadArnDecoded
    }
}

public struct CreateWorkloadShareInputBodyMiddleware: Middleware {
    public let id: String = "CreateWorkloadShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkloadShareInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkloadShareInput>
    public typealias MOutput = OperationOutput<CreateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkloadShareOutputError>
}

extension CreateWorkloadShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkloadShareInput(clientRequestToken: \(String(describing: clientRequestToken)), permissionType: \(String(describing: permissionType)), sharedWith: \(String(describing: sharedWith)), workloadId: \(String(describing: workloadId)))"}
}

extension CreateWorkloadShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case permissionType = "PermissionType"
        case sharedWith = "SharedWith"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
    }
}

public struct CreateWorkloadShareInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWorkloadShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkloadShareInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkloadShareInput>
    public typealias MOutput = OperationOutput<CreateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkloadShareOutputError>
}

public struct CreateWorkloadShareInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWorkloadShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkloadShareInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkloadShareInput>
    public typealias MOutput = OperationOutput<CreateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkloadShareOutputError>
}

/// <p>Input for Create Workload Share</p>
public struct CreateWorkloadShareInput: Equatable {
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent
    ///             (executes only once).</p>
    ///         <p>You should not reuse the same token for other requests. If you retry a request with
    ///             the same client request token and the same parameters after it has completed
    ///             successfully, the result of the original request is returned. </p>
    ///         <important>
    ///             <p>This token is listed as required, however, if you do not specify it, the AWS SDKs
    ///                 automatically generate one for you. If you are not using the AWS SDK or the AWS CLI,
    ///                 you must provide this token or the request will fail.</p>
    ///         </important>
    public var clientRequestToken: String?
    /// <p>Permission granted on a workload share.</p>
    public let permissionType: PermissionType?
    /// <p>The AWS account ID or IAM role with which the workload is shared.</p>
    public let sharedWith: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        clientRequestToken: String? = nil,
        permissionType: PermissionType? = nil,
        sharedWith: String? = nil,
        workloadId: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.permissionType = permissionType
        self.sharedWith = sharedWith
        self.workloadId = workloadId
    }
}

struct CreateWorkloadShareInputBody: Equatable {
    public let sharedWith: String?
    public let permissionType: PermissionType?
    public let clientRequestToken: String?
}

extension CreateWorkloadShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case permissionType = "PermissionType"
        case sharedWith = "SharedWith"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedWithDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateWorkloadShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkloadShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkloadShareOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkloadShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkloadShareOutputResponse(shareId: \(String(describing: shareId)), workloadId: \(String(describing: workloadId)))"}
}

extension CreateWorkloadShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWorkloadShareOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.shareId = output.shareId
            self.workloadId = output.workloadId
        } else {
            self.shareId = nil
            self.workloadId = nil
        }
    }
}

/// <p>Input for Create Workload Share</p>
public struct CreateWorkloadShareOutputResponse: Equatable {
    /// <p>The ID associated with the workload share.</p>
    public let shareId: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        shareId: String? = nil,
        workloadId: String? = nil
    )
    {
        self.shareId = shareId
        self.workloadId = workloadId
    }
}

struct CreateWorkloadShareOutputResponseBody: Equatable {
    public let workloadId: String?
    public let shareId: String?
}

extension CreateWorkloadShareOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case shareId = "ShareId"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let shareIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shareId)
        shareId = shareIdDecoded
    }
}

extension DeleteWorkloadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkloadInput(clientRequestToken: \(String(describing: clientRequestToken)), workloadId: \(String(describing: workloadId)))"}
}

extension DeleteWorkloadInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteWorkloadInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWorkloadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkloadInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkloadInput>
    public typealias MOutput = OperationOutput<DeleteWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkloadOutputError>
}

public struct DeleteWorkloadInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWorkloadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkloadInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientRequestToken = input.operationInput.clientRequestToken {
            let clientRequestTokenQueryItem = URLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: String(clientRequestToken).urlPercentEncoding())
            input.builder.withQueryItem(clientRequestTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkloadInput>
    public typealias MOutput = OperationOutput<DeleteWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkloadOutputError>
}

/// <p>Input for workload deletion.</p>
public struct DeleteWorkloadInput: Equatable {
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent
    ///             (executes only once).</p>
    ///         <p>You should not reuse the same token for other requests. If you retry a request with
    ///             the same client request token and the same parameters after it has completed
    ///             successfully, the result of the original request is returned. </p>
    ///         <important>
    ///             <p>This token is listed as required, however, if you do not specify it, the AWS SDKs
    ///                 automatically generate one for you. If you are not using the AWS SDK or the AWS CLI,
    ///                 you must provide this token or the request will fail.</p>
    ///         </important>
    public var clientRequestToken: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        clientRequestToken: String? = nil,
        workloadId: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.workloadId = workloadId
    }
}

struct DeleteWorkloadInputBody: Equatable {
}

extension DeleteWorkloadInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteWorkloadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkloadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkloadOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkloadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkloadOutputResponse()"}
}

extension DeleteWorkloadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkloadOutputResponse: Equatable {

    public init() {}
}

struct DeleteWorkloadOutputResponseBody: Equatable {
}

extension DeleteWorkloadOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteWorkloadShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkloadShareInput(clientRequestToken: \(String(describing: clientRequestToken)), shareId: \(String(describing: shareId)), workloadId: \(String(describing: workloadId)))"}
}

extension DeleteWorkloadShareInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteWorkloadShareInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWorkloadShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkloadShareInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkloadShareInput>
    public typealias MOutput = OperationOutput<DeleteWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkloadShareOutputError>
}

public struct DeleteWorkloadShareInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWorkloadShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkloadShareInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientRequestToken = input.operationInput.clientRequestToken {
            let clientRequestTokenQueryItem = URLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: String(clientRequestToken).urlPercentEncoding())
            input.builder.withQueryItem(clientRequestTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkloadShareInput>
    public typealias MOutput = OperationOutput<DeleteWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkloadShareOutputError>
}

/// <p>Input for Delete Workload Share</p>
public struct DeleteWorkloadShareInput: Equatable {
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent
    ///             (executes only once).</p>
    ///         <p>You should not reuse the same token for other requests. If you retry a request with
    ///             the same client request token and the same parameters after it has completed
    ///             successfully, the result of the original request is returned. </p>
    ///         <important>
    ///             <p>This token is listed as required, however, if you do not specify it, the AWS SDKs
    ///                 automatically generate one for you. If you are not using the AWS SDK or the AWS CLI,
    ///                 you must provide this token or the request will fail.</p>
    ///         </important>
    public var clientRequestToken: String?
    /// <p>The ID associated with the workload share.</p>
    public let shareId: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        clientRequestToken: String? = nil,
        shareId: String? = nil,
        workloadId: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.shareId = shareId
        self.workloadId = workloadId
    }
}

struct DeleteWorkloadShareInputBody: Equatable {
}

extension DeleteWorkloadShareInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteWorkloadShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkloadShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkloadShareOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkloadShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkloadShareOutputResponse()"}
}

extension DeleteWorkloadShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkloadShareOutputResponse: Equatable {

    public init() {}
}

struct DeleteWorkloadShareOutputResponseBody: Equatable {
}

extension DeleteWorkloadShareOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum DifferenceStatus {
    case deleted
    case new
    case updated
    case sdkUnknown(String)
}

extension DifferenceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DifferenceStatus] {
        return [
            .deleted,
            .new,
            .updated,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleted: return "DELETED"
        case .new: return "NEW"
        case .updated: return "UPDATED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DifferenceStatus(rawValue: rawValue) ?? DifferenceStatus.sdkUnknown(rawValue)
    }
}

public struct DisassociateLensesInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateLensesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateLensesInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateLensesInput>
    public typealias MOutput = OperationOutput<DisassociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateLensesOutputError>
}

extension DisassociateLensesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateLensesInput(lensAliases: \(String(describing: lensAliases)), workloadId: \(String(describing: workloadId)))"}
}

extension DisassociateLensesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lensAliases = "LensAliases"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAliases = lensAliases {
            var lensAliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lensAliases)
            for lensaliases0 in lensAliases {
                try lensAliasesContainer.encode(lensaliases0)
            }
        }
    }
}

public struct DisassociateLensesInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateLensesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateLensesInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateLensesInput>
    public typealias MOutput = OperationOutput<DisassociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateLensesOutputError>
}

public struct DisassociateLensesInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateLensesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateLensesInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateLensesInput>
    public typealias MOutput = OperationOutput<DisassociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateLensesOutputError>
}

/// <p>Input to disassociate lens reviews.</p>
public struct DisassociateLensesInput: Equatable {
    /// <p>List of lens aliases to associate or disassociate with a workload.</p>
    ///         <p>Identify a lens using its <a>LensSummary$LensAlias</a>.</p>
    public let lensAliases: [String]?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        lensAliases: [String]? = nil,
        workloadId: String? = nil
    )
    {
        self.lensAliases = lensAliases
        self.workloadId = workloadId
    }
}

struct DisassociateLensesInputBody: Equatable {
    public let lensAliases: [String]?
}

extension DisassociateLensesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lensAliases = "LensAliases"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .lensAliases)
        var lensAliasesDecoded0:[String]? = nil
        if let lensAliasesContainer = lensAliasesContainer {
            lensAliasesDecoded0 = [String]()
            for string0 in lensAliasesContainer {
                if let string0 = string0 {
                    lensAliasesDecoded0?.append(string0)
                }
            }
        }
        lensAliases = lensAliasesDecoded0
    }
}

extension DisassociateLensesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateLensesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateLensesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateLensesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateLensesOutputResponse()"}
}

extension DisassociateLensesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateLensesOutputResponse: Equatable {

    public init() {}
}

struct DisassociateLensesOutputResponseBody: Equatable {
}

extension DisassociateLensesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAnswerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAnswerInput(lensAlias: \(String(describing: lensAlias)), milestoneNumber: \(String(describing: milestoneNumber)), questionId: \(String(describing: questionId)), workloadId: \(String(describing: workloadId)))"}
}

extension GetAnswerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAnswerInputHeadersMiddleware: Middleware {
    public let id: String = "GetAnswerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnswerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnswerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnswerInput>
    public typealias MOutput = OperationOutput<GetAnswerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnswerOutputError>
}

public struct GetAnswerInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAnswerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnswerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnswerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let milestoneNumberQueryItem = URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: String(input.operationInput.milestoneNumber).urlPercentEncoding())
        input.builder.withQueryItem(milestoneNumberQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnswerInput>
    public typealias MOutput = OperationOutput<GetAnswerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnswerOutputError>
}

/// <p>Input to get answer.</p>
public struct GetAnswerInput: Equatable {
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The ID of the question.</p>
    public let questionId: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        lensAlias: String? = nil,
        milestoneNumber: Int = 0,
        questionId: String? = nil,
        workloadId: String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.questionId = questionId
        self.workloadId = workloadId
    }
}

struct GetAnswerInputBody: Equatable {
}

extension GetAnswerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAnswerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnswerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAnswerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnswerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAnswerOutputResponse(answer: \(String(describing: answer)), lensAlias: \(String(describing: lensAlias)), milestoneNumber: \(String(describing: milestoneNumber)), workloadId: \(String(describing: workloadId)))"}
}

extension GetAnswerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAnswerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.answer = output.answer
            self.lensAlias = output.lensAlias
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.answer = nil
            self.lensAlias = nil
            self.milestoneNumber = 0
            self.workloadId = nil
        }
    }
}

/// <p>Output of a get answer call.</p>
public struct GetAnswerOutputResponse: Equatable {
    /// <p>An answer of the question.</p>
    public let answer: Answer?
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        answer: Answer? = nil,
        lensAlias: String? = nil,
        milestoneNumber: Int = 0,
        workloadId: String? = nil
    )
    {
        self.answer = answer
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetAnswerOutputResponseBody: Equatable {
    public let workloadId: String?
    public let milestoneNumber: Int
    public let lensAlias: String?
    public let answer: Answer?
}

extension GetAnswerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case answer = "Answer"
        case lensAlias = "LensAlias"
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let answerDecoded = try containerValues.decodeIfPresent(Answer.self, forKey: .answer)
        answer = answerDecoded
    }
}

extension GetLensReviewInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLensReviewInput(lensAlias: \(String(describing: lensAlias)), milestoneNumber: \(String(describing: milestoneNumber)), workloadId: \(String(describing: workloadId)))"}
}

extension GetLensReviewInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLensReviewInputHeadersMiddleware: Middleware {
    public let id: String = "GetLensReviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLensReviewInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLensReviewInput>
    public typealias MOutput = OperationOutput<GetLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLensReviewOutputError>
}

public struct GetLensReviewInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLensReviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLensReviewInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let milestoneNumberQueryItem = URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: String(input.operationInput.milestoneNumber).urlPercentEncoding())
        input.builder.withQueryItem(milestoneNumberQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLensReviewInput>
    public typealias MOutput = OperationOutput<GetLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLensReviewOutputError>
}

/// <p>Input to get lens review.</p>
public struct GetLensReviewInput: Equatable {
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        lensAlias: String? = nil,
        milestoneNumber: Int = 0,
        workloadId: String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewInputBody: Equatable {
}

extension GetLensReviewInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLensReviewOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLensReviewOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLensReviewOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLensReviewOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLensReviewOutputResponse(lensReview: \(String(describing: lensReview)), milestoneNumber: \(String(describing: milestoneNumber)), workloadId: \(String(describing: workloadId)))"}
}

extension GetLensReviewOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLensReviewOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lensReview = output.lensReview
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.lensReview = nil
            self.milestoneNumber = 0
            self.workloadId = nil
        }
    }
}

/// <p>Output of a get lens review call.</p>
public struct GetLensReviewOutputResponse: Equatable {
    /// <p>A lens review of a question.</p>
    public let lensReview: LensReview?
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        lensReview: LensReview? = nil,
        milestoneNumber: Int = 0,
        workloadId: String? = nil
    )
    {
        self.lensReview = lensReview
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewOutputResponseBody: Equatable {
    public let workloadId: String?
    public let milestoneNumber: Int
    public let lensReview: LensReview?
}

extension GetLensReviewOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lensReview = "LensReview"
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensReviewDecoded = try containerValues.decodeIfPresent(LensReview.self, forKey: .lensReview)
        lensReview = lensReviewDecoded
    }
}

extension GetLensReviewReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLensReviewReportInput(lensAlias: \(String(describing: lensAlias)), milestoneNumber: \(String(describing: milestoneNumber)), workloadId: \(String(describing: workloadId)))"}
}

extension GetLensReviewReportInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLensReviewReportInputHeadersMiddleware: Middleware {
    public let id: String = "GetLensReviewReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLensReviewReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLensReviewReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLensReviewReportInput>
    public typealias MOutput = OperationOutput<GetLensReviewReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLensReviewReportOutputError>
}

public struct GetLensReviewReportInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLensReviewReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLensReviewReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLensReviewReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let milestoneNumberQueryItem = URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: String(input.operationInput.milestoneNumber).urlPercentEncoding())
        input.builder.withQueryItem(milestoneNumberQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLensReviewReportInput>
    public typealias MOutput = OperationOutput<GetLensReviewReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLensReviewReportOutputError>
}

/// <p>Input to get lens review report.</p>
public struct GetLensReviewReportInput: Equatable {
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        lensAlias: String? = nil,
        milestoneNumber: Int = 0,
        workloadId: String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewReportInputBody: Equatable {
}

extension GetLensReviewReportInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLensReviewReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLensReviewReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLensReviewReportOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLensReviewReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLensReviewReportOutputResponse(lensReviewReport: \(String(describing: lensReviewReport)), milestoneNumber: \(String(describing: milestoneNumber)), workloadId: \(String(describing: workloadId)))"}
}

extension GetLensReviewReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLensReviewReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lensReviewReport = output.lensReviewReport
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.lensReviewReport = nil
            self.milestoneNumber = 0
            self.workloadId = nil
        }
    }
}

/// <p>Output of a get lens review report call.</p>
public struct GetLensReviewReportOutputResponse: Equatable {
    /// <p>A report of a lens review.</p>
    public let lensReviewReport: LensReviewReport?
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        lensReviewReport: LensReviewReport? = nil,
        milestoneNumber: Int = 0,
        workloadId: String? = nil
    )
    {
        self.lensReviewReport = lensReviewReport
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewReportOutputResponseBody: Equatable {
    public let workloadId: String?
    public let milestoneNumber: Int
    public let lensReviewReport: LensReviewReport?
}

extension GetLensReviewReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lensReviewReport = "LensReviewReport"
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensReviewReportDecoded = try containerValues.decodeIfPresent(LensReviewReport.self, forKey: .lensReviewReport)
        lensReviewReport = lensReviewReportDecoded
    }
}

extension GetLensVersionDifferenceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLensVersionDifferenceInput(baseLensVersion: \(String(describing: baseLensVersion)), lensAlias: \(String(describing: lensAlias)))"}
}

extension GetLensVersionDifferenceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLensVersionDifferenceInputHeadersMiddleware: Middleware {
    public let id: String = "GetLensVersionDifferenceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLensVersionDifferenceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLensVersionDifferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLensVersionDifferenceInput>
    public typealias MOutput = OperationOutput<GetLensVersionDifferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLensVersionDifferenceOutputError>
}

public struct GetLensVersionDifferenceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLensVersionDifferenceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLensVersionDifferenceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLensVersionDifferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let baseLensVersion = input.operationInput.baseLensVersion {
            let baseLensVersionQueryItem = URLQueryItem(name: "BaseLensVersion".urlPercentEncoding(), value: String(baseLensVersion).urlPercentEncoding())
            input.builder.withQueryItem(baseLensVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLensVersionDifferenceInput>
    public typealias MOutput = OperationOutput<GetLensVersionDifferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLensVersionDifferenceOutputError>
}

public struct GetLensVersionDifferenceInput: Equatable {
    /// <p>The base version of the lens.</p>
    public let baseLensVersion: String?
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?

    public init (
        baseLensVersion: String? = nil,
        lensAlias: String? = nil
    )
    {
        self.baseLensVersion = baseLensVersion
        self.lensAlias = lensAlias
    }
}

struct GetLensVersionDifferenceInputBody: Equatable {
}

extension GetLensVersionDifferenceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLensVersionDifferenceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLensVersionDifferenceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLensVersionDifferenceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLensVersionDifferenceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLensVersionDifferenceOutputResponse(baseLensVersion: \(String(describing: baseLensVersion)), latestLensVersion: \(String(describing: latestLensVersion)), lensAlias: \(String(describing: lensAlias)), versionDifferences: \(String(describing: versionDifferences)))"}
}

extension GetLensVersionDifferenceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLensVersionDifferenceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baseLensVersion = output.baseLensVersion
            self.latestLensVersion = output.latestLensVersion
            self.lensAlias = output.lensAlias
            self.versionDifferences = output.versionDifferences
        } else {
            self.baseLensVersion = nil
            self.latestLensVersion = nil
            self.lensAlias = nil
            self.versionDifferences = nil
        }
    }
}

public struct GetLensVersionDifferenceOutputResponse: Equatable {
    /// <p>The base version of the lens.</p>
    public let baseLensVersion: String?
    /// <p>The latest version of the lens.</p>
    public let latestLensVersion: String?
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The differences between the base and latest versions of the lens.</p>
    public let versionDifferences: VersionDifferences?

    public init (
        baseLensVersion: String? = nil,
        latestLensVersion: String? = nil,
        lensAlias: String? = nil,
        versionDifferences: VersionDifferences? = nil
    )
    {
        self.baseLensVersion = baseLensVersion
        self.latestLensVersion = latestLensVersion
        self.lensAlias = lensAlias
        self.versionDifferences = versionDifferences
    }
}

struct GetLensVersionDifferenceOutputResponseBody: Equatable {
    public let lensAlias: String?
    public let baseLensVersion: String?
    public let latestLensVersion: String?
    public let versionDifferences: VersionDifferences?
}

extension GetLensVersionDifferenceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baseLensVersion = "BaseLensVersion"
        case latestLensVersion = "LatestLensVersion"
        case lensAlias = "LensAlias"
        case versionDifferences = "VersionDifferences"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let baseLensVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseLensVersion)
        baseLensVersion = baseLensVersionDecoded
        let latestLensVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestLensVersion)
        latestLensVersion = latestLensVersionDecoded
        let versionDifferencesDecoded = try containerValues.decodeIfPresent(VersionDifferences.self, forKey: .versionDifferences)
        versionDifferences = versionDifferencesDecoded
    }
}

extension GetMilestoneInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMilestoneInput(milestoneNumber: \(String(describing: milestoneNumber)), workloadId: \(String(describing: workloadId)))"}
}

extension GetMilestoneInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetMilestoneInputHeadersMiddleware: Middleware {
    public let id: String = "GetMilestoneInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMilestoneInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMilestoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMilestoneInput>
    public typealias MOutput = OperationOutput<GetMilestoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMilestoneOutputError>
}

public struct GetMilestoneInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMilestoneInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMilestoneInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMilestoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMilestoneInput>
    public typealias MOutput = OperationOutput<GetMilestoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMilestoneOutputError>
}

/// <p>Input to get a milestone.</p>
public struct GetMilestoneInput: Equatable {
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        milestoneNumber: Int = 0,
        workloadId: String? = nil
    )
    {
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetMilestoneInputBody: Equatable {
}

extension GetMilestoneInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetMilestoneOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMilestoneOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMilestoneOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMilestoneOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMilestoneOutputResponse(milestone: \(String(describing: milestone)), workloadId: \(String(describing: workloadId)))"}
}

extension GetMilestoneOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMilestoneOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.milestone = output.milestone
            self.workloadId = output.workloadId
        } else {
            self.milestone = nil
            self.workloadId = nil
        }
    }
}

/// <p>Output of a get milestone call.</p>
public struct GetMilestoneOutputResponse: Equatable {
    /// <p>A milestone return object.</p>
    public let milestone: Milestone?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        milestone: Milestone? = nil,
        workloadId: String? = nil
    )
    {
        self.milestone = milestone
        self.workloadId = workloadId
    }
}

struct GetMilestoneOutputResponseBody: Equatable {
    public let workloadId: String?
    public let milestone: Milestone?
}

extension GetMilestoneOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case milestone = "Milestone"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneDecoded = try containerValues.decodeIfPresent(Milestone.self, forKey: .milestone)
        milestone = milestoneDecoded
    }
}

extension GetWorkloadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorkloadInput(workloadId: \(String(describing: workloadId)))"}
}

extension GetWorkloadInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetWorkloadInputHeadersMiddleware: Middleware {
    public let id: String = "GetWorkloadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkloadInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkloadInput>
    public typealias MOutput = OperationOutput<GetWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkloadOutputError>
}

public struct GetWorkloadInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWorkloadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkloadInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkloadInput>
    public typealias MOutput = OperationOutput<GetWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkloadOutputError>
}

/// <p>Input to get a workload.</p>
public struct GetWorkloadInput: Equatable {
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        workloadId: String? = nil
    )
    {
        self.workloadId = workloadId
    }
}

struct GetWorkloadInputBody: Equatable {
}

extension GetWorkloadInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetWorkloadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkloadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWorkloadOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkloadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorkloadOutputResponse(workload: \(String(describing: workload)))"}
}

extension GetWorkloadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWorkloadOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.workload = output.workload
        } else {
            self.workload = nil
        }
    }
}

/// <p>Output of a get workload call.</p>
public struct GetWorkloadOutputResponse: Equatable {
    /// <p>A workload return object.</p>
    public let workload: Workload?

    public init (
        workload: Workload? = nil
    )
    {
        self.workload = workload
    }
}

struct GetWorkloadOutputResponseBody: Equatable {
    public let workload: Workload?
}

extension GetWorkloadOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case workload = "Workload"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadDecoded = try containerValues.decodeIfPresent(Workload.self, forKey: .workload)
        workload = workloadDecoded
    }
}

extension ImprovementSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case improvementPlanUrl = "ImprovementPlanUrl"
        case pillarId = "PillarId"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case risk = "Risk"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let improvementPlanUrl = improvementPlanUrl {
            try encodeContainer.encode(improvementPlanUrl, forKey: .improvementPlanUrl)
        }
        if let pillarId = pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionId = questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let risk = risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let riskDecoded = try containerValues.decodeIfPresent(Risk.self, forKey: .risk)
        risk = riskDecoded
        let improvementPlanUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .improvementPlanUrl)
        improvementPlanUrl = improvementPlanUrlDecoded
    }
}

extension ImprovementSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImprovementSummary(improvementPlanUrl: \(String(describing: improvementPlanUrl)), pillarId: \(String(describing: pillarId)), questionId: \(String(describing: questionId)), questionTitle: \(String(describing: questionTitle)), risk: \(String(describing: risk)))"}
}

/// <p>An improvement summary of a lens review in a workload.</p>
public struct ImprovementSummary: Equatable {
    /// <p>The improvement plan URL for a question.</p>
    public let improvementPlanUrl: String?
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    ///         <p>A pillar is identified by its <a>PillarReviewSummary$PillarId</a>.</p>
    public let pillarId: String?
    /// <p>The ID of the question.</p>
    public let questionId: String?
    /// <p>The title of the question.</p>
    public let questionTitle: String?
    /// <p>The risk for a given workload, lens review, pillar, or question.</p>
    public let risk: Risk?

    public init (
        improvementPlanUrl: String? = nil,
        pillarId: String? = nil,
        questionId: String? = nil,
        questionTitle: String? = nil,
        risk: Risk? = nil
    )
    {
        self.improvementPlanUrl = improvementPlanUrl
        self.pillarId = pillarId
        self.questionId = questionId
        self.questionTitle = questionTitle
        self.risk = risk
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is a problem with the AWS Well-Architected Tool API service.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>Description of the error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LensReview: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lensAlias = "LensAlias"
        case lensName = "LensName"
        case lensStatus = "LensStatus"
        case lensVersion = "LensVersion"
        case nextToken = "NextToken"
        case notes = "Notes"
        case pillarReviewSummaries = "PillarReviewSummaries"
        case riskCounts = "RiskCounts"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensName = lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let lensStatus = lensStatus {
            try encodeContainer.encode(lensStatus.rawValue, forKey: .lensStatus)
        }
        if let lensVersion = lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarReviewSummaries = pillarReviewSummaries {
            var pillarReviewSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarReviewSummaries)
            for pillarreviewsummaries0 in pillarReviewSummaries {
                try pillarReviewSummariesContainer.encode(pillarreviewsummaries0)
            }
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let lensStatusDecoded = try containerValues.decodeIfPresent(LensStatus.self, forKey: .lensStatus)
        lensStatus = lensStatusDecoded
        let pillarReviewSummariesContainer = try containerValues.decodeIfPresent([PillarReviewSummary?].self, forKey: .pillarReviewSummaries)
        var pillarReviewSummariesDecoded0:[PillarReviewSummary]? = nil
        if let pillarReviewSummariesContainer = pillarReviewSummariesContainer {
            pillarReviewSummariesDecoded0 = [PillarReviewSummary]()
            for structure0 in pillarReviewSummariesContainer {
                if let structure0 = structure0 {
                    pillarReviewSummariesDecoded0?.append(structure0)
                }
            }
        }
        pillarReviewSummaries = pillarReviewSummariesDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let notesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notes)
        notes = notesDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [String:Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [String:Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LensReview: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LensReview(lensAlias: \(String(describing: lensAlias)), lensName: \(String(describing: lensName)), lensStatus: \(String(describing: lensStatus)), lensVersion: \(String(describing: lensVersion)), nextToken: \(String(describing: nextToken)), notes: \(String(describing: notes)), pillarReviewSummaries: \(String(describing: pillarReviewSummaries)), riskCounts: \(String(describing: riskCounts)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>A lens review of a question.</p>
public struct LensReview: Equatable {
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The full name of the lens.</p>
    public let lensName: String?
    /// <p>The status of the lens.</p>
    public let lensStatus: LensStatus?
    /// <p>The version of the lens.</p>
    public let lensVersion: String?
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The notes associated with the workload.</p>
    public let notes: String?
    /// <p>List of pillar review summaries of lens review in a workload.</p>
    public let pillarReviewSummaries: [PillarReviewSummary]?
    /// <p>A map from risk names to the count of how questions have that rating.</p>
    public let riskCounts: [String:Int]?
    /// <p>The date and time recorded.</p>
    public let updatedAt: Date?

    public init (
        lensAlias: String? = nil,
        lensName: String? = nil,
        lensStatus: LensStatus? = nil,
        lensVersion: String? = nil,
        nextToken: String? = nil,
        notes: String? = nil,
        pillarReviewSummaries: [PillarReviewSummary]? = nil,
        riskCounts: [String:Int]? = nil,
        updatedAt: Date? = nil
    )
    {
        self.lensAlias = lensAlias
        self.lensName = lensName
        self.lensStatus = lensStatus
        self.lensVersion = lensVersion
        self.nextToken = nextToken
        self.notes = notes
        self.pillarReviewSummaries = pillarReviewSummaries
        self.riskCounts = riskCounts
        self.updatedAt = updatedAt
    }
}

extension LensReviewReport: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case base64String = "Base64String"
        case lensAlias = "LensAlias"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base64String = base64String {
            try encodeContainer.encode(base64String, forKey: .base64String)
        }
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let base64StringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .base64String)
        base64String = base64StringDecoded
    }
}

extension LensReviewReport: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LensReviewReport(base64String: \(String(describing: base64String)), lensAlias: \(String(describing: lensAlias)))"}
}

/// <p>A report of a lens review.</p>
public struct LensReviewReport: Equatable {
    /// <p>The Base64-encoded string representation of a lens review report.</p>
    ///         <p>This data can be used to create a PDF file.</p>
    public let base64String: String?
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?

    public init (
        base64String: String? = nil,
        lensAlias: String? = nil
    )
    {
        self.base64String = base64String
        self.lensAlias = lensAlias
    }
}

extension LensReviewSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lensAlias = "LensAlias"
        case lensName = "LensName"
        case lensStatus = "LensStatus"
        case lensVersion = "LensVersion"
        case riskCounts = "RiskCounts"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensName = lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let lensStatus = lensStatus {
            try encodeContainer.encode(lensStatus.rawValue, forKey: .lensStatus)
        }
        if let lensVersion = lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let lensStatusDecoded = try containerValues.decodeIfPresent(LensStatus.self, forKey: .lensStatus)
        lensStatus = lensStatusDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [String:Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [String:Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
    }
}

extension LensReviewSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LensReviewSummary(lensAlias: \(String(describing: lensAlias)), lensName: \(String(describing: lensName)), lensStatus: \(String(describing: lensStatus)), lensVersion: \(String(describing: lensVersion)), riskCounts: \(String(describing: riskCounts)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>A lens review summary of a workload.</p>
public struct LensReviewSummary: Equatable {
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The full name of the lens.</p>
    public let lensName: String?
    /// <p>The status of the lens.</p>
    public let lensStatus: LensStatus?
    /// <p>The version of the lens.</p>
    public let lensVersion: String?
    /// <p>A map from risk names to the count of how questions have that rating.</p>
    public let riskCounts: [String:Int]?
    /// <p>The date and time recorded.</p>
    public let updatedAt: Date?

    public init (
        lensAlias: String? = nil,
        lensName: String? = nil,
        lensStatus: LensStatus? = nil,
        lensVersion: String? = nil,
        riskCounts: [String:Int]? = nil,
        updatedAt: Date? = nil
    )
    {
        self.lensAlias = lensAlias
        self.lensName = lensName
        self.lensStatus = lensStatus
        self.lensVersion = lensVersion
        self.riskCounts = riskCounts
        self.updatedAt = updatedAt
    }
}

public enum LensStatus {
    case current
    case deprecated
    case notCurrent
    case sdkUnknown(String)
}

extension LensStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LensStatus] {
        return [
            .current,
            .deprecated,
            .notCurrent,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .current: return "CURRENT"
        case .deprecated: return "DEPRECATED"
        case .notCurrent: return "NOT_CURRENT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LensStatus(rawValue: rawValue) ?? LensStatus.sdkUnknown(rawValue)
    }
}

extension LensSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case lensAlias = "LensAlias"
        case lensName = "LensName"
        case lensVersion = "LensVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensName = lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let lensVersion = lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension LensSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LensSummary(description: \(String(describing: description)), lensAlias: \(String(describing: lensAlias)), lensName: \(String(describing: lensName)), lensVersion: \(String(describing: lensVersion)))"}
}

/// <p>A lens summary of a lens.</p>
public struct LensSummary: Equatable {
    /// <p>The description of the lens.</p>
    public let description: String?
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The full name of the lens.</p>
    public let lensName: String?
    /// <p>The version of the lens.</p>
    public let lensVersion: String?

    public init (
        description: String? = nil,
        lensAlias: String? = nil,
        lensName: String? = nil,
        lensVersion: String? = nil
    )
    {
        self.description = description
        self.lensAlias = lensAlias
        self.lensName = lensName
        self.lensVersion = lensVersion
    }
}

extension LensUpgradeSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentLensVersion = "CurrentLensVersion"
        case latestLensVersion = "LatestLensVersion"
        case lensAlias = "LensAlias"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentLensVersion = currentLensVersion {
            try encodeContainer.encode(currentLensVersion, forKey: .currentLensVersion)
        }
        if let latestLensVersion = latestLensVersion {
            try encodeContainer.encode(latestLensVersion, forKey: .latestLensVersion)
        }
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let currentLensVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentLensVersion)
        currentLensVersion = currentLensVersionDecoded
        let latestLensVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestLensVersion)
        latestLensVersion = latestLensVersionDecoded
    }
}

extension LensUpgradeSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LensUpgradeSummary(currentLensVersion: \(String(describing: currentLensVersion)), latestLensVersion: \(String(describing: latestLensVersion)), lensAlias: \(String(describing: lensAlias)), workloadId: \(String(describing: workloadId)), workloadName: \(String(describing: workloadName)))"}
}

/// <p>Lens upgrade summary return object.</p>
public struct LensUpgradeSummary: Equatable {
    /// <p>The current version of the lens.</p>
    public let currentLensVersion: String?
    /// <p>The latest version of the lens.</p>
    public let latestLensVersion: String?
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?
    /// <p>The name of the workload.</p>
    ///         <p>The name must be unique within an account within a Region. Spaces and capitalization
    ///             are ignored when checking for uniqueness.</p>
    public let workloadName: String?

    public init (
        currentLensVersion: String? = nil,
        latestLensVersion: String? = nil,
        lensAlias: String? = nil,
        workloadId: String? = nil,
        workloadName: String? = nil
    )
    {
        self.currentLensVersion = currentLensVersion
        self.latestLensVersion = latestLensVersion
        self.lensAlias = lensAlias
        self.workloadId = workloadId
        self.workloadName = workloadName
    }
}

extension ListAnswersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnswersInput(lensAlias: \(String(describing: lensAlias)), maxResults: \(String(describing: maxResults)), milestoneNumber: \(String(describing: milestoneNumber)), nextToken: \(String(describing: nextToken)), pillarId: \(String(describing: pillarId)), workloadId: \(String(describing: workloadId)))"}
}

extension ListAnswersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAnswersInputHeadersMiddleware: Middleware {
    public let id: String = "ListAnswersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnswersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnswersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnswersInput>
    public typealias MOutput = OperationOutput<ListAnswersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnswersOutputError>
}

public struct ListAnswersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAnswersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnswersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnswersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pillarId = input.operationInput.pillarId {
            let pillarIdQueryItem = URLQueryItem(name: "PillarId".urlPercentEncoding(), value: String(pillarId).urlPercentEncoding())
            input.builder.withQueryItem(pillarIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        let milestoneNumberQueryItem = URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: String(input.operationInput.milestoneNumber).urlPercentEncoding())
        input.builder.withQueryItem(milestoneNumberQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnswersInput>
    public typealias MOutput = OperationOutput<ListAnswersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnswersOutputError>
}

/// <p>Input to list answers.</p>
public struct ListAnswersInput: Equatable {
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The maximum number of results to return for this request.</p>
    public let maxResults: Int
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    ///         <p>A pillar is identified by its <a>PillarReviewSummary$PillarId</a>.</p>
    public let pillarId: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        lensAlias: String? = nil,
        maxResults: Int = 0,
        milestoneNumber: Int = 0,
        nextToken: String? = nil,
        pillarId: String? = nil,
        workloadId: String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.workloadId = workloadId
    }
}

struct ListAnswersInputBody: Equatable {
}

extension ListAnswersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAnswersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnswersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnswersOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnswersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnswersOutputResponse(answerSummaries: \(String(describing: answerSummaries)), lensAlias: \(String(describing: lensAlias)), milestoneNumber: \(String(describing: milestoneNumber)), nextToken: \(String(describing: nextToken)), workloadId: \(String(describing: workloadId)))"}
}

extension ListAnswersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAnswersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.answerSummaries = output.answerSummaries
            self.lensAlias = output.lensAlias
            self.milestoneNumber = output.milestoneNumber
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.answerSummaries = nil
            self.lensAlias = nil
            self.milestoneNumber = 0
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// <p>Output of a list answers call.</p>
public struct ListAnswersOutputResponse: Equatable {
    /// <p>List of answer summaries of lens review in a workload.</p>
    public let answerSummaries: [AnswerSummary]?
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        answerSummaries: [AnswerSummary]? = nil,
        lensAlias: String? = nil,
        milestoneNumber: Int = 0,
        nextToken: String? = nil,
        workloadId: String? = nil
    )
    {
        self.answerSummaries = answerSummaries
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListAnswersOutputResponseBody: Equatable {
    public let workloadId: String?
    public let milestoneNumber: Int
    public let lensAlias: String?
    public let answerSummaries: [AnswerSummary]?
    public let nextToken: String?
}

extension ListAnswersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case answerSummaries = "AnswerSummaries"
        case lensAlias = "LensAlias"
        case milestoneNumber = "MilestoneNumber"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let answerSummariesContainer = try containerValues.decodeIfPresent([AnswerSummary?].self, forKey: .answerSummaries)
        var answerSummariesDecoded0:[AnswerSummary]? = nil
        if let answerSummariesContainer = answerSummariesContainer {
            answerSummariesDecoded0 = [AnswerSummary]()
            for structure0 in answerSummariesContainer {
                if let structure0 = structure0 {
                    answerSummariesDecoded0?.append(structure0)
                }
            }
        }
        answerSummaries = answerSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLensReviewImprovementsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLensReviewImprovementsInput(lensAlias: \(String(describing: lensAlias)), maxResults: \(String(describing: maxResults)), milestoneNumber: \(String(describing: milestoneNumber)), nextToken: \(String(describing: nextToken)), pillarId: \(String(describing: pillarId)), workloadId: \(String(describing: workloadId)))"}
}

extension ListLensReviewImprovementsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListLensReviewImprovementsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLensReviewImprovementsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLensReviewImprovementsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLensReviewImprovementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLensReviewImprovementsInput>
    public typealias MOutput = OperationOutput<ListLensReviewImprovementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLensReviewImprovementsOutputError>
}

public struct ListLensReviewImprovementsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLensReviewImprovementsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLensReviewImprovementsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLensReviewImprovementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pillarId = input.operationInput.pillarId {
            let pillarIdQueryItem = URLQueryItem(name: "PillarId".urlPercentEncoding(), value: String(pillarId).urlPercentEncoding())
            input.builder.withQueryItem(pillarIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        let milestoneNumberQueryItem = URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: String(input.operationInput.milestoneNumber).urlPercentEncoding())
        input.builder.withQueryItem(milestoneNumberQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLensReviewImprovementsInput>
    public typealias MOutput = OperationOutput<ListLensReviewImprovementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLensReviewImprovementsOutputError>
}

/// <p>Input to list lens review improvements.</p>
public struct ListLensReviewImprovementsInput: Equatable {
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The maximum number of results to return for this request.</p>
    public let maxResults: Int
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    ///         <p>A pillar is identified by its <a>PillarReviewSummary$PillarId</a>.</p>
    public let pillarId: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        lensAlias: String? = nil,
        maxResults: Int = 0,
        milestoneNumber: Int = 0,
        nextToken: String? = nil,
        pillarId: String? = nil,
        workloadId: String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.workloadId = workloadId
    }
}

struct ListLensReviewImprovementsInputBody: Equatable {
}

extension ListLensReviewImprovementsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListLensReviewImprovementsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLensReviewImprovementsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLensReviewImprovementsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLensReviewImprovementsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLensReviewImprovementsOutputResponse(improvementSummaries: \(String(describing: improvementSummaries)), lensAlias: \(String(describing: lensAlias)), milestoneNumber: \(String(describing: milestoneNumber)), nextToken: \(String(describing: nextToken)), workloadId: \(String(describing: workloadId)))"}
}

extension ListLensReviewImprovementsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLensReviewImprovementsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.improvementSummaries = output.improvementSummaries
            self.lensAlias = output.lensAlias
            self.milestoneNumber = output.milestoneNumber
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.improvementSummaries = nil
            self.lensAlias = nil
            self.milestoneNumber = 0
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// <p>Output of a list lens review improvements call.</p>
public struct ListLensReviewImprovementsOutputResponse: Equatable {
    /// <p>List of improvement summaries of lens review in a workload.</p>
    public let improvementSummaries: [ImprovementSummary]?
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        improvementSummaries: [ImprovementSummary]? = nil,
        lensAlias: String? = nil,
        milestoneNumber: Int = 0,
        nextToken: String? = nil,
        workloadId: String? = nil
    )
    {
        self.improvementSummaries = improvementSummaries
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListLensReviewImprovementsOutputResponseBody: Equatable {
    public let workloadId: String?
    public let milestoneNumber: Int
    public let lensAlias: String?
    public let improvementSummaries: [ImprovementSummary]?
    public let nextToken: String?
}

extension ListLensReviewImprovementsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case improvementSummaries = "ImprovementSummaries"
        case lensAlias = "LensAlias"
        case milestoneNumber = "MilestoneNumber"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let improvementSummariesContainer = try containerValues.decodeIfPresent([ImprovementSummary?].self, forKey: .improvementSummaries)
        var improvementSummariesDecoded0:[ImprovementSummary]? = nil
        if let improvementSummariesContainer = improvementSummariesContainer {
            improvementSummariesDecoded0 = [ImprovementSummary]()
            for structure0 in improvementSummariesContainer {
                if let structure0 = structure0 {
                    improvementSummariesDecoded0?.append(structure0)
                }
            }
        }
        improvementSummaries = improvementSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLensReviewsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLensReviewsInput(maxResults: \(String(describing: maxResults)), milestoneNumber: \(String(describing: milestoneNumber)), nextToken: \(String(describing: nextToken)), workloadId: \(String(describing: workloadId)))"}
}

extension ListLensReviewsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListLensReviewsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLensReviewsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLensReviewsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLensReviewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLensReviewsInput>
    public typealias MOutput = OperationOutput<ListLensReviewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLensReviewsOutputError>
}

public struct ListLensReviewsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLensReviewsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLensReviewsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLensReviewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        let milestoneNumberQueryItem = URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: String(input.operationInput.milestoneNumber).urlPercentEncoding())
        input.builder.withQueryItem(milestoneNumberQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLensReviewsInput>
    public typealias MOutput = OperationOutput<ListLensReviewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLensReviewsOutputError>
}

/// <p>Input to list lens reviews.</p>
public struct ListLensReviewsInput: Equatable {
    /// <p>The maximum number of results to return for this request.</p>
    public let maxResults: Int
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        maxResults: Int = 0,
        milestoneNumber: Int = 0,
        nextToken: String? = nil,
        workloadId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListLensReviewsInputBody: Equatable {
}

extension ListLensReviewsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListLensReviewsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLensReviewsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLensReviewsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLensReviewsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLensReviewsOutputResponse(lensReviewSummaries: \(String(describing: lensReviewSummaries)), milestoneNumber: \(String(describing: milestoneNumber)), nextToken: \(String(describing: nextToken)), workloadId: \(String(describing: workloadId)))"}
}

extension ListLensReviewsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLensReviewsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lensReviewSummaries = output.lensReviewSummaries
            self.milestoneNumber = output.milestoneNumber
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.lensReviewSummaries = nil
            self.milestoneNumber = 0
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// <p>Output of a list lens reviews call.</p>
public struct ListLensReviewsOutputResponse: Equatable {
    /// <p>List of lens summaries of lens reviews of a workload.</p>
    public let lensReviewSummaries: [LensReviewSummary]?
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        lensReviewSummaries: [LensReviewSummary]? = nil,
        milestoneNumber: Int = 0,
        nextToken: String? = nil,
        workloadId: String? = nil
    )
    {
        self.lensReviewSummaries = lensReviewSummaries
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListLensReviewsOutputResponseBody: Equatable {
    public let workloadId: String?
    public let milestoneNumber: Int
    public let lensReviewSummaries: [LensReviewSummary]?
    public let nextToken: String?
}

extension ListLensReviewsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lensReviewSummaries = "LensReviewSummaries"
        case milestoneNumber = "MilestoneNumber"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensReviewSummariesContainer = try containerValues.decodeIfPresent([LensReviewSummary?].self, forKey: .lensReviewSummaries)
        var lensReviewSummariesDecoded0:[LensReviewSummary]? = nil
        if let lensReviewSummariesContainer = lensReviewSummariesContainer {
            lensReviewSummariesDecoded0 = [LensReviewSummary]()
            for structure0 in lensReviewSummariesContainer {
                if let structure0 = structure0 {
                    lensReviewSummariesDecoded0?.append(structure0)
                }
            }
        }
        lensReviewSummaries = lensReviewSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLensesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLensesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLensesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListLensesInputHeadersMiddleware: Middleware {
    public let id: String = "ListLensesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLensesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLensesInput>
    public typealias MOutput = OperationOutput<ListLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLensesOutputError>
}

public struct ListLensesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLensesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLensesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLensesInput>
    public typealias MOutput = OperationOutput<ListLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLensesOutputError>
}

/// <p>Input to list lenses.</p>
public struct ListLensesInput: Equatable {
    /// <p>The maximum number of results to return for this request.</p>
    public let maxResults: Int
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLensesInputBody: Equatable {
}

extension ListLensesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListLensesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLensesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLensesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLensesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLensesOutputResponse(lensSummaries: \(String(describing: lensSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLensesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLensesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lensSummaries = output.lensSummaries
            self.nextToken = output.nextToken
        } else {
            self.lensSummaries = nil
            self.nextToken = nil
        }
    }
}

/// <p>Output of a list lenses call.</p>
public struct ListLensesOutputResponse: Equatable {
    /// <p>List of lens summaries of available lenses.</p>
    public let lensSummaries: [LensSummary]?
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        lensSummaries: [LensSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.lensSummaries = lensSummaries
        self.nextToken = nextToken
    }
}

struct ListLensesOutputResponseBody: Equatable {
    public let lensSummaries: [LensSummary]?
    public let nextToken: String?
}

extension ListLensesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lensSummaries = "LensSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensSummariesContainer = try containerValues.decodeIfPresent([LensSummary?].self, forKey: .lensSummaries)
        var lensSummariesDecoded0:[LensSummary]? = nil
        if let lensSummariesContainer = lensSummariesContainer {
            lensSummariesDecoded0 = [LensSummary]()
            for structure0 in lensSummariesContainer {
                if let structure0 = structure0 {
                    lensSummariesDecoded0?.append(structure0)
                }
            }
        }
        lensSummaries = lensSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListMilestonesInputBodyMiddleware: Middleware {
    public let id: String = "ListMilestonesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMilestonesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMilestonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMilestonesInput>
    public typealias MOutput = OperationOutput<ListMilestonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMilestonesOutputError>
}

extension ListMilestonesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMilestonesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), workloadId: \(String(describing: workloadId)))"}
}

extension ListMilestonesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListMilestonesInputHeadersMiddleware: Middleware {
    public let id: String = "ListMilestonesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMilestonesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMilestonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMilestonesInput>
    public typealias MOutput = OperationOutput<ListMilestonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMilestonesOutputError>
}

public struct ListMilestonesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMilestonesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMilestonesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMilestonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMilestonesInput>
    public typealias MOutput = OperationOutput<ListMilestonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMilestonesOutputError>
}

/// <p>Input to list all milestones for a workload.</p>
public struct ListMilestonesInput: Equatable {
    /// <p>The maximum number of results to return for this request.</p>
    public let maxResults: Int
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        workloadId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListMilestonesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int
}

extension ListMilestonesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMilestonesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMilestonesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMilestonesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMilestonesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMilestonesOutputResponse(milestoneSummaries: \(String(describing: milestoneSummaries)), nextToken: \(String(describing: nextToken)), workloadId: \(String(describing: workloadId)))"}
}

extension ListMilestonesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMilestonesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.milestoneSummaries = output.milestoneSummaries
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.milestoneSummaries = nil
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// <p>Output of a list milestones call.</p>
public struct ListMilestonesOutputResponse: Equatable {
    /// <p>A list of milestone summaries.</p>
    public let milestoneSummaries: [MilestoneSummary]?
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        milestoneSummaries: [MilestoneSummary]? = nil,
        nextToken: String? = nil,
        workloadId: String? = nil
    )
    {
        self.milestoneSummaries = milestoneSummaries
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListMilestonesOutputResponseBody: Equatable {
    public let workloadId: String?
    public let milestoneSummaries: [MilestoneSummary]?
    public let nextToken: String?
}

extension ListMilestonesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case milestoneSummaries = "MilestoneSummaries"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneSummariesContainer = try containerValues.decodeIfPresent([MilestoneSummary?].self, forKey: .milestoneSummaries)
        var milestoneSummariesDecoded0:[MilestoneSummary]? = nil
        if let milestoneSummariesContainer = milestoneSummariesContainer {
            milestoneSummariesDecoded0 = [MilestoneSummary]()
            for structure0 in milestoneSummariesContainer {
                if let structure0 = structure0 {
                    milestoneSummariesDecoded0?.append(structure0)
                }
            }
        }
        milestoneSummaries = milestoneSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListNotificationsInputBodyMiddleware: Middleware {
    public let id: String = "ListNotificationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNotificationsInput>
    public typealias MOutput = OperationOutput<ListNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNotificationsOutputError>
}

extension ListNotificationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNotificationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), workloadId: \(String(describing: workloadId)))"}
}

extension ListNotificationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
    }
}

public struct ListNotificationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNotificationsInput>
    public typealias MOutput = OperationOutput<ListNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNotificationsOutputError>
}

public struct ListNotificationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNotificationsInput>
    public typealias MOutput = OperationOutput<ListNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNotificationsOutputError>
}

public struct ListNotificationsInput: Equatable {
    /// <p>The maximum number of results to return for this request.</p>
    public let maxResults: Int
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        workloadId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListNotificationsInputBody: Equatable {
    public let workloadId: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListNotificationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListNotificationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNotificationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNotificationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNotificationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNotificationsOutputResponse(nextToken: \(String(describing: nextToken)), notificationSummaries: \(String(describing: notificationSummaries)))"}
}

extension ListNotificationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListNotificationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.notificationSummaries = output.notificationSummaries
        } else {
            self.nextToken = nil
            self.notificationSummaries = nil
        }
    }
}

public struct ListNotificationsOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>List of lens notification summaries in a workload.</p>
    public let notificationSummaries: [NotificationSummary]?

    public init (
        nextToken: String? = nil,
        notificationSummaries: [NotificationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.notificationSummaries = notificationSummaries
    }
}

struct ListNotificationsOutputResponseBody: Equatable {
    public let notificationSummaries: [NotificationSummary]?
    public let nextToken: String?
}

extension ListNotificationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case notificationSummaries = "NotificationSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationSummariesContainer = try containerValues.decodeIfPresent([NotificationSummary?].self, forKey: .notificationSummaries)
        var notificationSummariesDecoded0:[NotificationSummary]? = nil
        if let notificationSummariesContainer = notificationSummariesContainer {
            notificationSummariesDecoded0 = [NotificationSummary]()
            for structure0 in notificationSummariesContainer {
                if let structure0 = structure0 {
                    notificationSummariesDecoded0?.append(structure0)
                }
            }
        }
        notificationSummaries = notificationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListShareInvitationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListShareInvitationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), workloadNamePrefix: \(String(describing: workloadNamePrefix)))"}
}

extension ListShareInvitationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListShareInvitationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListShareInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListShareInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListShareInvitationsInput>
    public typealias MOutput = OperationOutput<ListShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListShareInvitationsOutputError>
}

public struct ListShareInvitationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListShareInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListShareInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let workloadNamePrefix = input.operationInput.workloadNamePrefix {
            let workloadNamePrefixQueryItem = URLQueryItem(name: "WorkloadNamePrefix".urlPercentEncoding(), value: String(workloadNamePrefix).urlPercentEncoding())
            input.builder.withQueryItem(workloadNamePrefixQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListShareInvitationsInput>
    public typealias MOutput = OperationOutput<ListShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListShareInvitationsOutputError>
}

/// <p>Input for List Share Invitations</p>
public struct ListShareInvitationsInput: Equatable {
    /// <p>The maximum number of results to return for this request.</p>
    public let maxResults: Int
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>An optional string added to the beginning of each workload name returned in the
    ///             results.</p>
    public let workloadNamePrefix: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        workloadNamePrefix: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadNamePrefix = workloadNamePrefix
    }
}

struct ListShareInvitationsInputBody: Equatable {
}

extension ListShareInvitationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListShareInvitationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListShareInvitationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListShareInvitationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListShareInvitationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListShareInvitationsOutputResponse(nextToken: \(String(describing: nextToken)), shareInvitationSummaries: \(String(describing: shareInvitationSummaries)))"}
}

extension ListShareInvitationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListShareInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.shareInvitationSummaries = output.shareInvitationSummaries
        } else {
            self.nextToken = nil
            self.shareInvitationSummaries = nil
        }
    }
}

/// <p>Input for List Share Invitations</p>
public struct ListShareInvitationsOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>List of share invitation summaries in a workload.</p>
    public let shareInvitationSummaries: [ShareInvitationSummary]?

    public init (
        nextToken: String? = nil,
        shareInvitationSummaries: [ShareInvitationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.shareInvitationSummaries = shareInvitationSummaries
    }
}

struct ListShareInvitationsOutputResponseBody: Equatable {
    public let shareInvitationSummaries: [ShareInvitationSummary]?
    public let nextToken: String?
}

extension ListShareInvitationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case shareInvitationSummaries = "ShareInvitationSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationSummariesContainer = try containerValues.decodeIfPresent([ShareInvitationSummary?].self, forKey: .shareInvitationSummaries)
        var shareInvitationSummariesDecoded0:[ShareInvitationSummary]? = nil
        if let shareInvitationSummariesContainer = shareInvitationSummariesContainer {
            shareInvitationSummariesDecoded0 = [ShareInvitationSummary]()
            for structure0 in shareInvitationSummariesContainer {
                if let structure0 = structure0 {
                    shareInvitationSummariesDecoded0?.append(structure0)
                }
            }
        }
        shareInvitationSummaries = shareInvitationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(workloadArn: \(String(describing: workloadArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN for the workload.</p>
    public let workloadArn: String?

    public init (
        workloadArn: String? = nil
    )
    {
        self.workloadArn = workloadArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags for the resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListWorkloadSharesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorkloadSharesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sharedWithPrefix: \(String(describing: sharedWithPrefix)), workloadId: \(String(describing: workloadId)))"}
}

extension ListWorkloadSharesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListWorkloadSharesInputHeadersMiddleware: Middleware {
    public let id: String = "ListWorkloadSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkloadSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkloadSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkloadSharesInput>
    public typealias MOutput = OperationOutput<ListWorkloadSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkloadSharesOutputError>
}

public struct ListWorkloadSharesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWorkloadSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkloadSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkloadSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let sharedWithPrefix = input.operationInput.sharedWithPrefix {
            let sharedWithPrefixQueryItem = URLQueryItem(name: "SharedWithPrefix".urlPercentEncoding(), value: String(sharedWithPrefix).urlPercentEncoding())
            input.builder.withQueryItem(sharedWithPrefixQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkloadSharesInput>
    public typealias MOutput = OperationOutput<ListWorkloadSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkloadSharesOutputError>
}

/// <p>Input for List Workload Share</p>
public struct ListWorkloadSharesInput: Equatable {
    /// <p>The maximum number of results to return for this request.</p>
    public let maxResults: Int
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The AWS account ID or IAM role with which the workload is shared.</p>
    public let sharedWithPrefix: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        sharedWithPrefix: String? = nil,
        workloadId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sharedWithPrefix = sharedWithPrefix
        self.workloadId = workloadId
    }
}

struct ListWorkloadSharesInputBody: Equatable {
}

extension ListWorkloadSharesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListWorkloadSharesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkloadSharesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkloadSharesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkloadSharesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorkloadSharesOutputResponse(nextToken: \(String(describing: nextToken)), workloadId: \(String(describing: workloadId)), workloadShareSummaries: \(String(describing: workloadShareSummaries)))"}
}

extension ListWorkloadSharesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWorkloadSharesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
            self.workloadShareSummaries = output.workloadShareSummaries
        } else {
            self.nextToken = nil
            self.workloadId = nil
            self.workloadShareSummaries = nil
        }
    }
}

/// <p>Input for List Workload Share</p>
public struct ListWorkloadSharesOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?
    /// <p>A list of workload share summaries.</p>
    public let workloadShareSummaries: [WorkloadShareSummary]?

    public init (
        nextToken: String? = nil,
        workloadId: String? = nil,
        workloadShareSummaries: [WorkloadShareSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloadId = workloadId
        self.workloadShareSummaries = workloadShareSummaries
    }
}

struct ListWorkloadSharesOutputResponseBody: Equatable {
    public let workloadId: String?
    public let workloadShareSummaries: [WorkloadShareSummary]?
    public let nextToken: String?
}

extension ListWorkloadSharesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
        case workloadShareSummaries = "WorkloadShareSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadShareSummariesContainer = try containerValues.decodeIfPresent([WorkloadShareSummary?].self, forKey: .workloadShareSummaries)
        var workloadShareSummariesDecoded0:[WorkloadShareSummary]? = nil
        if let workloadShareSummariesContainer = workloadShareSummariesContainer {
            workloadShareSummariesDecoded0 = [WorkloadShareSummary]()
            for structure0 in workloadShareSummariesContainer {
                if let structure0 = structure0 {
                    workloadShareSummariesDecoded0?.append(structure0)
                }
            }
        }
        workloadShareSummaries = workloadShareSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListWorkloadsInputBodyMiddleware: Middleware {
    public let id: String = "ListWorkloadsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkloadsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkloadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkloadsInput>
    public typealias MOutput = OperationOutput<ListWorkloadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkloadsOutputError>
}

extension ListWorkloadsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorkloadsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), workloadNamePrefix: \(String(describing: workloadNamePrefix)))"}
}

extension ListWorkloadsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workloadNamePrefix = "WorkloadNamePrefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workloadNamePrefix = workloadNamePrefix {
            try encodeContainer.encode(workloadNamePrefix, forKey: .workloadNamePrefix)
        }
    }
}

public struct ListWorkloadsInputHeadersMiddleware: Middleware {
    public let id: String = "ListWorkloadsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkloadsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkloadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkloadsInput>
    public typealias MOutput = OperationOutput<ListWorkloadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkloadsOutputError>
}

public struct ListWorkloadsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWorkloadsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkloadsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkloadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkloadsInput>
    public typealias MOutput = OperationOutput<ListWorkloadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkloadsOutputError>
}

/// <p>Input to list all workloads.</p>
public struct ListWorkloadsInput: Equatable {
    /// <p>The maximum number of results to return for this request.</p>
    public let maxResults: Int
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>An optional string added to the beginning of each workload name returned in the
    ///             results.</p>
    public let workloadNamePrefix: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        workloadNamePrefix: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadNamePrefix = workloadNamePrefix
    }
}

struct ListWorkloadsInputBody: Equatable {
    public let workloadNamePrefix: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListWorkloadsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workloadNamePrefix = "WorkloadNamePrefix"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNamePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadNamePrefix)
        workloadNamePrefix = workloadNamePrefixDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorkloadsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkloadsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkloadsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkloadsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorkloadsOutputResponse(nextToken: \(String(describing: nextToken)), workloadSummaries: \(String(describing: workloadSummaries)))"}
}

extension ListWorkloadsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWorkloadsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.workloadSummaries = output.workloadSummaries
        } else {
            self.nextToken = nil
            self.workloadSummaries = nil
        }
    }
}

/// <p>Output of a list workloads call.</p>
public struct ListWorkloadsOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>A list of workload summaries.</p>
    public let workloadSummaries: [WorkloadSummary]?

    public init (
        nextToken: String? = nil,
        workloadSummaries: [WorkloadSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloadSummaries = workloadSummaries
    }
}

struct ListWorkloadsOutputResponseBody: Equatable {
    public let workloadSummaries: [WorkloadSummary]?
    public let nextToken: String?
}

extension ListWorkloadsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case workloadSummaries = "WorkloadSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadSummariesContainer = try containerValues.decodeIfPresent([WorkloadSummary?].self, forKey: .workloadSummaries)
        var workloadSummariesDecoded0:[WorkloadSummary]? = nil
        if let workloadSummariesContainer = workloadSummariesContainer {
            workloadSummariesDecoded0 = [WorkloadSummary]()
            for structure0 in workloadSummariesContainer {
                if let structure0 = structure0 {
                    workloadSummariesDecoded0?.append(structure0)
                }
            }
        }
        workloadSummaries = workloadSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Milestone: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case milestoneName = "MilestoneName"
        case milestoneNumber = "MilestoneNumber"
        case recordedAt = "RecordedAt"
        case workload = "Workload"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let milestoneName = milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
        if milestoneNumber != 0 {
            try encodeContainer.encode(milestoneNumber, forKey: .milestoneNumber)
        }
        if let recordedAt = recordedAt {
            try encodeContainer.encode(recordedAt.timeIntervalSince1970, forKey: .recordedAt)
        }
        if let workload = workload {
            try encodeContainer.encode(workload, forKey: .workload)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNumberDecoded = try containerValues.decode(Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let milestoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let recordedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .recordedAt)
        recordedAt = recordedAtDecoded
        let workloadDecoded = try containerValues.decodeIfPresent(Workload.self, forKey: .workload)
        workload = workloadDecoded
    }
}

extension Milestone: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Milestone(milestoneName: \(String(describing: milestoneName)), milestoneNumber: \(String(describing: milestoneNumber)), recordedAt: \(String(describing: recordedAt)), workload: \(String(describing: workload)))"}
}

/// <p>A milestone return object.</p>
public struct Milestone: Equatable {
    /// <p>The name of the milestone in a workload.</p>
    ///         <p>Milestone names must be unique within a workload.</p>
    public let milestoneName: String?
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The date and time recorded.</p>
    public let recordedAt: Date?
    /// <p>A workload return object.</p>
    public let workload: Workload?

    public init (
        milestoneName: String? = nil,
        milestoneNumber: Int = 0,
        recordedAt: Date? = nil,
        workload: Workload? = nil
    )
    {
        self.milestoneName = milestoneName
        self.milestoneNumber = milestoneNumber
        self.recordedAt = recordedAt
        self.workload = workload
    }
}

extension MilestoneSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case milestoneName = "MilestoneName"
        case milestoneNumber = "MilestoneNumber"
        case recordedAt = "RecordedAt"
        case workloadSummary = "WorkloadSummary"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let milestoneName = milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
        if milestoneNumber != 0 {
            try encodeContainer.encode(milestoneNumber, forKey: .milestoneNumber)
        }
        if let recordedAt = recordedAt {
            try encodeContainer.encode(recordedAt.timeIntervalSince1970, forKey: .recordedAt)
        }
        if let workloadSummary = workloadSummary {
            try encodeContainer.encode(workloadSummary, forKey: .workloadSummary)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNumberDecoded = try containerValues.decode(Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let milestoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let recordedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .recordedAt)
        recordedAt = recordedAtDecoded
        let workloadSummaryDecoded = try containerValues.decodeIfPresent(WorkloadSummary.self, forKey: .workloadSummary)
        workloadSummary = workloadSummaryDecoded
    }
}

extension MilestoneSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MilestoneSummary(milestoneName: \(String(describing: milestoneName)), milestoneNumber: \(String(describing: milestoneNumber)), recordedAt: \(String(describing: recordedAt)), workloadSummary: \(String(describing: workloadSummary)))"}
}

/// <p>A milestone summary return object.</p>
public struct MilestoneSummary: Equatable {
    /// <p>The name of the milestone in a workload.</p>
    ///         <p>Milestone names must be unique within a workload.</p>
    public let milestoneName: String?
    /// <p>The milestone number.</p>
    ///         <p>A workload can have a maximum of 100 milestones.</p>
    public let milestoneNumber: Int
    /// <p>The date and time recorded.</p>
    public let recordedAt: Date?
    /// <p>A workload summary return object.</p>
    public let workloadSummary: WorkloadSummary?

    public init (
        milestoneName: String? = nil,
        milestoneNumber: Int = 0,
        recordedAt: Date? = nil,
        workloadSummary: WorkloadSummary? = nil
    )
    {
        self.milestoneName = milestoneName
        self.milestoneNumber = milestoneNumber
        self.recordedAt = recordedAt
        self.workloadSummary = workloadSummary
    }
}

extension NotificationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lensUpgradeSummary = "LensUpgradeSummary"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensUpgradeSummary = lensUpgradeSummary {
            try encodeContainer.encode(lensUpgradeSummary, forKey: .lensUpgradeSummary)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(NotificationType.self, forKey: .type)
        type = typeDecoded
        let lensUpgradeSummaryDecoded = try containerValues.decodeIfPresent(LensUpgradeSummary.self, forKey: .lensUpgradeSummary)
        lensUpgradeSummary = lensUpgradeSummaryDecoded
    }
}

extension NotificationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationSummary(lensUpgradeSummary: \(String(describing: lensUpgradeSummary)), type: \(String(describing: type)))"}
}

/// <p>A notification summary return object.</p>
public struct NotificationSummary: Equatable {
    /// <p>Summary of lens upgrade.</p>
    public let lensUpgradeSummary: LensUpgradeSummary?
    /// <p>The type of notification.</p>
    public let type: NotificationType?

    public init (
        lensUpgradeSummary: LensUpgradeSummary? = nil,
        type: NotificationType? = nil
    )
    {
        self.lensUpgradeSummary = lensUpgradeSummary
        self.type = type
    }
}

public enum NotificationType {
    case lensVersionDeprecated
    case lensVersionUpgraded
    case sdkUnknown(String)
}

extension NotificationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NotificationType] {
        return [
            .lensVersionDeprecated,
            .lensVersionUpgraded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lensVersionDeprecated: return "LENS_VERSION_DEPRECATED"
        case .lensVersionUpgraded: return "LENS_VERSION_UPGRADED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NotificationType(rawValue: rawValue) ?? NotificationType.sdkUnknown(rawValue)
    }
}

/// <p>Permission granted on a workload share.</p>
public enum PermissionType {
    case contributor
    case readonly
    case sdkUnknown(String)
}

extension PermissionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PermissionType] {
        return [
            .contributor,
            .readonly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contributor: return "CONTRIBUTOR"
        case .readonly: return "READONLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PermissionType(rawValue: rawValue) ?? PermissionType.sdkUnknown(rawValue)
    }
}

extension PillarDifference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case differenceStatus = "DifferenceStatus"
        case pillarId = "PillarId"
        case questionDifferences = "QuestionDifferences"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let differenceStatus = differenceStatus {
            try encodeContainer.encode(differenceStatus.rawValue, forKey: .differenceStatus)
        }
        if let pillarId = pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionDifferences = questionDifferences {
            var questionDifferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .questionDifferences)
            for questiondifferences0 in questionDifferences {
                try questionDifferencesContainer.encode(questiondifferences0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pillarIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let differenceStatusDecoded = try containerValues.decodeIfPresent(DifferenceStatus.self, forKey: .differenceStatus)
        differenceStatus = differenceStatusDecoded
        let questionDifferencesContainer = try containerValues.decodeIfPresent([QuestionDifference?].self, forKey: .questionDifferences)
        var questionDifferencesDecoded0:[QuestionDifference]? = nil
        if let questionDifferencesContainer = questionDifferencesContainer {
            questionDifferencesDecoded0 = [QuestionDifference]()
            for structure0 in questionDifferencesContainer {
                if let structure0 = structure0 {
                    questionDifferencesDecoded0?.append(structure0)
                }
            }
        }
        questionDifferences = questionDifferencesDecoded0
    }
}

extension PillarDifference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PillarDifference(differenceStatus: \(String(describing: differenceStatus)), pillarId: \(String(describing: pillarId)), questionDifferences: \(String(describing: questionDifferences)))"}
}

/// <p>A pillar difference return object.</p>
public struct PillarDifference: Equatable {
    /// <p>Indicates the type of change to the pillar.</p>
    public let differenceStatus: DifferenceStatus?
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    ///         <p>A pillar is identified by its <a>PillarReviewSummary$PillarId</a>.</p>
    public let pillarId: String?
    /// <p>List of question differences.</p>
    public let questionDifferences: [QuestionDifference]?

    public init (
        differenceStatus: DifferenceStatus? = nil,
        pillarId: String? = nil,
        questionDifferences: [QuestionDifference]? = nil
    )
    {
        self.differenceStatus = differenceStatus
        self.pillarId = pillarId
        self.questionDifferences = questionDifferences
    }
}

extension PillarReviewSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case notes = "Notes"
        case pillarId = "PillarId"
        case pillarName = "PillarName"
        case riskCounts = "RiskCounts"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarId = pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let pillarName = pillarName {
            try encodeContainer.encode(pillarName, forKey: .pillarName)
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pillarIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let pillarNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pillarName)
        pillarName = pillarNameDecoded
        let notesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notes)
        notes = notesDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [String:Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [String:Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
    }
}

extension PillarReviewSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PillarReviewSummary(notes: \(String(describing: notes)), pillarId: \(String(describing: pillarId)), pillarName: \(String(describing: pillarName)), riskCounts: \(String(describing: riskCounts)))"}
}

/// <p>A pillar review summary of a lens review.</p>
public struct PillarReviewSummary: Equatable {
    /// <p>The notes associated with the workload.</p>
    public let notes: String?
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    ///         <p>A pillar is identified by its <a>PillarReviewSummary$PillarId</a>.</p>
    public let pillarId: String?
    /// <p>The name of the pillar.</p>
    public let pillarName: String?
    /// <p>A map from risk names to the count of how questions have that rating.</p>
    public let riskCounts: [String:Int]?

    public init (
        notes: String? = nil,
        pillarId: String? = nil,
        pillarName: String? = nil,
        riskCounts: [String:Int]? = nil
    )
    {
        self.notes = notes
        self.pillarId = pillarId
        self.pillarName = pillarName
        self.riskCounts = riskCounts
    }
}

extension QuestionDifference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case differenceStatus = "DifferenceStatus"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let differenceStatus = differenceStatus {
            try encodeContainer.encode(differenceStatus.rawValue, forKey: .differenceStatus)
        }
        if let questionId = questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let differenceStatusDecoded = try containerValues.decodeIfPresent(DifferenceStatus.self, forKey: .differenceStatus)
        differenceStatus = differenceStatusDecoded
    }
}

extension QuestionDifference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QuestionDifference(differenceStatus: \(String(describing: differenceStatus)), questionId: \(String(describing: questionId)), questionTitle: \(String(describing: questionTitle)))"}
}

/// <p>A question difference return object.</p>
public struct QuestionDifference: Equatable {
    /// <p>Indicates the type of change to the question.</p>
    public let differenceStatus: DifferenceStatus?
    /// <p>The ID of the question.</p>
    public let questionId: String?
    /// <p>The title of the question.</p>
    public let questionTitle: String?

    public init (
        differenceStatus: DifferenceStatus? = nil,
        questionId: String? = nil,
        questionTitle: String? = nil
    )
    {
        self.differenceStatus = differenceStatus
        self.questionId = questionId
        self.questionTitle = questionTitle
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Description of the error.</p>
    public var message: String?
    /// <p>Identifier of the resource affected.</p>
    public var resourceId: String?
    /// <p>Type of the resource affected.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

/// <p>The risk for a given workload, lens review, pillar, or question.</p>
public enum Risk {
    case high
    case medium
    case `none`
    case notApplicable
    case unanswered
    case sdkUnknown(String)
}

extension Risk : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Risk] {
        return [
            .high,
            .medium,
            .none,
            .notApplicable,
            .unanswered,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .high: return "HIGH"
        case .medium: return "MEDIUM"
        case .none: return "NONE"
        case .notApplicable: return "NOT_APPLICABLE"
        case .unanswered: return "UNANSWERED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Risk(rawValue: rawValue) ?? Risk.sdkUnknown(rawValue)
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user has reached their resource quota.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Description of the error.</p>
    public var message: String?
    /// <p>Service Quotas requirement to identify originating quota.</p>
    public var quotaCode: String?
    /// <p>Identifier of the resource affected.</p>
    public var resourceId: String?
    /// <p>Type of the resource affected.</p>
    public var resourceType: String?
    /// <p>Service Quotas requirement to identify originating service.</p>
    public var serviceCode: String?

    public init (
        message: String? = nil,
        quotaCode: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
    public let quotaCode: String?
    public let serviceCode: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension ShareInvitation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case shareInvitationId = "ShareInvitationId"
        case workloadId = "WorkloadId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shareInvitationId = shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
    }
}

extension ShareInvitation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ShareInvitation(shareInvitationId: \(String(describing: shareInvitationId)), workloadId: \(String(describing: workloadId)))"}
}

/// <p>The share invitation.</p>
public struct ShareInvitation: Equatable {
    /// <p>The ID assigned to the share invitation.</p>
    public let shareInvitationId: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        shareInvitationId: String? = nil,
        workloadId: String? = nil
    )
    {
        self.shareInvitationId = shareInvitationId
        self.workloadId = workloadId
    }
}

/// <p>Share invitation action taken by contributor.</p>
public enum ShareInvitationAction {
    case accept
    case reject
    case sdkUnknown(String)
}

extension ShareInvitationAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ShareInvitationAction] {
        return [
            .accept,
            .reject,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accept: return "ACCEPT"
        case .reject: return "REJECT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ShareInvitationAction(rawValue: rawValue) ?? ShareInvitationAction.sdkUnknown(rawValue)
    }
}

extension ShareInvitationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case permissionType = "PermissionType"
        case shareInvitationId = "ShareInvitationId"
        case sharedBy = "SharedBy"
        case sharedWith = "SharedWith"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let shareInvitationId = shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
        if let sharedBy = sharedBy {
            try encodeContainer.encode(sharedBy, forKey: .sharedBy)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
        let sharedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedBy)
        sharedBy = sharedByDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
    }
}

extension ShareInvitationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ShareInvitationSummary(permissionType: \(String(describing: permissionType)), shareInvitationId: \(String(describing: shareInvitationId)), sharedBy: \(String(describing: sharedBy)), sharedWith: \(String(describing: sharedWith)), workloadId: \(String(describing: workloadId)), workloadName: \(String(describing: workloadName)))"}
}

/// <p>A share invitation summary return object.</p>
public struct ShareInvitationSummary: Equatable {
    /// <p>Permission granted on a workload share.</p>
    public let permissionType: PermissionType?
    /// <p>The ID assigned to the share invitation.</p>
    public let shareInvitationId: String?
    /// <p>An AWS account ID.</p>
    public let sharedBy: String?
    /// <p>The AWS account ID or IAM role with which the workload is shared.</p>
    public let sharedWith: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?
    /// <p>The name of the workload.</p>
    ///         <p>The name must be unique within an account within a Region. Spaces and capitalization
    ///             are ignored when checking for uniqueness.</p>
    public let workloadName: String?

    public init (
        permissionType: PermissionType? = nil,
        shareInvitationId: String? = nil,
        sharedBy: String? = nil,
        sharedWith: String? = nil,
        workloadId: String? = nil,
        workloadName: String? = nil
    )
    {
        self.permissionType = permissionType
        self.shareInvitationId = shareInvitationId
        self.sharedBy = sharedBy
        self.sharedWith = sharedWith
        self.workloadId = workloadId
        self.workloadName = workloadName
    }
}

/// <p>The status of a workload share.</p>
public enum ShareStatus {
    case accepted
    case expired
    case pending
    case rejected
    case revoked
    case sdkUnknown(String)
}

extension ShareStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ShareStatus] {
        return [
            .accepted,
            .expired,
            .pending,
            .rejected,
            .revoked,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accepted: return "ACCEPTED"
        case .expired: return "EXPIRED"
        case .pending: return "PENDING"
        case .rejected: return "REJECTED"
        case .revoked: return "REVOKED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ShareStatus(rawValue: rawValue) ?? ShareStatus.sdkUnknown(rawValue)
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(tags: \(String(describing: tags)), workloadArn: \(String(describing: workloadArn)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The tags for the resource.</p>
    public let tags: [String:String]?
    /// <p>The ARN for the workload.</p>
    public let workloadArn: String?

    public init (
        tags: [String:String]? = nil,
        workloadArn: String? = nil
    )
    {
        self.tags = tags
        self.workloadArn = workloadArn
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Description of the error.</p>
    public var message: String?
    /// <p>Service Quotas requirement to identify originating quota.</p>
    public var quotaCode: String?
    /// <p>Service Quotas requirement to identify originating service.</p>
    public var serviceCode: String?

    public init (
        message: String? = nil,
        quotaCode: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
    public let quotaCode: String?
    public let serviceCode: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(tagKeys: \(String(describing: tagKeys)), workloadArn: \(String(describing: workloadArn)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The keys of the tags to be removed.</p>
    public let tagKeys: [String]?
    /// <p>The ARN for the workload.</p>
    public let workloadArn: String?

    public init (
        tagKeys: [String]? = nil,
        workloadArn: String? = nil
    )
    {
        self.tagKeys = tagKeys
        self.workloadArn = workloadArn
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAnswerInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAnswerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnswerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnswerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnswerInput>
    public typealias MOutput = OperationOutput<UpdateAnswerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnswerOutputError>
}

extension UpdateAnswerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAnswerInput(isApplicable: \(String(describing: isApplicable)), lensAlias: \(String(describing: lensAlias)), notes: \(String(describing: notes)), questionId: \(String(describing: questionId)), selectedChoices: \(String(describing: selectedChoices)), workloadId: \(String(describing: workloadId)))"}
}

extension UpdateAnswerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isApplicable = "IsApplicable"
        case notes = "Notes"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isApplicable != false {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for selectedchoices0 in selectedChoices {
                try selectedChoicesContainer.encode(selectedchoices0)
            }
        }
    }
}

public struct UpdateAnswerInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAnswerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnswerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnswerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnswerInput>
    public typealias MOutput = OperationOutput<UpdateAnswerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnswerOutputError>
}

public struct UpdateAnswerInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAnswerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnswerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnswerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnswerInput>
    public typealias MOutput = OperationOutput<UpdateAnswerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnswerOutputError>
}

/// <p>Input to update answer.</p>
public struct UpdateAnswerInput: Equatable {
    /// <p>Defines whether this question is applicable to a lens review.</p>
    public let isApplicable: Bool
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The notes associated with the workload.</p>
    public let notes: String?
    /// <p>The ID of the question.</p>
    public let questionId: String?
    /// <p>List of selected choice IDs in a question answer.</p>
    ///         <p>The values entered replace the previously selected choices.</p>
    public let selectedChoices: [String]?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        isApplicable: Bool = false,
        lensAlias: String? = nil,
        notes: String? = nil,
        questionId: String? = nil,
        selectedChoices: [String]? = nil,
        workloadId: String? = nil
    )
    {
        self.isApplicable = isApplicable
        self.lensAlias = lensAlias
        self.notes = notes
        self.questionId = questionId
        self.selectedChoices = selectedChoices
        self.workloadId = workloadId
    }
}

struct UpdateAnswerInputBody: Equatable {
    public let selectedChoices: [String]?
    public let notes: String?
    public let isApplicable: Bool
}

extension UpdateAnswerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isApplicable = "IsApplicable"
        case notes = "Notes"
        case selectedChoices = "SelectedChoices"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedChoicesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let notesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notes)
        notes = notesDecoded
        let isApplicableDecoded = try containerValues.decode(Bool.self, forKey: .isApplicable)
        isApplicable = isApplicableDecoded
    }
}

extension UpdateAnswerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnswerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAnswerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnswerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAnswerOutputResponse(answer: \(String(describing: answer)), lensAlias: \(String(describing: lensAlias)), workloadId: \(String(describing: workloadId)))"}
}

extension UpdateAnswerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAnswerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.answer = output.answer
            self.lensAlias = output.lensAlias
            self.workloadId = output.workloadId
        } else {
            self.answer = nil
            self.lensAlias = nil
            self.workloadId = nil
        }
    }
}

/// <p>Output of a update answer call.</p>
public struct UpdateAnswerOutputResponse: Equatable {
    /// <p>An answer of the question.</p>
    public let answer: Answer?
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        answer: Answer? = nil,
        lensAlias: String? = nil,
        workloadId: String? = nil
    )
    {
        self.answer = answer
        self.lensAlias = lensAlias
        self.workloadId = workloadId
    }
}

struct UpdateAnswerOutputResponseBody: Equatable {
    public let workloadId: String?
    public let lensAlias: String?
    public let answer: Answer?
}

extension UpdateAnswerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case answer = "Answer"
        case lensAlias = "LensAlias"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let answerDecoded = try containerValues.decodeIfPresent(Answer.self, forKey: .answer)
        answer = answerDecoded
    }
}

public struct UpdateLensReviewInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLensReviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLensReviewInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLensReviewInput>
    public typealias MOutput = OperationOutput<UpdateLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLensReviewOutputError>
}

extension UpdateLensReviewInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLensReviewInput(lensAlias: \(String(describing: lensAlias)), lensNotes: \(String(describing: lensNotes)), pillarNotes: \(String(describing: pillarNotes)), workloadId: \(String(describing: workloadId)))"}
}

extension UpdateLensReviewInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lensNotes = "LensNotes"
        case pillarNotes = "PillarNotes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensNotes = lensNotes {
            try encodeContainer.encode(lensNotes, forKey: .lensNotes)
        }
        if let pillarNotes = pillarNotes {
            var pillarNotesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .pillarNotes)
            for (dictKey0, pillarnotes0) in pillarNotes {
                try pillarNotesContainer.encode(pillarnotes0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateLensReviewInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLensReviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLensReviewInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLensReviewInput>
    public typealias MOutput = OperationOutput<UpdateLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLensReviewOutputError>
}

public struct UpdateLensReviewInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLensReviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLensReviewInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLensReviewInput>
    public typealias MOutput = OperationOutput<UpdateLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLensReviewOutputError>
}

/// <p>Input for update lens review.</p>
public struct UpdateLensReviewInput: Equatable {
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The notes associated with the workload.</p>
    public let lensNotes: String?
    /// <p>List of pillar notes of a lens review in a workload.</p>
    public let pillarNotes: [String:String]?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        lensAlias: String? = nil,
        lensNotes: String? = nil,
        pillarNotes: [String:String]? = nil,
        workloadId: String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.lensNotes = lensNotes
        self.pillarNotes = pillarNotes
        self.workloadId = workloadId
    }
}

struct UpdateLensReviewInputBody: Equatable {
    public let lensNotes: String?
    public let pillarNotes: [String:String]?
}

extension UpdateLensReviewInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lensNotes = "LensNotes"
        case pillarNotes = "PillarNotes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensNotesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lensNotes)
        lensNotes = lensNotesDecoded
        let pillarNotesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .pillarNotes)
        var pillarNotesDecoded0: [String:String]? = nil
        if let pillarNotesContainer = pillarNotesContainer {
            pillarNotesDecoded0 = [String:String]()
            for (key0, notes0) in pillarNotesContainer {
                if let notes0 = notes0 {
                    pillarNotesDecoded0?[key0] = notes0
                }
            }
        }
        pillarNotes = pillarNotesDecoded0
    }
}

extension UpdateLensReviewOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLensReviewOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLensReviewOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLensReviewOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLensReviewOutputResponse(lensReview: \(String(describing: lensReview)), workloadId: \(String(describing: workloadId)))"}
}

extension UpdateLensReviewOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateLensReviewOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lensReview = output.lensReview
            self.workloadId = output.workloadId
        } else {
            self.lensReview = nil
            self.workloadId = nil
        }
    }
}

/// <p>Output of a update lens review call.</p>
public struct UpdateLensReviewOutputResponse: Equatable {
    /// <p>A lens review of a question.</p>
    public let lensReview: LensReview?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        lensReview: LensReview? = nil,
        workloadId: String? = nil
    )
    {
        self.lensReview = lensReview
        self.workloadId = workloadId
    }
}

struct UpdateLensReviewOutputResponseBody: Equatable {
    public let workloadId: String?
    public let lensReview: LensReview?
}

extension UpdateLensReviewOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lensReview = "LensReview"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let lensReviewDecoded = try containerValues.decodeIfPresent(LensReview.self, forKey: .lensReview)
        lensReview = lensReviewDecoded
    }
}

public struct UpdateShareInvitationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateShareInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateShareInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateShareInvitationInput>
    public typealias MOutput = OperationOutput<UpdateShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateShareInvitationOutputError>
}

extension UpdateShareInvitationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateShareInvitationInput(shareInvitationAction: \(String(describing: shareInvitationAction)), shareInvitationId: \(String(describing: shareInvitationId)))"}
}

extension UpdateShareInvitationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case shareInvitationAction = "ShareInvitationAction"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shareInvitationAction = shareInvitationAction {
            try encodeContainer.encode(shareInvitationAction.rawValue, forKey: .shareInvitationAction)
        }
    }
}

public struct UpdateShareInvitationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateShareInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateShareInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateShareInvitationInput>
    public typealias MOutput = OperationOutput<UpdateShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateShareInvitationOutputError>
}

public struct UpdateShareInvitationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateShareInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateShareInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateShareInvitationInput>
    public typealias MOutput = OperationOutput<UpdateShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateShareInvitationOutputError>
}

/// <p>Input for Update Share Invitation</p>
public struct UpdateShareInvitationInput: Equatable {
    /// <p>Share invitation action taken by contributor.</p>
    public let shareInvitationAction: ShareInvitationAction?
    /// <p>The ID assigned to the share invitation.</p>
    public let shareInvitationId: String?

    public init (
        shareInvitationAction: ShareInvitationAction? = nil,
        shareInvitationId: String? = nil
    )
    {
        self.shareInvitationAction = shareInvitationAction
        self.shareInvitationId = shareInvitationId
    }
}

struct UpdateShareInvitationInputBody: Equatable {
    public let shareInvitationAction: ShareInvitationAction?
}

extension UpdateShareInvitationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case shareInvitationAction = "ShareInvitationAction"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationActionDecoded = try containerValues.decodeIfPresent(ShareInvitationAction.self, forKey: .shareInvitationAction)
        shareInvitationAction = shareInvitationActionDecoded
    }
}

extension UpdateShareInvitationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateShareInvitationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateShareInvitationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateShareInvitationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateShareInvitationOutputResponse(shareInvitation: \(String(describing: shareInvitation)))"}
}

extension UpdateShareInvitationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateShareInvitationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.shareInvitation = output.shareInvitation
        } else {
            self.shareInvitation = nil
        }
    }
}

public struct UpdateShareInvitationOutputResponse: Equatable {
    /// <p>The updated workload share invitation.</p>
    public let shareInvitation: ShareInvitation?

    public init (
        shareInvitation: ShareInvitation? = nil
    )
    {
        self.shareInvitation = shareInvitation
    }
}

struct UpdateShareInvitationOutputResponseBody: Equatable {
    public let shareInvitation: ShareInvitation?
}

extension UpdateShareInvitationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case shareInvitation = "ShareInvitation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationDecoded = try containerValues.decodeIfPresent(ShareInvitation.self, forKey: .shareInvitation)
        shareInvitation = shareInvitationDecoded
    }
}

public struct UpdateWorkloadInputBodyMiddleware: Middleware {
    public let id: String = "UpdateWorkloadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkloadInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkloadInput>
    public typealias MOutput = OperationOutput<UpdateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkloadOutputError>
}

extension UpdateWorkloadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorkloadInput(accountIds: \(String(describing: accountIds)), architecturalDesign: \(String(describing: architecturalDesign)), awsRegions: \(String(describing: awsRegions)), description: \(String(describing: description)), environment: \(String(describing: environment)), improvementStatus: \(String(describing: improvementStatus)), industry: \(String(describing: industry)), industryType: \(String(describing: industryType)), isReviewOwnerUpdateAcknowledged: \(String(describing: isReviewOwnerUpdateAcknowledged)), nonAwsRegions: \(String(describing: nonAwsRegions)), notes: \(String(describing: notes)), pillarPriorities: \(String(describing: pillarPriorities)), reviewOwner: \(String(describing: reviewOwner)), workloadId: \(String(describing: workloadId)), workloadName: \(String(describing: workloadName)))"}
}

extension UpdateWorkloadInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case description = "Description"
        case environment = "Environment"
        case improvementStatus = "ImprovementStatus"
        case industry = "Industry"
        case industryType = "IndustryType"
        case isReviewOwnerUpdateAcknowledged = "IsReviewOwnerUpdateAcknowledged"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for workloadaccountids0 in accountIds {
                try accountIdsContainer.encode(workloadaccountids0)
            }
        }
        if let architecturalDesign = architecturalDesign {
            try encodeContainer.encode(architecturalDesign, forKey: .architecturalDesign)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for workloadawsregions0 in awsRegions {
                try awsRegionsContainer.encode(workloadawsregions0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment.rawValue, forKey: .environment)
        }
        if let improvementStatus = improvementStatus {
            try encodeContainer.encode(improvementStatus.rawValue, forKey: .improvementStatus)
        }
        if let industry = industry {
            try encodeContainer.encode(industry, forKey: .industry)
        }
        if let industryType = industryType {
            try encodeContainer.encode(industryType, forKey: .industryType)
        }
        if isReviewOwnerUpdateAcknowledged != false {
            try encodeContainer.encode(isReviewOwnerUpdateAcknowledged, forKey: .isReviewOwnerUpdateAcknowledged)
        }
        if let nonAwsRegions = nonAwsRegions {
            var nonAwsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nonAwsRegions)
            for workloadnonawsregions0 in nonAwsRegions {
                try nonAwsRegionsContainer.encode(workloadnonawsregions0)
            }
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarPriorities = pillarPriorities {
            var pillarPrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarPriorities)
            for workloadpillarpriorities0 in pillarPriorities {
                try pillarPrioritiesContainer.encode(workloadpillarpriorities0)
            }
        }
        if let reviewOwner = reviewOwner {
            try encodeContainer.encode(reviewOwner, forKey: .reviewOwner)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }
}

public struct UpdateWorkloadInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateWorkloadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkloadInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkloadInput>
    public typealias MOutput = OperationOutput<UpdateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkloadOutputError>
}

public struct UpdateWorkloadInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateWorkloadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkloadInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkloadInput>
    public typealias MOutput = OperationOutput<UpdateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkloadOutputError>
}

/// <p>Input to update a workload.</p>
public struct UpdateWorkloadInput: Equatable {
    /// <p>The list of AWS account IDs associated with the workload.</p>
    public let accountIds: [String]?
    /// <p>The URL of the architectural design for the workload.</p>
    public let architecturalDesign: String?
    /// <p>The list of AWS Regions associated with the workload, for example,
    ///                 <code>us-east-2</code>, or <code>ca-central-1</code>.</p>
    public let awsRegions: [String]?
    /// <p>The description for the workload.</p>
    public let description: String?
    /// <p>The environment for the workload.</p>
    public let environment: WorkloadEnvironment?
    /// <p>The improvement status for a workload.</p>
    public let improvementStatus: WorkloadImprovementStatus?
    /// <p>The industry for the workload.</p>
    public let industry: String?
    /// <p>The industry type for the workload.</p>
    ///         <p>If specified, must be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>Agriculture</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Automobile</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Defense</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Design and Engineering</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Digital Advertising</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Education</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Environmental Protection</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Financial Services</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Gaming</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>General Public Services</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Healthcare</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Hospitality</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>InfoTech</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Justice and Public Safety</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Life Sciences</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Manufacturing</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Media & Entertainment</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Mining & Resources</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Oil & Gas</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Power & Utilities</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Professional Services</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Real Estate & Construction</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Retail & Wholesale</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Social Protection</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Telecommunications</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Travel, Transportation & Logistics</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Other</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let industryType: String?
    /// <p>Flag indicating whether the workload owner has acknowledged that the <i>Review
    ///                 owner</i> field is required.</p>
    ///         <p>If a <b>Review owner</b> is not added to the workload within
    ///             60 days of acknowledgement, access to the workload is restricted until an owner is
    ///             added.</p>
    public let isReviewOwnerUpdateAcknowledged: Bool
    /// <p> The list of non-AWS Regions associated with the workload.</p>
    public let nonAwsRegions: [String]?
    /// <p>The notes associated with the workload.</p>
    public let notes: String?
    /// <p>The priorities of the pillars, which are used to order items in the improvement plan.
    ///             Each pillar is represented by its <a>PillarReviewSummary$PillarId</a>.</p>
    public let pillarPriorities: [String]?
    /// <p>The review owner of the workload. The name, email address, or identifier for the
    ///             primary group or individual that owns the workload review process.</p>
    public let reviewOwner: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?
    /// <p>The name of the workload.</p>
    ///         <p>The name must be unique within an account within a Region. Spaces and capitalization
    ///             are ignored when checking for uniqueness.</p>
    public let workloadName: String?

    public init (
        accountIds: [String]? = nil,
        architecturalDesign: String? = nil,
        awsRegions: [String]? = nil,
        description: String? = nil,
        environment: WorkloadEnvironment? = nil,
        improvementStatus: WorkloadImprovementStatus? = nil,
        industry: String? = nil,
        industryType: String? = nil,
        isReviewOwnerUpdateAcknowledged: Bool = false,
        nonAwsRegions: [String]? = nil,
        notes: String? = nil,
        pillarPriorities: [String]? = nil,
        reviewOwner: String? = nil,
        workloadId: String? = nil,
        workloadName: String? = nil
    )
    {
        self.accountIds = accountIds
        self.architecturalDesign = architecturalDesign
        self.awsRegions = awsRegions
        self.description = description
        self.environment = environment
        self.improvementStatus = improvementStatus
        self.industry = industry
        self.industryType = industryType
        self.isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledged
        self.nonAwsRegions = nonAwsRegions
        self.notes = notes
        self.pillarPriorities = pillarPriorities
        self.reviewOwner = reviewOwner
        self.workloadId = workloadId
        self.workloadName = workloadName
    }
}

struct UpdateWorkloadInputBody: Equatable {
    public let workloadName: String?
    public let description: String?
    public let environment: WorkloadEnvironment?
    public let accountIds: [String]?
    public let awsRegions: [String]?
    public let nonAwsRegions: [String]?
    public let pillarPriorities: [String]?
    public let architecturalDesign: String?
    public let reviewOwner: String?
    public let isReviewOwnerUpdateAcknowledged: Bool
    public let industryType: String?
    public let industry: String?
    public let notes: String?
    public let improvementStatus: WorkloadImprovementStatus?
}

extension UpdateWorkloadInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case description = "Description"
        case environment = "Environment"
        case improvementStatus = "ImprovementStatus"
        case industry = "Industry"
        case industryType = "IndustryType"
        case isReviewOwnerUpdateAcknowledged = "IsReviewOwnerUpdateAcknowledged"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case workloadName = "WorkloadName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(WorkloadEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let awsRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
        let nonAwsRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .nonAwsRegions)
        var nonAwsRegionsDecoded0:[String]? = nil
        if let nonAwsRegionsContainer = nonAwsRegionsContainer {
            nonAwsRegionsDecoded0 = [String]()
            for string0 in nonAwsRegionsContainer {
                if let string0 = string0 {
                    nonAwsRegionsDecoded0?.append(string0)
                }
            }
        }
        nonAwsRegions = nonAwsRegionsDecoded0
        let pillarPrioritiesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .pillarPriorities)
        var pillarPrioritiesDecoded0:[String]? = nil
        if let pillarPrioritiesContainer = pillarPrioritiesContainer {
            pillarPrioritiesDecoded0 = [String]()
            for string0 in pillarPrioritiesContainer {
                if let string0 = string0 {
                    pillarPrioritiesDecoded0?.append(string0)
                }
            }
        }
        pillarPriorities = pillarPrioritiesDecoded0
        let architecturalDesignDecoded = try containerValues.decodeIfPresent(String.self, forKey: .architecturalDesign)
        architecturalDesign = architecturalDesignDecoded
        let reviewOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reviewOwner)
        reviewOwner = reviewOwnerDecoded
        let isReviewOwnerUpdateAcknowledgedDecoded = try containerValues.decode(Bool.self, forKey: .isReviewOwnerUpdateAcknowledged)
        isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledgedDecoded
        let industryTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .industryType)
        industryType = industryTypeDecoded
        let industryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .industry)
        industry = industryDecoded
        let notesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notes)
        notes = notesDecoded
        let improvementStatusDecoded = try containerValues.decodeIfPresent(WorkloadImprovementStatus.self, forKey: .improvementStatus)
        improvementStatus = improvementStatusDecoded
    }
}

extension UpdateWorkloadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkloadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkloadOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkloadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorkloadOutputResponse(workload: \(String(describing: workload)))"}
}

extension UpdateWorkloadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateWorkloadOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.workload = output.workload
        } else {
            self.workload = nil
        }
    }
}

/// <p>Output of an update workload call.</p>
public struct UpdateWorkloadOutputResponse: Equatable {
    /// <p>A workload return object.</p>
    public let workload: Workload?

    public init (
        workload: Workload? = nil
    )
    {
        self.workload = workload
    }
}

struct UpdateWorkloadOutputResponseBody: Equatable {
    public let workload: Workload?
}

extension UpdateWorkloadOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case workload = "Workload"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadDecoded = try containerValues.decodeIfPresent(Workload.self, forKey: .workload)
        workload = workloadDecoded
    }
}

public struct UpdateWorkloadShareInputBodyMiddleware: Middleware {
    public let id: String = "UpdateWorkloadShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkloadShareInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkloadShareInput>
    public typealias MOutput = OperationOutput<UpdateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkloadShareOutputError>
}

extension UpdateWorkloadShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorkloadShareInput(permissionType: \(String(describing: permissionType)), shareId: \(String(describing: shareId)), workloadId: \(String(describing: workloadId)))"}
}

extension UpdateWorkloadShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case permissionType = "PermissionType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
    }
}

public struct UpdateWorkloadShareInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateWorkloadShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkloadShareInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkloadShareInput>
    public typealias MOutput = OperationOutput<UpdateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkloadShareOutputError>
}

public struct UpdateWorkloadShareInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateWorkloadShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkloadShareInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkloadShareInput>
    public typealias MOutput = OperationOutput<UpdateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkloadShareOutputError>
}

/// <p>Input for Update Workload Share</p>
public struct UpdateWorkloadShareInput: Equatable {
    /// <p>Permission granted on a workload share.</p>
    public let permissionType: PermissionType?
    /// <p>The ID associated with the workload share.</p>
    public let shareId: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        permissionType: PermissionType? = nil,
        shareId: String? = nil,
        workloadId: String? = nil
    )
    {
        self.permissionType = permissionType
        self.shareId = shareId
        self.workloadId = workloadId
    }
}

struct UpdateWorkloadShareInputBody: Equatable {
    public let permissionType: PermissionType?
}

extension UpdateWorkloadShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case permissionType = "PermissionType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionTypeDecoded = try containerValues.decodeIfPresent(PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
    }
}

extension UpdateWorkloadShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkloadShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkloadShareOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkloadShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorkloadShareOutputResponse(workloadId: \(String(describing: workloadId)), workloadShare: \(String(describing: workloadShare)))"}
}

extension UpdateWorkloadShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateWorkloadShareOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.workloadId = output.workloadId
            self.workloadShare = output.workloadShare
        } else {
            self.workloadId = nil
            self.workloadShare = nil
        }
    }
}

/// <p>Input for Update Workload Share</p>
public struct UpdateWorkloadShareOutputResponse: Equatable {
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?
    /// <p>A workload share return object.</p>
    public let workloadShare: WorkloadShare?

    public init (
        workloadId: String? = nil,
        workloadShare: WorkloadShare? = nil
    )
    {
        self.workloadId = workloadId
        self.workloadShare = workloadShare
    }
}

struct UpdateWorkloadShareOutputResponseBody: Equatable {
    public let workloadId: String?
    public let workloadShare: WorkloadShare?
}

extension UpdateWorkloadShareOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case workloadId = "WorkloadId"
        case workloadShare = "WorkloadShare"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadShareDecoded = try containerValues.decodeIfPresent(WorkloadShare.self, forKey: .workloadShare)
        workloadShare = workloadShareDecoded
    }
}

public struct UpgradeLensReviewInputBodyMiddleware: Middleware {
    public let id: String = "UpgradeLensReviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpgradeLensReviewInput>,
                  next: H) -> Swift.Result<OperationOutput<UpgradeLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpgradeLensReviewInput>
    public typealias MOutput = OperationOutput<UpgradeLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpgradeLensReviewOutputError>
}

extension UpgradeLensReviewInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpgradeLensReviewInput(clientRequestToken: \(String(describing: clientRequestToken)), lensAlias: \(String(describing: lensAlias)), milestoneName: \(String(describing: milestoneName)), workloadId: \(String(describing: workloadId)))"}
}

extension UpgradeLensReviewInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let milestoneName = milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
    }
}

public struct UpgradeLensReviewInputHeadersMiddleware: Middleware {
    public let id: String = "UpgradeLensReviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpgradeLensReviewInput>,
                  next: H) -> Swift.Result<OperationOutput<UpgradeLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpgradeLensReviewInput>
    public typealias MOutput = OperationOutput<UpgradeLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpgradeLensReviewOutputError>
}

public struct UpgradeLensReviewInputQueryItemMiddleware: Middleware {
    public let id: String = "UpgradeLensReviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpgradeLensReviewInput>,
                  next: H) -> Swift.Result<OperationOutput<UpgradeLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpgradeLensReviewInput>
    public typealias MOutput = OperationOutput<UpgradeLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpgradeLensReviewOutputError>
}

public struct UpgradeLensReviewInput: Equatable {
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent
    ///             (executes only once).</p>
    ///         <p>You should not reuse the same token for other requests. If you retry a request with
    ///             the same client request token and the same parameters after it has completed
    ///             successfully, the result of the original request is returned. </p>
    ///         <important>
    ///             <p>This token is listed as required, however, if you do not specify it, the AWS SDKs
    ///                 automatically generate one for you. If you are not using the AWS SDK or the AWS CLI,
    ///                 you must provide this token or the request will fail.</p>
    ///         </important>
    public let clientRequestToken: String?
    /// <p>The alias of the lens, for example, <code>serverless</code>.</p>
    ///         <p>Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lensAlias: String?
    /// <p>The name of the milestone in a workload.</p>
    ///         <p>Milestone names must be unique within a workload.</p>
    public let milestoneName: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?

    public init (
        clientRequestToken: String? = nil,
        lensAlias: String? = nil,
        milestoneName: String? = nil,
        workloadId: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.milestoneName = milestoneName
        self.workloadId = workloadId
    }
}

struct UpgradeLensReviewInputBody: Equatable {
    public let milestoneName: String?
    public let clientRequestToken: String?
}

extension UpgradeLensReviewInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension UpgradeLensReviewOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpgradeLensReviewOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpgradeLensReviewOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpgradeLensReviewOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpgradeLensReviewOutputResponse()"}
}

extension UpgradeLensReviewOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpgradeLensReviewOutputResponse: Equatable {

    public init() {}
}

struct UpgradeLensReviewOutputResponseBody: Equatable {
}

extension UpgradeLensReviewOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(fields: \(String(describing: fields)), message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user input is not valid.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The fields that caused the error, if applicable.</p>
    public var fields: [ValidationExceptionField]?
    /// <p>Description of the error.</p>
    public var message: String?
    /// <p>The reason why the request failed validation.</p>
    public var reason: ValidationExceptionReason?

    public init (
        fields: [ValidationExceptionField]? = nil,
        message: String? = nil,
        reason: ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
    public let reason: ValidationExceptionReason?
    public let fields: [ValidationExceptionField]?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension ValidationExceptionField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationExceptionField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationExceptionField(message: \(String(describing: message)), name: \(String(describing: name)))"}
}

/// <p>Stores information about a field passed inside a request that resulted in an exception.</p>
public struct ValidationExceptionField: Equatable {
    /// <p>Description of the error.</p>
    public let message: String?
    /// <p>The field name for which validation failed.</p>
    public let name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

/// <p>The reason why the request failed validation.</p>
public enum ValidationExceptionReason {
    case cannotParse
    case fieldValidationFailed
    case other
    case unknownOperation
    case sdkUnknown(String)
}

extension ValidationExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidationExceptionReason] {
        return [
            .cannotParse,
            .fieldValidationFailed,
            .other,
            .unknownOperation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cannotParse: return "CANNOT_PARSE"
        case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
        case .other: return "OTHER"
        case .unknownOperation: return "UNKNOWN_OPERATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
    }
}

extension VersionDifferences: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pillarDifferences = "PillarDifferences"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pillarDifferences = pillarDifferences {
            var pillarDifferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarDifferences)
            for pillardifferences0 in pillarDifferences {
                try pillarDifferencesContainer.encode(pillardifferences0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pillarDifferencesContainer = try containerValues.decodeIfPresent([PillarDifference?].self, forKey: .pillarDifferences)
        var pillarDifferencesDecoded0:[PillarDifference]? = nil
        if let pillarDifferencesContainer = pillarDifferencesContainer {
            pillarDifferencesDecoded0 = [PillarDifference]()
            for structure0 in pillarDifferencesContainer {
                if let structure0 = structure0 {
                    pillarDifferencesDecoded0?.append(structure0)
                }
            }
        }
        pillarDifferences = pillarDifferencesDecoded0
    }
}

extension VersionDifferences: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VersionDifferences(pillarDifferences: \(String(describing: pillarDifferences)))"}
}

/// <p>The differences between the base and latest versions of the lens.</p>
public struct VersionDifferences: Equatable {
    /// <p>The differences between the base and latest versions of the lens.</p>
    public let pillarDifferences: [PillarDifference]?

    public init (
        pillarDifferences: [PillarDifference]? = nil
    )
    {
        self.pillarDifferences = pillarDifferences
    }
}

extension Workload: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case description = "Description"
        case environment = "Environment"
        case improvementStatus = "ImprovementStatus"
        case industry = "Industry"
        case industryType = "IndustryType"
        case isReviewOwnerUpdateAcknowledged = "IsReviewOwnerUpdateAcknowledged"
        case lenses = "Lenses"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case owner = "Owner"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case reviewRestrictionDate = "ReviewRestrictionDate"
        case riskCounts = "RiskCounts"
        case shareInvitationId = "ShareInvitationId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
        case workloadArn = "WorkloadArn"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for workloadaccountids0 in accountIds {
                try accountIdsContainer.encode(workloadaccountids0)
            }
        }
        if let architecturalDesign = architecturalDesign {
            try encodeContainer.encode(architecturalDesign, forKey: .architecturalDesign)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for workloadawsregions0 in awsRegions {
                try awsRegionsContainer.encode(workloadawsregions0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment.rawValue, forKey: .environment)
        }
        if let improvementStatus = improvementStatus {
            try encodeContainer.encode(improvementStatus.rawValue, forKey: .improvementStatus)
        }
        if let industry = industry {
            try encodeContainer.encode(industry, forKey: .industry)
        }
        if let industryType = industryType {
            try encodeContainer.encode(industryType, forKey: .industryType)
        }
        if isReviewOwnerUpdateAcknowledged != false {
            try encodeContainer.encode(isReviewOwnerUpdateAcknowledged, forKey: .isReviewOwnerUpdateAcknowledged)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for workloadlenses0 in lenses {
                try lensesContainer.encode(workloadlenses0)
            }
        }
        if let nonAwsRegions = nonAwsRegions {
            var nonAwsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nonAwsRegions)
            for workloadnonawsregions0 in nonAwsRegions {
                try nonAwsRegionsContainer.encode(workloadnonawsregions0)
            }
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let pillarPriorities = pillarPriorities {
            var pillarPrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarPriorities)
            for workloadpillarpriorities0 in pillarPriorities {
                try pillarPrioritiesContainer.encode(workloadpillarpriorities0)
            }
        }
        if let reviewOwner = reviewOwner {
            try encodeContainer.encode(reviewOwner, forKey: .reviewOwner)
        }
        if let reviewRestrictionDate = reviewRestrictionDate {
            try encodeContainer.encode(reviewRestrictionDate.timeIntervalSince1970, forKey: .reviewRestrictionDate)
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let shareInvitationId = shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let workloadArn = workloadArn {
            try encodeContainer.encode(workloadArn, forKey: .workloadArn)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadArn)
        workloadArn = workloadArnDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(WorkloadEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let awsRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
        let nonAwsRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .nonAwsRegions)
        var nonAwsRegionsDecoded0:[String]? = nil
        if let nonAwsRegionsContainer = nonAwsRegionsContainer {
            nonAwsRegionsDecoded0 = [String]()
            for string0 in nonAwsRegionsContainer {
                if let string0 = string0 {
                    nonAwsRegionsDecoded0?.append(string0)
                }
            }
        }
        nonAwsRegions = nonAwsRegionsDecoded0
        let architecturalDesignDecoded = try containerValues.decodeIfPresent(String.self, forKey: .architecturalDesign)
        architecturalDesign = architecturalDesignDecoded
        let reviewOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reviewOwner)
        reviewOwner = reviewOwnerDecoded
        let reviewRestrictionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .reviewRestrictionDate)
        reviewRestrictionDate = reviewRestrictionDateDecoded
        let isReviewOwnerUpdateAcknowledgedDecoded = try containerValues.decode(Bool.self, forKey: .isReviewOwnerUpdateAcknowledged)
        isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledgedDecoded
        let industryTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .industryType)
        industryType = industryTypeDecoded
        let industryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .industry)
        industry = industryDecoded
        let notesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notes)
        notes = notesDecoded
        let improvementStatusDecoded = try containerValues.decodeIfPresent(WorkloadImprovementStatus.self, forKey: .improvementStatus)
        improvementStatus = improvementStatusDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [String:Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [String:Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let pillarPrioritiesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .pillarPriorities)
        var pillarPrioritiesDecoded0:[String]? = nil
        if let pillarPrioritiesContainer = pillarPrioritiesContainer {
            pillarPrioritiesDecoded0 = [String]()
            for string0 in pillarPrioritiesContainer {
                if let string0 = string0 {
                    pillarPrioritiesDecoded0?.append(string0)
                }
            }
        }
        pillarPriorities = pillarPrioritiesDecoded0
        let lensesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .lenses)
        var lensesDecoded0:[String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Workload: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Workload(accountIds: \(String(describing: accountIds)), architecturalDesign: \(String(describing: architecturalDesign)), awsRegions: \(String(describing: awsRegions)), description: \(String(describing: description)), environment: \(String(describing: environment)), improvementStatus: \(String(describing: improvementStatus)), industry: \(String(describing: industry)), industryType: \(String(describing: industryType)), isReviewOwnerUpdateAcknowledged: \(String(describing: isReviewOwnerUpdateAcknowledged)), lenses: \(String(describing: lenses)), nonAwsRegions: \(String(describing: nonAwsRegions)), notes: \(String(describing: notes)), owner: \(String(describing: owner)), pillarPriorities: \(String(describing: pillarPriorities)), reviewOwner: \(String(describing: reviewOwner)), reviewRestrictionDate: \(String(describing: reviewRestrictionDate)), riskCounts: \(String(describing: riskCounts)), shareInvitationId: \(String(describing: shareInvitationId)), tags: \(String(describing: tags)), updatedAt: \(String(describing: updatedAt)), workloadArn: \(String(describing: workloadArn)), workloadId: \(String(describing: workloadId)), workloadName: \(String(describing: workloadName)))"}
}

/// <p>A workload return object.</p>
public struct Workload: Equatable {
    /// <p>The list of AWS account IDs associated with the workload.</p>
    public let accountIds: [String]?
    /// <p>The URL of the architectural design for the workload.</p>
    public let architecturalDesign: String?
    /// <p>The list of AWS Regions associated with the workload, for example,
    ///                 <code>us-east-2</code>, or <code>ca-central-1</code>.</p>
    public let awsRegions: [String]?
    /// <p>The description for the workload.</p>
    public let description: String?
    /// <p>The environment for the workload.</p>
    public let environment: WorkloadEnvironment?
    /// <p>The improvement status for a workload.</p>
    public let improvementStatus: WorkloadImprovementStatus?
    /// <p>The industry for the workload.</p>
    public let industry: String?
    /// <p>The industry type for the workload.</p>
    ///         <p>If specified, must be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>Agriculture</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Automobile</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Defense</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Design and Engineering</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Digital Advertising</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Education</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Environmental Protection</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Financial Services</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Gaming</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>General Public Services</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Healthcare</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Hospitality</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>InfoTech</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Justice and Public Safety</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Life Sciences</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Manufacturing</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Media & Entertainment</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Mining & Resources</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Oil & Gas</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Power & Utilities</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Professional Services</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Real Estate & Construction</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Retail & Wholesale</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Social Protection</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Telecommunications</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Travel, Transportation & Logistics</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Other</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let industryType: String?
    /// <p>Flag indicating whether the workload owner has acknowledged that the <i>Review
    ///                 owner</i> field is required.</p>
    ///         <p>If a <b>Review owner</b> is not added to the workload within
    ///             60 days of acknowledgement, access to the workload is restricted until an owner is
    ///             added.</p>
    public let isReviewOwnerUpdateAcknowledged: Bool
    /// <p>The list of lenses associated with the workload. Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lenses: [String]?
    /// <p> The list of non-AWS Regions associated with the workload.</p>
    public let nonAwsRegions: [String]?
    /// <p>The notes associated with the workload.</p>
    public let notes: String?
    /// <p>An AWS account ID.</p>
    public let owner: String?
    /// <p>The priorities of the pillars, which are used to order items in the improvement plan.
    ///             Each pillar is represented by its <a>PillarReviewSummary$PillarId</a>.</p>
    public let pillarPriorities: [String]?
    /// <p>The review owner of the workload. The name, email address, or identifier for the
    ///             primary group or individual that owns the workload review process.</p>
    public let reviewOwner: String?
    /// <p>The date and time recorded.</p>
    public let reviewRestrictionDate: Date?
    /// <p>A map from risk names to the count of how questions have that rating.</p>
    public let riskCounts: [String:Int]?
    /// <p>The ID assigned to the share invitation.</p>
    public let shareInvitationId: String?
    /// <p>The tags associated with the workload.</p>
    public let tags: [String:String]?
    /// <p>The date and time recorded.</p>
    public let updatedAt: Date?
    /// <p>The ARN for the workload.</p>
    public let workloadArn: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?
    /// <p>The name of the workload.</p>
    ///         <p>The name must be unique within an account within a Region. Spaces and capitalization
    ///             are ignored when checking for uniqueness.</p>
    public let workloadName: String?

    public init (
        accountIds: [String]? = nil,
        architecturalDesign: String? = nil,
        awsRegions: [String]? = nil,
        description: String? = nil,
        environment: WorkloadEnvironment? = nil,
        improvementStatus: WorkloadImprovementStatus? = nil,
        industry: String? = nil,
        industryType: String? = nil,
        isReviewOwnerUpdateAcknowledged: Bool = false,
        lenses: [String]? = nil,
        nonAwsRegions: [String]? = nil,
        notes: String? = nil,
        owner: String? = nil,
        pillarPriorities: [String]? = nil,
        reviewOwner: String? = nil,
        reviewRestrictionDate: Date? = nil,
        riskCounts: [String:Int]? = nil,
        shareInvitationId: String? = nil,
        tags: [String:String]? = nil,
        updatedAt: Date? = nil,
        workloadArn: String? = nil,
        workloadId: String? = nil,
        workloadName: String? = nil
    )
    {
        self.accountIds = accountIds
        self.architecturalDesign = architecturalDesign
        self.awsRegions = awsRegions
        self.description = description
        self.environment = environment
        self.improvementStatus = improvementStatus
        self.industry = industry
        self.industryType = industryType
        self.isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledged
        self.lenses = lenses
        self.nonAwsRegions = nonAwsRegions
        self.notes = notes
        self.owner = owner
        self.pillarPriorities = pillarPriorities
        self.reviewOwner = reviewOwner
        self.reviewRestrictionDate = reviewRestrictionDate
        self.riskCounts = riskCounts
        self.shareInvitationId = shareInvitationId
        self.tags = tags
        self.updatedAt = updatedAt
        self.workloadArn = workloadArn
        self.workloadId = workloadId
        self.workloadName = workloadName
    }
}

/// <p>The environment for the workload.</p>
public enum WorkloadEnvironment {
    case preproduction
    case production
    case sdkUnknown(String)
}

extension WorkloadEnvironment : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorkloadEnvironment] {
        return [
            .preproduction,
            .production,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .preproduction: return "PREPRODUCTION"
        case .production: return "PRODUCTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorkloadEnvironment(rawValue: rawValue) ?? WorkloadEnvironment.sdkUnknown(rawValue)
    }
}

/// <p>The improvement status for a workload.</p>
public enum WorkloadImprovementStatus {
    case complete
    case inProgress
    case notApplicable
    case notStarted
    case riskAcknowledged
    case sdkUnknown(String)
}

extension WorkloadImprovementStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorkloadImprovementStatus] {
        return [
            .complete,
            .inProgress,
            .notApplicable,
            .notStarted,
            .riskAcknowledged,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .inProgress: return "IN_PROGRESS"
        case .notApplicable: return "NOT_APPLICABLE"
        case .notStarted: return "NOT_STARTED"
        case .riskAcknowledged: return "RISK_ACKNOWLEDGED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorkloadImprovementStatus(rawValue: rawValue) ?? WorkloadImprovementStatus.sdkUnknown(rawValue)
    }
}

extension WorkloadShare: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case permissionType = "PermissionType"
        case shareId = "ShareId"
        case sharedBy = "SharedBy"
        case sharedWith = "SharedWith"
        case status = "Status"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let shareId = shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let sharedBy = sharedBy {
            try encodeContainer.encode(sharedBy, forKey: .sharedBy)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let sharedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedBy)
        sharedBy = sharedByDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ShareStatus.self, forKey: .status)
        status = statusDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
    }
}

extension WorkloadShare: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkloadShare(permissionType: \(String(describing: permissionType)), shareId: \(String(describing: shareId)), sharedBy: \(String(describing: sharedBy)), sharedWith: \(String(describing: sharedWith)), status: \(String(describing: status)), workloadId: \(String(describing: workloadId)), workloadName: \(String(describing: workloadName)))"}
}

/// <p>A workload share return object.</p>
public struct WorkloadShare: Equatable {
    /// <p>Permission granted on a workload share.</p>
    public let permissionType: PermissionType?
    /// <p>The ID associated with the workload share.</p>
    public let shareId: String?
    /// <p>An AWS account ID.</p>
    public let sharedBy: String?
    /// <p>The AWS account ID or IAM role with which the workload is shared.</p>
    public let sharedWith: String?
    /// <p>The status of a workload share.</p>
    public let status: ShareStatus?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?
    /// <p>The name of the workload.</p>
    ///         <p>The name must be unique within an account within a Region. Spaces and capitalization
    ///             are ignored when checking for uniqueness.</p>
    public let workloadName: String?

    public init (
        permissionType: PermissionType? = nil,
        shareId: String? = nil,
        sharedBy: String? = nil,
        sharedWith: String? = nil,
        status: ShareStatus? = nil,
        workloadId: String? = nil,
        workloadName: String? = nil
    )
    {
        self.permissionType = permissionType
        self.shareId = shareId
        self.sharedBy = sharedBy
        self.sharedWith = sharedWith
        self.status = status
        self.workloadId = workloadId
        self.workloadName = workloadName
    }
}

extension WorkloadShareSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case permissionType = "PermissionType"
        case shareId = "ShareId"
        case sharedWith = "SharedWith"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let shareId = shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ShareStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension WorkloadShareSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkloadShareSummary(permissionType: \(String(describing: permissionType)), shareId: \(String(describing: shareId)), sharedWith: \(String(describing: sharedWith)), status: \(String(describing: status)))"}
}

/// <p>A workload share summary return object.</p>
public struct WorkloadShareSummary: Equatable {
    /// <p>Permission granted on a workload share.</p>
    public let permissionType: PermissionType?
    /// <p>The ID associated with the workload share.</p>
    public let shareId: String?
    /// <p>The AWS account ID or IAM role with which the workload is shared.</p>
    public let sharedWith: String?
    /// <p>The status of a workload share.</p>
    public let status: ShareStatus?

    public init (
        permissionType: PermissionType? = nil,
        shareId: String? = nil,
        sharedWith: String? = nil,
        status: ShareStatus? = nil
    )
    {
        self.permissionType = permissionType
        self.shareId = shareId
        self.sharedWith = sharedWith
        self.status = status
    }
}

extension WorkloadSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case improvementStatus = "ImprovementStatus"
        case lenses = "Lenses"
        case owner = "Owner"
        case riskCounts = "RiskCounts"
        case updatedAt = "UpdatedAt"
        case workloadArn = "WorkloadArn"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let improvementStatus = improvementStatus {
            try encodeContainer.encode(improvementStatus.rawValue, forKey: .improvementStatus)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for workloadlenses0 in lenses {
                try lensesContainer.encode(workloadlenses0)
            }
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let workloadArn = workloadArn {
            try encodeContainer.encode(workloadArn, forKey: .workloadArn)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadArn)
        workloadArn = workloadArnDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let lensesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .lenses)
        var lensesDecoded0:[String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let riskCountsContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [String:Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [String:Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let improvementStatusDecoded = try containerValues.decodeIfPresent(WorkloadImprovementStatus.self, forKey: .improvementStatus)
        improvementStatus = improvementStatusDecoded
    }
}

extension WorkloadSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkloadSummary(improvementStatus: \(String(describing: improvementStatus)), lenses: \(String(describing: lenses)), owner: \(String(describing: owner)), riskCounts: \(String(describing: riskCounts)), updatedAt: \(String(describing: updatedAt)), workloadArn: \(String(describing: workloadArn)), workloadId: \(String(describing: workloadId)), workloadName: \(String(describing: workloadName)))"}
}

/// <p>A workload summary return object.</p>
public struct WorkloadSummary: Equatable {
    /// <p>The improvement status for a workload.</p>
    public let improvementStatus: WorkloadImprovementStatus?
    /// <p>The list of lenses associated with the workload. Each lens is identified by its <a>LensSummary$LensAlias</a>.</p>
    public let lenses: [String]?
    /// <p>An AWS account ID.</p>
    public let owner: String?
    /// <p>A map from risk names to the count of how questions have that rating.</p>
    public let riskCounts: [String:Int]?
    /// <p>The date and time recorded.</p>
    public let updatedAt: Date?
    /// <p>The ARN for the workload.</p>
    public let workloadArn: String?
    /// <p>The ID assigned to the workload. This ID is unique within an AWS Region.</p>
    public let workloadId: String?
    /// <p>The name of the workload.</p>
    ///         <p>The name must be unique within an account within a Region. Spaces and capitalization
    ///             are ignored when checking for uniqueness.</p>
    public let workloadName: String?

    public init (
        improvementStatus: WorkloadImprovementStatus? = nil,
        lenses: [String]? = nil,
        owner: String? = nil,
        riskCounts: [String:Int]? = nil,
        updatedAt: Date? = nil,
        workloadArn: String? = nil,
        workloadId: String? = nil,
        workloadName: String? = nil
    )
    {
        self.improvementStatus = improvementStatus
        self.lenses = lenses
        self.owner = owner
        self.riskCounts = riskCounts
        self.updatedAt = updatedAt
        self.workloadArn = workloadArn
        self.workloadId = workloadId
        self.workloadName = workloadName
    }
}
