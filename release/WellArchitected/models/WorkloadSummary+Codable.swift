// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension WorkloadSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case improvementStatus = "ImprovementStatus"
        case lenses = "Lenses"
        case owner = "Owner"
        case riskCounts = "RiskCounts"
        case updatedAt = "UpdatedAt"
        case workloadArn = "WorkloadArn"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let improvementStatus = improvementStatus {
            try encodeContainer.encode(improvementStatus.rawValue, forKey: .improvementStatus)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for workloadlenses0 in lenses {
                try lensesContainer.encode(workloadlenses0)
            }
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let workloadArn = workloadArn {
            try encodeContainer.encode(workloadArn, forKey: .workloadArn)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadArn)
        workloadArn = workloadArnDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let lensesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .lenses)
        var lensesDecoded0:[String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let riskCountsContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [String:Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [String:Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let improvementStatusDecoded = try containerValues.decodeIfPresent(WorkloadImprovementStatus.self, forKey: .improvementStatus)
        improvementStatus = improvementStatusDecoded
    }
}
