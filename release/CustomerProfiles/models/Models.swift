// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AddProfileKeyInputBodyMiddleware: Middleware {
    public let id: String = "AddProfileKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddProfileKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<AddProfileKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddProfileKeyInput>
    public typealias MOutput = OperationOutput<AddProfileKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddProfileKeyOutputError>
}

extension AddProfileKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddProfileKeyInput(domainName: \(String(describing: domainName)), keyName: \(String(describing: keyName)), profileId: \(String(describing: profileId)), values: \(String(describing: values)))"}
}

extension AddProfileKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyName = "KeyName"
        case profileId = "ProfileId"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyName = keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let profileId = profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for requestvaluelist0 in values {
                try valuesContainer.encode(requestvaluelist0)
            }
        }
    }
}

public struct AddProfileKeyInputHeadersMiddleware: Middleware {
    public let id: String = "AddProfileKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddProfileKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<AddProfileKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddProfileKeyInput>
    public typealias MOutput = OperationOutput<AddProfileKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddProfileKeyOutputError>
}

public struct AddProfileKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "AddProfileKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddProfileKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<AddProfileKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddProfileKeyInput>
    public typealias MOutput = OperationOutput<AddProfileKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddProfileKeyOutputError>
}

public struct AddProfileKeyInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>A searchable identifier of a customer profile.</p>
    public let keyName: String?
    /// <p>The unique identifier of a customer profile.</p>
    public let profileId: String?
    /// <p>A list of key values.</p>
    public let values: [String]?

    public init (
        domainName: String? = nil,
        keyName: String? = nil,
        profileId: String? = nil,
        values: [String]? = nil
    )
    {
        self.domainName = domainName
        self.keyName = keyName
        self.profileId = profileId
        self.values = values
    }
}

struct AddProfileKeyInputBody: Equatable {
    public let profileId: String?
    public let keyName: String?
    public let values: [String]?
}

extension AddProfileKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyName = "KeyName"
        case profileId = "ProfileId"
        case values = "Values"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension AddProfileKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddProfileKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddProfileKeyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddProfileKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddProfileKeyOutputResponse(keyName: \(String(describing: keyName)), values: \(String(describing: values)))"}
}

extension AddProfileKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddProfileKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keyName = output.keyName
            self.values = output.values
        } else {
            self.keyName = nil
            self.values = nil
        }
    }
}

public struct AddProfileKeyOutputResponse: Equatable {
    /// <p>A searchable identifier of a customer profile.</p>
    public let keyName: String?
    /// <p>A list of key values.</p>
    public let values: [String]?

    public init (
        keyName: String? = nil,
        values: [String]? = nil
    )
    {
        self.keyName = keyName
        self.values = values
    }
}

struct AddProfileKeyOutputResponseBody: Equatable {
    public let keyName: String?
    public let values: [String]?
}

extension AddProfileKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyName = "KeyName"
        case values = "Values"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Address: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address1 = "Address1"
        case address2 = "Address2"
        case address3 = "Address3"
        case address4 = "Address4"
        case city = "City"
        case country = "Country"
        case county = "County"
        case postalCode = "PostalCode"
        case province = "Province"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address1 = address1 {
            try encodeContainer.encode(address1, forKey: .address1)
        }
        if let address2 = address2 {
            try encodeContainer.encode(address2, forKey: .address2)
        }
        if let address3 = address3 {
            try encodeContainer.encode(address3, forKey: .address3)
        }
        if let address4 = address4 {
            try encodeContainer.encode(address4, forKey: .address4)
        }
        if let city = city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let county = county {
            try encodeContainer.encode(county, forKey: .county)
        }
        if let postalCode = postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let province = province {
            try encodeContainer.encode(province, forKey: .province)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let address1Decoded = try containerValues.decodeIfPresent(String.self, forKey: .address1)
        address1 = address1Decoded
        let address2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .address2)
        address2 = address2Decoded
        let address3Decoded = try containerValues.decodeIfPresent(String.self, forKey: .address3)
        address3 = address3Decoded
        let address4Decoded = try containerValues.decodeIfPresent(String.self, forKey: .address4)
        address4 = address4Decoded
        let cityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .city)
        city = cityDecoded
        let countyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .county)
        county = countyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let provinceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .province)
        province = provinceDecoded
        let countryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .country)
        country = countryDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
    }
}

extension Address: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Address(address1: \(String(describing: address1)), address2: \(String(describing: address2)), address3: \(String(describing: address3)), address4: \(String(describing: address4)), city: \(String(describing: city)), country: \(String(describing: country)), county: \(String(describing: county)), postalCode: \(String(describing: postalCode)), province: \(String(describing: province)), state: \(String(describing: state)))"}
}

/// <p>A generic address associated with the customer that is not mailing, shipping, or
///          billing.</p>
public struct Address: Equatable {
    /// <p>The first line of a customer address.</p>
    public let address1: String?
    /// <p>The second line of a customer address.</p>
    public let address2: String?
    /// <p>The third line of a customer address.</p>
    public let address3: String?
    /// <p>The fourth line of a customer address.</p>
    public let address4: String?
    /// <p>The city in which a customer lives.</p>
    public let city: String?
    /// <p>The country in which a customer lives.</p>
    public let country: String?
    /// <p>The county in which a customer lives.</p>
    public let county: String?
    /// <p>The postal code of a customer address.</p>
    public let postalCode: String?
    /// <p>The province in which a customer lives.</p>
    public let province: String?
    /// <p>The state in which a customer lives.</p>
    public let state: String?

    public init (
        address1: String? = nil,
        address2: String? = nil,
        address3: String? = nil,
        address4: String? = nil,
        city: String? = nil,
        country: String? = nil,
        county: String? = nil,
        postalCode: String? = nil,
        province: String? = nil,
        state: String? = nil
    )
    {
        self.address1 = address1
        self.address2 = address2
        self.address3 = address3
        self.address4 = address4
        self.city = city
        self.country = country
        self.county = county
        self.postalCode = postalCode
        self.province = province
        self.state = state
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input you provided is invalid.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectorOperator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case marketo = "Marketo"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marketo = marketo {
            try encodeContainer.encode(marketo.rawValue, forKey: .marketo)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3.rawValue, forKey: .s3)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce.rawValue, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow.rawValue, forKey: .serviceNow)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk.rawValue, forKey: .zendesk)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let marketoDecoded = try containerValues.decodeIfPresent(MarketoConnectorOperator.self, forKey: .marketo)
        marketo = marketoDecoded
        let s3Decoded = try containerValues.decodeIfPresent(S3ConnectorOperator.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(SalesforceConnectorOperator.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(ServiceNowConnectorOperator.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(ZendeskConnectorOperator.self, forKey: .zendesk)
        zendesk = zendeskDecoded
    }
}

extension ConnectorOperator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectorOperator(marketo: \(String(describing: marketo)), s3: \(String(describing: s3)), salesforce: \(String(describing: salesforce)), serviceNow: \(String(describing: serviceNow)), zendesk: \(String(describing: zendesk)))"}
}

/// <p>The operation to be performed on the provided source fields.</p>
public struct ConnectorOperator: Equatable {
    /// <p>The operation to be performed on the provided Marketo source fields.</p>
    public let marketo: MarketoConnectorOperator?
    /// <p>The operation to be performed on the provided Amazon S3 source fields.</p>
    public let s3: S3ConnectorOperator?
    /// <p>The operation to be performed on the provided Salesforce source fields.</p>
    public let salesforce: SalesforceConnectorOperator?
    /// <p>The operation to be performed on the provided ServiceNow source fields.</p>
    public let serviceNow: ServiceNowConnectorOperator?
    /// <p>The operation to be performed on the provided Zendesk source fields.</p>
    public let zendesk: ZendeskConnectorOperator?

    public init (
        marketo: MarketoConnectorOperator? = nil,
        s3: S3ConnectorOperator? = nil,
        salesforce: SalesforceConnectorOperator? = nil,
        serviceNow: ServiceNowConnectorOperator? = nil,
        zendesk: ZendeskConnectorOperator? = nil
    )
    {
        self.marketo = marketo
        self.s3 = s3
        self.salesforce = salesforce
        self.serviceNow = serviceNow
        self.zendesk = zendesk
    }
}

public struct CreateDomainInputBodyMiddleware: Middleware {
    public let id: String = "CreateDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainInput>
    public typealias MOutput = OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainOutputError>
}

extension CreateDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDomainInput(deadLetterQueueUrl: \(String(describing: deadLetterQueueUrl)), defaultEncryptionKey: \(String(describing: defaultEncryptionKey)), defaultExpirationDays: \(String(describing: defaultExpirationDays)), domainName: \(String(describing: domainName)), matching: \(String(describing: matching)), tags: \(String(describing: tags)))"}
}

extension CreateDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deadLetterQueueUrl = "DeadLetterQueueUrl"
        case defaultEncryptionKey = "DefaultEncryptionKey"
        case defaultExpirationDays = "DefaultExpirationDays"
        case matching = "Matching"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deadLetterQueueUrl = deadLetterQueueUrl {
            try encodeContainer.encode(deadLetterQueueUrl, forKey: .deadLetterQueueUrl)
        }
        if let defaultEncryptionKey = defaultEncryptionKey {
            try encodeContainer.encode(defaultEncryptionKey, forKey: .defaultEncryptionKey)
        }
        if let defaultExpirationDays = defaultExpirationDays {
            try encodeContainer.encode(defaultExpirationDays, forKey: .defaultExpirationDays)
        }
        if let matching = matching {
            try encodeContainer.encode(matching, forKey: .matching)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDomainInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainInput>
    public typealias MOutput = OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainOutputError>
}

public struct CreateDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainInput>
    public typealias MOutput = OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainOutputError>
}

public struct CreateDomainInput: Equatable {
    /// <p>The URL of the SQS dead letter queue, which is used for reporting errors associated with
    ///          ingesting data from third party applications. You must set up a policy on the
    ///          DeadLetterQueue for the SendMessage operation to enable Amazon Connect Customer Profiles to send
    ///          messages to the DeadLetterQueue.</p>
    public let deadLetterQueueUrl: String?
    /// <p>The default encryption key, which is an AWS managed key, is used when no specific type
    ///          of encryption key is specified. It is used to encrypt all data before it is placed in
    ///          permanent or semi-permanent storage.</p>
    public let defaultEncryptionKey: String?
    /// <p>The default number of days until the data within the domain expires.</p>
    public let defaultExpirationDays: Int?
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The process of matching duplicate profiles. This process runs every Saturday at 12AM.</p>
    public let matching: MatchingRequest?
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?

    public init (
        deadLetterQueueUrl: String? = nil,
        defaultEncryptionKey: String? = nil,
        defaultExpirationDays: Int? = nil,
        domainName: String? = nil,
        matching: MatchingRequest? = nil,
        tags: [String:String]? = nil
    )
    {
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.matching = matching
        self.tags = tags
    }
}

struct CreateDomainInputBody: Equatable {
    public let defaultExpirationDays: Int?
    public let defaultEncryptionKey: String?
    public let deadLetterQueueUrl: String?
    public let matching: MatchingRequest?
    public let tags: [String:String]?
}

extension CreateDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deadLetterQueueUrl = "DeadLetterQueueUrl"
        case defaultEncryptionKey = "DefaultEncryptionKey"
        case defaultExpirationDays = "DefaultExpirationDays"
        case matching = "Matching"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultExpirationDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultExpirationDays)
        defaultExpirationDays = defaultExpirationDaysDecoded
        let defaultEncryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultEncryptionKey)
        defaultEncryptionKey = defaultEncryptionKeyDecoded
        let deadLetterQueueUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deadLetterQueueUrl)
        deadLetterQueueUrl = deadLetterQueueUrlDecoded
        let matchingDecoded = try containerValues.decodeIfPresent(MatchingRequest.self, forKey: .matching)
        matching = matchingDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDomainOutputResponse(createdAt: \(String(describing: createdAt)), deadLetterQueueUrl: \(String(describing: deadLetterQueueUrl)), defaultEncryptionKey: \(String(describing: defaultEncryptionKey)), defaultExpirationDays: \(String(describing: defaultExpirationDays)), domainName: \(String(describing: domainName)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), matching: \(String(describing: matching)), tags: \(String(describing: tags)))"}
}

extension CreateDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.deadLetterQueueUrl = output.deadLetterQueueUrl
            self.defaultEncryptionKey = output.defaultEncryptionKey
            self.defaultExpirationDays = output.defaultExpirationDays
            self.domainName = output.domainName
            self.lastUpdatedAt = output.lastUpdatedAt
            self.matching = output.matching
            self.tags = output.tags
        } else {
            self.createdAt = nil
            self.deadLetterQueueUrl = nil
            self.defaultEncryptionKey = nil
            self.defaultExpirationDays = nil
            self.domainName = nil
            self.lastUpdatedAt = nil
            self.matching = nil
            self.tags = nil
        }
    }
}

public struct CreateDomainOutputResponse: Equatable {
    /// <p>The timestamp of when the domain was created.</p>
    public let createdAt: Date?
    /// <p>The URL of the SQS dead letter queue, which is used for reporting errors associated with
    ///          ingesting data from third party applications.</p>
    public let deadLetterQueueUrl: String?
    /// <p>The default encryption key, which is an AWS managed key, is used when no specific type
    ///          of encryption key is specified. It is used to encrypt all data before it is placed in
    ///          permanent or semi-permanent storage.</p>
    public let defaultEncryptionKey: String?
    /// <p>The default number of days until the data within the domain expires.</p>
    public let defaultExpirationDays: Int?
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The timestamp of when the domain was most recently edited.</p>
    public let lastUpdatedAt: Date?
    /// <p>The process of matching duplicate profiles. This process runs every Saturday at 12AM.</p>
    public let matching: MatchingResponse?
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?

    public init (
        createdAt: Date? = nil,
        deadLetterQueueUrl: String? = nil,
        defaultEncryptionKey: String? = nil,
        defaultExpirationDays: Int? = nil,
        domainName: String? = nil,
        lastUpdatedAt: Date? = nil,
        matching: MatchingResponse? = nil,
        tags: [String:String]? = nil
    )
    {
        self.createdAt = createdAt
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.matching = matching
        self.tags = tags
    }
}

struct CreateDomainOutputResponseBody: Equatable {
    public let domainName: String?
    public let defaultExpirationDays: Int?
    public let defaultEncryptionKey: String?
    public let deadLetterQueueUrl: String?
    public let matching: MatchingResponse?
    public let createdAt: Date?
    public let lastUpdatedAt: Date?
    public let tags: [String:String]?
}

extension CreateDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case deadLetterQueueUrl = "DeadLetterQueueUrl"
        case defaultEncryptionKey = "DefaultEncryptionKey"
        case defaultExpirationDays = "DefaultExpirationDays"
        case domainName = "DomainName"
        case lastUpdatedAt = "LastUpdatedAt"
        case matching = "Matching"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let defaultExpirationDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultExpirationDays)
        defaultExpirationDays = defaultExpirationDaysDecoded
        let defaultEncryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultEncryptionKey)
        defaultEncryptionKey = defaultEncryptionKeyDecoded
        let deadLetterQueueUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deadLetterQueueUrl)
        deadLetterQueueUrl = deadLetterQueueUrlDecoded
        let matchingDecoded = try containerValues.decodeIfPresent(MatchingResponse.self, forKey: .matching)
        matching = matchingDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProfileInput>
    public typealias MOutput = OperationOutput<CreateProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProfileOutputError>
}

extension CreateProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProfileInput(accountNumber: \(String(describing: accountNumber)), additionalInformation: \(String(describing: additionalInformation)), address: \(String(describing: address)), attributes: \(String(describing: attributes)), billingAddress: \(String(describing: billingAddress)), birthDate: \(String(describing: birthDate)), businessEmailAddress: \(String(describing: businessEmailAddress)), businessName: \(String(describing: businessName)), businessPhoneNumber: \(String(describing: businessPhoneNumber)), domainName: \(String(describing: domainName)), emailAddress: \(String(describing: emailAddress)), firstName: \(String(describing: firstName)), gender: \(String(describing: gender)), homePhoneNumber: \(String(describing: homePhoneNumber)), lastName: \(String(describing: lastName)), mailingAddress: \(String(describing: mailingAddress)), middleName: \(String(describing: middleName)), mobilePhoneNumber: \(String(describing: mobilePhoneNumber)), partyType: \(String(describing: partyType)), personalEmailAddress: \(String(describing: personalEmailAddress)), phoneNumber: \(String(describing: phoneNumber)), shippingAddress: \(String(describing: shippingAddress)))"}
}

extension CreateProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountNumber = "AccountNumber"
        case additionalInformation = "AdditionalInformation"
        case address = "Address"
        case attributes = "Attributes"
        case billingAddress = "BillingAddress"
        case birthDate = "BirthDate"
        case businessEmailAddress = "BusinessEmailAddress"
        case businessName = "BusinessName"
        case businessPhoneNumber = "BusinessPhoneNumber"
        case emailAddress = "EmailAddress"
        case firstName = "FirstName"
        case gender = "Gender"
        case homePhoneNumber = "HomePhoneNumber"
        case lastName = "LastName"
        case mailingAddress = "MailingAddress"
        case middleName = "MiddleName"
        case mobilePhoneNumber = "MobilePhoneNumber"
        case partyType = "PartyType"
        case personalEmailAddress = "PersonalEmailAddress"
        case phoneNumber = "PhoneNumber"
        case shippingAddress = "ShippingAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountNumber = accountNumber {
            try encodeContainer.encode(accountNumber, forKey: .accountNumber)
        }
        if let additionalInformation = additionalInformation {
            try encodeContainer.encode(additionalInformation, forKey: .additionalInformation)
        }
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let billingAddress = billingAddress {
            try encodeContainer.encode(billingAddress, forKey: .billingAddress)
        }
        if let birthDate = birthDate {
            try encodeContainer.encode(birthDate, forKey: .birthDate)
        }
        if let businessEmailAddress = businessEmailAddress {
            try encodeContainer.encode(businessEmailAddress, forKey: .businessEmailAddress)
        }
        if let businessName = businessName {
            try encodeContainer.encode(businessName, forKey: .businessName)
        }
        if let businessPhoneNumber = businessPhoneNumber {
            try encodeContainer.encode(businessPhoneNumber, forKey: .businessPhoneNumber)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let gender = gender {
            try encodeContainer.encode(gender.rawValue, forKey: .gender)
        }
        if let homePhoneNumber = homePhoneNumber {
            try encodeContainer.encode(homePhoneNumber, forKey: .homePhoneNumber)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let mailingAddress = mailingAddress {
            try encodeContainer.encode(mailingAddress, forKey: .mailingAddress)
        }
        if let middleName = middleName {
            try encodeContainer.encode(middleName, forKey: .middleName)
        }
        if let mobilePhoneNumber = mobilePhoneNumber {
            try encodeContainer.encode(mobilePhoneNumber, forKey: .mobilePhoneNumber)
        }
        if let partyType = partyType {
            try encodeContainer.encode(partyType.rawValue, forKey: .partyType)
        }
        if let personalEmailAddress = personalEmailAddress {
            try encodeContainer.encode(personalEmailAddress, forKey: .personalEmailAddress)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let shippingAddress = shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
    }
}

public struct CreateProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProfileInput>
    public typealias MOutput = OperationOutput<CreateProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProfileOutputError>
}

public struct CreateProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProfileInput>
    public typealias MOutput = OperationOutput<CreateProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProfileOutputError>
}

public struct CreateProfileInput: Equatable {
    /// <p>A unique account number that you have given to the customer.</p>
    public let accountNumber: String?
    /// <p>Any additional information relevant to the customer’s profile.</p>
    public let additionalInformation: String?
    /// <p>A generic address associated with the customer that is not mailing, shipping, or
    ///          billing.</p>
    public let address: Address?
    /// <p>A key value pair of attributes of a customer profile.</p>
    public let attributes: [String:String]?
    /// <p>The customer’s billing address.</p>
    public let billingAddress: Address?
    /// <p>The customer’s birth date. </p>
    public let birthDate: String?
    /// <p>The customer’s business email address.</p>
    public let businessEmailAddress: String?
    /// <p>The name of the customer’s business.</p>
    public let businessName: String?
    /// <p>The customer’s business phone number.</p>
    public let businessPhoneNumber: String?
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The customer’s email address, which has not been specified as a personal or business
    ///          address. </p>
    public let emailAddress: String?
    /// <p>The customer’s first name.</p>
    public let firstName: String?
    /// <p>The gender with which the customer identifies. </p>
    public let gender: Gender?
    /// <p>The customer’s home phone number.</p>
    public let homePhoneNumber: String?
    /// <p>The customer’s last name.</p>
    public let lastName: String?
    /// <p>The customer’s mailing address.</p>
    public let mailingAddress: Address?
    /// <p>The customer’s middle name.</p>
    public let middleName: String?
    /// <p>The customer’s mobile phone number.</p>
    public let mobilePhoneNumber: String?
    /// <p>The type of profile used to describe the customer.</p>
    public let partyType: PartyType?
    /// <p>The customer’s personal email address.</p>
    public let personalEmailAddress: String?
    /// <p>The customer’s phone number, which has not been specified as a mobile, home, or business
    ///          number. </p>
    public let phoneNumber: String?
    /// <p>The customer’s shipping address.</p>
    public let shippingAddress: Address?

    public init (
        accountNumber: String? = nil,
        additionalInformation: String? = nil,
        address: Address? = nil,
        attributes: [String:String]? = nil,
        billingAddress: Address? = nil,
        birthDate: String? = nil,
        businessEmailAddress: String? = nil,
        businessName: String? = nil,
        businessPhoneNumber: String? = nil,
        domainName: String? = nil,
        emailAddress: String? = nil,
        firstName: String? = nil,
        gender: Gender? = nil,
        homePhoneNumber: String? = nil,
        lastName: String? = nil,
        mailingAddress: Address? = nil,
        middleName: String? = nil,
        mobilePhoneNumber: String? = nil,
        partyType: PartyType? = nil,
        personalEmailAddress: String? = nil,
        phoneNumber: String? = nil,
        shippingAddress: Address? = nil
    )
    {
        self.accountNumber = accountNumber
        self.additionalInformation = additionalInformation
        self.address = address
        self.attributes = attributes
        self.billingAddress = billingAddress
        self.birthDate = birthDate
        self.businessEmailAddress = businessEmailAddress
        self.businessName = businessName
        self.businessPhoneNumber = businessPhoneNumber
        self.domainName = domainName
        self.emailAddress = emailAddress
        self.firstName = firstName
        self.gender = gender
        self.homePhoneNumber = homePhoneNumber
        self.lastName = lastName
        self.mailingAddress = mailingAddress
        self.middleName = middleName
        self.mobilePhoneNumber = mobilePhoneNumber
        self.partyType = partyType
        self.personalEmailAddress = personalEmailAddress
        self.phoneNumber = phoneNumber
        self.shippingAddress = shippingAddress
    }
}

struct CreateProfileInputBody: Equatable {
    public let accountNumber: String?
    public let additionalInformation: String?
    public let partyType: PartyType?
    public let businessName: String?
    public let firstName: String?
    public let middleName: String?
    public let lastName: String?
    public let birthDate: String?
    public let gender: Gender?
    public let phoneNumber: String?
    public let mobilePhoneNumber: String?
    public let homePhoneNumber: String?
    public let businessPhoneNumber: String?
    public let emailAddress: String?
    public let personalEmailAddress: String?
    public let businessEmailAddress: String?
    public let address: Address?
    public let shippingAddress: Address?
    public let mailingAddress: Address?
    public let billingAddress: Address?
    public let attributes: [String:String]?
}

extension CreateProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountNumber = "AccountNumber"
        case additionalInformation = "AdditionalInformation"
        case address = "Address"
        case attributes = "Attributes"
        case billingAddress = "BillingAddress"
        case birthDate = "BirthDate"
        case businessEmailAddress = "BusinessEmailAddress"
        case businessName = "BusinessName"
        case businessPhoneNumber = "BusinessPhoneNumber"
        case emailAddress = "EmailAddress"
        case firstName = "FirstName"
        case gender = "Gender"
        case homePhoneNumber = "HomePhoneNumber"
        case lastName = "LastName"
        case mailingAddress = "MailingAddress"
        case middleName = "MiddleName"
        case mobilePhoneNumber = "MobilePhoneNumber"
        case partyType = "PartyType"
        case personalEmailAddress = "PersonalEmailAddress"
        case phoneNumber = "PhoneNumber"
        case shippingAddress = "ShippingAddress"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountNumber)
        accountNumber = accountNumberDecoded
        let additionalInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .additionalInformation)
        additionalInformation = additionalInformationDecoded
        let partyTypeDecoded = try containerValues.decodeIfPresent(PartyType.self, forKey: .partyType)
        partyType = partyTypeDecoded
        let businessNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .businessName)
        businessName = businessNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let middleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .middleName)
        middleName = middleNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let birthDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .birthDate)
        birthDate = birthDateDecoded
        let genderDecoded = try containerValues.decodeIfPresent(Gender.self, forKey: .gender)
        gender = genderDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let mobilePhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mobilePhoneNumber)
        mobilePhoneNumber = mobilePhoneNumberDecoded
        let homePhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homePhoneNumber)
        homePhoneNumber = homePhoneNumberDecoded
        let businessPhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .businessPhoneNumber)
        businessPhoneNumber = businessPhoneNumberDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let personalEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .personalEmailAddress)
        personalEmailAddress = personalEmailAddressDecoded
        let businessEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .businessEmailAddress)
        businessEmailAddress = businessEmailAddressDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Address.self, forKey: .address)
        address = addressDecoded
        let shippingAddressDecoded = try containerValues.decodeIfPresent(Address.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let mailingAddressDecoded = try containerValues.decodeIfPresent(Address.self, forKey: .mailingAddress)
        mailingAddress = mailingAddressDecoded
        let billingAddressDecoded = try containerValues.decodeIfPresent(Address.self, forKey: .billingAddress)
        billingAddress = billingAddressDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, string1to2550) in attributesContainer {
                if let string1to2550 = string1to2550 {
                    attributesDecoded0?[key0] = string1to2550
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CreateProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProfileOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProfileOutputResponse(profileId: \(String(describing: profileId)))"}
}

extension CreateProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.profileId = output.profileId
        } else {
            self.profileId = nil
        }
    }
}

public struct CreateProfileOutputResponse: Equatable {
    /// <p>The unique identifier of a customer profile.</p>
    public let profileId: String?

    public init (
        profileId: String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct CreateProfileOutputResponseBody: Equatable {
    public let profileId: String?
}

extension CreateProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case profileId = "ProfileId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

public enum DataPullMode {
    case complete
    case incremental
    case sdkUnknown(String)
}

extension DataPullMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataPullMode] {
        return [
            .complete,
            .incremental,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "Complete"
        case .incremental: return "Incremental"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataPullMode(rawValue: rawValue) ?? DataPullMode.sdkUnknown(rawValue)
    }
}

extension DeleteDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainInput(domainName: \(String(describing: domainName)))"}
}

extension DeleteDomainInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDomainInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainInput>
    public typealias MOutput = OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainOutputError>
}

public struct DeleteDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainInput>
    public typealias MOutput = OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainOutputError>
}

public struct DeleteDomainInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DeleteDomainInputBody: Equatable {
}

extension DeleteDomainInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainOutputResponse(message: \(String(describing: message)))"}
}

extension DeleteDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteDomainOutputResponse: Equatable {
    /// <p>A message that indicates the delete request is done.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteDomainOutputResponseBody: Equatable {
    public let message: String?
}

extension DeleteDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteIntegrationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteIntegrationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIntegrationInput>
    public typealias MOutput = OperationOutput<DeleteIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIntegrationOutputError>
}

extension DeleteIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIntegrationInput(domainName: \(String(describing: domainName)), uri: \(String(describing: uri)))"}
}

extension DeleteIntegrationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case uri = "Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

public struct DeleteIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIntegrationInput>
    public typealias MOutput = OperationOutput<DeleteIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIntegrationOutputError>
}

public struct DeleteIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIntegrationInput>
    public typealias MOutput = OperationOutput<DeleteIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIntegrationOutputError>
}

public struct DeleteIntegrationInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The URI of the S3 bucket or any other type of data source.</p>
    public let uri: String?

    public init (
        domainName: String? = nil,
        uri: String? = nil
    )
    {
        self.domainName = domainName
        self.uri = uri
    }
}

struct DeleteIntegrationInputBody: Equatable {
    public let uri: String?
}

extension DeleteIntegrationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case uri = "Uri"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension DeleteIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIntegrationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIntegrationOutputResponse(message: \(String(describing: message)))"}
}

extension DeleteIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteIntegrationOutputResponse: Equatable {
    /// <p>A message that indicates the delete request is done.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteIntegrationOutputResponseBody: Equatable {
    public let message: String?
}

extension DeleteIntegrationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteProfileInputBodyMiddleware: Middleware {
    public let id: String = "DeleteProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfileInput>
    public typealias MOutput = OperationOutput<DeleteProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfileOutputError>
}

extension DeleteProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProfileInput(domainName: \(String(describing: domainName)), profileId: \(String(describing: profileId)))"}
}

extension DeleteProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case profileId = "ProfileId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileId = profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
    }
}

public struct DeleteProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfileInput>
    public typealias MOutput = OperationOutput<DeleteProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfileOutputError>
}

public struct DeleteProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfileInput>
    public typealias MOutput = OperationOutput<DeleteProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfileOutputError>
}

public struct DeleteProfileInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The unique identifier of a customer profile.</p>
    public let profileId: String?

    public init (
        domainName: String? = nil,
        profileId: String? = nil
    )
    {
        self.domainName = domainName
        self.profileId = profileId
    }
}

struct DeleteProfileInputBody: Equatable {
    public let profileId: String?
}

extension DeleteProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case profileId = "ProfileId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

public struct DeleteProfileKeyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteProfileKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfileKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfileKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfileKeyInput>
    public typealias MOutput = OperationOutput<DeleteProfileKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfileKeyOutputError>
}

extension DeleteProfileKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProfileKeyInput(domainName: \(String(describing: domainName)), keyName: \(String(describing: keyName)), profileId: \(String(describing: profileId)), values: \(String(describing: values)))"}
}

extension DeleteProfileKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyName = "KeyName"
        case profileId = "ProfileId"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyName = keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let profileId = profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for requestvaluelist0 in values {
                try valuesContainer.encode(requestvaluelist0)
            }
        }
    }
}

public struct DeleteProfileKeyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProfileKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfileKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfileKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfileKeyInput>
    public typealias MOutput = OperationOutput<DeleteProfileKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfileKeyOutputError>
}

public struct DeleteProfileKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProfileKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfileKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfileKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfileKeyInput>
    public typealias MOutput = OperationOutput<DeleteProfileKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfileKeyOutputError>
}

public struct DeleteProfileKeyInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>A searchable identifier of a customer profile.</p>
    public let keyName: String?
    /// <p>The unique identifier of a customer profile.</p>
    public let profileId: String?
    /// <p>A list of key values.</p>
    public let values: [String]?

    public init (
        domainName: String? = nil,
        keyName: String? = nil,
        profileId: String? = nil,
        values: [String]? = nil
    )
    {
        self.domainName = domainName
        self.keyName = keyName
        self.profileId = profileId
        self.values = values
    }
}

struct DeleteProfileKeyInputBody: Equatable {
    public let profileId: String?
    public let keyName: String?
    public let values: [String]?
}

extension DeleteProfileKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyName = "KeyName"
        case profileId = "ProfileId"
        case values = "Values"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DeleteProfileKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProfileKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProfileKeyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProfileKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProfileKeyOutputResponse(message: \(String(describing: message)))"}
}

extension DeleteProfileKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteProfileKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteProfileKeyOutputResponse: Equatable {
    /// <p>A message that indicates the delete request is done.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteProfileKeyOutputResponseBody: Equatable {
    public let message: String?
}

extension DeleteProfileKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteProfileObjectInputBodyMiddleware: Middleware {
    public let id: String = "DeleteProfileObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfileObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfileObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfileObjectInput>
    public typealias MOutput = OperationOutput<DeleteProfileObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfileObjectOutputError>
}

extension DeleteProfileObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProfileObjectInput(domainName: \(String(describing: domainName)), objectTypeName: \(String(describing: objectTypeName)), profileId: \(String(describing: profileId)), profileObjectUniqueKey: \(String(describing: profileObjectUniqueKey)))"}
}

extension DeleteProfileObjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectTypeName = "ObjectTypeName"
        case profileId = "ProfileId"
        case profileObjectUniqueKey = "ProfileObjectUniqueKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectTypeName = objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
        if let profileId = profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let profileObjectUniqueKey = profileObjectUniqueKey {
            try encodeContainer.encode(profileObjectUniqueKey, forKey: .profileObjectUniqueKey)
        }
    }
}

public struct DeleteProfileObjectInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProfileObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfileObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfileObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfileObjectInput>
    public typealias MOutput = OperationOutput<DeleteProfileObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfileObjectOutputError>
}

public struct DeleteProfileObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProfileObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfileObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfileObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfileObjectInput>
    public typealias MOutput = OperationOutput<DeleteProfileObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfileObjectOutputError>
}

public struct DeleteProfileObjectInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The name of the profile object type.</p>
    public let objectTypeName: String?
    /// <p>The unique identifier of a customer profile.</p>
    public let profileId: String?
    /// <p>The unique identifier of the profile object generated by the service.</p>
    public let profileObjectUniqueKey: String?

    public init (
        domainName: String? = nil,
        objectTypeName: String? = nil,
        profileId: String? = nil,
        profileObjectUniqueKey: String? = nil
    )
    {
        self.domainName = domainName
        self.objectTypeName = objectTypeName
        self.profileId = profileId
        self.profileObjectUniqueKey = profileObjectUniqueKey
    }
}

struct DeleteProfileObjectInputBody: Equatable {
    public let profileId: String?
    public let profileObjectUniqueKey: String?
    public let objectTypeName: String?
}

extension DeleteProfileObjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectTypeName = "ObjectTypeName"
        case profileId = "ProfileId"
        case profileObjectUniqueKey = "ProfileObjectUniqueKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let profileObjectUniqueKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileObjectUniqueKey)
        profileObjectUniqueKey = profileObjectUniqueKeyDecoded
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
    }
}

extension DeleteProfileObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProfileObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProfileObjectOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProfileObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProfileObjectOutputResponse(message: \(String(describing: message)))"}
}

extension DeleteProfileObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteProfileObjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteProfileObjectOutputResponse: Equatable {
    /// <p>A message that indicates the delete request is done.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteProfileObjectOutputResponseBody: Equatable {
    public let message: String?
}

extension DeleteProfileObjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteProfileObjectTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProfileObjectTypeInput(domainName: \(String(describing: domainName)), objectTypeName: \(String(describing: objectTypeName)))"}
}

extension DeleteProfileObjectTypeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteProfileObjectTypeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProfileObjectTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfileObjectTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfileObjectTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfileObjectTypeInput>
    public typealias MOutput = OperationOutput<DeleteProfileObjectTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfileObjectTypeOutputError>
}

public struct DeleteProfileObjectTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProfileObjectTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfileObjectTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfileObjectTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfileObjectTypeInput>
    public typealias MOutput = OperationOutput<DeleteProfileObjectTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfileObjectTypeOutputError>
}

public struct DeleteProfileObjectTypeInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The name of the profile object type.</p>
    public let objectTypeName: String?

    public init (
        domainName: String? = nil,
        objectTypeName: String? = nil
    )
    {
        self.domainName = domainName
        self.objectTypeName = objectTypeName
    }
}

struct DeleteProfileObjectTypeInputBody: Equatable {
}

extension DeleteProfileObjectTypeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProfileObjectTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProfileObjectTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProfileObjectTypeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProfileObjectTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProfileObjectTypeOutputResponse(message: \(String(describing: message)))"}
}

extension DeleteProfileObjectTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteProfileObjectTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteProfileObjectTypeOutputResponse: Equatable {
    /// <p>A message that indicates the delete request is done.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteProfileObjectTypeOutputResponseBody: Equatable {
    public let message: String?
}

extension DeleteProfileObjectTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProfileOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProfileOutputResponse(message: \(String(describing: message)))"}
}

extension DeleteProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteProfileOutputResponse: Equatable {
    /// <p>A message that indicates the delete request is done.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteProfileOutputResponseBody: Equatable {
    public let message: String?
}

extension DeleteProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DomainStats: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case meteringProfileCount = "MeteringProfileCount"
        case objectCount = "ObjectCount"
        case profileCount = "ProfileCount"
        case totalSize = "TotalSize"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if meteringProfileCount != 0 {
            try encodeContainer.encode(meteringProfileCount, forKey: .meteringProfileCount)
        }
        if objectCount != 0 {
            try encodeContainer.encode(objectCount, forKey: .objectCount)
        }
        if profileCount != 0 {
            try encodeContainer.encode(profileCount, forKey: .profileCount)
        }
        if totalSize != 0 {
            try encodeContainer.encode(totalSize, forKey: .totalSize)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileCountDecoded = try containerValues.decode(Int.self, forKey: .profileCount)
        profileCount = profileCountDecoded
        let meteringProfileCountDecoded = try containerValues.decode(Int.self, forKey: .meteringProfileCount)
        meteringProfileCount = meteringProfileCountDecoded
        let objectCountDecoded = try containerValues.decode(Int.self, forKey: .objectCount)
        objectCount = objectCountDecoded
        let totalSizeDecoded = try containerValues.decode(Int.self, forKey: .totalSize)
        totalSize = totalSizeDecoded
    }
}

extension DomainStats: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainStats(meteringProfileCount: \(String(describing: meteringProfileCount)), objectCount: \(String(describing: objectCount)), profileCount: \(String(describing: profileCount)), totalSize: \(String(describing: totalSize)))"}
}

/// <p>Usage-specific statistics about the domain.</p>
public struct DomainStats: Equatable {
    /// <p>The number of profiles that you are currently paying for in the domain. If you have more
    ///          than 100 objects associated with a single profile, that profile counts as two profiles. If
    ///          you have more than 200 objects, that profile counts as three, and so on.</p>
    public let meteringProfileCount: Int
    /// <p>The total number of objects in domain.</p>
    public let objectCount: Int
    /// <p>The total number of profiles currently in the domain.</p>
    public let profileCount: Int
    /// <p>The total size, in bytes, of all objects in the domain.</p>
    public let totalSize: Int

    public init (
        meteringProfileCount: Int = 0,
        objectCount: Int = 0,
        profileCount: Int = 0,
        totalSize: Int = 0
    )
    {
        self.meteringProfileCount = meteringProfileCount
        self.objectCount = objectCount
        self.profileCount = profileCount
        self.totalSize = totalSize
    }
}

public enum FieldContentType {
    case emailAddress
    case name
    case number
    case phoneNumber
    case string
    case sdkUnknown(String)
}

extension FieldContentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FieldContentType] {
        return [
            .emailAddress,
            .name,
            .number,
            .phoneNumber,
            .string,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .emailAddress: return "EMAIL_ADDRESS"
        case .name: return "NAME"
        case .number: return "NUMBER"
        case .phoneNumber: return "PHONE_NUMBER"
        case .string: return "STRING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FieldContentType(rawValue: rawValue) ?? FieldContentType.sdkUnknown(rawValue)
    }
}

extension FieldSourceProfileIds: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountNumber = "AccountNumber"
        case additionalInformation = "AdditionalInformation"
        case address = "Address"
        case attributes = "Attributes"
        case billingAddress = "BillingAddress"
        case birthDate = "BirthDate"
        case businessEmailAddress = "BusinessEmailAddress"
        case businessName = "BusinessName"
        case businessPhoneNumber = "BusinessPhoneNumber"
        case emailAddress = "EmailAddress"
        case firstName = "FirstName"
        case gender = "Gender"
        case homePhoneNumber = "HomePhoneNumber"
        case lastName = "LastName"
        case mailingAddress = "MailingAddress"
        case middleName = "MiddleName"
        case mobilePhoneNumber = "MobilePhoneNumber"
        case partyType = "PartyType"
        case personalEmailAddress = "PersonalEmailAddress"
        case phoneNumber = "PhoneNumber"
        case shippingAddress = "ShippingAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountNumber = accountNumber {
            try encodeContainer.encode(accountNumber, forKey: .accountNumber)
        }
        if let additionalInformation = additionalInformation {
            try encodeContainer.encode(additionalInformation, forKey: .additionalInformation)
        }
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributesourceidmap0) in attributes {
                try attributesContainer.encode(attributesourceidmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let billingAddress = billingAddress {
            try encodeContainer.encode(billingAddress, forKey: .billingAddress)
        }
        if let birthDate = birthDate {
            try encodeContainer.encode(birthDate, forKey: .birthDate)
        }
        if let businessEmailAddress = businessEmailAddress {
            try encodeContainer.encode(businessEmailAddress, forKey: .businessEmailAddress)
        }
        if let businessName = businessName {
            try encodeContainer.encode(businessName, forKey: .businessName)
        }
        if let businessPhoneNumber = businessPhoneNumber {
            try encodeContainer.encode(businessPhoneNumber, forKey: .businessPhoneNumber)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let gender = gender {
            try encodeContainer.encode(gender, forKey: .gender)
        }
        if let homePhoneNumber = homePhoneNumber {
            try encodeContainer.encode(homePhoneNumber, forKey: .homePhoneNumber)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let mailingAddress = mailingAddress {
            try encodeContainer.encode(mailingAddress, forKey: .mailingAddress)
        }
        if let middleName = middleName {
            try encodeContainer.encode(middleName, forKey: .middleName)
        }
        if let mobilePhoneNumber = mobilePhoneNumber {
            try encodeContainer.encode(mobilePhoneNumber, forKey: .mobilePhoneNumber)
        }
        if let partyType = partyType {
            try encodeContainer.encode(partyType, forKey: .partyType)
        }
        if let personalEmailAddress = personalEmailAddress {
            try encodeContainer.encode(personalEmailAddress, forKey: .personalEmailAddress)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let shippingAddress = shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountNumber)
        accountNumber = accountNumberDecoded
        let additionalInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .additionalInformation)
        additionalInformation = additionalInformationDecoded
        let partyTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partyType)
        partyType = partyTypeDecoded
        let businessNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .businessName)
        businessName = businessNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let middleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .middleName)
        middleName = middleNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let birthDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .birthDate)
        birthDate = birthDateDecoded
        let genderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gender)
        gender = genderDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let mobilePhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mobilePhoneNumber)
        mobilePhoneNumber = mobilePhoneNumberDecoded
        let homePhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homePhoneNumber)
        homePhoneNumber = homePhoneNumberDecoded
        let businessPhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .businessPhoneNumber)
        businessPhoneNumber = businessPhoneNumberDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let personalEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .personalEmailAddress)
        personalEmailAddress = personalEmailAddressDecoded
        let businessEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .businessEmailAddress)
        businessEmailAddress = businessEmailAddressDecoded
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let shippingAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let mailingAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mailingAddress)
        mailingAddress = mailingAddressDecoded
        let billingAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingAddress)
        billingAddress = billingAddressDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, uuid0) in attributesContainer {
                if let uuid0 = uuid0 {
                    attributesDecoded0?[key0] = uuid0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension FieldSourceProfileIds: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldSourceProfileIds(accountNumber: \(String(describing: accountNumber)), additionalInformation: \(String(describing: additionalInformation)), address: \(String(describing: address)), attributes: \(String(describing: attributes)), billingAddress: \(String(describing: billingAddress)), birthDate: \(String(describing: birthDate)), businessEmailAddress: \(String(describing: businessEmailAddress)), businessName: \(String(describing: businessName)), businessPhoneNumber: \(String(describing: businessPhoneNumber)), emailAddress: \(String(describing: emailAddress)), firstName: \(String(describing: firstName)), gender: \(String(describing: gender)), homePhoneNumber: \(String(describing: homePhoneNumber)), lastName: \(String(describing: lastName)), mailingAddress: \(String(describing: mailingAddress)), middleName: \(String(describing: middleName)), mobilePhoneNumber: \(String(describing: mobilePhoneNumber)), partyType: \(String(describing: partyType)), personalEmailAddress: \(String(describing: personalEmailAddress)), phoneNumber: \(String(describing: phoneNumber)), shippingAddress: \(String(describing: shippingAddress)))"}
}

/// <p>A duplicate customer profile that is to be merged into a main profile. </p>
public struct FieldSourceProfileIds: Equatable {
    /// <p>A unique identifier for the account number field to be merged. </p>
    public let accountNumber: String?
    /// <p>A unique identifier for the additional information field to be merged.</p>
    public let additionalInformation: String?
    /// <p>A unique identifier for the party type field to be merged.</p>
    public let address: String?
    /// <p>A unique identifier for the attributes field to be merged.</p>
    public let attributes: [String:String]?
    /// <p>A unique identifier for the billing type field to be merged.</p>
    public let billingAddress: String?
    /// <p>A unique identifier for the birthdate field to be merged.</p>
    public let birthDate: String?
    /// <p>A unique identifier for the party type field to be merged.</p>
    public let businessEmailAddress: String?
    /// <p>A unique identifier for the business name field to be merged.</p>
    public let businessName: String?
    /// <p>A unique identifier for the business phone number field to be merged.</p>
    public let businessPhoneNumber: String?
    /// <p>A unique identifier for the email address field to be merged.</p>
    public let emailAddress: String?
    /// <p>A unique identifier for the first name field to be merged.</p>
    public let firstName: String?
    /// <p>A unique identifier for the gender field to be merged.</p>
    public let gender: String?
    /// <p>A unique identifier for the home phone number field to be merged.</p>
    public let homePhoneNumber: String?
    /// <p>A unique identifier for the last name field to be merged.</p>
    public let lastName: String?
    /// <p>A unique identifier for the mailing address field to be merged.</p>
    public let mailingAddress: String?
    /// <p>A unique identifier for the middle name field to be merged.</p>
    public let middleName: String?
    /// <p>A unique identifier for the mobile phone number field to be merged.</p>
    public let mobilePhoneNumber: String?
    /// <p>A unique identifier for the party type field to be merged.</p>
    public let partyType: String?
    /// <p>A unique identifier for the personal email address field to be merged.</p>
    public let personalEmailAddress: String?
    /// <p>A unique identifier for the phone number field to be merged.</p>
    public let phoneNumber: String?
    /// <p>A unique identifier for the shipping address field to be merged.</p>
    public let shippingAddress: String?

    public init (
        accountNumber: String? = nil,
        additionalInformation: String? = nil,
        address: String? = nil,
        attributes: [String:String]? = nil,
        billingAddress: String? = nil,
        birthDate: String? = nil,
        businessEmailAddress: String? = nil,
        businessName: String? = nil,
        businessPhoneNumber: String? = nil,
        emailAddress: String? = nil,
        firstName: String? = nil,
        gender: String? = nil,
        homePhoneNumber: String? = nil,
        lastName: String? = nil,
        mailingAddress: String? = nil,
        middleName: String? = nil,
        mobilePhoneNumber: String? = nil,
        partyType: String? = nil,
        personalEmailAddress: String? = nil,
        phoneNumber: String? = nil,
        shippingAddress: String? = nil
    )
    {
        self.accountNumber = accountNumber
        self.additionalInformation = additionalInformation
        self.address = address
        self.attributes = attributes
        self.billingAddress = billingAddress
        self.birthDate = birthDate
        self.businessEmailAddress = businessEmailAddress
        self.businessName = businessName
        self.businessPhoneNumber = businessPhoneNumber
        self.emailAddress = emailAddress
        self.firstName = firstName
        self.gender = gender
        self.homePhoneNumber = homePhoneNumber
        self.lastName = lastName
        self.mailingAddress = mailingAddress
        self.middleName = middleName
        self.mobilePhoneNumber = mobilePhoneNumber
        self.partyType = partyType
        self.personalEmailAddress = personalEmailAddress
        self.phoneNumber = phoneNumber
        self.shippingAddress = shippingAddress
    }
}

extension FlowDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case flowName = "FlowName"
        case kmsArn = "KmsArn"
        case sourceFlowConfig = "SourceFlowConfig"
        case tasks = "Tasks"
        case triggerConfig = "TriggerConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let kmsArn = kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
        if let sourceFlowConfig = sourceFlowConfig {
            try encodeContainer.encode(sourceFlowConfig, forKey: .sourceFlowConfig)
        }
        if let tasks = tasks {
            var tasksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tasks)
            for tasks0 in tasks {
                try tasksContainer.encode(tasks0)
            }
        }
        if let triggerConfig = triggerConfig {
            try encodeContainer.encode(triggerConfig, forKey: .triggerConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let flowNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let sourceFlowConfigDecoded = try containerValues.decodeIfPresent(SourceFlowConfig.self, forKey: .sourceFlowConfig)
        sourceFlowConfig = sourceFlowConfigDecoded
        let tasksContainer = try containerValues.decodeIfPresent([Task?].self, forKey: .tasks)
        var tasksDecoded0:[Task]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [Task]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let triggerConfigDecoded = try containerValues.decodeIfPresent(TriggerConfig.self, forKey: .triggerConfig)
        triggerConfig = triggerConfigDecoded
    }
}

extension FlowDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlowDefinition(description: \(String(describing: description)), flowName: \(String(describing: flowName)), kmsArn: \(String(describing: kmsArn)), sourceFlowConfig: \(String(describing: sourceFlowConfig)), tasks: \(String(describing: tasks)), triggerConfig: \(String(describing: triggerConfig)))"}
}

/// <p>The configurations that control how Customer Profiles retrieves data from the source,
///          Amazon AppFlow. Customer Profiles uses this information to create an AppFlow flow on behalf of
///          customers.</p>
public struct FlowDefinition: Equatable {
    /// <p>A description of the flow you want to create.</p>
    public let description: String?
    /// <p>The specified name of the flow. Use underscores (_) or hyphens (-) only. Spaces are not
    ///          allowed.</p>
    public let flowName: String?
    /// <p>The Amazon Resource Name of the AWS Key Management Service (KMS) key you provide for encryption.</p>
    public let kmsArn: String?
    /// <p>The configuration that controls how Customer Profiles retrieves data from the
    ///          source.</p>
    public let sourceFlowConfig: SourceFlowConfig?
    /// <p>A list of tasks that Customer Profiles performs while transferring the data in the flow
    ///          run.</p>
    public let tasks: [Task]?
    /// <p>The trigger settings that determine how and when the flow runs.</p>
    public let triggerConfig: TriggerConfig?

    public init (
        description: String? = nil,
        flowName: String? = nil,
        kmsArn: String? = nil,
        sourceFlowConfig: SourceFlowConfig? = nil,
        tasks: [Task]? = nil,
        triggerConfig: TriggerConfig? = nil
    )
    {
        self.description = description
        self.flowName = flowName
        self.kmsArn = kmsArn
        self.sourceFlowConfig = sourceFlowConfig
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

public enum Gender {
    case female
    case male
    case unspecified
    case sdkUnknown(String)
}

extension Gender : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Gender] {
        return [
            .female,
            .male,
            .unspecified,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .female: return "FEMALE"
        case .male: return "MALE"
        case .unspecified: return "UNSPECIFIED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Gender(rawValue: rawValue) ?? Gender.sdkUnknown(rawValue)
    }
}

extension GetDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainInput(domainName: \(String(describing: domainName)))"}
}

extension GetDomainInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDomainInputHeadersMiddleware: Middleware {
    public let id: String = "GetDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainInput>
    public typealias MOutput = OperationOutput<GetDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainOutputError>
}

public struct GetDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainInput>
    public typealias MOutput = OperationOutput<GetDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainOutputError>
}

public struct GetDomainInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetDomainInputBody: Equatable {
}

extension GetDomainInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainOutputResponse(createdAt: \(String(describing: createdAt)), deadLetterQueueUrl: \(String(describing: deadLetterQueueUrl)), defaultEncryptionKey: \(String(describing: defaultEncryptionKey)), defaultExpirationDays: \(String(describing: defaultExpirationDays)), domainName: \(String(describing: domainName)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), matching: \(String(describing: matching)), stats: \(String(describing: stats)), tags: \(String(describing: tags)))"}
}

extension GetDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.deadLetterQueueUrl = output.deadLetterQueueUrl
            self.defaultEncryptionKey = output.defaultEncryptionKey
            self.defaultExpirationDays = output.defaultExpirationDays
            self.domainName = output.domainName
            self.lastUpdatedAt = output.lastUpdatedAt
            self.matching = output.matching
            self.stats = output.stats
            self.tags = output.tags
        } else {
            self.createdAt = nil
            self.deadLetterQueueUrl = nil
            self.defaultEncryptionKey = nil
            self.defaultExpirationDays = nil
            self.domainName = nil
            self.lastUpdatedAt = nil
            self.matching = nil
            self.stats = nil
            self.tags = nil
        }
    }
}

public struct GetDomainOutputResponse: Equatable {
    /// <p>The timestamp of when the domain was created.</p>
    public let createdAt: Date?
    /// <p>The URL of the SQS dead letter queue, which is used for reporting errors associated with
    ///          ingesting data from third party applications.</p>
    public let deadLetterQueueUrl: String?
    /// <p>The default encryption key, which is an AWS managed key, is used when no specific type
    ///          of encryption key is specified. It is used to encrypt all data before it is placed in
    ///          permanent or semi-permanent storage.</p>
    public let defaultEncryptionKey: String?
    /// <p>The default number of days until the data within the domain expires.</p>
    public let defaultExpirationDays: Int?
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The timestamp of when the domain was most recently edited.</p>
    public let lastUpdatedAt: Date?
    /// <p>The process of matching duplicate profiles. This process runs every Saturday at 12AM.</p>
    public let matching: MatchingResponse?
    /// <p>Usage-specific statistics about the domain.</p>
    public let stats: DomainStats?
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?

    public init (
        createdAt: Date? = nil,
        deadLetterQueueUrl: String? = nil,
        defaultEncryptionKey: String? = nil,
        defaultExpirationDays: Int? = nil,
        domainName: String? = nil,
        lastUpdatedAt: Date? = nil,
        matching: MatchingResponse? = nil,
        stats: DomainStats? = nil,
        tags: [String:String]? = nil
    )
    {
        self.createdAt = createdAt
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.matching = matching
        self.stats = stats
        self.tags = tags
    }
}

struct GetDomainOutputResponseBody: Equatable {
    public let domainName: String?
    public let defaultExpirationDays: Int?
    public let defaultEncryptionKey: String?
    public let deadLetterQueueUrl: String?
    public let stats: DomainStats?
    public let matching: MatchingResponse?
    public let createdAt: Date?
    public let lastUpdatedAt: Date?
    public let tags: [String:String]?
}

extension GetDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case deadLetterQueueUrl = "DeadLetterQueueUrl"
        case defaultEncryptionKey = "DefaultEncryptionKey"
        case defaultExpirationDays = "DefaultExpirationDays"
        case domainName = "DomainName"
        case lastUpdatedAt = "LastUpdatedAt"
        case matching = "Matching"
        case stats = "Stats"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let defaultExpirationDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultExpirationDays)
        defaultExpirationDays = defaultExpirationDaysDecoded
        let defaultEncryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultEncryptionKey)
        defaultEncryptionKey = defaultEncryptionKeyDecoded
        let deadLetterQueueUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deadLetterQueueUrl)
        deadLetterQueueUrl = deadLetterQueueUrlDecoded
        let statsDecoded = try containerValues.decodeIfPresent(DomainStats.self, forKey: .stats)
        stats = statsDecoded
        let matchingDecoded = try containerValues.decodeIfPresent(MatchingResponse.self, forKey: .matching)
        matching = matchingDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct GetIntegrationInputBodyMiddleware: Middleware {
    public let id: String = "GetIntegrationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntegrationInput>
    public typealias MOutput = OperationOutput<GetIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntegrationOutputError>
}

extension GetIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntegrationInput(domainName: \(String(describing: domainName)), uri: \(String(describing: uri)))"}
}

extension GetIntegrationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case uri = "Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

public struct GetIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "GetIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntegrationInput>
    public typealias MOutput = OperationOutput<GetIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntegrationOutputError>
}

public struct GetIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntegrationInput>
    public typealias MOutput = OperationOutput<GetIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntegrationOutputError>
}

public struct GetIntegrationInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The URI of the S3 bucket or any other type of data source.</p>
    public let uri: String?

    public init (
        domainName: String? = nil,
        uri: String? = nil
    )
    {
        self.domainName = domainName
        self.uri = uri
    }
}

struct GetIntegrationInputBody: Equatable {
    public let uri: String?
}

extension GetIntegrationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case uri = "Uri"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension GetIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntegrationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntegrationOutputResponse(createdAt: \(String(describing: createdAt)), domainName: \(String(describing: domainName)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), objectTypeName: \(String(describing: objectTypeName)), tags: \(String(describing: tags)), uri: \(String(describing: uri)))"}
}

extension GetIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.domainName = output.domainName
            self.lastUpdatedAt = output.lastUpdatedAt
            self.objectTypeName = output.objectTypeName
            self.tags = output.tags
            self.uri = output.uri
        } else {
            self.createdAt = nil
            self.domainName = nil
            self.lastUpdatedAt = nil
            self.objectTypeName = nil
            self.tags = nil
            self.uri = nil
        }
    }
}

public struct GetIntegrationOutputResponse: Equatable {
    /// <p>The timestamp of when the domain was created.</p>
    public let createdAt: Date?
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The timestamp of when the domain was most recently edited.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the profile object type.</p>
    public let objectTypeName: String?
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?
    /// <p>The URI of the S3 bucket or any other type of data source.</p>
    public let uri: String?

    public init (
        createdAt: Date? = nil,
        domainName: String? = nil,
        lastUpdatedAt: Date? = nil,
        objectTypeName: String? = nil,
        tags: [String:String]? = nil,
        uri: String? = nil
    )
    {
        self.createdAt = createdAt
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.tags = tags
        self.uri = uri
    }
}

struct GetIntegrationOutputResponseBody: Equatable {
    public let domainName: String?
    public let uri: String?
    public let objectTypeName: String?
    public let createdAt: Date?
    public let lastUpdatedAt: Date?
    public let tags: [String:String]?
}

extension GetIntegrationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case domainName = "DomainName"
        case lastUpdatedAt = "LastUpdatedAt"
        case objectTypeName = "ObjectTypeName"
        case tags = "Tags"
        case uri = "Uri"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetMatchesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMatchesInput(domainName: \(String(describing: domainName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetMatchesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetMatchesInputHeadersMiddleware: Middleware {
    public let id: String = "GetMatchesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMatchesInput>
    public typealias MOutput = OperationOutput<GetMatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMatchesOutputError>
}

public struct GetMatchesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMatchesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMatchesInput>
    public typealias MOutput = OperationOutput<GetMatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMatchesOutputError>
}

public struct GetMatchesInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        domainName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetMatchesInputBody: Equatable {
}

extension GetMatchesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetMatchesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMatchesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMatchesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMatchesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMatchesOutputResponse(matchGenerationDate: \(String(describing: matchGenerationDate)), matches: \(String(describing: matches)), nextToken: \(String(describing: nextToken)), potentialMatches: \(String(describing: potentialMatches)))"}
}

extension GetMatchesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMatchesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.matchGenerationDate = output.matchGenerationDate
            self.matches = output.matches
            self.nextToken = output.nextToken
            self.potentialMatches = output.potentialMatches
        } else {
            self.matchGenerationDate = nil
            self.matches = nil
            self.nextToken = nil
            self.potentialMatches = nil
        }
    }
}

public struct GetMatchesOutputResponse: Equatable {
    /// <p>The timestamp this version of Match Result generated.</p>
    public let matchGenerationDate: Date?
    /// <p>The list of matched profiles for this instance.</p>
    public let matches: [MatchItem]?
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?
    /// <p>The number of potential matches found.</p>
    public let potentialMatches: Int?

    public init (
        matchGenerationDate: Date? = nil,
        matches: [MatchItem]? = nil,
        nextToken: String? = nil,
        potentialMatches: Int? = nil
    )
    {
        self.matchGenerationDate = matchGenerationDate
        self.matches = matches
        self.nextToken = nextToken
        self.potentialMatches = potentialMatches
    }
}

struct GetMatchesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let matchGenerationDate: Date?
    public let potentialMatches: Int?
    public let matches: [MatchItem]?
}

extension GetMatchesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case matchGenerationDate = "MatchGenerationDate"
        case matches = "Matches"
        case nextToken = "NextToken"
        case potentialMatches = "PotentialMatches"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let matchGenerationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .matchGenerationDate)
        matchGenerationDate = matchGenerationDateDecoded
        let potentialMatchesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .potentialMatches)
        potentialMatches = potentialMatchesDecoded
        let matchesContainer = try containerValues.decodeIfPresent([MatchItem?].self, forKey: .matches)
        var matchesDecoded0:[MatchItem]? = nil
        if let matchesContainer = matchesContainer {
            matchesDecoded0 = [MatchItem]()
            for structure0 in matchesContainer {
                if let structure0 = structure0 {
                    matchesDecoded0?.append(structure0)
                }
            }
        }
        matches = matchesDecoded0
    }
}

extension GetProfileObjectTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProfileObjectTypeInput(domainName: \(String(describing: domainName)), objectTypeName: \(String(describing: objectTypeName)))"}
}

extension GetProfileObjectTypeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetProfileObjectTypeInputHeadersMiddleware: Middleware {
    public let id: String = "GetProfileObjectTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProfileObjectTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProfileObjectTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProfileObjectTypeInput>
    public typealias MOutput = OperationOutput<GetProfileObjectTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProfileObjectTypeOutputError>
}

public struct GetProfileObjectTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "GetProfileObjectTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProfileObjectTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProfileObjectTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProfileObjectTypeInput>
    public typealias MOutput = OperationOutput<GetProfileObjectTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProfileObjectTypeOutputError>
}

public struct GetProfileObjectTypeInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The name of the profile object type.</p>
    public let objectTypeName: String?

    public init (
        domainName: String? = nil,
        objectTypeName: String? = nil
    )
    {
        self.domainName = domainName
        self.objectTypeName = objectTypeName
    }
}

struct GetProfileObjectTypeInputBody: Equatable {
}

extension GetProfileObjectTypeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetProfileObjectTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProfileObjectTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProfileObjectTypeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProfileObjectTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProfileObjectTypeOutputResponse(allowProfileCreation: \(String(describing: allowProfileCreation)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), encryptionKey: \(String(describing: encryptionKey)), expirationDays: \(String(describing: expirationDays)), fields: \(String(describing: fields)), keys: \(String(describing: keys)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), objectTypeName: \(String(describing: objectTypeName)), tags: \(String(describing: tags)), templateId: \(String(describing: templateId)))"}
}

extension GetProfileObjectTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetProfileObjectTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.allowProfileCreation = output.allowProfileCreation
            self.createdAt = output.createdAt
            self.description = output.description
            self.encryptionKey = output.encryptionKey
            self.expirationDays = output.expirationDays
            self.fields = output.fields
            self.keys = output.keys
            self.lastUpdatedAt = output.lastUpdatedAt
            self.objectTypeName = output.objectTypeName
            self.tags = output.tags
            self.templateId = output.templateId
        } else {
            self.allowProfileCreation = false
            self.createdAt = nil
            self.description = nil
            self.encryptionKey = nil
            self.expirationDays = nil
            self.fields = nil
            self.keys = nil
            self.lastUpdatedAt = nil
            self.objectTypeName = nil
            self.tags = nil
            self.templateId = nil
        }
    }
}

public struct GetProfileObjectTypeOutputResponse: Equatable {
    /// <p>Indicates whether a profile should be created when data is received if one doesn’t exist
    ///          for an object of this type. The default is <code>FALSE</code>. If the AllowProfileCreation
    ///          flag is set to <code>FALSE</code>, then the service tries to fetch a standard profile and
    ///          associate this object with the profile. If it is set to <code>TRUE</code>, and if no match
    ///          is found, then the service creates a new standard profile.</p>
    public let allowProfileCreation: Bool
    /// <p>The timestamp of when the domain was created.</p>
    public let createdAt: Date?
    /// <p>The description of the profile object type.</p>
    public let description: String?
    /// <p>The customer-provided key to encrypt the profile object that will be created in this
    ///          profile object type.</p>
    public let encryptionKey: String?
    /// <p>The number of days until the data in the object expires.</p>
    public let expirationDays: Int?
    /// <p>A map of the name and ObjectType field.</p>
    public let fields: [String:ObjectTypeField]?
    /// <p>A list of unique keys that can be used to map data to the profile.</p>
    public let keys: [String:[ObjectTypeKey]]?
    /// <p>The timestamp of when the domain was most recently edited.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the profile object type.</p>
    public let objectTypeName: String?
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?
    /// <p>A unique identifier for the object template.</p>
    public let templateId: String?

    public init (
        allowProfileCreation: Bool = false,
        createdAt: Date? = nil,
        description: String? = nil,
        encryptionKey: String? = nil,
        expirationDays: Int? = nil,
        fields: [String:ObjectTypeField]? = nil,
        keys: [String:[ObjectTypeKey]]? = nil,
        lastUpdatedAt: Date? = nil,
        objectTypeName: String? = nil,
        tags: [String:String]? = nil,
        templateId: String? = nil
    )
    {
        self.allowProfileCreation = allowProfileCreation
        self.createdAt = createdAt
        self.description = description
        self.encryptionKey = encryptionKey
        self.expirationDays = expirationDays
        self.fields = fields
        self.keys = keys
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.tags = tags
        self.templateId = templateId
    }
}

struct GetProfileObjectTypeOutputResponseBody: Equatable {
    public let objectTypeName: String?
    public let description: String?
    public let templateId: String?
    public let expirationDays: Int?
    public let encryptionKey: String?
    public let allowProfileCreation: Bool
    public let fields: [String:ObjectTypeField]?
    public let keys: [String:[ObjectTypeKey]]?
    public let createdAt: Date?
    public let lastUpdatedAt: Date?
    public let tags: [String:String]?
}

extension GetProfileObjectTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowProfileCreation = "AllowProfileCreation"
        case createdAt = "CreatedAt"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case expirationDays = "ExpirationDays"
        case fields = "Fields"
        case keys = "Keys"
        case lastUpdatedAt = "LastUpdatedAt"
        case objectTypeName = "ObjectTypeName"
        case tags = "Tags"
        case templateId = "TemplateId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let expirationDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expirationDays)
        expirationDays = expirationDaysDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let allowProfileCreationDecoded = try containerValues.decode(Bool.self, forKey: .allowProfileCreation)
        allowProfileCreation = allowProfileCreationDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([String: ObjectTypeField?].self, forKey: .fields)
        var fieldsDecoded0: [String:ObjectTypeField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [String:ObjectTypeField]()
            for (key0, objecttypefield0) in fieldsContainer {
                if let objecttypefield0 = objecttypefield0 {
                    fieldsDecoded0?[key0] = objecttypefield0
                }
            }
        }
        fields = fieldsDecoded0
        let keysContainer = try containerValues.decodeIfPresent([String: [ObjectTypeKey?]?].self, forKey: .keys)
        var keysDecoded0: [String:[ObjectTypeKey]]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [String:[ObjectTypeKey]]()
            for (key0, objecttypekeylist0) in keysContainer {
                var objecttypekeylist0Decoded0: [ObjectTypeKey]? = nil
                if let objecttypekeylist0 = objecttypekeylist0 {
                    objecttypekeylist0Decoded0 = [ObjectTypeKey]()
                    for structure1 in objecttypekeylist0 {
                        if let structure1 = structure1 {
                            objecttypekeylist0Decoded0?.append(structure1)
                        }
                    }
                }
                keysDecoded0?[key0] = objecttypekeylist0Decoded0
            }
        }
        keys = keysDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetProfileObjectTypeTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProfileObjectTypeTemplateInput(templateId: \(String(describing: templateId)))"}
}

extension GetProfileObjectTypeTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetProfileObjectTypeTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetProfileObjectTypeTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProfileObjectTypeTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProfileObjectTypeTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProfileObjectTypeTemplateInput>
    public typealias MOutput = OperationOutput<GetProfileObjectTypeTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProfileObjectTypeTemplateOutputError>
}

public struct GetProfileObjectTypeTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetProfileObjectTypeTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProfileObjectTypeTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProfileObjectTypeTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProfileObjectTypeTemplateInput>
    public typealias MOutput = OperationOutput<GetProfileObjectTypeTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProfileObjectTypeTemplateOutputError>
}

public struct GetProfileObjectTypeTemplateInput: Equatable {
    /// <p>A unique identifier for the object template.</p>
    public let templateId: String?

    public init (
        templateId: String? = nil
    )
    {
        self.templateId = templateId
    }
}

struct GetProfileObjectTypeTemplateInputBody: Equatable {
}

extension GetProfileObjectTypeTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetProfileObjectTypeTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProfileObjectTypeTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProfileObjectTypeTemplateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProfileObjectTypeTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProfileObjectTypeTemplateOutputResponse(allowProfileCreation: \(String(describing: allowProfileCreation)), fields: \(String(describing: fields)), keys: \(String(describing: keys)), sourceName: \(String(describing: sourceName)), sourceObject: \(String(describing: sourceObject)), templateId: \(String(describing: templateId)))"}
}

extension GetProfileObjectTypeTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetProfileObjectTypeTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.allowProfileCreation = output.allowProfileCreation
            self.fields = output.fields
            self.keys = output.keys
            self.sourceName = output.sourceName
            self.sourceObject = output.sourceObject
            self.templateId = output.templateId
        } else {
            self.allowProfileCreation = false
            self.fields = nil
            self.keys = nil
            self.sourceName = nil
            self.sourceObject = nil
            self.templateId = nil
        }
    }
}

public struct GetProfileObjectTypeTemplateOutputResponse: Equatable {
    /// <p>Indicates whether a profile should be created when data is received if one doesn’t exist
    ///          for an object of this type. The default is <code>FALSE</code>. If the AllowProfileCreation
    ///          flag is set to <code>FALSE</code>, then the service tries to fetch a standard profile and
    ///          associate this object with the profile. If it is set to <code>TRUE</code>, and if no match
    ///          is found, then the service creates a new standard profile.</p>
    public let allowProfileCreation: Bool
    /// <p>A map of the name and ObjectType field.</p>
    public let fields: [String:ObjectTypeField]?
    /// <p>A list of unique keys that can be used to map data to the profile.</p>
    public let keys: [String:[ObjectTypeKey]]?
    /// <p>The name of the source of the object template.</p>
    public let sourceName: String?
    /// <p>The source of the object template.</p>
    public let sourceObject: String?
    /// <p>A unique identifier for the object template.</p>
    public let templateId: String?

    public init (
        allowProfileCreation: Bool = false,
        fields: [String:ObjectTypeField]? = nil,
        keys: [String:[ObjectTypeKey]]? = nil,
        sourceName: String? = nil,
        sourceObject: String? = nil,
        templateId: String? = nil
    )
    {
        self.allowProfileCreation = allowProfileCreation
        self.fields = fields
        self.keys = keys
        self.sourceName = sourceName
        self.sourceObject = sourceObject
        self.templateId = templateId
    }
}

struct GetProfileObjectTypeTemplateOutputResponseBody: Equatable {
    public let templateId: String?
    public let sourceName: String?
    public let sourceObject: String?
    public let allowProfileCreation: Bool
    public let fields: [String:ObjectTypeField]?
    public let keys: [String:[ObjectTypeKey]]?
}

extension GetProfileObjectTypeTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowProfileCreation = "AllowProfileCreation"
        case fields = "Fields"
        case keys = "Keys"
        case sourceName = "SourceName"
        case sourceObject = "SourceObject"
        case templateId = "TemplateId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let sourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceObjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceObject)
        sourceObject = sourceObjectDecoded
        let allowProfileCreationDecoded = try containerValues.decode(Bool.self, forKey: .allowProfileCreation)
        allowProfileCreation = allowProfileCreationDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([String: ObjectTypeField?].self, forKey: .fields)
        var fieldsDecoded0: [String:ObjectTypeField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [String:ObjectTypeField]()
            for (key0, objecttypefield0) in fieldsContainer {
                if let objecttypefield0 = objecttypefield0 {
                    fieldsDecoded0?[key0] = objecttypefield0
                }
            }
        }
        fields = fieldsDecoded0
        let keysContainer = try containerValues.decodeIfPresent([String: [ObjectTypeKey?]?].self, forKey: .keys)
        var keysDecoded0: [String:[ObjectTypeKey]]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [String:[ObjectTypeKey]]()
            for (key0, objecttypekeylist0) in keysContainer {
                var objecttypekeylist0Decoded0: [ObjectTypeKey]? = nil
                if let objecttypekeylist0 = objecttypekeylist0 {
                    objecttypekeylist0Decoded0 = [ObjectTypeKey]()
                    for structure1 in objecttypekeylist0 {
                        if let structure1 = structure1 {
                            objecttypekeylist0Decoded0?.append(structure1)
                        }
                    }
                }
                keysDecoded0?[key0] = objecttypekeylist0Decoded0
            }
        }
        keys = keysDecoded0
    }
}

extension IncrementalPullConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datetimeTypeFieldName = "DatetimeTypeFieldName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datetimeTypeFieldName = datetimeTypeFieldName {
            try encodeContainer.encode(datetimeTypeFieldName, forKey: .datetimeTypeFieldName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datetimeTypeFieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datetimeTypeFieldName)
        datetimeTypeFieldName = datetimeTypeFieldNameDecoded
    }
}

extension IncrementalPullConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncrementalPullConfig(datetimeTypeFieldName: \(String(describing: datetimeTypeFieldName)))"}
}

/// <p>Specifies the configuration used when importing incremental records from the
///          source.</p>
public struct IncrementalPullConfig: Equatable {
    /// <p>A field that specifies the date time or timestamp field as the criteria to use when
    ///          importing incremental records from the source.</p>
    public let datetimeTypeFieldName: String?

    public init (
        datetimeTypeFieldName: String? = nil
    )
    {
        self.datetimeTypeFieldName = datetimeTypeFieldName
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal service error occurred.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAccountIntegrationsInputBodyMiddleware: Middleware {
    public let id: String = "ListAccountIntegrationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountIntegrationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountIntegrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountIntegrationsInput>
    public typealias MOutput = OperationOutput<ListAccountIntegrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountIntegrationsOutputError>
}

extension ListAccountIntegrationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountIntegrationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), uri: \(String(describing: uri)))"}
}

extension ListAccountIntegrationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case uri = "Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

public struct ListAccountIntegrationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccountIntegrationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountIntegrationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountIntegrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountIntegrationsInput>
    public typealias MOutput = OperationOutput<ListAccountIntegrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountIntegrationsOutputError>
}

public struct ListAccountIntegrationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccountIntegrationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountIntegrationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountIntegrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountIntegrationsInput>
    public typealias MOutput = OperationOutput<ListAccountIntegrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountIntegrationsOutputError>
}

public struct ListAccountIntegrationsInput: Equatable {
    /// <p>The maximum number of objects returned per page.</p>
    public let maxResults: Int?
    /// <p>The pagination token from the previous ListAccountIntegrations API call.</p>
    public let nextToken: String?
    /// <p>The URI of the S3 bucket or any other type of data source.</p>
    public let uri: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        uri: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.uri = uri
    }
}

struct ListAccountIntegrationsInputBody: Equatable {
    public let uri: String?
}

extension ListAccountIntegrationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case uri = "Uri"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension ListAccountIntegrationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccountIntegrationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccountIntegrationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountIntegrationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountIntegrationsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccountIntegrationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccountIntegrationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountIntegrationsOutputResponse: Equatable {
    /// <p>The list of ListAccountIntegration instances.</p>
    public let items: [ListIntegrationItem]?
    /// <p>The pagination token from the previous ListAccountIntegrations API call.</p>
    public let nextToken: String?

    public init (
        items: [ListIntegrationItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListAccountIntegrationsOutputResponseBody: Equatable {
    public let items: [ListIntegrationItem]?
    public let nextToken: String?
}

extension ListAccountIntegrationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ListIntegrationItem?].self, forKey: .items)
        var itemsDecoded0:[ListIntegrationItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ListIntegrationItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDomainItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case domainName = "DomainName"
        case lastUpdatedAt = "LastUpdatedAt"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListDomainItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainItem(createdAt: \(String(describing: createdAt)), domainName: \(String(describing: domainName)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), tags: \(String(describing: tags)))"}
}

/// <p>An object in a list that represents a domain.</p>
public struct ListDomainItem: Equatable {
    /// <p>The timestamp of when the domain was created.</p>
    public let createdAt: Date?
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The timestamp of when the domain was most recently edited.</p>
    public let lastUpdatedAt: Date?
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?

    public init (
        createdAt: Date? = nil,
        domainName: String? = nil,
        lastUpdatedAt: Date? = nil,
        tags: [String:String]? = nil
    )
    {
        self.createdAt = createdAt
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.tags = tags
    }
}

extension ListDomainsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDomainsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDomainsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDomainsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainsInput>
    public typealias MOutput = OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainsOutputError>
}

public struct ListDomainsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDomainsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainsInput>
    public typealias MOutput = OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainsOutputError>
}

public struct ListDomainsInput: Equatable {
    /// <p>The maximum number of objects returned per page.</p>
    public let maxResults: Int?
    /// <p>The pagination token from the previous ListDomain API call.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Equatable {
}

extension ListDomainsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDomainsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDomainsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDomainsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutputResponse: Equatable {
    /// <p>The list of ListDomains instances.</p>
    public let items: [ListDomainItem]?
    /// <p>The pagination token from the previous ListDomains API call.</p>
    public let nextToken: String?

    public init (
        items: [ListDomainItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputResponseBody: Equatable {
    public let items: [ListDomainItem]?
    public let nextToken: String?
}

extension ListDomainsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ListDomainItem?].self, forKey: .items)
        var itemsDecoded0:[ListDomainItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ListDomainItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIntegrationItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case domainName = "DomainName"
        case lastUpdatedAt = "LastUpdatedAt"
        case objectTypeName = "ObjectTypeName"
        case tags = "Tags"
        case uri = "Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let objectTypeName = objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListIntegrationItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIntegrationItem(createdAt: \(String(describing: createdAt)), domainName: \(String(describing: domainName)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), objectTypeName: \(String(describing: objectTypeName)), tags: \(String(describing: tags)), uri: \(String(describing: uri)))"}
}

/// <p>An integration in list of integrations.</p>
public struct ListIntegrationItem: Equatable {
    /// <p>The timestamp of when the domain was created.</p>
    public let createdAt: Date?
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The timestamp of when the domain was most recently edited.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the profile object type.</p>
    public let objectTypeName: String?
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?
    /// <p>The URI of the S3 bucket or any other type of data source.</p>
    public let uri: String?

    public init (
        createdAt: Date? = nil,
        domainName: String? = nil,
        lastUpdatedAt: Date? = nil,
        objectTypeName: String? = nil,
        tags: [String:String]? = nil,
        uri: String? = nil
    )
    {
        self.createdAt = createdAt
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.tags = tags
        self.uri = uri
    }
}

extension ListIntegrationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIntegrationsInput(domainName: \(String(describing: domainName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIntegrationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListIntegrationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListIntegrationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIntegrationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIntegrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIntegrationsInput>
    public typealias MOutput = OperationOutput<ListIntegrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIntegrationsOutputError>
}

public struct ListIntegrationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIntegrationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIntegrationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIntegrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIntegrationsInput>
    public typealias MOutput = OperationOutput<ListIntegrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIntegrationsOutputError>
}

public struct ListIntegrationsInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The maximum number of objects returned per page.</p>
    public let maxResults: Int?
    /// <p>The pagination token from the previous ListIntegrations API call.</p>
    public let nextToken: String?

    public init (
        domainName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIntegrationsInputBody: Equatable {
}

extension ListIntegrationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListIntegrationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIntegrationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIntegrationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIntegrationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIntegrationsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIntegrationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIntegrationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListIntegrationsOutputResponse: Equatable {
    /// <p>The list of ListIntegrations instances.</p>
    public let items: [ListIntegrationItem]?
    /// <p>The pagination token from the previous ListIntegrations API call.</p>
    public let nextToken: String?

    public init (
        items: [ListIntegrationItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListIntegrationsOutputResponseBody: Equatable {
    public let items: [ListIntegrationItem]?
    public let nextToken: String?
}

extension ListIntegrationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ListIntegrationItem?].self, forKey: .items)
        var itemsDecoded0:[ListIntegrationItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ListIntegrationItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProfileObjectTypeItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case lastUpdatedAt = "LastUpdatedAt"
        case objectTypeName = "ObjectTypeName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let objectTypeName = objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListProfileObjectTypeItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProfileObjectTypeItem(createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), objectTypeName: \(String(describing: objectTypeName)), tags: \(String(describing: tags)))"}
}

/// <p>A ProfileObjectType instance.</p>
public struct ListProfileObjectTypeItem: Equatable {
    /// <p>The timestamp of when the domain was created.</p>
    public let createdAt: Date?
    /// <p>Description of the profile object type.</p>
    public let description: String?
    /// <p>The timestamp of when the domain was most recently edited.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the profile object type.</p>
    public let objectTypeName: String?
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?

    public init (
        createdAt: Date? = nil,
        description: String? = nil,
        lastUpdatedAt: Date? = nil,
        objectTypeName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.tags = tags
    }
}

extension ListProfileObjectTypeTemplateItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceName = "SourceName"
        case sourceObject = "SourceObject"
        case templateId = "TemplateId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceName = sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceObject = sourceObject {
            try encodeContainer.encode(sourceObject, forKey: .sourceObject)
        }
        if let templateId = templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let sourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceObjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceObject)
        sourceObject = sourceObjectDecoded
    }
}

extension ListProfileObjectTypeTemplateItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProfileObjectTypeTemplateItem(sourceName: \(String(describing: sourceName)), sourceObject: \(String(describing: sourceObject)), templateId: \(String(describing: templateId)))"}
}

/// <p>A ProfileObjectTypeTemplate in a list of ProfileObjectTypeTemplates.</p>
public struct ListProfileObjectTypeTemplateItem: Equatable {
    /// <p>The name of the source of the object template.</p>
    public let sourceName: String?
    /// <p>The source of the object template.</p>
    public let sourceObject: String?
    /// <p>A unique identifier for the object template.</p>
    public let templateId: String?

    public init (
        sourceName: String? = nil,
        sourceObject: String? = nil,
        templateId: String? = nil
    )
    {
        self.sourceName = sourceName
        self.sourceObject = sourceObject
        self.templateId = templateId
    }
}

extension ListProfileObjectTypeTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProfileObjectTypeTemplatesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProfileObjectTypeTemplatesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProfileObjectTypeTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListProfileObjectTypeTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProfileObjectTypeTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProfileObjectTypeTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProfileObjectTypeTemplatesInput>
    public typealias MOutput = OperationOutput<ListProfileObjectTypeTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProfileObjectTypeTemplatesOutputError>
}

public struct ListProfileObjectTypeTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProfileObjectTypeTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProfileObjectTypeTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProfileObjectTypeTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProfileObjectTypeTemplatesInput>
    public typealias MOutput = OperationOutput<ListProfileObjectTypeTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProfileObjectTypeTemplatesOutputError>
}

public struct ListProfileObjectTypeTemplatesInput: Equatable {
    /// <p>The maximum number of objects returned per page.</p>
    public let maxResults: Int?
    /// <p>The pagination token from the previous ListObjectTypeTemplates API call.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProfileObjectTypeTemplatesInputBody: Equatable {
}

extension ListProfileObjectTypeTemplatesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProfileObjectTypeTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProfileObjectTypeTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProfileObjectTypeTemplatesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProfileObjectTypeTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProfileObjectTypeTemplatesOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProfileObjectTypeTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProfileObjectTypeTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListProfileObjectTypeTemplatesOutputResponse: Equatable {
    /// <p>The list of ListProfileObjectType template instances.</p>
    public let items: [ListProfileObjectTypeTemplateItem]?
    /// <p>The pagination token from the previous ListObjectTypeTemplates API call. </p>
    public let nextToken: String?

    public init (
        items: [ListProfileObjectTypeTemplateItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListProfileObjectTypeTemplatesOutputResponseBody: Equatable {
    public let items: [ListProfileObjectTypeTemplateItem]?
    public let nextToken: String?
}

extension ListProfileObjectTypeTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ListProfileObjectTypeTemplateItem?].self, forKey: .items)
        var itemsDecoded0:[ListProfileObjectTypeTemplateItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ListProfileObjectTypeTemplateItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProfileObjectTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProfileObjectTypesInput(domainName: \(String(describing: domainName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProfileObjectTypesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProfileObjectTypesInputHeadersMiddleware: Middleware {
    public let id: String = "ListProfileObjectTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProfileObjectTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProfileObjectTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProfileObjectTypesInput>
    public typealias MOutput = OperationOutput<ListProfileObjectTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProfileObjectTypesOutputError>
}

public struct ListProfileObjectTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProfileObjectTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProfileObjectTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProfileObjectTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProfileObjectTypesInput>
    public typealias MOutput = OperationOutput<ListProfileObjectTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProfileObjectTypesOutputError>
}

public struct ListProfileObjectTypesInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The maximum number of objects returned per page.</p>
    public let maxResults: Int?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        domainName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProfileObjectTypesInputBody: Equatable {
}

extension ListProfileObjectTypesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProfileObjectTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProfileObjectTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProfileObjectTypesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProfileObjectTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProfileObjectTypesOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProfileObjectTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProfileObjectTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListProfileObjectTypesOutputResponse: Equatable {
    /// <p>The list of ListProfileObjectTypes instances.</p>
    public let items: [ListProfileObjectTypeItem]?
    /// <p>Identifies the next page of results to return.</p>
    public let nextToken: String?

    public init (
        items: [ListProfileObjectTypeItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListProfileObjectTypesOutputResponseBody: Equatable {
    public let items: [ListProfileObjectTypeItem]?
    public let nextToken: String?
}

extension ListProfileObjectTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ListProfileObjectTypeItem?].self, forKey: .items)
        var itemsDecoded0:[ListProfileObjectTypeItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ListProfileObjectTypeItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListProfileObjectsInputBodyMiddleware: Middleware {
    public let id: String = "ListProfileObjectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProfileObjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProfileObjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProfileObjectsInput>
    public typealias MOutput = OperationOutput<ListProfileObjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProfileObjectsOutputError>
}

extension ListProfileObjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProfileObjectsInput(domainName: \(String(describing: domainName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), objectTypeName: \(String(describing: objectTypeName)), profileId: \(String(describing: profileId)))"}
}

extension ListProfileObjectsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectTypeName = "ObjectTypeName"
        case profileId = "ProfileId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectTypeName = objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
        if let profileId = profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
    }
}

public struct ListProfileObjectsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProfileObjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProfileObjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProfileObjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProfileObjectsInput>
    public typealias MOutput = OperationOutput<ListProfileObjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProfileObjectsOutputError>
}

public struct ListProfileObjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProfileObjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProfileObjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProfileObjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProfileObjectsInput>
    public typealias MOutput = OperationOutput<ListProfileObjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProfileObjectsOutputError>
}

public struct ListProfileObjectsInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The maximum number of objects returned per page.</p>
    public let maxResults: Int?
    /// <p>The pagination token from the previous call to ListProfileObjects.</p>
    public let nextToken: String?
    /// <p>The name of the profile object type.</p>
    public let objectTypeName: String?
    /// <p>The unique identifier of a customer profile.</p>
    public let profileId: String?

    public init (
        domainName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        objectTypeName: String? = nil,
        profileId: String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectTypeName = objectTypeName
        self.profileId = profileId
    }
}

struct ListProfileObjectsInputBody: Equatable {
    public let objectTypeName: String?
    public let profileId: String?
}

extension ListProfileObjectsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectTypeName = "ObjectTypeName"
        case profileId = "ProfileId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

extension ListProfileObjectsItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object = "Object"
        case objectTypeName = "ObjectTypeName"
        case profileObjectUniqueKey = "ProfileObjectUniqueKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
        if let objectTypeName = objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
        if let profileObjectUniqueKey = profileObjectUniqueKey {
            try encodeContainer.encode(profileObjectUniqueKey, forKey: .profileObjectUniqueKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let profileObjectUniqueKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileObjectUniqueKey)
        profileObjectUniqueKey = profileObjectUniqueKeyDecoded
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension ListProfileObjectsItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProfileObjectsItem(object: \(String(describing: object)), objectTypeName: \(String(describing: objectTypeName)), profileObjectUniqueKey: \(String(describing: profileObjectUniqueKey)))"}
}

/// <p>A ProfileObject in a list of ProfileObjects.</p>
public struct ListProfileObjectsItem: Equatable {
    /// <p>A JSON representation of a ProfileObject that belongs to a profile.</p>
    public let object: String?
    /// <p>Specifies the kind of object being added to a profile, such as
    ///          "Salesforce-Account."</p>
    public let objectTypeName: String?
    /// <p>The unique identifier of the ProfileObject generated by the service.</p>
    public let profileObjectUniqueKey: String?

    public init (
        object: String? = nil,
        objectTypeName: String? = nil,
        profileObjectUniqueKey: String? = nil
    )
    {
        self.object = object
        self.objectTypeName = objectTypeName
        self.profileObjectUniqueKey = profileObjectUniqueKey
    }
}

extension ListProfileObjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProfileObjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProfileObjectsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProfileObjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProfileObjectsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProfileObjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProfileObjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListProfileObjectsOutputResponse: Equatable {
    /// <p>The list of ListProfileObject instances.</p>
    public let items: [ListProfileObjectsItem]?
    /// <p>The pagination token from the previous call to ListProfileObjects.</p>
    public let nextToken: String?

    public init (
        items: [ListProfileObjectsItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListProfileObjectsOutputResponseBody: Equatable {
    public let items: [ListProfileObjectsItem]?
    public let nextToken: String?
}

extension ListProfileObjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ListProfileObjectsItem?].self, forKey: .items)
        var itemsDecoded0:[ListProfileObjectsItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ListProfileObjectsItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the resource for which you want to view tags.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum MarketoConnectorOperator {
    case addition
    case between
    case division
    case greaterThan
    case lessThan
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension MarketoConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MarketoConnectorOperator] {
        return [
            .addition,
            .between,
            .division,
            .greaterThan,
            .lessThan,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .between: return "BETWEEN"
        case .division: return "DIVISION"
        case .greaterThan: return "GREATER_THAN"
        case .lessThan: return "LESS_THAN"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MarketoConnectorOperator(rawValue: rawValue) ?? MarketoConnectorOperator.sdkUnknown(rawValue)
    }
}

extension MarketoSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object = "Object"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension MarketoSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MarketoSourceProperties(object: \(String(describing: object)))"}
}

/// <p>The properties that are applied when Marketo is being used as a source.</p>
public struct MarketoSourceProperties: Equatable {
    /// <p>The object specified in the Marketo flow source.</p>
    public let object: String?

    public init (
        object: String? = nil
    )
    {
        self.object = object
    }
}

extension MatchItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case matchId = "MatchId"
        case profileIds = "ProfileIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let matchId = matchId {
            try encodeContainer.encode(matchId, forKey: .matchId)
        }
        if let profileIds = profileIds {
            var profileIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .profileIds)
            for profileidlist0 in profileIds {
                try profileIdsContainer.encode(profileidlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .matchId)
        matchId = matchIdDecoded
        let profileIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .profileIds)
        var profileIdsDecoded0:[String]? = nil
        if let profileIdsContainer = profileIdsContainer {
            profileIdsDecoded0 = [String]()
            for string0 in profileIdsContainer {
                if let string0 = string0 {
                    profileIdsDecoded0?.append(string0)
                }
            }
        }
        profileIds = profileIdsDecoded0
    }
}

extension MatchItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MatchItem(matchId: \(String(describing: matchId)), profileIds: \(String(describing: profileIds)))"}
}

/// <p>The Match group object.</p>
public struct MatchItem: Equatable {
    /// <p>The unique identifiers for this group of profiles that match.</p>
    public let matchId: String?
    /// <p>A list of identifiers for profiles that match.</p>
    public let profileIds: [String]?

    public init (
        matchId: String? = nil,
        profileIds: [String]? = nil
    )
    {
        self.matchId = matchId
        self.profileIds = profileIds
    }
}

extension MatchingRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension MatchingRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MatchingRequest(enabled: \(String(describing: enabled)))"}
}

/// <p>The flag that enables the matching process of duplicate profiles.</p>
public struct MatchingRequest: Equatable {
    /// <p>The flag that enables the matching process of duplicate profiles.</p>
    public let enabled: Bool?

    public init (
        enabled: Bool? = nil
    )
    {
        self.enabled = enabled
    }
}

extension MatchingResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension MatchingResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MatchingResponse(enabled: \(String(describing: enabled)))"}
}

/// <p>The flag that enables the matching process of duplicate profiles.</p>
public struct MatchingResponse: Equatable {
    /// <p>The flag that enables the matching process of duplicate profiles.</p>
    public let enabled: Bool?

    public init (
        enabled: Bool? = nil
    )
    {
        self.enabled = enabled
    }
}

public struct MergeProfilesInputBodyMiddleware: Middleware {
    public let id: String = "MergeProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeProfilesInput>
    public typealias MOutput = OperationOutput<MergeProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeProfilesOutputError>
}

extension MergeProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeProfilesInput(domainName: \(String(describing: domainName)), fieldSourceProfileIds: \(String(describing: fieldSourceProfileIds)), mainProfileId: \(String(describing: mainProfileId)), profileIdsToBeMerged: \(String(describing: profileIdsToBeMerged)))"}
}

extension MergeProfilesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldSourceProfileIds = "FieldSourceProfileIds"
        case mainProfileId = "MainProfileId"
        case profileIdsToBeMerged = "ProfileIdsToBeMerged"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldSourceProfileIds = fieldSourceProfileIds {
            try encodeContainer.encode(fieldSourceProfileIds, forKey: .fieldSourceProfileIds)
        }
        if let mainProfileId = mainProfileId {
            try encodeContainer.encode(mainProfileId, forKey: .mainProfileId)
        }
        if let profileIdsToBeMerged = profileIdsToBeMerged {
            var profileIdsToBeMergedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .profileIdsToBeMerged)
            for profileidtobemergedlist0 in profileIdsToBeMerged {
                try profileIdsToBeMergedContainer.encode(profileidtobemergedlist0)
            }
        }
    }
}

public struct MergeProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "MergeProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeProfilesInput>
    public typealias MOutput = OperationOutput<MergeProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeProfilesOutputError>
}

public struct MergeProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "MergeProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeProfilesInput>
    public typealias MOutput = OperationOutput<MergeProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeProfilesOutputError>
}

public struct MergeProfilesInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The identifiers of the fields in the profile that has the information you want to apply to the
    ///          merge. For example, say you want to merge EmailAddress from Profile1 into MainProfile. This would be the
    ///          identifier of the EmailAddress field in Profile1. </p>
    public let fieldSourceProfileIds: FieldSourceProfileIds?
    /// <p>The identifier of the profile to be taken.</p>
    public let mainProfileId: String?
    /// <p>The identifier of the profile to be merged into MainProfileId.</p>
    public let profileIdsToBeMerged: [String]?

    public init (
        domainName: String? = nil,
        fieldSourceProfileIds: FieldSourceProfileIds? = nil,
        mainProfileId: String? = nil,
        profileIdsToBeMerged: [String]? = nil
    )
    {
        self.domainName = domainName
        self.fieldSourceProfileIds = fieldSourceProfileIds
        self.mainProfileId = mainProfileId
        self.profileIdsToBeMerged = profileIdsToBeMerged
    }
}

struct MergeProfilesInputBody: Equatable {
    public let mainProfileId: String?
    public let profileIdsToBeMerged: [String]?
    public let fieldSourceProfileIds: FieldSourceProfileIds?
}

extension MergeProfilesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldSourceProfileIds = "FieldSourceProfileIds"
        case mainProfileId = "MainProfileId"
        case profileIdsToBeMerged = "ProfileIdsToBeMerged"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mainProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mainProfileId)
        mainProfileId = mainProfileIdDecoded
        let profileIdsToBeMergedContainer = try containerValues.decodeIfPresent([String?].self, forKey: .profileIdsToBeMerged)
        var profileIdsToBeMergedDecoded0:[String]? = nil
        if let profileIdsToBeMergedContainer = profileIdsToBeMergedContainer {
            profileIdsToBeMergedDecoded0 = [String]()
            for string0 in profileIdsToBeMergedContainer {
                if let string0 = string0 {
                    profileIdsToBeMergedDecoded0?.append(string0)
                }
            }
        }
        profileIdsToBeMerged = profileIdsToBeMergedDecoded0
        let fieldSourceProfileIdsDecoded = try containerValues.decodeIfPresent(FieldSourceProfileIds.self, forKey: .fieldSourceProfileIds)
        fieldSourceProfileIds = fieldSourceProfileIdsDecoded
    }
}

extension MergeProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergeProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MergeProfilesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergeProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeProfilesOutputResponse(message: \(String(describing: message)))"}
}

extension MergeProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MergeProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct MergeProfilesOutputResponse: Equatable {
    /// <p>A message that indicates the merge request is complete.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MergeProfilesOutputResponseBody: Equatable {
    public let message: String?
}

extension MergeProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ObjectTypeField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentType = "ContentType"
        case source = "Source"
        case target = "Target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(FieldContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension ObjectTypeField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectTypeField(contentType: \(String(describing: contentType)), source: \(String(describing: source)), target: \(String(describing: target)))"}
}

/// <p>Represents a field in a ProfileObjectType.</p>
public struct ObjectTypeField: Equatable {
    /// <p>The content type of the field. Used for determining equality when searching.</p>
    public let contentType: FieldContentType?
    /// <p>A field of a ProfileObject. For example: _source.FirstName, where “_source” is a
    ///          ProfileObjectType of a Zendesk user and “FirstName” is a field in that ObjectType.</p>
    public let source: String?
    /// <p>The location of the data in the standard ProfileObject model. For example:
    ///          _profile.Address.PostalCode.</p>
    public let target: String?

    public init (
        contentType: FieldContentType? = nil,
        source: String? = nil,
        target: String? = nil
    )
    {
        self.contentType = contentType
        self.source = source
        self.target = target
    }
}

extension ObjectTypeKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldNames = "FieldNames"
        case standardIdentifiers = "StandardIdentifiers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldNames = fieldNames {
            var fieldNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldNames)
            for fieldnamelist0 in fieldNames {
                try fieldNamesContainer.encode(fieldnamelist0)
            }
        }
        if let standardIdentifiers = standardIdentifiers {
            var standardIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .standardIdentifiers)
            for standardidentifierlist0 in standardIdentifiers {
                try standardIdentifiersContainer.encode(standardidentifierlist0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardIdentifiersContainer = try containerValues.decodeIfPresent([StandardIdentifier?].self, forKey: .standardIdentifiers)
        var standardIdentifiersDecoded0:[StandardIdentifier]? = nil
        if let standardIdentifiersContainer = standardIdentifiersContainer {
            standardIdentifiersDecoded0 = [StandardIdentifier]()
            for string0 in standardIdentifiersContainer {
                if let string0 = string0 {
                    standardIdentifiersDecoded0?.append(string0)
                }
            }
        }
        standardIdentifiers = standardIdentifiersDecoded0
        let fieldNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .fieldNames)
        var fieldNamesDecoded0:[String]? = nil
        if let fieldNamesContainer = fieldNamesContainer {
            fieldNamesDecoded0 = [String]()
            for string0 in fieldNamesContainer {
                if let string0 = string0 {
                    fieldNamesDecoded0?.append(string0)
                }
            }
        }
        fieldNames = fieldNamesDecoded0
    }
}

extension ObjectTypeKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectTypeKey(fieldNames: \(String(describing: fieldNames)), standardIdentifiers: \(String(describing: standardIdentifiers)))"}
}

/// <p>An object that defines the Key element of a ProfileObject. A Key is a special element
///          that can be used to search for a customer profile.</p>
public struct ObjectTypeKey: Equatable {
    /// <p>The reference for the key name of the fields map.</p>
    public let fieldNames: [String]?
    /// <p>The types of keys that a ProfileObject can have. Each ProfileObject can have only 1
    ///          UNIQUE key but multiple PROFILE keys. PROFILE means that this key can be used to tie an
    ///          object to a PROFILE. UNIQUE means that it can be used to uniquely identify an object. If a
    ///          key a is marked as SECONDARY, it will be used to search for profiles after all other
    ///          PROFILE keys have been searched. A LOOKUP_ONLY key is only used to match a profile but is
    ///          not persisted to be used for searching of the profile. A NEW_ONLY key is only used if the
    ///          profile does not already exist before the object is ingested, otherwise it is only used for
    ///          matching objects to profiles.</p>
    public let standardIdentifiers: [StandardIdentifier]?

    public init (
        fieldNames: [String]? = nil,
        standardIdentifiers: [StandardIdentifier]? = nil
    )
    {
        self.fieldNames = fieldNames
        self.standardIdentifiers = standardIdentifiers
    }
}

public enum OperatorPropertiesKeys {
    case concatFormat
    case dataType
    case destinationDataType
    case lowerBound
    case maskLength
    case maskValue
    case mathOperationFieldsOrder
    case sourceDataType
    case subfieldCategoryMap
    case truncateLength
    case upperBound
    case validationAction
    case value
    case values
    case sdkUnknown(String)
}

extension OperatorPropertiesKeys : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperatorPropertiesKeys] {
        return [
            .concatFormat,
            .dataType,
            .destinationDataType,
            .lowerBound,
            .maskLength,
            .maskValue,
            .mathOperationFieldsOrder,
            .sourceDataType,
            .subfieldCategoryMap,
            .truncateLength,
            .upperBound,
            .validationAction,
            .value,
            .values,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .concatFormat: return "CONCAT_FORMAT"
        case .dataType: return "DATA_TYPE"
        case .destinationDataType: return "DESTINATION_DATA_TYPE"
        case .lowerBound: return "LOWER_BOUND"
        case .maskLength: return "MASK_LENGTH"
        case .maskValue: return "MASK_VALUE"
        case .mathOperationFieldsOrder: return "MATH_OPERATION_FIELDS_ORDER"
        case .sourceDataType: return "SOURCE_DATA_TYPE"
        case .subfieldCategoryMap: return "SUBFIELD_CATEGORY_MAP"
        case .truncateLength: return "TRUNCATE_LENGTH"
        case .upperBound: return "UPPER_BOUND"
        case .validationAction: return "VALIDATION_ACTION"
        case .value: return "VALUE"
        case .values: return "VALUES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperatorPropertiesKeys(rawValue: rawValue) ?? OperatorPropertiesKeys.sdkUnknown(rawValue)
    }
}

public enum PartyType {
    case business
    case individual
    case other
    case sdkUnknown(String)
}

extension PartyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PartyType] {
        return [
            .business,
            .individual,
            .other,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .business: return "BUSINESS"
        case .individual: return "INDIVIDUAL"
        case .other: return "OTHER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PartyType(rawValue: rawValue) ?? PartyType.sdkUnknown(rawValue)
    }
}

extension Profile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountNumber = "AccountNumber"
        case additionalInformation = "AdditionalInformation"
        case address = "Address"
        case attributes = "Attributes"
        case billingAddress = "BillingAddress"
        case birthDate = "BirthDate"
        case businessEmailAddress = "BusinessEmailAddress"
        case businessName = "BusinessName"
        case businessPhoneNumber = "BusinessPhoneNumber"
        case emailAddress = "EmailAddress"
        case firstName = "FirstName"
        case gender = "Gender"
        case homePhoneNumber = "HomePhoneNumber"
        case lastName = "LastName"
        case mailingAddress = "MailingAddress"
        case middleName = "MiddleName"
        case mobilePhoneNumber = "MobilePhoneNumber"
        case partyType = "PartyType"
        case personalEmailAddress = "PersonalEmailAddress"
        case phoneNumber = "PhoneNumber"
        case profileId = "ProfileId"
        case shippingAddress = "ShippingAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountNumber = accountNumber {
            try encodeContainer.encode(accountNumber, forKey: .accountNumber)
        }
        if let additionalInformation = additionalInformation {
            try encodeContainer.encode(additionalInformation, forKey: .additionalInformation)
        }
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let billingAddress = billingAddress {
            try encodeContainer.encode(billingAddress, forKey: .billingAddress)
        }
        if let birthDate = birthDate {
            try encodeContainer.encode(birthDate, forKey: .birthDate)
        }
        if let businessEmailAddress = businessEmailAddress {
            try encodeContainer.encode(businessEmailAddress, forKey: .businessEmailAddress)
        }
        if let businessName = businessName {
            try encodeContainer.encode(businessName, forKey: .businessName)
        }
        if let businessPhoneNumber = businessPhoneNumber {
            try encodeContainer.encode(businessPhoneNumber, forKey: .businessPhoneNumber)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let gender = gender {
            try encodeContainer.encode(gender.rawValue, forKey: .gender)
        }
        if let homePhoneNumber = homePhoneNumber {
            try encodeContainer.encode(homePhoneNumber, forKey: .homePhoneNumber)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let mailingAddress = mailingAddress {
            try encodeContainer.encode(mailingAddress, forKey: .mailingAddress)
        }
        if let middleName = middleName {
            try encodeContainer.encode(middleName, forKey: .middleName)
        }
        if let mobilePhoneNumber = mobilePhoneNumber {
            try encodeContainer.encode(mobilePhoneNumber, forKey: .mobilePhoneNumber)
        }
        if let partyType = partyType {
            try encodeContainer.encode(partyType.rawValue, forKey: .partyType)
        }
        if let personalEmailAddress = personalEmailAddress {
            try encodeContainer.encode(personalEmailAddress, forKey: .personalEmailAddress)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let profileId = profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let shippingAddress = shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let accountNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountNumber)
        accountNumber = accountNumberDecoded
        let additionalInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .additionalInformation)
        additionalInformation = additionalInformationDecoded
        let partyTypeDecoded = try containerValues.decodeIfPresent(PartyType.self, forKey: .partyType)
        partyType = partyTypeDecoded
        let businessNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .businessName)
        businessName = businessNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let middleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .middleName)
        middleName = middleNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let birthDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .birthDate)
        birthDate = birthDateDecoded
        let genderDecoded = try containerValues.decodeIfPresent(Gender.self, forKey: .gender)
        gender = genderDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let mobilePhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mobilePhoneNumber)
        mobilePhoneNumber = mobilePhoneNumberDecoded
        let homePhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homePhoneNumber)
        homePhoneNumber = homePhoneNumberDecoded
        let businessPhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .businessPhoneNumber)
        businessPhoneNumber = businessPhoneNumberDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let personalEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .personalEmailAddress)
        personalEmailAddress = personalEmailAddressDecoded
        let businessEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .businessEmailAddress)
        businessEmailAddress = businessEmailAddressDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Address.self, forKey: .address)
        address = addressDecoded
        let shippingAddressDecoded = try containerValues.decodeIfPresent(Address.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let mailingAddressDecoded = try containerValues.decodeIfPresent(Address.self, forKey: .mailingAddress)
        mailingAddress = mailingAddressDecoded
        let billingAddressDecoded = try containerValues.decodeIfPresent(Address.self, forKey: .billingAddress)
        billingAddress = billingAddressDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, string1to2550) in attributesContainer {
                if let string1to2550 = string1to2550 {
                    attributesDecoded0?[key0] = string1to2550
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension Profile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Profile(accountNumber: \(String(describing: accountNumber)), additionalInformation: \(String(describing: additionalInformation)), address: \(String(describing: address)), attributes: \(String(describing: attributes)), billingAddress: \(String(describing: billingAddress)), birthDate: \(String(describing: birthDate)), businessEmailAddress: \(String(describing: businessEmailAddress)), businessName: \(String(describing: businessName)), businessPhoneNumber: \(String(describing: businessPhoneNumber)), emailAddress: \(String(describing: emailAddress)), firstName: \(String(describing: firstName)), gender: \(String(describing: gender)), homePhoneNumber: \(String(describing: homePhoneNumber)), lastName: \(String(describing: lastName)), mailingAddress: \(String(describing: mailingAddress)), middleName: \(String(describing: middleName)), mobilePhoneNumber: \(String(describing: mobilePhoneNumber)), partyType: \(String(describing: partyType)), personalEmailAddress: \(String(describing: personalEmailAddress)), phoneNumber: \(String(describing: phoneNumber)), profileId: \(String(describing: profileId)), shippingAddress: \(String(describing: shippingAddress)))"}
}

/// <p>The standard profile of a customer.</p>
public struct Profile: Equatable {
    /// <p>A unique account number that you have given to the customer.</p>
    public let accountNumber: String?
    /// <p>Any additional information relevant to the customer’s profile.</p>
    public let additionalInformation: String?
    /// <p>A generic address associated with the customer that is not mailing, shipping, or
    ///          billing.</p>
    public let address: Address?
    /// <p>A key value pair of attributes of a customer profile.</p>
    public let attributes: [String:String]?
    /// <p>The customer’s billing address.</p>
    public let billingAddress: Address?
    /// <p>The customer’s birth date. </p>
    public let birthDate: String?
    /// <p>The customer’s business email address.</p>
    public let businessEmailAddress: String?
    /// <p>The name of the customer’s business.</p>
    public let businessName: String?
    /// <p>The customer’s home phone number.</p>
    public let businessPhoneNumber: String?
    /// <p>The customer’s email address, which has not been specified as a personal or business
    ///          address. </p>
    public let emailAddress: String?
    /// <p>The customer’s first name.</p>
    public let firstName: String?
    /// <p>The gender with which the customer identifies. </p>
    public let gender: Gender?
    /// <p>The customer’s home phone number.</p>
    public let homePhoneNumber: String?
    /// <p>The customer’s last name.</p>
    public let lastName: String?
    /// <p>The customer’s mailing address.</p>
    public let mailingAddress: Address?
    /// <p>The customer’s middle name.</p>
    public let middleName: String?
    /// <p>The customer’s mobile phone number.</p>
    public let mobilePhoneNumber: String?
    /// <p>The type of profile used to describe the customer.</p>
    public let partyType: PartyType?
    /// <p>The customer’s personal email address.</p>
    public let personalEmailAddress: String?
    /// <p>The customer's phone number, which has not been specified as a mobile, home, or business
    ///          number.</p>
    public let phoneNumber: String?
    /// <p>The unique identifier of a customer profile.</p>
    public let profileId: String?
    /// <p>The customer’s shipping address.</p>
    public let shippingAddress: Address?

    public init (
        accountNumber: String? = nil,
        additionalInformation: String? = nil,
        address: Address? = nil,
        attributes: [String:String]? = nil,
        billingAddress: Address? = nil,
        birthDate: String? = nil,
        businessEmailAddress: String? = nil,
        businessName: String? = nil,
        businessPhoneNumber: String? = nil,
        emailAddress: String? = nil,
        firstName: String? = nil,
        gender: Gender? = nil,
        homePhoneNumber: String? = nil,
        lastName: String? = nil,
        mailingAddress: Address? = nil,
        middleName: String? = nil,
        mobilePhoneNumber: String? = nil,
        partyType: PartyType? = nil,
        personalEmailAddress: String? = nil,
        phoneNumber: String? = nil,
        profileId: String? = nil,
        shippingAddress: Address? = nil
    )
    {
        self.accountNumber = accountNumber
        self.additionalInformation = additionalInformation
        self.address = address
        self.attributes = attributes
        self.billingAddress = billingAddress
        self.birthDate = birthDate
        self.businessEmailAddress = businessEmailAddress
        self.businessName = businessName
        self.businessPhoneNumber = businessPhoneNumber
        self.emailAddress = emailAddress
        self.firstName = firstName
        self.gender = gender
        self.homePhoneNumber = homePhoneNumber
        self.lastName = lastName
        self.mailingAddress = mailingAddress
        self.middleName = middleName
        self.mobilePhoneNumber = mobilePhoneNumber
        self.partyType = partyType
        self.personalEmailAddress = personalEmailAddress
        self.phoneNumber = phoneNumber
        self.profileId = profileId
        self.shippingAddress = shippingAddress
    }
}

public struct PutIntegrationInputBodyMiddleware: Middleware {
    public let id: String = "PutIntegrationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutIntegrationInput>
    public typealias MOutput = OperationOutput<PutIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutIntegrationOutputError>
}

extension PutIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutIntegrationInput(domainName: \(String(describing: domainName)), flowDefinition: \(String(describing: flowDefinition)), objectTypeName: \(String(describing: objectTypeName)), tags: \(String(describing: tags)), uri: \(String(describing: uri)))"}
}

extension PutIntegrationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case flowDefinition = "FlowDefinition"
        case objectTypeName = "ObjectTypeName"
        case tags = "Tags"
        case uri = "Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowDefinition = flowDefinition {
            try encodeContainer.encode(flowDefinition, forKey: .flowDefinition)
        }
        if let objectTypeName = objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

public struct PutIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "PutIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutIntegrationInput>
    public typealias MOutput = OperationOutput<PutIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutIntegrationOutputError>
}

public struct PutIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutIntegrationInput>
    public typealias MOutput = OperationOutput<PutIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutIntegrationOutputError>
}

public struct PutIntegrationInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The configuration that controls how Customer Profiles retrieves data from the
    ///          source.</p>
    public let flowDefinition: FlowDefinition?
    /// <p>The name of the profile object type.</p>
    public let objectTypeName: String?
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?
    /// <p>The URI of the S3 bucket or any other type of data source.</p>
    public let uri: String?

    public init (
        domainName: String? = nil,
        flowDefinition: FlowDefinition? = nil,
        objectTypeName: String? = nil,
        tags: [String:String]? = nil,
        uri: String? = nil
    )
    {
        self.domainName = domainName
        self.flowDefinition = flowDefinition
        self.objectTypeName = objectTypeName
        self.tags = tags
        self.uri = uri
    }
}

struct PutIntegrationInputBody: Equatable {
    public let uri: String?
    public let objectTypeName: String?
    public let tags: [String:String]?
    public let flowDefinition: FlowDefinition?
}

extension PutIntegrationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowDefinition = "FlowDefinition"
        case objectTypeName = "ObjectTypeName"
        case tags = "Tags"
        case uri = "Uri"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let flowDefinitionDecoded = try containerValues.decodeIfPresent(FlowDefinition.self, forKey: .flowDefinition)
        flowDefinition = flowDefinitionDecoded
    }
}

extension PutIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutIntegrationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutIntegrationOutputResponse(createdAt: \(String(describing: createdAt)), domainName: \(String(describing: domainName)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), objectTypeName: \(String(describing: objectTypeName)), tags: \(String(describing: tags)), uri: \(String(describing: uri)))"}
}

extension PutIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.domainName = output.domainName
            self.lastUpdatedAt = output.lastUpdatedAt
            self.objectTypeName = output.objectTypeName
            self.tags = output.tags
            self.uri = output.uri
        } else {
            self.createdAt = nil
            self.domainName = nil
            self.lastUpdatedAt = nil
            self.objectTypeName = nil
            self.tags = nil
            self.uri = nil
        }
    }
}

public struct PutIntegrationOutputResponse: Equatable {
    /// <p>The timestamp of when the domain was created.</p>
    public let createdAt: Date?
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The timestamp of when the domain was most recently edited.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the profile object type.</p>
    public let objectTypeName: String?
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?
    /// <p>The URI of the S3 bucket or any other type of data source.</p>
    public let uri: String?

    public init (
        createdAt: Date? = nil,
        domainName: String? = nil,
        lastUpdatedAt: Date? = nil,
        objectTypeName: String? = nil,
        tags: [String:String]? = nil,
        uri: String? = nil
    )
    {
        self.createdAt = createdAt
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.tags = tags
        self.uri = uri
    }
}

struct PutIntegrationOutputResponseBody: Equatable {
    public let domainName: String?
    public let uri: String?
    public let objectTypeName: String?
    public let createdAt: Date?
    public let lastUpdatedAt: Date?
    public let tags: [String:String]?
}

extension PutIntegrationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case domainName = "DomainName"
        case lastUpdatedAt = "LastUpdatedAt"
        case objectTypeName = "ObjectTypeName"
        case tags = "Tags"
        case uri = "Uri"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct PutProfileObjectInputBodyMiddleware: Middleware {
    public let id: String = "PutProfileObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutProfileObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<PutProfileObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutProfileObjectInput>
    public typealias MOutput = OperationOutput<PutProfileObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutProfileObjectOutputError>
}

extension PutProfileObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutProfileObjectInput(domainName: \(String(describing: domainName)), object: \(String(describing: object)), objectTypeName: \(String(describing: objectTypeName)))"}
}

extension PutProfileObjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object = "Object"
        case objectTypeName = "ObjectTypeName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
        if let objectTypeName = objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
    }
}

public struct PutProfileObjectInputHeadersMiddleware: Middleware {
    public let id: String = "PutProfileObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutProfileObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<PutProfileObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutProfileObjectInput>
    public typealias MOutput = OperationOutput<PutProfileObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutProfileObjectOutputError>
}

public struct PutProfileObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "PutProfileObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutProfileObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<PutProfileObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutProfileObjectInput>
    public typealias MOutput = OperationOutput<PutProfileObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutProfileObjectOutputError>
}

public struct PutProfileObjectInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>A string that is serialized from a JSON object.</p>
    public let object: String?
    /// <p>The name of the profile object type.</p>
    public let objectTypeName: String?

    public init (
        domainName: String? = nil,
        object: String? = nil,
        objectTypeName: String? = nil
    )
    {
        self.domainName = domainName
        self.object = object
        self.objectTypeName = objectTypeName
    }
}

struct PutProfileObjectInputBody: Equatable {
    public let objectTypeName: String?
    public let object: String?
}

extension PutProfileObjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case object = "Object"
        case objectTypeName = "ObjectTypeName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension PutProfileObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutProfileObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutProfileObjectOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutProfileObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutProfileObjectOutputResponse(profileObjectUniqueKey: \(String(describing: profileObjectUniqueKey)))"}
}

extension PutProfileObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutProfileObjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.profileObjectUniqueKey = output.profileObjectUniqueKey
        } else {
            self.profileObjectUniqueKey = nil
        }
    }
}

public struct PutProfileObjectOutputResponse: Equatable {
    /// <p>The unique identifier of the profile object generated by the service.</p>
    public let profileObjectUniqueKey: String?

    public init (
        profileObjectUniqueKey: String? = nil
    )
    {
        self.profileObjectUniqueKey = profileObjectUniqueKey
    }
}

struct PutProfileObjectOutputResponseBody: Equatable {
    public let profileObjectUniqueKey: String?
}

extension PutProfileObjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case profileObjectUniqueKey = "ProfileObjectUniqueKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileObjectUniqueKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileObjectUniqueKey)
        profileObjectUniqueKey = profileObjectUniqueKeyDecoded
    }
}

public struct PutProfileObjectTypeInputBodyMiddleware: Middleware {
    public let id: String = "PutProfileObjectTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutProfileObjectTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<PutProfileObjectTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutProfileObjectTypeInput>
    public typealias MOutput = OperationOutput<PutProfileObjectTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutProfileObjectTypeOutputError>
}

extension PutProfileObjectTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutProfileObjectTypeInput(allowProfileCreation: \(String(describing: allowProfileCreation)), description: \(String(describing: description)), domainName: \(String(describing: domainName)), encryptionKey: \(String(describing: encryptionKey)), expirationDays: \(String(describing: expirationDays)), fields: \(String(describing: fields)), keys: \(String(describing: keys)), objectTypeName: \(String(describing: objectTypeName)), tags: \(String(describing: tags)), templateId: \(String(describing: templateId)))"}
}

extension PutProfileObjectTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowProfileCreation = "AllowProfileCreation"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case expirationDays = "ExpirationDays"
        case fields = "Fields"
        case keys = "Keys"
        case tags = "Tags"
        case templateId = "TemplateId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowProfileCreation != false {
            try encodeContainer.encode(allowProfileCreation, forKey: .allowProfileCreation)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let expirationDays = expirationDays {
            try encodeContainer.encode(expirationDays, forKey: .expirationDays)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .fields)
            for (dictKey0, fieldmap0) in fields {
                try fieldsContainer.encode(fieldmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let keys = keys {
            var keysContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .keys)
            for (dictKey0, keymap0) in keys {
                try keysContainer.encode(keymap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let templateId = templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }
}

public struct PutProfileObjectTypeInputHeadersMiddleware: Middleware {
    public let id: String = "PutProfileObjectTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutProfileObjectTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<PutProfileObjectTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutProfileObjectTypeInput>
    public typealias MOutput = OperationOutput<PutProfileObjectTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutProfileObjectTypeOutputError>
}

public struct PutProfileObjectTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "PutProfileObjectTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutProfileObjectTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<PutProfileObjectTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutProfileObjectTypeInput>
    public typealias MOutput = OperationOutput<PutProfileObjectTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutProfileObjectTypeOutputError>
}

public struct PutProfileObjectTypeInput: Equatable {
    /// <p>Indicates whether a profile should be created when data is received if one doesn’t exist
    ///          for an object of this type. The default is <code>FALSE</code>. If the AllowProfileCreation
    ///          flag is set to <code>FALSE</code>, then the service tries to fetch a standard profile and
    ///          associate this object with the profile. If it is set to <code>TRUE</code>, and if no match
    ///          is found, then the service creates a new standard profile.</p>
    public let allowProfileCreation: Bool
    /// <p>Description of the profile object type.</p>
    public let description: String?
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The customer-provided key to encrypt the profile object that will be created in this
    ///          profile object type.</p>
    public let encryptionKey: String?
    /// <p>The number of days until the data in the object expires.</p>
    public let expirationDays: Int?
    /// <p>A map of the name and ObjectType field.</p>
    public let fields: [String:ObjectTypeField]?
    /// <p>A list of unique keys that can be used to map data to the profile.</p>
    public let keys: [String:[ObjectTypeKey]]?
    /// <p>The name of the profile object type.</p>
    public let objectTypeName: String?
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?
    /// <p>A unique identifier for the object template.</p>
    public let templateId: String?

    public init (
        allowProfileCreation: Bool = false,
        description: String? = nil,
        domainName: String? = nil,
        encryptionKey: String? = nil,
        expirationDays: Int? = nil,
        fields: [String:ObjectTypeField]? = nil,
        keys: [String:[ObjectTypeKey]]? = nil,
        objectTypeName: String? = nil,
        tags: [String:String]? = nil,
        templateId: String? = nil
    )
    {
        self.allowProfileCreation = allowProfileCreation
        self.description = description
        self.domainName = domainName
        self.encryptionKey = encryptionKey
        self.expirationDays = expirationDays
        self.fields = fields
        self.keys = keys
        self.objectTypeName = objectTypeName
        self.tags = tags
        self.templateId = templateId
    }
}

struct PutProfileObjectTypeInputBody: Equatable {
    public let description: String?
    public let templateId: String?
    public let expirationDays: Int?
    public let encryptionKey: String?
    public let allowProfileCreation: Bool
    public let fields: [String:ObjectTypeField]?
    public let keys: [String:[ObjectTypeKey]]?
    public let tags: [String:String]?
}

extension PutProfileObjectTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowProfileCreation = "AllowProfileCreation"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case expirationDays = "ExpirationDays"
        case fields = "Fields"
        case keys = "Keys"
        case tags = "Tags"
        case templateId = "TemplateId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let expirationDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expirationDays)
        expirationDays = expirationDaysDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let allowProfileCreationDecoded = try containerValues.decode(Bool.self, forKey: .allowProfileCreation)
        allowProfileCreation = allowProfileCreationDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([String: ObjectTypeField?].self, forKey: .fields)
        var fieldsDecoded0: [String:ObjectTypeField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [String:ObjectTypeField]()
            for (key0, objecttypefield0) in fieldsContainer {
                if let objecttypefield0 = objecttypefield0 {
                    fieldsDecoded0?[key0] = objecttypefield0
                }
            }
        }
        fields = fieldsDecoded0
        let keysContainer = try containerValues.decodeIfPresent([String: [ObjectTypeKey?]?].self, forKey: .keys)
        var keysDecoded0: [String:[ObjectTypeKey]]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [String:[ObjectTypeKey]]()
            for (key0, objecttypekeylist0) in keysContainer {
                var objecttypekeylist0Decoded0: [ObjectTypeKey]? = nil
                if let objecttypekeylist0 = objecttypekeylist0 {
                    objecttypekeylist0Decoded0 = [ObjectTypeKey]()
                    for structure1 in objecttypekeylist0 {
                        if let structure1 = structure1 {
                            objecttypekeylist0Decoded0?.append(structure1)
                        }
                    }
                }
                keysDecoded0?[key0] = objecttypekeylist0Decoded0
            }
        }
        keys = keysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutProfileObjectTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutProfileObjectTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutProfileObjectTypeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutProfileObjectTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutProfileObjectTypeOutputResponse(allowProfileCreation: \(String(describing: allowProfileCreation)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), encryptionKey: \(String(describing: encryptionKey)), expirationDays: \(String(describing: expirationDays)), fields: \(String(describing: fields)), keys: \(String(describing: keys)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), objectTypeName: \(String(describing: objectTypeName)), tags: \(String(describing: tags)), templateId: \(String(describing: templateId)))"}
}

extension PutProfileObjectTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutProfileObjectTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.allowProfileCreation = output.allowProfileCreation
            self.createdAt = output.createdAt
            self.description = output.description
            self.encryptionKey = output.encryptionKey
            self.expirationDays = output.expirationDays
            self.fields = output.fields
            self.keys = output.keys
            self.lastUpdatedAt = output.lastUpdatedAt
            self.objectTypeName = output.objectTypeName
            self.tags = output.tags
            self.templateId = output.templateId
        } else {
            self.allowProfileCreation = false
            self.createdAt = nil
            self.description = nil
            self.encryptionKey = nil
            self.expirationDays = nil
            self.fields = nil
            self.keys = nil
            self.lastUpdatedAt = nil
            self.objectTypeName = nil
            self.tags = nil
            self.templateId = nil
        }
    }
}

public struct PutProfileObjectTypeOutputResponse: Equatable {
    /// <p>Indicates whether a profile should be created when data is received if one doesn’t exist
    ///          for an object of this type. The default is <code>FALSE</code>. If the AllowProfileCreation
    ///          flag is set to <code>FALSE</code>, then the service tries to fetch a standard profile and
    ///          associate this object with the profile. If it is set to <code>TRUE</code>, and if no match
    ///          is found, then the service creates a new standard profile.</p>
    public let allowProfileCreation: Bool
    /// <p>The timestamp of when the domain was created.</p>
    public let createdAt: Date?
    /// <p>Description of the profile object type.</p>
    public let description: String?
    /// <p>The customer-provided key to encrypt the profile object that will be created in this
    ///          profile object type.</p>
    public let encryptionKey: String?
    /// <p>The number of days until the data in the object expires.</p>
    public let expirationDays: Int?
    /// <p>A map of the name and ObjectType field.</p>
    public let fields: [String:ObjectTypeField]?
    /// <p>A list of unique keys that can be used to map data to the profile.</p>
    public let keys: [String:[ObjectTypeKey]]?
    /// <p>The timestamp of when the domain was most recently edited.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the profile object type.</p>
    public let objectTypeName: String?
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?
    /// <p>A unique identifier for the object template.</p>
    public let templateId: String?

    public init (
        allowProfileCreation: Bool = false,
        createdAt: Date? = nil,
        description: String? = nil,
        encryptionKey: String? = nil,
        expirationDays: Int? = nil,
        fields: [String:ObjectTypeField]? = nil,
        keys: [String:[ObjectTypeKey]]? = nil,
        lastUpdatedAt: Date? = nil,
        objectTypeName: String? = nil,
        tags: [String:String]? = nil,
        templateId: String? = nil
    )
    {
        self.allowProfileCreation = allowProfileCreation
        self.createdAt = createdAt
        self.description = description
        self.encryptionKey = encryptionKey
        self.expirationDays = expirationDays
        self.fields = fields
        self.keys = keys
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.tags = tags
        self.templateId = templateId
    }
}

struct PutProfileObjectTypeOutputResponseBody: Equatable {
    public let objectTypeName: String?
    public let description: String?
    public let templateId: String?
    public let expirationDays: Int?
    public let encryptionKey: String?
    public let allowProfileCreation: Bool
    public let fields: [String:ObjectTypeField]?
    public let keys: [String:[ObjectTypeKey]]?
    public let createdAt: Date?
    public let lastUpdatedAt: Date?
    public let tags: [String:String]?
}

extension PutProfileObjectTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowProfileCreation = "AllowProfileCreation"
        case createdAt = "CreatedAt"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case expirationDays = "ExpirationDays"
        case fields = "Fields"
        case keys = "Keys"
        case lastUpdatedAt = "LastUpdatedAt"
        case objectTypeName = "ObjectTypeName"
        case tags = "Tags"
        case templateId = "TemplateId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let expirationDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expirationDays)
        expirationDays = expirationDaysDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let allowProfileCreationDecoded = try containerValues.decode(Bool.self, forKey: .allowProfileCreation)
        allowProfileCreation = allowProfileCreationDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([String: ObjectTypeField?].self, forKey: .fields)
        var fieldsDecoded0: [String:ObjectTypeField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [String:ObjectTypeField]()
            for (key0, objecttypefield0) in fieldsContainer {
                if let objecttypefield0 = objecttypefield0 {
                    fieldsDecoded0?[key0] = objecttypefield0
                }
            }
        }
        fields = fieldsDecoded0
        let keysContainer = try containerValues.decodeIfPresent([String: [ObjectTypeKey?]?].self, forKey: .keys)
        var keysDecoded0: [String:[ObjectTypeKey]]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [String:[ObjectTypeKey]]()
            for (key0, objecttypekeylist0) in keysContainer {
                var objecttypekeylist0Decoded0: [ObjectTypeKey]? = nil
                if let objecttypekeylist0 = objecttypekeylist0 {
                    objecttypekeylist0Decoded0 = [ObjectTypeKey]()
                    for structure1 in objecttypekeylist0 {
                        if let structure1 = structure1 {
                            objecttypekeylist0Decoded0?.append(structure1)
                        }
                    }
                }
                keysDecoded0?[key0] = objecttypekeylist0Decoded0
            }
        }
        keys = keysDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource does not exist, or access was denied.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum S3ConnectorOperator {
    case addition
    case between
    case division
    case equalTo
    case greaterThan
    case greaterThanOrEqualTo
    case lessThan
    case lessThanOrEqualTo
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case notEqualTo
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension S3ConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3ConnectorOperator] {
        return [
            .addition,
            .between,
            .division,
            .equalTo,
            .greaterThan,
            .greaterThanOrEqualTo,
            .lessThan,
            .lessThanOrEqualTo,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .notEqualTo,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .between: return "BETWEEN"
        case .division: return "DIVISION"
        case .equalTo: return "EQUAL_TO"
        case .greaterThan: return "GREATER_THAN"
        case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
        case .lessThan: return "LESS_THAN"
        case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .notEqualTo: return "NOT_EQUAL_TO"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3ConnectorOperator(rawValue: rawValue) ?? S3ConnectorOperator.sdkUnknown(rawValue)
    }
}

extension S3SourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName = "BucketName"
        case bucketPrefix = "BucketPrefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
    }
}

extension S3SourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3SourceProperties(bucketName: \(String(describing: bucketName)), bucketPrefix: \(String(describing: bucketPrefix)))"}
}

/// <p>The properties that are applied when Amazon S3 is being used as the flow source.</p>
public struct S3SourceProperties: Equatable {
    /// <p>The Amazon S3 bucket name where the source files are stored.</p>
    public let bucketName: String?
    /// <p>The object key for the Amazon S3 bucket in which the source files are stored.</p>
    public let bucketPrefix: String?

    public init (
        bucketName: String? = nil,
        bucketPrefix: String? = nil
    )
    {
        self.bucketName = bucketName
        self.bucketPrefix = bucketPrefix
    }
}

public enum SalesforceConnectorOperator {
    case addition
    case between
    case contains
    case division
    case equalTo
    case greaterThan
    case greaterThanOrEqualTo
    case lessThan
    case lessThanOrEqualTo
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case notEqualTo
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension SalesforceConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SalesforceConnectorOperator] {
        return [
            .addition,
            .between,
            .contains,
            .division,
            .equalTo,
            .greaterThan,
            .greaterThanOrEqualTo,
            .lessThan,
            .lessThanOrEqualTo,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .notEqualTo,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .between: return "BETWEEN"
        case .contains: return "CONTAINS"
        case .division: return "DIVISION"
        case .equalTo: return "EQUAL_TO"
        case .greaterThan: return "GREATER_THAN"
        case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
        case .lessThan: return "LESS_THAN"
        case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .notEqualTo: return "NOT_EQUAL_TO"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SalesforceConnectorOperator(rawValue: rawValue) ?? SalesforceConnectorOperator.sdkUnknown(rawValue)
    }
}

extension SalesforceSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enableDynamicFieldUpdate = "EnableDynamicFieldUpdate"
        case includeDeletedRecords = "IncludeDeletedRecords"
        case object = "Object"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enableDynamicFieldUpdate != false {
            try encodeContainer.encode(enableDynamicFieldUpdate, forKey: .enableDynamicFieldUpdate)
        }
        if includeDeletedRecords != false {
            try encodeContainer.encode(includeDeletedRecords, forKey: .includeDeletedRecords)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
        let enableDynamicFieldUpdateDecoded = try containerValues.decode(Bool.self, forKey: .enableDynamicFieldUpdate)
        enableDynamicFieldUpdate = enableDynamicFieldUpdateDecoded
        let includeDeletedRecordsDecoded = try containerValues.decode(Bool.self, forKey: .includeDeletedRecords)
        includeDeletedRecords = includeDeletedRecordsDecoded
    }
}

extension SalesforceSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SalesforceSourceProperties(enableDynamicFieldUpdate: \(String(describing: enableDynamicFieldUpdate)), includeDeletedRecords: \(String(describing: includeDeletedRecords)), object: \(String(describing: object)))"}
}

/// <p>The properties that are applied when Salesforce is being used as a source.</p>
public struct SalesforceSourceProperties: Equatable {
    /// <p>The flag that enables dynamic fetching of new (recently added) fields in the Salesforce
    ///          objects while running a flow.</p>
    public let enableDynamicFieldUpdate: Bool
    /// <p>Indicates whether Amazon AppFlow includes deleted files in the flow run.</p>
    public let includeDeletedRecords: Bool
    /// <p>The object specified in the Salesforce flow source.</p>
    public let object: String?

    public init (
        enableDynamicFieldUpdate: Bool = false,
        includeDeletedRecords: Bool = false,
        object: String? = nil
    )
    {
        self.enableDynamicFieldUpdate = enableDynamicFieldUpdate
        self.includeDeletedRecords = includeDeletedRecords
        self.object = object
    }
}

extension ScheduledTriggerProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataPullMode = "DataPullMode"
        case firstExecutionFrom = "FirstExecutionFrom"
        case scheduleEndTime = "ScheduleEndTime"
        case scheduleExpression = "ScheduleExpression"
        case scheduleOffset = "ScheduleOffset"
        case scheduleStartTime = "ScheduleStartTime"
        case timezone = "Timezone"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPullMode = dataPullMode {
            try encodeContainer.encode(dataPullMode.rawValue, forKey: .dataPullMode)
        }
        if let firstExecutionFrom = firstExecutionFrom {
            try encodeContainer.encode(firstExecutionFrom.timeIntervalSince1970, forKey: .firstExecutionFrom)
        }
        if let scheduleEndTime = scheduleEndTime {
            try encodeContainer.encode(scheduleEndTime.timeIntervalSince1970, forKey: .scheduleEndTime)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if scheduleOffset != 0 {
            try encodeContainer.encode(scheduleOffset, forKey: .scheduleOffset)
        }
        if let scheduleStartTime = scheduleStartTime {
            try encodeContainer.encode(scheduleStartTime.timeIntervalSince1970, forKey: .scheduleStartTime)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let dataPullModeDecoded = try containerValues.decodeIfPresent(DataPullMode.self, forKey: .dataPullMode)
        dataPullMode = dataPullModeDecoded
        let scheduleStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .scheduleStartTime)
        scheduleStartTime = scheduleStartTimeDecoded
        let scheduleEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .scheduleEndTime)
        scheduleEndTime = scheduleEndTimeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let firstExecutionFromDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .firstExecutionFrom)
        firstExecutionFrom = firstExecutionFromDecoded
    }
}

extension ScheduledTriggerProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduledTriggerProperties(dataPullMode: \(String(describing: dataPullMode)), firstExecutionFrom: \(String(describing: firstExecutionFrom)), scheduleEndTime: \(String(describing: scheduleEndTime)), scheduleExpression: \(String(describing: scheduleExpression)), scheduleOffset: \(String(describing: scheduleOffset)), scheduleStartTime: \(String(describing: scheduleStartTime)), timezone: \(String(describing: timezone)))"}
}

/// <p>Specifies the configuration details of a scheduled-trigger flow that you define.
///          Currently, these settings only apply to the scheduled-trigger type.</p>
public struct ScheduledTriggerProperties: Equatable {
    /// <p>Specifies whether a scheduled flow has an incremental data transfer or a complete data
    ///          transfer for each flow run.</p>
    public let dataPullMode: DataPullMode?
    /// <p>Specifies the date range for the records to import from the connector in the first flow
    ///          run.</p>
    public let firstExecutionFrom: Date?
    /// <p>Specifies the scheduled end time for a scheduled-trigger flow.</p>
    public let scheduleEndTime: Date?
    /// <p>The scheduling expression that determines the rate at which the schedule will run, for
    ///          example rate (5 minutes).</p>
    public let scheduleExpression: String?
    /// <p>Specifies the optional offset that is added to the time interval for a
    ///          schedule-triggered flow.</p>
    public let scheduleOffset: Int
    /// <p>Specifies the scheduled start time for a scheduled-trigger flow.</p>
    public let scheduleStartTime: Date?
    /// <p>Specifies the time zone used when referring to the date and time of a
    ///          scheduled-triggered flow, such as America/New_York.</p>
    public let timezone: String?

    public init (
        dataPullMode: DataPullMode? = nil,
        firstExecutionFrom: Date? = nil,
        scheduleEndTime: Date? = nil,
        scheduleExpression: String? = nil,
        scheduleOffset: Int = 0,
        scheduleStartTime: Date? = nil,
        timezone: String? = nil
    )
    {
        self.dataPullMode = dataPullMode
        self.firstExecutionFrom = firstExecutionFrom
        self.scheduleEndTime = scheduleEndTime
        self.scheduleExpression = scheduleExpression
        self.scheduleOffset = scheduleOffset
        self.scheduleStartTime = scheduleStartTime
        self.timezone = timezone
    }
}

public struct SearchProfilesInputBodyMiddleware: Middleware {
    public let id: String = "SearchProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchProfilesInput>
    public typealias MOutput = OperationOutput<SearchProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchProfilesOutputError>
}

extension SearchProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchProfilesInput(domainName: \(String(describing: domainName)), keyName: \(String(describing: keyName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), values: \(String(describing: values)))"}
}

extension SearchProfilesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyName = "KeyName"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyName = keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for requestvaluelist0 in values {
                try valuesContainer.encode(requestvaluelist0)
            }
        }
    }
}

public struct SearchProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "SearchProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchProfilesInput>
    public typealias MOutput = OperationOutput<SearchProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchProfilesOutputError>
}

public struct SearchProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchProfilesInput>
    public typealias MOutput = OperationOutput<SearchProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchProfilesOutputError>
}

public struct SearchProfilesInput: Equatable {
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>A searchable identifier of a customer profile. The predefined keys you can use to search include: _account, _profileId,
    ///          _fullName, _phone, _email, _ctrContactId, _marketoLeadId, _salesforceAccountId,
    ///          _salesforceContactId, _zendeskUserId, _zendeskExternalId, _serviceNowSystemId.</p>
    public let keyName: String?
    /// <p>The maximum number of objects returned per page.</p>
    public let maxResults: Int?
    /// <p>The pagination token from the previous SearchProfiles API call.</p>
    public let nextToken: String?
    /// <p>A list of key values.</p>
    public let values: [String]?

    public init (
        domainName: String? = nil,
        keyName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        values: [String]? = nil
    )
    {
        self.domainName = domainName
        self.keyName = keyName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.values = values
    }
}

struct SearchProfilesInputBody: Equatable {
    public let keyName: String?
    public let values: [String]?
}

extension SearchProfilesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyName = "KeyName"
        case values = "Values"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SearchProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchProfilesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchProfilesOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct SearchProfilesOutputResponse: Equatable {
    /// <p>The list of SearchProfiles instances.</p>
    public let items: [Profile]?
    /// <p>The pagination token from the previous SearchProfiles API call.</p>
    public let nextToken: String?

    public init (
        items: [Profile]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct SearchProfilesOutputResponseBody: Equatable {
    public let items: [Profile]?
    public let nextToken: String?
}

extension SearchProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Profile?].self, forKey: .items)
        var itemsDecoded0:[Profile]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Profile]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum ServiceNowConnectorOperator {
    case addition
    case between
    case contains
    case division
    case equalTo
    case greaterThan
    case greaterThanOrEqualTo
    case lessThan
    case lessThanOrEqualTo
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case notEqualTo
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension ServiceNowConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceNowConnectorOperator] {
        return [
            .addition,
            .between,
            .contains,
            .division,
            .equalTo,
            .greaterThan,
            .greaterThanOrEqualTo,
            .lessThan,
            .lessThanOrEqualTo,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .notEqualTo,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .between: return "BETWEEN"
        case .contains: return "CONTAINS"
        case .division: return "DIVISION"
        case .equalTo: return "EQUAL_TO"
        case .greaterThan: return "GREATER_THAN"
        case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
        case .lessThan: return "LESS_THAN"
        case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .notEqualTo: return "NOT_EQUAL_TO"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceNowConnectorOperator(rawValue: rawValue) ?? ServiceNowConnectorOperator.sdkUnknown(rawValue)
    }
}

extension ServiceNowSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object = "Object"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension ServiceNowSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceNowSourceProperties(object: \(String(describing: object)))"}
}

/// <p>The properties that are applied when ServiceNow is being used as a source.</p>
public struct ServiceNowSourceProperties: Equatable {
    /// <p>The object specified in the ServiceNow flow source.</p>
    public let object: String?

    public init (
        object: String? = nil
    )
    {
        self.object = object
    }
}

extension SourceConnectorProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case marketo = "Marketo"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marketo = marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let marketoDecoded = try containerValues.decodeIfPresent(MarketoSourceProperties.self, forKey: .marketo)
        marketo = marketoDecoded
        let s3Decoded = try containerValues.decodeIfPresent(S3SourceProperties.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(SalesforceSourceProperties.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(ServiceNowSourceProperties.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(ZendeskSourceProperties.self, forKey: .zendesk)
        zendesk = zendeskDecoded
    }
}

extension SourceConnectorProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceConnectorProperties(marketo: \(String(describing: marketo)), s3: \(String(describing: s3)), salesforce: \(String(describing: salesforce)), serviceNow: \(String(describing: serviceNow)), zendesk: \(String(describing: zendesk)))"}
}

/// <p>Specifies the information that is required to query a particular Amazon AppFlow connector.
///          Customer Profiles supports Salesforce, Zendesk, Marketo, ServiceNow and Amazon S3.</p>
public struct SourceConnectorProperties: Equatable {
    /// <p>The properties that are applied when Marketo is being used as a source.</p>
    public let marketo: MarketoSourceProperties?
    /// <p>The properties that are applied when Amazon S3 is being used as the flow source.</p>
    public let s3: S3SourceProperties?
    /// <p>The properties that are applied when Salesforce is being used as a source.</p>
    public let salesforce: SalesforceSourceProperties?
    /// <p>The properties that are applied when ServiceNow is being used as a source.</p>
    public let serviceNow: ServiceNowSourceProperties?
    /// <p>The properties that are applied when using Zendesk as a flow source.</p>
    public let zendesk: ZendeskSourceProperties?

    public init (
        marketo: MarketoSourceProperties? = nil,
        s3: S3SourceProperties? = nil,
        salesforce: SalesforceSourceProperties? = nil,
        serviceNow: ServiceNowSourceProperties? = nil,
        zendesk: ZendeskSourceProperties? = nil
    )
    {
        self.marketo = marketo
        self.s3 = s3
        self.salesforce = salesforce
        self.serviceNow = serviceNow
        self.zendesk = zendesk
    }
}

public enum SourceConnectorType {
    case marketo
    case s3
    case salesforce
    case servicenow
    case zendesk
    case sdkUnknown(String)
}

extension SourceConnectorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceConnectorType] {
        return [
            .marketo,
            .s3,
            .salesforce,
            .servicenow,
            .zendesk,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .marketo: return "Marketo"
        case .s3: return "S3"
        case .salesforce: return "Salesforce"
        case .servicenow: return "Servicenow"
        case .zendesk: return "Zendesk"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceConnectorType(rawValue: rawValue) ?? SourceConnectorType.sdkUnknown(rawValue)
    }
}

extension SourceFlowConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorProfileName = "ConnectorProfileName"
        case connectorType = "ConnectorType"
        case incrementalPullConfig = "IncrementalPullConfig"
        case sourceConnectorProperties = "SourceConnectorProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let incrementalPullConfig = incrementalPullConfig {
            try encodeContainer.encode(incrementalPullConfig, forKey: .incrementalPullConfig)
        }
        if let sourceConnectorProperties = sourceConnectorProperties {
            try encodeContainer.encode(sourceConnectorProperties, forKey: .sourceConnectorProperties)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(SourceConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let incrementalPullConfigDecoded = try containerValues.decodeIfPresent(IncrementalPullConfig.self, forKey: .incrementalPullConfig)
        incrementalPullConfig = incrementalPullConfigDecoded
        let sourceConnectorPropertiesDecoded = try containerValues.decodeIfPresent(SourceConnectorProperties.self, forKey: .sourceConnectorProperties)
        sourceConnectorProperties = sourceConnectorPropertiesDecoded
    }
}

extension SourceFlowConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceFlowConfig(connectorProfileName: \(String(describing: connectorProfileName)), connectorType: \(String(describing: connectorType)), incrementalPullConfig: \(String(describing: incrementalPullConfig)), sourceConnectorProperties: \(String(describing: sourceConnectorProperties)))"}
}

/// <p>Contains information about the configuration of the source connector used in the
///          flow.</p>
public struct SourceFlowConfig: Equatable {
    /// <p>The name of the AppFlow connector profile. This name must be unique for each connector
    ///          profile in the AWS account.</p>
    public let connectorProfileName: String?
    /// <p>The type of connector, such as Salesforce, Marketo, and so on.</p>
    public let connectorType: SourceConnectorType?
    /// <p>Defines the configuration for a scheduled incremental data pull. If a valid
    ///          configuration is provided, the fields specified in the configuration are used when querying
    ///          for the incremental data pull.</p>
    public let incrementalPullConfig: IncrementalPullConfig?
    /// <p>Specifies the information that is required to query a particular source
    ///          connector.</p>
    public let sourceConnectorProperties: SourceConnectorProperties?

    public init (
        connectorProfileName: String? = nil,
        connectorType: SourceConnectorType? = nil,
        incrementalPullConfig: IncrementalPullConfig? = nil,
        sourceConnectorProperties: SourceConnectorProperties? = nil
    )
    {
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
        self.incrementalPullConfig = incrementalPullConfig
        self.sourceConnectorProperties = sourceConnectorProperties
    }
}

public enum StandardIdentifier {
    case lookupOnly
    case newOnly
    case profile
    case secondary
    case unique
    case sdkUnknown(String)
}

extension StandardIdentifier : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StandardIdentifier] {
        return [
            .lookupOnly,
            .newOnly,
            .profile,
            .secondary,
            .unique,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lookupOnly: return "LOOKUP_ONLY"
        case .newOnly: return "NEW_ONLY"
        case .profile: return "PROFILE"
        case .secondary: return "SECONDARY"
        case .unique: return "UNIQUE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StandardIdentifier(rawValue: rawValue) ?? StandardIdentifier.sdkUnknown(rawValue)
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the resource that you're adding tags to.</p>
    public let resourceArn: String?
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Task: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorOperator = "ConnectorOperator"
        case destinationField = "DestinationField"
        case sourceFields = "SourceFields"
        case taskProperties = "TaskProperties"
        case taskType = "TaskType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorOperator = connectorOperator {
            try encodeContainer.encode(connectorOperator, forKey: .connectorOperator)
        }
        if let destinationField = destinationField {
            try encodeContainer.encode(destinationField, forKey: .destinationField)
        }
        if let sourceFields = sourceFields {
            var sourceFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceFields)
            for sourcefields0 in sourceFields {
                try sourceFieldsContainer.encode(sourcefields0)
            }
        }
        if let taskProperties = taskProperties {
            var taskPropertiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .taskProperties)
            for (dictKey0, taskpropertiesmap0) in taskProperties {
                try taskPropertiesContainer.encode(taskpropertiesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let taskType = taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorOperatorDecoded = try containerValues.decodeIfPresent(ConnectorOperator.self, forKey: .connectorOperator)
        connectorOperator = connectorOperatorDecoded
        let destinationFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationField)
        destinationField = destinationFieldDecoded
        let sourceFieldsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sourceFields)
        var sourceFieldsDecoded0:[String]? = nil
        if let sourceFieldsContainer = sourceFieldsContainer {
            sourceFieldsDecoded0 = [String]()
            for string0 in sourceFieldsContainer {
                if let string0 = string0 {
                    sourceFieldsDecoded0?.append(string0)
                }
            }
        }
        sourceFields = sourceFieldsDecoded0
        let taskPropertiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .taskProperties)
        var taskPropertiesDecoded0: [String:String]? = nil
        if let taskPropertiesContainer = taskPropertiesContainer {
            taskPropertiesDecoded0 = [String:String]()
            for (key0, property0) in taskPropertiesContainer {
                if let property0 = property0 {
                    taskPropertiesDecoded0?[key0] = property0
                }
            }
        }
        taskProperties = taskPropertiesDecoded0
        let taskTypeDecoded = try containerValues.decodeIfPresent(TaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
    }
}

extension Task: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Task(connectorOperator: \(String(describing: connectorOperator)), destinationField: \(String(describing: destinationField)), sourceFields: \(String(describing: sourceFields)), taskProperties: \(String(describing: taskProperties)), taskType: \(String(describing: taskType)))"}
}

/// <p>A class for modeling different type of tasks. Task implementation varies based on the
///          TaskType.</p>
public struct Task: Equatable {
    /// <p>The operation to be performed on the provided source fields.</p>
    public let connectorOperator: ConnectorOperator?
    /// <p>A field in a destination connector, or a field value against which Amazon AppFlow validates a
    ///          source field.</p>
    public let destinationField: String?
    /// <p>The source fields to which a particular task is applied.</p>
    public let sourceFields: [String]?
    /// <p>A map used to store task-related information. The service looks for particular
    ///          information based on the TaskType.</p>
    public let taskProperties: [String:String]?
    /// <p>Specifies the particular task implementation that Amazon AppFlow performs.</p>
    public let taskType: TaskType?

    public init (
        connectorOperator: ConnectorOperator? = nil,
        destinationField: String? = nil,
        sourceFields: [String]? = nil,
        taskProperties: [String:String]? = nil,
        taskType: TaskType? = nil
    )
    {
        self.connectorOperator = connectorOperator
        self.destinationField = destinationField
        self.sourceFields = sourceFields
        self.taskProperties = taskProperties
        self.taskType = taskType
    }
}

public enum TaskType {
    case arithmetic
    case filter
    case map
    case mask
    case merge
    case truncate
    case validate
    case sdkUnknown(String)
}

extension TaskType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TaskType] {
        return [
            .arithmetic,
            .filter,
            .map,
            .mask,
            .merge,
            .truncate,
            .validate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .arithmetic: return "Arithmetic"
        case .filter: return "Filter"
        case .map: return "Map"
        case .mask: return "Mask"
        case .merge: return "Merge"
        case .truncate: return "Truncate"
        case .validate: return "Validate"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TaskType(rawValue: rawValue) ?? TaskType.sdkUnknown(rawValue)
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You exceeded the maximum number of requests.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TriggerConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case triggerProperties = "TriggerProperties"
        case triggerType = "TriggerType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let triggerProperties = triggerProperties {
            try encodeContainer.encode(triggerProperties, forKey: .triggerProperties)
        }
        if let triggerType = triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerTypeDecoded = try containerValues.decodeIfPresent(TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerPropertiesDecoded = try containerValues.decodeIfPresent(TriggerProperties.self, forKey: .triggerProperties)
        triggerProperties = triggerPropertiesDecoded
    }
}

extension TriggerConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TriggerConfig(triggerProperties: \(String(describing: triggerProperties)), triggerType: \(String(describing: triggerType)))"}
}

/// <p>The trigger settings that determine how and when Amazon AppFlow runs the specified
///          flow.</p>
public struct TriggerConfig: Equatable {
    /// <p>Specifies the configuration details of a schedule-triggered flow that you define.
    ///          Currently, these settings only apply to the Scheduled trigger type.</p>
    public let triggerProperties: TriggerProperties?
    /// <p>Specifies the type of flow trigger. It can be OnDemand, Scheduled, or Event.</p>
    public let triggerType: TriggerType?

    public init (
        triggerProperties: TriggerProperties? = nil,
        triggerType: TriggerType? = nil
    )
    {
        self.triggerProperties = triggerProperties
        self.triggerType = triggerType
    }
}

extension TriggerProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case scheduled = "Scheduled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduled = scheduled {
            try encodeContainer.encode(scheduled, forKey: .scheduled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledDecoded = try containerValues.decodeIfPresent(ScheduledTriggerProperties.self, forKey: .scheduled)
        scheduled = scheduledDecoded
    }
}

extension TriggerProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TriggerProperties(scheduled: \(String(describing: scheduled)))"}
}

/// <p>Specifies the configuration details that control the trigger for a flow. Currently,
///          these settings only apply to the Scheduled trigger type.</p>
public struct TriggerProperties: Equatable {
    /// <p>Specifies the configuration details of a schedule-triggered flow that you define.</p>
    public let scheduled: ScheduledTriggerProperties?

    public init (
        scheduled: ScheduledTriggerProperties? = nil
    )
    {
        self.scheduled = scheduled
    }
}

public enum TriggerType {
    case event
    case ondemand
    case scheduled
    case sdkUnknown(String)
}

extension TriggerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TriggerType] {
        return [
            .event,
            .ondemand,
            .scheduled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .event: return "Event"
        case .ondemand: return "OnDemand"
        case .scheduled: return "Scheduled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TriggerType(rawValue: rawValue) ?? TriggerType.sdkUnknown(rawValue)
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the resource from which you are removing tags.</p>
    public let resourceArn: String?
    /// <p>The list of tag keys to remove from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateAddress: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address1 = "Address1"
        case address2 = "Address2"
        case address3 = "Address3"
        case address4 = "Address4"
        case city = "City"
        case country = "Country"
        case county = "County"
        case postalCode = "PostalCode"
        case province = "Province"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address1 = address1 {
            try encodeContainer.encode(address1, forKey: .address1)
        }
        if let address2 = address2 {
            try encodeContainer.encode(address2, forKey: .address2)
        }
        if let address3 = address3 {
            try encodeContainer.encode(address3, forKey: .address3)
        }
        if let address4 = address4 {
            try encodeContainer.encode(address4, forKey: .address4)
        }
        if let city = city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let county = county {
            try encodeContainer.encode(county, forKey: .county)
        }
        if let postalCode = postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let province = province {
            try encodeContainer.encode(province, forKey: .province)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let address1Decoded = try containerValues.decodeIfPresent(String.self, forKey: .address1)
        address1 = address1Decoded
        let address2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .address2)
        address2 = address2Decoded
        let address3Decoded = try containerValues.decodeIfPresent(String.self, forKey: .address3)
        address3 = address3Decoded
        let address4Decoded = try containerValues.decodeIfPresent(String.self, forKey: .address4)
        address4 = address4Decoded
        let cityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .city)
        city = cityDecoded
        let countyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .county)
        county = countyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let provinceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .province)
        province = provinceDecoded
        let countryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .country)
        country = countryDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
    }
}

extension UpdateAddress: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAddress(address1: \(String(describing: address1)), address2: \(String(describing: address2)), address3: \(String(describing: address3)), address4: \(String(describing: address4)), city: \(String(describing: city)), country: \(String(describing: country)), county: \(String(describing: county)), postalCode: \(String(describing: postalCode)), province: \(String(describing: province)), state: \(String(describing: state)))"}
}

/// <p>Updates associated with the address properties of a customer profile.</p>
public struct UpdateAddress: Equatable {
    /// <p>The first line of a customer address.</p>
    public let address1: String?
    /// <p>The second line of a customer address.</p>
    public let address2: String?
    /// <p>The third line of a customer address.</p>
    public let address3: String?
    /// <p>The fourth line of a customer address.</p>
    public let address4: String?
    /// <p>The city in which a customer lives.</p>
    public let city: String?
    /// <p>The country in which a customer lives.</p>
    public let country: String?
    /// <p>The county in which a customer lives.</p>
    public let county: String?
    /// <p>The postal code of a customer address.</p>
    public let postalCode: String?
    /// <p>The province in which a customer lives.</p>
    public let province: String?
    /// <p>The state in which a customer lives.</p>
    public let state: String?

    public init (
        address1: String? = nil,
        address2: String? = nil,
        address3: String? = nil,
        address4: String? = nil,
        city: String? = nil,
        country: String? = nil,
        county: String? = nil,
        postalCode: String? = nil,
        province: String? = nil,
        state: String? = nil
    )
    {
        self.address1 = address1
        self.address2 = address2
        self.address3 = address3
        self.address4 = address4
        self.city = city
        self.country = country
        self.county = county
        self.postalCode = postalCode
        self.province = province
        self.state = state
    }
}

public struct UpdateDomainInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainInput>
    public typealias MOutput = OperationOutput<UpdateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainOutputError>
}

extension UpdateDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainInput(deadLetterQueueUrl: \(String(describing: deadLetterQueueUrl)), defaultEncryptionKey: \(String(describing: defaultEncryptionKey)), defaultExpirationDays: \(String(describing: defaultExpirationDays)), domainName: \(String(describing: domainName)), matching: \(String(describing: matching)), tags: \(String(describing: tags)))"}
}

extension UpdateDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deadLetterQueueUrl = "DeadLetterQueueUrl"
        case defaultEncryptionKey = "DefaultEncryptionKey"
        case defaultExpirationDays = "DefaultExpirationDays"
        case matching = "Matching"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deadLetterQueueUrl = deadLetterQueueUrl {
            try encodeContainer.encode(deadLetterQueueUrl, forKey: .deadLetterQueueUrl)
        }
        if let defaultEncryptionKey = defaultEncryptionKey {
            try encodeContainer.encode(defaultEncryptionKey, forKey: .defaultEncryptionKey)
        }
        if let defaultExpirationDays = defaultExpirationDays {
            try encodeContainer.encode(defaultExpirationDays, forKey: .defaultExpirationDays)
        }
        if let matching = matching {
            try encodeContainer.encode(matching, forKey: .matching)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateDomainInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainInput>
    public typealias MOutput = OperationOutput<UpdateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainOutputError>
}

public struct UpdateDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainInput>
    public typealias MOutput = OperationOutput<UpdateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainOutputError>
}

public struct UpdateDomainInput: Equatable {
    /// <p>The URL of the SQS dead letter queue, which is used for reporting errors associated with
    ///          ingesting data from third party applications. If specified as an empty string, it will
    ///          clear any existing value. You must set up a policy on the DeadLetterQueue for the
    ///          SendMessage operation to enable Amazon Connect Customer Profiles to send messages to the
    ///          DeadLetterQueue.</p>
    public let deadLetterQueueUrl: String?
    /// <p>The default encryption key, which is an AWS managed key, is used when no specific type
    ///          of encryption key is specified. It is used to encrypt all data before it is placed in
    ///          permanent or semi-permanent storage. If specified as an empty string, it will clear any
    ///          existing value.</p>
    public let defaultEncryptionKey: String?
    /// <p>The default number of days until the data within the domain expires.</p>
    public let defaultExpirationDays: Int?
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The process of matching duplicate profiles. This process runs every Saturday at 12AM.</p>
    public let matching: MatchingRequest?
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?

    public init (
        deadLetterQueueUrl: String? = nil,
        defaultEncryptionKey: String? = nil,
        defaultExpirationDays: Int? = nil,
        domainName: String? = nil,
        matching: MatchingRequest? = nil,
        tags: [String:String]? = nil
    )
    {
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.matching = matching
        self.tags = tags
    }
}

struct UpdateDomainInputBody: Equatable {
    public let defaultExpirationDays: Int?
    public let defaultEncryptionKey: String?
    public let deadLetterQueueUrl: String?
    public let matching: MatchingRequest?
    public let tags: [String:String]?
}

extension UpdateDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deadLetterQueueUrl = "DeadLetterQueueUrl"
        case defaultEncryptionKey = "DefaultEncryptionKey"
        case defaultExpirationDays = "DefaultExpirationDays"
        case matching = "Matching"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultExpirationDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultExpirationDays)
        defaultExpirationDays = defaultExpirationDaysDecoded
        let defaultEncryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultEncryptionKey)
        defaultEncryptionKey = defaultEncryptionKeyDecoded
        let deadLetterQueueUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deadLetterQueueUrl)
        deadLetterQueueUrl = deadLetterQueueUrlDecoded
        let matchingDecoded = try containerValues.decodeIfPresent(MatchingRequest.self, forKey: .matching)
        matching = matchingDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainOutputResponse(createdAt: \(String(describing: createdAt)), deadLetterQueueUrl: \(String(describing: deadLetterQueueUrl)), defaultEncryptionKey: \(String(describing: defaultEncryptionKey)), defaultExpirationDays: \(String(describing: defaultExpirationDays)), domainName: \(String(describing: domainName)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), matching: \(String(describing: matching)), tags: \(String(describing: tags)))"}
}

extension UpdateDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.deadLetterQueueUrl = output.deadLetterQueueUrl
            self.defaultEncryptionKey = output.defaultEncryptionKey
            self.defaultExpirationDays = output.defaultExpirationDays
            self.domainName = output.domainName
            self.lastUpdatedAt = output.lastUpdatedAt
            self.matching = output.matching
            self.tags = output.tags
        } else {
            self.createdAt = nil
            self.deadLetterQueueUrl = nil
            self.defaultEncryptionKey = nil
            self.defaultExpirationDays = nil
            self.domainName = nil
            self.lastUpdatedAt = nil
            self.matching = nil
            self.tags = nil
        }
    }
}

public struct UpdateDomainOutputResponse: Equatable {
    /// <p>The timestamp of when the domain was created.</p>
    public let createdAt: Date?
    /// <p>The URL of the SQS dead letter queue, which is used for reporting errors associated with
    ///          ingesting data from third party applications.</p>
    public let deadLetterQueueUrl: String?
    /// <p>The default encryption key, which is an AWS managed key, is used when no specific type
    ///          of encryption key is specified. It is used to encrypt all data before it is placed in
    ///          permanent or semi-permanent storage.</p>
    public let defaultEncryptionKey: String?
    /// <p>The default number of days until the data within the domain expires.</p>
    public let defaultExpirationDays: Int?
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The timestamp of when the domain was most recently edited.</p>
    public let lastUpdatedAt: Date?
    /// <p>The process of matching duplicate profiles. This process runs every Saturday at 12AM.</p>
    public let matching: MatchingResponse?
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    public let tags: [String:String]?

    public init (
        createdAt: Date? = nil,
        deadLetterQueueUrl: String? = nil,
        defaultEncryptionKey: String? = nil,
        defaultExpirationDays: Int? = nil,
        domainName: String? = nil,
        lastUpdatedAt: Date? = nil,
        matching: MatchingResponse? = nil,
        tags: [String:String]? = nil
    )
    {
        self.createdAt = createdAt
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.matching = matching
        self.tags = tags
    }
}

struct UpdateDomainOutputResponseBody: Equatable {
    public let domainName: String?
    public let defaultExpirationDays: Int?
    public let defaultEncryptionKey: String?
    public let deadLetterQueueUrl: String?
    public let matching: MatchingResponse?
    public let createdAt: Date?
    public let lastUpdatedAt: Date?
    public let tags: [String:String]?
}

extension UpdateDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case deadLetterQueueUrl = "DeadLetterQueueUrl"
        case defaultEncryptionKey = "DefaultEncryptionKey"
        case defaultExpirationDays = "DefaultExpirationDays"
        case domainName = "DomainName"
        case lastUpdatedAt = "LastUpdatedAt"
        case matching = "Matching"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let defaultExpirationDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultExpirationDays)
        defaultExpirationDays = defaultExpirationDaysDecoded
        let defaultEncryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultEncryptionKey)
        defaultEncryptionKey = defaultEncryptionKeyDecoded
        let deadLetterQueueUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deadLetterQueueUrl)
        deadLetterQueueUrl = deadLetterQueueUrlDecoded
        let matchingDecoded = try containerValues.decodeIfPresent(MatchingResponse.self, forKey: .matching)
        matching = matchingDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProfileInput>
    public typealias MOutput = OperationOutput<UpdateProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProfileOutputError>
}

extension UpdateProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProfileInput(accountNumber: \(String(describing: accountNumber)), additionalInformation: \(String(describing: additionalInformation)), address: \(String(describing: address)), attributes: \(String(describing: attributes)), billingAddress: \(String(describing: billingAddress)), birthDate: \(String(describing: birthDate)), businessEmailAddress: \(String(describing: businessEmailAddress)), businessName: \(String(describing: businessName)), businessPhoneNumber: \(String(describing: businessPhoneNumber)), domainName: \(String(describing: domainName)), emailAddress: \(String(describing: emailAddress)), firstName: \(String(describing: firstName)), gender: \(String(describing: gender)), homePhoneNumber: \(String(describing: homePhoneNumber)), lastName: \(String(describing: lastName)), mailingAddress: \(String(describing: mailingAddress)), middleName: \(String(describing: middleName)), mobilePhoneNumber: \(String(describing: mobilePhoneNumber)), partyType: \(String(describing: partyType)), personalEmailAddress: \(String(describing: personalEmailAddress)), phoneNumber: \(String(describing: phoneNumber)), profileId: \(String(describing: profileId)), shippingAddress: \(String(describing: shippingAddress)))"}
}

extension UpdateProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountNumber = "AccountNumber"
        case additionalInformation = "AdditionalInformation"
        case address = "Address"
        case attributes = "Attributes"
        case billingAddress = "BillingAddress"
        case birthDate = "BirthDate"
        case businessEmailAddress = "BusinessEmailAddress"
        case businessName = "BusinessName"
        case businessPhoneNumber = "BusinessPhoneNumber"
        case emailAddress = "EmailAddress"
        case firstName = "FirstName"
        case gender = "Gender"
        case homePhoneNumber = "HomePhoneNumber"
        case lastName = "LastName"
        case mailingAddress = "MailingAddress"
        case middleName = "MiddleName"
        case mobilePhoneNumber = "MobilePhoneNumber"
        case partyType = "PartyType"
        case personalEmailAddress = "PersonalEmailAddress"
        case phoneNumber = "PhoneNumber"
        case profileId = "ProfileId"
        case shippingAddress = "ShippingAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountNumber = accountNumber {
            try encodeContainer.encode(accountNumber, forKey: .accountNumber)
        }
        if let additionalInformation = additionalInformation {
            try encodeContainer.encode(additionalInformation, forKey: .additionalInformation)
        }
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, updateattributes0) in attributes {
                try attributesContainer.encode(updateattributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let billingAddress = billingAddress {
            try encodeContainer.encode(billingAddress, forKey: .billingAddress)
        }
        if let birthDate = birthDate {
            try encodeContainer.encode(birthDate, forKey: .birthDate)
        }
        if let businessEmailAddress = businessEmailAddress {
            try encodeContainer.encode(businessEmailAddress, forKey: .businessEmailAddress)
        }
        if let businessName = businessName {
            try encodeContainer.encode(businessName, forKey: .businessName)
        }
        if let businessPhoneNumber = businessPhoneNumber {
            try encodeContainer.encode(businessPhoneNumber, forKey: .businessPhoneNumber)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let gender = gender {
            try encodeContainer.encode(gender.rawValue, forKey: .gender)
        }
        if let homePhoneNumber = homePhoneNumber {
            try encodeContainer.encode(homePhoneNumber, forKey: .homePhoneNumber)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let mailingAddress = mailingAddress {
            try encodeContainer.encode(mailingAddress, forKey: .mailingAddress)
        }
        if let middleName = middleName {
            try encodeContainer.encode(middleName, forKey: .middleName)
        }
        if let mobilePhoneNumber = mobilePhoneNumber {
            try encodeContainer.encode(mobilePhoneNumber, forKey: .mobilePhoneNumber)
        }
        if let partyType = partyType {
            try encodeContainer.encode(partyType.rawValue, forKey: .partyType)
        }
        if let personalEmailAddress = personalEmailAddress {
            try encodeContainer.encode(personalEmailAddress, forKey: .personalEmailAddress)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let profileId = profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let shippingAddress = shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
    }
}

public struct UpdateProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProfileInput>
    public typealias MOutput = OperationOutput<UpdateProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProfileOutputError>
}

public struct UpdateProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProfileInput>
    public typealias MOutput = OperationOutput<UpdateProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProfileOutputError>
}

public struct UpdateProfileInput: Equatable {
    /// <p>A unique account number that you have given to the customer.</p>
    public let accountNumber: String?
    /// <p>Any additional information relevant to the customer’s profile.</p>
    public let additionalInformation: String?
    /// <p>A generic address associated with the customer that is not mailing, shipping, or
    ///          billing.</p>
    public let address: UpdateAddress?
    /// <p>A key value pair of attributes of a customer profile.</p>
    public let attributes: [String:String]?
    /// <p>The customer’s billing address.</p>
    public let billingAddress: UpdateAddress?
    /// <p>The customer’s birth date. </p>
    public let birthDate: String?
    /// <p>The customer’s business email address.</p>
    public let businessEmailAddress: String?
    /// <p>The name of the customer’s business.</p>
    public let businessName: String?
    /// <p>The customer’s business phone number.</p>
    public let businessPhoneNumber: String?
    /// <p>The unique name of the domain.</p>
    public let domainName: String?
    /// <p>The customer’s email address, which has not been specified as a personal or business
    ///          address. </p>
    public let emailAddress: String?
    /// <p>The customer’s first name.</p>
    public let firstName: String?
    /// <p>The gender with which the customer identifies. </p>
    public let gender: Gender?
    /// <p>The customer’s home phone number.</p>
    public let homePhoneNumber: String?
    /// <p>The customer’s last name.</p>
    public let lastName: String?
    /// <p>The customer’s mailing address.</p>
    public let mailingAddress: UpdateAddress?
    /// <p>The customer’s middle name.</p>
    public let middleName: String?
    /// <p>The customer’s mobile phone number.</p>
    public let mobilePhoneNumber: String?
    /// <p>The type of profile used to describe the customer.</p>
    public let partyType: PartyType?
    /// <p>The customer’s personal email address.</p>
    public let personalEmailAddress: String?
    /// <p>The customer’s phone number, which has not been specified as a mobile, home, or business
    ///          number. </p>
    public let phoneNumber: String?
    /// <p>The unique identifier of a customer profile.</p>
    public let profileId: String?
    /// <p>The customer’s shipping address.</p>
    public let shippingAddress: UpdateAddress?

    public init (
        accountNumber: String? = nil,
        additionalInformation: String? = nil,
        address: UpdateAddress? = nil,
        attributes: [String:String]? = nil,
        billingAddress: UpdateAddress? = nil,
        birthDate: String? = nil,
        businessEmailAddress: String? = nil,
        businessName: String? = nil,
        businessPhoneNumber: String? = nil,
        domainName: String? = nil,
        emailAddress: String? = nil,
        firstName: String? = nil,
        gender: Gender? = nil,
        homePhoneNumber: String? = nil,
        lastName: String? = nil,
        mailingAddress: UpdateAddress? = nil,
        middleName: String? = nil,
        mobilePhoneNumber: String? = nil,
        partyType: PartyType? = nil,
        personalEmailAddress: String? = nil,
        phoneNumber: String? = nil,
        profileId: String? = nil,
        shippingAddress: UpdateAddress? = nil
    )
    {
        self.accountNumber = accountNumber
        self.additionalInformation = additionalInformation
        self.address = address
        self.attributes = attributes
        self.billingAddress = billingAddress
        self.birthDate = birthDate
        self.businessEmailAddress = businessEmailAddress
        self.businessName = businessName
        self.businessPhoneNumber = businessPhoneNumber
        self.domainName = domainName
        self.emailAddress = emailAddress
        self.firstName = firstName
        self.gender = gender
        self.homePhoneNumber = homePhoneNumber
        self.lastName = lastName
        self.mailingAddress = mailingAddress
        self.middleName = middleName
        self.mobilePhoneNumber = mobilePhoneNumber
        self.partyType = partyType
        self.personalEmailAddress = personalEmailAddress
        self.phoneNumber = phoneNumber
        self.profileId = profileId
        self.shippingAddress = shippingAddress
    }
}

struct UpdateProfileInputBody: Equatable {
    public let profileId: String?
    public let additionalInformation: String?
    public let accountNumber: String?
    public let partyType: PartyType?
    public let businessName: String?
    public let firstName: String?
    public let middleName: String?
    public let lastName: String?
    public let birthDate: String?
    public let gender: Gender?
    public let phoneNumber: String?
    public let mobilePhoneNumber: String?
    public let homePhoneNumber: String?
    public let businessPhoneNumber: String?
    public let emailAddress: String?
    public let personalEmailAddress: String?
    public let businessEmailAddress: String?
    public let address: UpdateAddress?
    public let shippingAddress: UpdateAddress?
    public let mailingAddress: UpdateAddress?
    public let billingAddress: UpdateAddress?
    public let attributes: [String:String]?
}

extension UpdateProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountNumber = "AccountNumber"
        case additionalInformation = "AdditionalInformation"
        case address = "Address"
        case attributes = "Attributes"
        case billingAddress = "BillingAddress"
        case birthDate = "BirthDate"
        case businessEmailAddress = "BusinessEmailAddress"
        case businessName = "BusinessName"
        case businessPhoneNumber = "BusinessPhoneNumber"
        case emailAddress = "EmailAddress"
        case firstName = "FirstName"
        case gender = "Gender"
        case homePhoneNumber = "HomePhoneNumber"
        case lastName = "LastName"
        case mailingAddress = "MailingAddress"
        case middleName = "MiddleName"
        case mobilePhoneNumber = "MobilePhoneNumber"
        case partyType = "PartyType"
        case personalEmailAddress = "PersonalEmailAddress"
        case phoneNumber = "PhoneNumber"
        case profileId = "ProfileId"
        case shippingAddress = "ShippingAddress"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let additionalInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .additionalInformation)
        additionalInformation = additionalInformationDecoded
        let accountNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountNumber)
        accountNumber = accountNumberDecoded
        let partyTypeDecoded = try containerValues.decodeIfPresent(PartyType.self, forKey: .partyType)
        partyType = partyTypeDecoded
        let businessNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .businessName)
        businessName = businessNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let middleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .middleName)
        middleName = middleNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let birthDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .birthDate)
        birthDate = birthDateDecoded
        let genderDecoded = try containerValues.decodeIfPresent(Gender.self, forKey: .gender)
        gender = genderDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let mobilePhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mobilePhoneNumber)
        mobilePhoneNumber = mobilePhoneNumberDecoded
        let homePhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homePhoneNumber)
        homePhoneNumber = homePhoneNumberDecoded
        let businessPhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .businessPhoneNumber)
        businessPhoneNumber = businessPhoneNumberDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let personalEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .personalEmailAddress)
        personalEmailAddress = personalEmailAddressDecoded
        let businessEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .businessEmailAddress)
        businessEmailAddress = businessEmailAddressDecoded
        let addressDecoded = try containerValues.decodeIfPresent(UpdateAddress.self, forKey: .address)
        address = addressDecoded
        let shippingAddressDecoded = try containerValues.decodeIfPresent(UpdateAddress.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let mailingAddressDecoded = try containerValues.decodeIfPresent(UpdateAddress.self, forKey: .mailingAddress)
        mailingAddress = mailingAddressDecoded
        let billingAddressDecoded = try containerValues.decodeIfPresent(UpdateAddress.self, forKey: .billingAddress)
        billingAddress = billingAddressDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, string0to2550) in attributesContainer {
                if let string0to2550 = string0to2550 {
                    attributesDecoded0?[key0] = string0to2550
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension UpdateProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProfileOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProfileOutputResponse(profileId: \(String(describing: profileId)))"}
}

extension UpdateProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.profileId = output.profileId
        } else {
            self.profileId = nil
        }
    }
}

public struct UpdateProfileOutputResponse: Equatable {
    /// <p>The unique identifier of a customer profile.</p>
    public let profileId: String?

    public init (
        profileId: String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct UpdateProfileOutputResponseBody: Equatable {
    public let profileId: String?
}

extension UpdateProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case profileId = "ProfileId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

public enum ZendeskConnectorOperator {
    case addition
    case division
    case greaterThan
    case maskAll
    case maskFirstN
    case maskLastN
    case multiplication
    case noOp
    case projection
    case subtraction
    case validateNonNegative
    case validateNonNull
    case validateNonZero
    case validateNumeric
    case sdkUnknown(String)
}

extension ZendeskConnectorOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ZendeskConnectorOperator] {
        return [
            .addition,
            .division,
            .greaterThan,
            .maskAll,
            .maskFirstN,
            .maskLastN,
            .multiplication,
            .noOp,
            .projection,
            .subtraction,
            .validateNonNegative,
            .validateNonNull,
            .validateNonZero,
            .validateNumeric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addition: return "ADDITION"
        case .division: return "DIVISION"
        case .greaterThan: return "GREATER_THAN"
        case .maskAll: return "MASK_ALL"
        case .maskFirstN: return "MASK_FIRST_N"
        case .maskLastN: return "MASK_LAST_N"
        case .multiplication: return "MULTIPLICATION"
        case .noOp: return "NO_OP"
        case .projection: return "PROJECTION"
        case .subtraction: return "SUBTRACTION"
        case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
        case .validateNonNull: return "VALIDATE_NON_NULL"
        case .validateNonZero: return "VALIDATE_NON_ZERO"
        case .validateNumeric: return "VALIDATE_NUMERIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ZendeskConnectorOperator(rawValue: rawValue) ?? ZendeskConnectorOperator.sdkUnknown(rawValue)
    }
}

extension ZendeskSourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case object = "Object"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .object)
        object = objectDecoded
    }
}

extension ZendeskSourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ZendeskSourceProperties(object: \(String(describing: object)))"}
}

/// <p>The properties that are applied when using Zendesk as a flow source.</p>
public struct ZendeskSourceProperties: Equatable {
    /// <p>The object specified in the Zendesk flow source.</p>
    public let object: String?

    public init (
        object: String? = nil
    )
    {
        self.object = object
    }
}
