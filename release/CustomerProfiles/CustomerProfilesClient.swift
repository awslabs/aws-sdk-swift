// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class CustomerProfilesClient {
    let client: SdkHttpClient
    let config: CustomerProfilesClientConfiguration
    let serviceName = "Customer Profiles"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: CustomerProfilesClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class CustomerProfilesClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> CustomerProfilesClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try CustomerProfilesClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension CustomerProfilesClient: CustomerProfilesClientProtocol {
    /// <p>Associates a new key value with a specific profile, such as a Contact Trace Record (CTR)
    ///          ContactId.</p>
    ///          <p>A profile object can have a single unique key and any number of additional keys that can
    ///          be used to identify the profile that it belongs to.</p>
    public func addProfileKey(input: AddProfileKeyInput, completion: @escaping (SdkResult<AddProfileKeyOutputResponse, AddProfileKeyOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/profiles/keys"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "addProfileKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AddProfileKeyInput, AddProfileKeyOutputResponse, AddProfileKeyOutputError>(id: "addProfileKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AddProfileKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AddProfileKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AddProfileKeyInput, AddProfileKeyOutputResponse, AddProfileKeyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AddProfileKeyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a domain, which is a container for all customer data, such as customer profile
    ///          attributes, object types, profile keys, and encryption keys. You can create multiple
    ///          domains, and each domain can have multiple third-party integrations.</p>
    ///          <p>Each Amazon Connect instance can be associated with only one domain. Multiple Amazon Connect instances can
    ///          be associated with one domain.</p>
    public func createDomain(input: CreateDomainInput, completion: @escaping (SdkResult<CreateDomainOutputResponse, CreateDomainOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDomain")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDomainInput, CreateDomainOutputResponse, CreateDomainOutputError>(id: "createDomain")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDomainInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDomainInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDomainInput, CreateDomainOutputResponse, CreateDomainOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDomainInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a standard profile.</p>
    ///          <p>A standard profile represents the following attributes for a customer profile in a
    ///          domain.</p>
    public func createProfile(input: CreateProfileInput, completion: @escaping (SdkResult<CreateProfileOutputResponse, CreateProfileOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/profiles"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateProfileInput, CreateProfileOutputResponse, CreateProfileOutputError>(id: "createProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateProfileInput, CreateProfileOutputResponse, CreateProfileOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateProfileInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a specific domain and all of its customer data, such as customer profile
    ///          attributes and their related objects.</p>
    public func deleteDomain(input: DeleteDomainInput, completion: @escaping (SdkResult<DeleteDomainOutputResponse, DeleteDomainOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDomain")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDomainInput, DeleteDomainOutputResponse, DeleteDomainOutputError>(id: "deleteDomain")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDomainInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDomainInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteDomainInput, DeleteDomainOutputResponse, DeleteDomainOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes an integration from a specific domain.</p>
    public func deleteIntegration(input: DeleteIntegrationInput, completion: @escaping (SdkResult<DeleteIntegrationOutputResponse, DeleteIntegrationOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/integrations/delete"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteIntegration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteIntegrationInput, DeleteIntegrationOutputResponse, DeleteIntegrationOutputError>(id: "deleteIntegration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntegrationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntegrationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteIntegrationInput, DeleteIntegrationOutputResponse, DeleteIntegrationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntegrationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the standard customer profile and all data pertaining to the profile.</p>
    public func deleteProfile(input: DeleteProfileInput, completion: @escaping (SdkResult<DeleteProfileOutputResponse, DeleteProfileOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/profiles/delete"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteProfileInput, DeleteProfileOutputResponse, DeleteProfileOutputError>(id: "deleteProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteProfileInput, DeleteProfileOutputResponse, DeleteProfileOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteProfileInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes a searchable key from a customer profile.</p>
    public func deleteProfileKey(input: DeleteProfileKeyInput, completion: @escaping (SdkResult<DeleteProfileKeyOutputResponse, DeleteProfileKeyOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/profiles/keys/delete"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteProfileKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteProfileKeyInput, DeleteProfileKeyOutputResponse, DeleteProfileKeyOutputError>(id: "deleteProfileKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteProfileKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteProfileKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteProfileKeyInput, DeleteProfileKeyOutputResponse, DeleteProfileKeyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteProfileKeyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes an object associated with a profile of a given ProfileObjectType.</p>
    public func deleteProfileObject(input: DeleteProfileObjectInput, completion: @escaping (SdkResult<DeleteProfileObjectOutputResponse, DeleteProfileObjectOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/profiles/objects/delete"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteProfileObject")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteProfileObjectInput, DeleteProfileObjectOutputResponse, DeleteProfileObjectOutputError>(id: "deleteProfileObject")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteProfileObjectInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteProfileObjectInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteProfileObjectInput, DeleteProfileObjectOutputResponse, DeleteProfileObjectOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteProfileObjectInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes a ProfileObjectType from a specific domain as well as removes all the
    ///          ProfileObjects of that type. It also disables integrations from this specific
    ///          ProfileObjectType. In addition, it scrubs all of the fields of the standard profile that
    ///          were populated from this ProfileObjectType.</p>
    public func deleteProfileObjectType(input: DeleteProfileObjectTypeInput, completion: @escaping (SdkResult<DeleteProfileObjectTypeOutputResponse, DeleteProfileObjectTypeOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        guard let objectTypeName = input.objectTypeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component objectTypeName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/object-types/\(objectTypeName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteProfileObjectType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteProfileObjectTypeInput, DeleteProfileObjectTypeOutputResponse, DeleteProfileObjectTypeOutputError>(id: "deleteProfileObjectType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteProfileObjectTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteProfileObjectTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteProfileObjectTypeInput, DeleteProfileObjectTypeOutputResponse, DeleteProfileObjectTypeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about a specific domain.</p>
    public func getDomain(input: GetDomainInput, completion: @escaping (SdkResult<GetDomainOutputResponse, GetDomainOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDomain")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDomainInput, GetDomainOutputResponse, GetDomainOutputError>(id: "getDomain")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDomainInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDomainInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDomainInput, GetDomainOutputResponse, GetDomainOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns an integration for a domain.</p>
    public func getIntegration(input: GetIntegrationInput, completion: @escaping (SdkResult<GetIntegrationOutputResponse, GetIntegrationOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/integrations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getIntegration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetIntegrationInput, GetIntegrationOutputResponse, GetIntegrationOutputError>(id: "getIntegration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetIntegrationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetIntegrationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetIntegrationInput, GetIntegrationOutputResponse, GetIntegrationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: GetIntegrationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and subject to change.</p>
    ///          <p>Before calling this API, use <a href="https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_CreateDomain.html">CreateDomain</a> or
    ///             <a href="https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_UpdateDomain.html">UpdateDomain</a> to
    ///          enable identity resolution: set <code>Matching</code> to true.</p>
    ///          <p>GetMatches returns potentially matching profiles, based on the results of the latest run
    ///          of a machine learning process. </p>
    ///          <important>
    ///             <p>Amazon Connect runs a batch process every Saturday at 12AM UTC to identify matching profiles.
    ///             The results are returned up to seven days after the Saturday run.</p>
    ///          </important>
    ///
    ///          <p>Amazon Connect uses the following profile attributes to identify matches:</p>
    ///          <ul>
    ///             <li>
    ///                <p>PhoneNumber</p>
    ///             </li>
    ///             <li>
    ///                <p>HomePhoneNumber</p>
    ///             </li>
    ///             <li>
    ///                <p>BusinessPhoneNumber</p>
    ///             </li>
    ///             <li>
    ///                <p>MobilePhoneNumber</p>
    ///             </li>
    ///             <li>
    ///                <p>EmailAddress</p>
    ///             </li>
    ///             <li>
    ///                <p>PersonalEmailAddress</p>
    ///             </li>
    ///             <li>
    ///                <p>BusinessEmailAddress</p>
    ///             </li>
    ///             <li>
    ///                <p>FullName</p>
    ///             </li>
    ///             <li>
    ///                <p>BusinessName</p>
    ///             </li>
    ///          </ul>
    public func getMatches(input: GetMatchesInput, completion: @escaping (SdkResult<GetMatchesOutputResponse, GetMatchesOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/matches"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getMatches")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetMatchesInput, GetMatchesOutputResponse, GetMatchesOutputError>(id: "getMatches")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetMatchesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetMatchesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetMatchesInput, GetMatchesOutputResponse, GetMatchesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the object types for a specific domain.</p>
    public func getProfileObjectType(input: GetProfileObjectTypeInput, completion: @escaping (SdkResult<GetProfileObjectTypeOutputResponse, GetProfileObjectTypeOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        guard let objectTypeName = input.objectTypeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component objectTypeName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/object-types/\(objectTypeName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getProfileObjectType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetProfileObjectTypeInput, GetProfileObjectTypeOutputResponse, GetProfileObjectTypeOutputError>(id: "getProfileObjectType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetProfileObjectTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetProfileObjectTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetProfileObjectTypeInput, GetProfileObjectTypeOutputResponse, GetProfileObjectTypeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the template information for a specific object type.</p>
    ///          <p>A template is a predefined ProfileObjectType, such as “Salesforce-Account” or
    ///          “Salesforce-Contact.” When a user sends a ProfileObject, using the PutProfileObject API,
    ///          with an ObjectTypeName that matches one of the TemplateIds, it uses the mappings from the
    ///          template.</p>
    public func getProfileObjectTypeTemplate(input: GetProfileObjectTypeTemplateInput, completion: @escaping (SdkResult<GetProfileObjectTypeTemplateOutputResponse, GetProfileObjectTypeTemplateOutputError>) -> Void)
    {
        guard let templateId = input.templateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateId unexpectedly nil"))))
            return
        }
        let urlPath = "/templates/\(templateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getProfileObjectTypeTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetProfileObjectTypeTemplateInput, GetProfileObjectTypeTemplateOutputResponse, GetProfileObjectTypeTemplateOutputError>(id: "getProfileObjectTypeTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetProfileObjectTypeTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetProfileObjectTypeTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetProfileObjectTypeTemplateInput, GetProfileObjectTypeTemplateOutputResponse, GetProfileObjectTypeTemplateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all of the integrations associated to a specific URI in the AWS account.</p>
    public func listAccountIntegrations(input: ListAccountIntegrationsInput, completion: @escaping (SdkResult<ListAccountIntegrationsOutputResponse, ListAccountIntegrationsOutputError>) -> Void)
    {
        let urlPath = "/integrations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAccountIntegrations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAccountIntegrationsInput, ListAccountIntegrationsOutputResponse, ListAccountIntegrationsOutputError>(id: "listAccountIntegrations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAccountIntegrationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAccountIntegrationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAccountIntegrationsInput, ListAccountIntegrationsOutputResponse, ListAccountIntegrationsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListAccountIntegrationsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of all the domains for an AWS account that have been created.</p>
    public func listDomains(input: ListDomainsInput, completion: @escaping (SdkResult<ListDomainsOutputResponse, ListDomainsOutputError>) -> Void)
    {
        let urlPath = "/domains"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDomains")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDomainsInput, ListDomainsOutputResponse, ListDomainsOutputError>(id: "listDomains")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDomainsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDomainsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDomainsInput, ListDomainsOutputResponse, ListDomainsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all of the integrations in your domain.</p>
    public func listIntegrations(input: ListIntegrationsInput, completion: @escaping (SdkResult<ListIntegrationsOutputResponse, ListIntegrationsOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/integrations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listIntegrations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListIntegrationsInput, ListIntegrationsOutputResponse, ListIntegrationsOutputError>(id: "listIntegrations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListIntegrationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListIntegrationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListIntegrationsInput, ListIntegrationsOutputResponse, ListIntegrationsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all of the template information for object types.</p>
    public func listProfileObjectTypeTemplates(input: ListProfileObjectTypeTemplatesInput, completion: @escaping (SdkResult<ListProfileObjectTypeTemplatesOutputResponse, ListProfileObjectTypeTemplatesOutputError>) -> Void)
    {
        let urlPath = "/templates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listProfileObjectTypeTemplates")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListProfileObjectTypeTemplatesInput, ListProfileObjectTypeTemplatesOutputResponse, ListProfileObjectTypeTemplatesOutputError>(id: "listProfileObjectTypeTemplates")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListProfileObjectTypeTemplatesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListProfileObjectTypeTemplatesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListProfileObjectTypeTemplatesInput, ListProfileObjectTypeTemplatesOutputResponse, ListProfileObjectTypeTemplatesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all of the templates available within the service.</p>
    public func listProfileObjectTypes(input: ListProfileObjectTypesInput, completion: @escaping (SdkResult<ListProfileObjectTypesOutputResponse, ListProfileObjectTypesOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/object-types"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listProfileObjectTypes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListProfileObjectTypesInput, ListProfileObjectTypesOutputResponse, ListProfileObjectTypesOutputError>(id: "listProfileObjectTypes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListProfileObjectTypesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListProfileObjectTypesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListProfileObjectTypesInput, ListProfileObjectTypesOutputResponse, ListProfileObjectTypesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of objects associated with a profile of a given ProfileObjectType.</p>
    public func listProfileObjects(input: ListProfileObjectsInput, completion: @escaping (SdkResult<ListProfileObjectsOutputResponse, ListProfileObjectsOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/profiles/objects"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listProfileObjects")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListProfileObjectsInput, ListProfileObjectsOutputResponse, ListProfileObjectsOutputError>(id: "listProfileObjects")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListProfileObjectsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListProfileObjectsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListProfileObjectsInput, ListProfileObjectsOutputResponse, ListProfileObjectsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListProfileObjectsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Displays the tags associated with an Amazon Connect Customer Profiles resource. In Connect
    ///          Customer Profiles, domains, profile object types, and integrations can be tagged.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and subject to change.</p>
    ///          <p>Runs an AWS Lambda job that does the following:</p>
    ///          <ol>
    ///             <li>
    ///                <p>All the profileKeys in the <code>ProfileToBeMerged</code> will be moved to the
    ///                main profile.</p>
    ///             </li>
    ///             <li>
    ///                <p>All the objects in the <code>ProfileToBeMerged</code> will be moved to the main
    ///                profile.</p>
    ///             </li>
    ///             <li>
    ///                <p>All the <code>ProfileToBeMerged</code> will be deleted at the end.</p>
    ///             </li>
    ///             <li>
    ///                <p>All the profileKeys in the <code>ProfileIdsToBeMerged</code> will be moved to the
    ///                main profile.</p>
    ///             </li>
    ///             <li>
    ///                <p>Standard fields are merged as follows:</p>
    ///                <ol>
    ///                   <li>
    ///                      <p>Fields are always "union"-ed if there are no conflicts in standard fields or
    ///                      attributeKeys.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>When there are conflicting fields:</p>
    ///
    ///                      <ol>
    ///                         <li>
    ///                            <p>If no <code>SourceProfileIds</code> entry is specified, the main
    ///                            Profile value is always taken. </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>If a <code>SourceProfileIds</code> entry is specified, the specified
    ///                            profileId is always taken, even if it is a NULL value.</p>
    ///                         </li>
    ///                      </ol>
    ///                   </li>
    ///                </ol>
    ///             </li>
    ///          </ol>
    ///          <p>You can use MergeProfiles together with <a href="https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html">GetMatches</a>, which
    ///          returns potentially matching profiles, or use it with the results of another matching
    ///          system. After profiles have been merged, they cannot be separated (unmerged).</p>
    public func mergeProfiles(input: MergeProfilesInput, completion: @escaping (SdkResult<MergeProfilesOutputResponse, MergeProfilesOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/profiles/objects/merge"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "mergeProfiles")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<MergeProfilesInput, MergeProfilesOutputResponse, MergeProfilesOutputError>(id: "mergeProfiles")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: MergeProfilesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: MergeProfilesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<MergeProfilesInput, MergeProfilesOutputResponse, MergeProfilesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: MergeProfilesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds an integration between the service and a third-party service, which includes
    ///          Amazon AppFlow and Amazon Connect.</p>
    ///          <p>An integration can belong to only one domain.</p>
    public func putIntegration(input: PutIntegrationInput, completion: @escaping (SdkResult<PutIntegrationOutputResponse, PutIntegrationOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/integrations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putIntegration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutIntegrationInput, PutIntegrationOutputResponse, PutIntegrationOutputError>(id: "putIntegration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutIntegrationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutIntegrationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutIntegrationInput, PutIntegrationOutputResponse, PutIntegrationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutIntegrationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds additional objects to customer profiles of a given ObjectType.</p>
    ///          <p>When adding a specific profile object, like a Contact Trace Record (CTR), an inferred
    ///          profile can get created if it is not mapped to an existing profile. The resulting profile
    ///          will only have a phone number populated in the standard ProfileObject. Any additional CTRs
    ///          with the same phone number will be mapped to the same inferred profile.</p>
    ///          <p>When a ProfileObject is created and if a ProfileObjectType already exists for the
    ///          ProfileObject, it will provide data to a standard profile depending on the
    ///          ProfileObjectType definition.</p>
    ///          <p>PutProfileObject needs an ObjectType, which can be created using
    ///          PutProfileObjectType.</p>
    public func putProfileObject(input: PutProfileObjectInput, completion: @escaping (SdkResult<PutProfileObjectOutputResponse, PutProfileObjectOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/profiles/objects"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putProfileObject")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutProfileObjectInput, PutProfileObjectOutputResponse, PutProfileObjectOutputError>(id: "putProfileObject")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutProfileObjectInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutProfileObjectInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutProfileObjectInput, PutProfileObjectOutputResponse, PutProfileObjectOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutProfileObjectInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Defines a ProfileObjectType.</p>
    public func putProfileObjectType(input: PutProfileObjectTypeInput, completion: @escaping (SdkResult<PutProfileObjectTypeOutputResponse, PutProfileObjectTypeOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        guard let objectTypeName = input.objectTypeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component objectTypeName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/object-types/\(objectTypeName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putProfileObjectType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutProfileObjectTypeInput, PutProfileObjectTypeOutputResponse, PutProfileObjectTypeOutputError>(id: "putProfileObjectType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutProfileObjectTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutProfileObjectTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutProfileObjectTypeInput, PutProfileObjectTypeOutputResponse, PutProfileObjectTypeOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutProfileObjectTypeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Searches for profiles within a specific domain name using name, phone number, email
    ///          address, account number, or a custom defined index.</p>
    public func searchProfiles(input: SearchProfilesInput, completion: @escaping (SdkResult<SearchProfilesOutputResponse, SearchProfilesOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/profiles/search"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "searchProfiles")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SearchProfilesInput, SearchProfilesOutputResponse, SearchProfilesOutputError>(id: "searchProfiles")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SearchProfilesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SearchProfilesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SearchProfilesInput, SearchProfilesOutputResponse, SearchProfilesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: SearchProfilesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Assigns one or more tags (key-value pairs) to the specified Amazon Connect Customer Profiles
    ///          resource. Tags can help you organize and categorize your resources. You can also use them
    ///          to scope user permissions by granting a user permission to access or change only resources
    ///          with certain tag values. In Connect Customer Profiles, domains, profile object types, and
    ///          integrations can be tagged.</p>
    ///          <p>Tags don't have any semantic meaning to AWS and are interpreted strictly as strings of
    ///          characters.</p>
    ///          <p>You can use the TagResource action with a resource that already has tags. If you specify
    ///          a new tag key, this tag is appended to the list of tags associated with the resource. If
    ///          you specify a tag key that is already associated with the resource, the new tag value that
    ///          you specify replaces the previous value for that tag.</p>
    ///          <p>You can associate as many as 50 tags with a resource.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes one or more tags from the specified Amazon Connect Customer Profiles resource. In Connect
    ///          Customer Profiles, domains, profile object types, and integrations can be tagged.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the properties of a domain, including creating or selecting a dead letter queue
    ///          or an encryption key.</p>
    ///          <p>After a domain is created, the name can’t be changed.</p>
    public func updateDomain(input: UpdateDomainInput, completion: @escaping (SdkResult<UpdateDomainOutputResponse, UpdateDomainOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateDomain")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateDomainInput, UpdateDomainOutputResponse, UpdateDomainOutputError>(id: "updateDomain")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateDomainInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateDomainInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateDomainInput, UpdateDomainOutputResponse, UpdateDomainOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateDomainInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the properties of a profile. The ProfileId is required for updating a customer
    ///          profile.</p>
    ///          <p>When calling the UpdateProfile API, specifying an empty string value means that any
    ///          existing value will be removed. Not specifying a string value means that any value already
    ///          there will be kept.</p>
    public func updateProfile(input: UpdateProfileInput, completion: @escaping (SdkResult<UpdateProfileOutputResponse, UpdateProfileOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domains/\(domainName)/profiles"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "profile.\(config.region).amazonaws.com")
                      .withSigningName(value: "profile")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateProfileInput, UpdateProfileOutputResponse, UpdateProfileOutputError>(id: "updateProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateProfileInput, UpdateProfileOutputResponse, UpdateProfileOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateProfileInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
