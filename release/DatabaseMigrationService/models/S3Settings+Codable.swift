// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension S3Settings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketFolder = "BucketFolder"
        case bucketName = "BucketName"
        case cdcInsertsAndUpdates = "CdcInsertsAndUpdates"
        case cdcInsertsOnly = "CdcInsertsOnly"
        case cdcPath = "CdcPath"
        case compressionType = "CompressionType"
        case csvDelimiter = "CsvDelimiter"
        case csvNoSupValue = "CsvNoSupValue"
        case csvRowDelimiter = "CsvRowDelimiter"
        case dataFormat = "DataFormat"
        case dataPageSize = "DataPageSize"
        case datePartitionDelimiter = "DatePartitionDelimiter"
        case datePartitionEnabled = "DatePartitionEnabled"
        case datePartitionSequence = "DatePartitionSequence"
        case dictPageSizeLimit = "DictPageSizeLimit"
        case enableStatistics = "EnableStatistics"
        case encodingType = "EncodingType"
        case encryptionMode = "EncryptionMode"
        case externalTableDefinition = "ExternalTableDefinition"
        case includeOpForFullLoad = "IncludeOpForFullLoad"
        case parquetTimestampInMillisecond = "ParquetTimestampInMillisecond"
        case parquetVersion = "ParquetVersion"
        case preserveTransactions = "PreserveTransactions"
        case rowGroupLength = "RowGroupLength"
        case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case timestampColumnName = "TimestampColumnName"
        case useCsvNoSupValue = "UseCsvNoSupValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketFolder = bucketFolder {
            try encodeContainer.encode(bucketFolder, forKey: .bucketFolder)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let cdcInsertsAndUpdates = cdcInsertsAndUpdates {
            try encodeContainer.encode(cdcInsertsAndUpdates, forKey: .cdcInsertsAndUpdates)
        }
        if let cdcInsertsOnly = cdcInsertsOnly {
            try encodeContainer.encode(cdcInsertsOnly, forKey: .cdcInsertsOnly)
        }
        if let cdcPath = cdcPath {
            try encodeContainer.encode(cdcPath, forKey: .cdcPath)
        }
        if let compressionType = compressionType {
            try encodeContainer.encode(compressionType.rawValue, forKey: .compressionType)
        }
        if let csvDelimiter = csvDelimiter {
            try encodeContainer.encode(csvDelimiter, forKey: .csvDelimiter)
        }
        if let csvNoSupValue = csvNoSupValue {
            try encodeContainer.encode(csvNoSupValue, forKey: .csvNoSupValue)
        }
        if let csvRowDelimiter = csvRowDelimiter {
            try encodeContainer.encode(csvRowDelimiter, forKey: .csvRowDelimiter)
        }
        if let dataFormat = dataFormat {
            try encodeContainer.encode(dataFormat.rawValue, forKey: .dataFormat)
        }
        if let dataPageSize = dataPageSize {
            try encodeContainer.encode(dataPageSize, forKey: .dataPageSize)
        }
        if let datePartitionDelimiter = datePartitionDelimiter {
            try encodeContainer.encode(datePartitionDelimiter.rawValue, forKey: .datePartitionDelimiter)
        }
        if let datePartitionEnabled = datePartitionEnabled {
            try encodeContainer.encode(datePartitionEnabled, forKey: .datePartitionEnabled)
        }
        if let datePartitionSequence = datePartitionSequence {
            try encodeContainer.encode(datePartitionSequence.rawValue, forKey: .datePartitionSequence)
        }
        if let dictPageSizeLimit = dictPageSizeLimit {
            try encodeContainer.encode(dictPageSizeLimit, forKey: .dictPageSizeLimit)
        }
        if let enableStatistics = enableStatistics {
            try encodeContainer.encode(enableStatistics, forKey: .enableStatistics)
        }
        if let encodingType = encodingType {
            try encodeContainer.encode(encodingType.rawValue, forKey: .encodingType)
        }
        if let encryptionMode = encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let externalTableDefinition = externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let includeOpForFullLoad = includeOpForFullLoad {
            try encodeContainer.encode(includeOpForFullLoad, forKey: .includeOpForFullLoad)
        }
        if let parquetTimestampInMillisecond = parquetTimestampInMillisecond {
            try encodeContainer.encode(parquetTimestampInMillisecond, forKey: .parquetTimestampInMillisecond)
        }
        if let parquetVersion = parquetVersion {
            try encodeContainer.encode(parquetVersion.rawValue, forKey: .parquetVersion)
        }
        if let preserveTransactions = preserveTransactions {
            try encodeContainer.encode(preserveTransactions, forKey: .preserveTransactions)
        }
        if let rowGroupLength = rowGroupLength {
            try encodeContainer.encode(rowGroupLength, forKey: .rowGroupLength)
        }
        if let serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId {
            try encodeContainer.encode(serverSideEncryptionKmsKeyId, forKey: .serverSideEncryptionKmsKeyId)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let timestampColumnName = timestampColumnName {
            try encodeContainer.encode(timestampColumnName, forKey: .timestampColumnName)
        }
        if let useCsvNoSupValue = useCsvNoSupValue {
            try encodeContainer.encode(useCsvNoSupValue, forKey: .useCsvNoSupValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let csvRowDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .csvRowDelimiter)
        csvRowDelimiter = csvRowDelimiterDecoded
        let csvDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .csvDelimiter)
        csvDelimiter = csvDelimiterDecoded
        let bucketFolderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketFolder)
        bucketFolder = bucketFolderDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let compressionTypeDecoded = try containerValues.decodeIfPresent(CompressionTypeValue.self, forKey: .compressionType)
        compressionType = compressionTypeDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(EncryptionModeValue.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let serverSideEncryptionKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverSideEncryptionKmsKeyId)
        serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyIdDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(DataFormatValue.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let encodingTypeDecoded = try containerValues.decodeIfPresent(EncodingTypeValue.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
        let dictPageSizeLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dictPageSizeLimit)
        dictPageSizeLimit = dictPageSizeLimitDecoded
        let rowGroupLengthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .rowGroupLength)
        rowGroupLength = rowGroupLengthDecoded
        let dataPageSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dataPageSize)
        dataPageSize = dataPageSizeDecoded
        let parquetVersionDecoded = try containerValues.decodeIfPresent(ParquetVersionValue.self, forKey: .parquetVersion)
        parquetVersion = parquetVersionDecoded
        let enableStatisticsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableStatistics)
        enableStatistics = enableStatisticsDecoded
        let includeOpForFullLoadDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeOpForFullLoad)
        includeOpForFullLoad = includeOpForFullLoadDecoded
        let cdcInsertsOnlyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .cdcInsertsOnly)
        cdcInsertsOnly = cdcInsertsOnlyDecoded
        let timestampColumnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestampColumnName)
        timestampColumnName = timestampColumnNameDecoded
        let parquetTimestampInMillisecondDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .parquetTimestampInMillisecond)
        parquetTimestampInMillisecond = parquetTimestampInMillisecondDecoded
        let cdcInsertsAndUpdatesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .cdcInsertsAndUpdates)
        cdcInsertsAndUpdates = cdcInsertsAndUpdatesDecoded
        let datePartitionEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .datePartitionEnabled)
        datePartitionEnabled = datePartitionEnabledDecoded
        let datePartitionSequenceDecoded = try containerValues.decodeIfPresent(DatePartitionSequenceValue.self, forKey: .datePartitionSequence)
        datePartitionSequence = datePartitionSequenceDecoded
        let datePartitionDelimiterDecoded = try containerValues.decodeIfPresent(DatePartitionDelimiterValue.self, forKey: .datePartitionDelimiter)
        datePartitionDelimiter = datePartitionDelimiterDecoded
        let useCsvNoSupValueDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useCsvNoSupValue)
        useCsvNoSupValue = useCsvNoSupValueDecoded
        let csvNoSupValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .csvNoSupValue)
        csvNoSupValue = csvNoSupValueDecoded
        let preserveTransactionsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .preserveTransactions)
        preserveTransactions = preserveTransactionsDecoded
        let cdcPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cdcPath)
        cdcPath = cdcPathDecoded
    }
}
