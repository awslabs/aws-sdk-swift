// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Certificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case certificateCreationDate = "CertificateCreationDate"
        case certificateIdentifier = "CertificateIdentifier"
        case certificateOwner = "CertificateOwner"
        case certificatePem = "CertificatePem"
        case certificateWallet = "CertificateWallet"
        case keyLength = "KeyLength"
        case signingAlgorithm = "SigningAlgorithm"
        case validFromDate = "ValidFromDate"
        case validToDate = "ValidToDate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateCreationDate = certificateCreationDate {
            try encodeContainer.encode(certificateCreationDate.timeIntervalSince1970, forKey: .certificateCreationDate)
        }
        if let certificateIdentifier = certificateIdentifier {
            try encodeContainer.encode(certificateIdentifier, forKey: .certificateIdentifier)
        }
        if let certificateOwner = certificateOwner {
            try encodeContainer.encode(certificateOwner, forKey: .certificateOwner)
        }
        if let certificatePem = certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let certificateWallet = certificateWallet {
            try encodeContainer.encode(certificateWallet.base64EncodedString(), forKey: .certificateWallet)
        }
        if let keyLength = keyLength {
            try encodeContainer.encode(keyLength, forKey: .keyLength)
        }
        if let signingAlgorithm = signingAlgorithm {
            try encodeContainer.encode(signingAlgorithm, forKey: .signingAlgorithm)
        }
        if let validFromDate = validFromDate {
            try encodeContainer.encode(validFromDate.timeIntervalSince1970, forKey: .validFromDate)
        }
        if let validToDate = validToDate {
            try encodeContainer.encode(validToDate.timeIntervalSince1970, forKey: .validToDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateIdentifier)
        certificateIdentifier = certificateIdentifierDecoded
        let certificateCreationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .certificateCreationDate)
        certificateCreationDate = certificateCreationDateDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let certificateWalletDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .certificateWallet)
        certificateWallet = certificateWalletDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateOwner)
        certificateOwner = certificateOwnerDecoded
        let validFromDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .validFromDate)
        validFromDate = validFromDateDecoded
        let validToDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .validToDate)
        validToDate = validToDateDecoded
        let signingAlgorithmDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingAlgorithm)
        signingAlgorithm = signingAlgorithmDecoded
        let keyLengthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .keyLength)
        keyLength = keyLengthDecoded
    }
}
