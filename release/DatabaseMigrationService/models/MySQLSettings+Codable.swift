// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension MySQLSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case afterConnectScript = "AfterConnectScript"
        case cleanSourceMetadataOnMismatch = "CleanSourceMetadataOnMismatch"
        case databaseName = "DatabaseName"
        case eventsPollInterval = "EventsPollInterval"
        case maxFileSize = "MaxFileSize"
        case parallelLoadThreads = "ParallelLoadThreads"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case serverTimezone = "ServerTimezone"
        case targetDbType = "TargetDbType"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterConnectScript = afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatch {
            try encodeContainer.encode(cleanSourceMetadataOnMismatch, forKey: .cleanSourceMetadataOnMismatch)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let eventsPollInterval = eventsPollInterval {
            try encodeContainer.encode(eventsPollInterval, forKey: .eventsPollInterval)
        }
        if let maxFileSize = maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let parallelLoadThreads = parallelLoadThreads {
            try encodeContainer.encode(parallelLoadThreads, forKey: .parallelLoadThreads)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serverTimezone = serverTimezone {
            try encodeContainer.encode(serverTimezone, forKey: .serverTimezone)
        }
        if let targetDbType = targetDbType {
            try encodeContainer.encode(targetDbType.rawValue, forKey: .targetDbType)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let cleanSourceMetadataOnMismatchDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .cleanSourceMetadataOnMismatch)
        cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatchDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let eventsPollIntervalDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .eventsPollInterval)
        eventsPollInterval = eventsPollIntervalDecoded
        let targetDbTypeDecoded = try containerValues.decodeIfPresent(TargetDbType.self, forKey: .targetDbType)
        targetDbType = targetDbTypeDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let parallelLoadThreadsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelLoadThreads)
        parallelLoadThreads = parallelLoadThreadsDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serverTimezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverTimezone)
        serverTimezone = serverTimezoneDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}
