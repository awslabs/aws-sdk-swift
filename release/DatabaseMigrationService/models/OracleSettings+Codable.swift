// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension OracleSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessAlternateDirectly = "AccessAlternateDirectly"
        case addSupplementalLogging = "AddSupplementalLogging"
        case additionalArchivedLogDestId = "AdditionalArchivedLogDestId"
        case allowSelectNestedTables = "AllowSelectNestedTables"
        case archivedLogDestId = "ArchivedLogDestId"
        case archivedLogsOnly = "ArchivedLogsOnly"
        case asmPassword = "AsmPassword"
        case asmServer = "AsmServer"
        case asmUser = "AsmUser"
        case charLengthSemantics = "CharLengthSemantics"
        case databaseName = "DatabaseName"
        case directPathNoLog = "DirectPathNoLog"
        case directPathParallelLoad = "DirectPathParallelLoad"
        case enableHomogenousTablespace = "EnableHomogenousTablespace"
        case failTasksOnLobTruncation = "FailTasksOnLobTruncation"
        case numberDatatypeScale = "NumberDatatypeScale"
        case oraclePathPrefix = "OraclePathPrefix"
        case parallelAsmReadThreads = "ParallelAsmReadThreads"
        case password = "Password"
        case port = "Port"
        case readAheadBlocks = "ReadAheadBlocks"
        case readTableSpaceName = "ReadTableSpaceName"
        case replacePathPrefix = "ReplacePathPrefix"
        case retryInterval = "RetryInterval"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerOracleAsmAccessRoleArn = "SecretsManagerOracleAsmAccessRoleArn"
        case secretsManagerOracleAsmSecretId = "SecretsManagerOracleAsmSecretId"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case securityDbEncryption = "SecurityDbEncryption"
        case securityDbEncryptionName = "SecurityDbEncryptionName"
        case serverName = "ServerName"
        case spatialDataOptionToGeoJsonFunctionName = "SpatialDataOptionToGeoJsonFunctionName"
        case useAlternateFolderForOnline = "UseAlternateFolderForOnline"
        case usePathPrefix = "UsePathPrefix"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessAlternateDirectly = accessAlternateDirectly {
            try encodeContainer.encode(accessAlternateDirectly, forKey: .accessAlternateDirectly)
        }
        if let addSupplementalLogging = addSupplementalLogging {
            try encodeContainer.encode(addSupplementalLogging, forKey: .addSupplementalLogging)
        }
        if let additionalArchivedLogDestId = additionalArchivedLogDestId {
            try encodeContainer.encode(additionalArchivedLogDestId, forKey: .additionalArchivedLogDestId)
        }
        if let allowSelectNestedTables = allowSelectNestedTables {
            try encodeContainer.encode(allowSelectNestedTables, forKey: .allowSelectNestedTables)
        }
        if let archivedLogDestId = archivedLogDestId {
            try encodeContainer.encode(archivedLogDestId, forKey: .archivedLogDestId)
        }
        if let archivedLogsOnly = archivedLogsOnly {
            try encodeContainer.encode(archivedLogsOnly, forKey: .archivedLogsOnly)
        }
        if let asmPassword = asmPassword {
            try encodeContainer.encode(asmPassword, forKey: .asmPassword)
        }
        if let asmServer = asmServer {
            try encodeContainer.encode(asmServer, forKey: .asmServer)
        }
        if let asmUser = asmUser {
            try encodeContainer.encode(asmUser, forKey: .asmUser)
        }
        if let charLengthSemantics = charLengthSemantics {
            try encodeContainer.encode(charLengthSemantics.rawValue, forKey: .charLengthSemantics)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let directPathNoLog = directPathNoLog {
            try encodeContainer.encode(directPathNoLog, forKey: .directPathNoLog)
        }
        if let directPathParallelLoad = directPathParallelLoad {
            try encodeContainer.encode(directPathParallelLoad, forKey: .directPathParallelLoad)
        }
        if let enableHomogenousTablespace = enableHomogenousTablespace {
            try encodeContainer.encode(enableHomogenousTablespace, forKey: .enableHomogenousTablespace)
        }
        if let failTasksOnLobTruncation = failTasksOnLobTruncation {
            try encodeContainer.encode(failTasksOnLobTruncation, forKey: .failTasksOnLobTruncation)
        }
        if let numberDatatypeScale = numberDatatypeScale {
            try encodeContainer.encode(numberDatatypeScale, forKey: .numberDatatypeScale)
        }
        if let oraclePathPrefix = oraclePathPrefix {
            try encodeContainer.encode(oraclePathPrefix, forKey: .oraclePathPrefix)
        }
        if let parallelAsmReadThreads = parallelAsmReadThreads {
            try encodeContainer.encode(parallelAsmReadThreads, forKey: .parallelAsmReadThreads)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let readAheadBlocks = readAheadBlocks {
            try encodeContainer.encode(readAheadBlocks, forKey: .readAheadBlocks)
        }
        if let readTableSpaceName = readTableSpaceName {
            try encodeContainer.encode(readTableSpaceName, forKey: .readTableSpaceName)
        }
        if let replacePathPrefix = replacePathPrefix {
            try encodeContainer.encode(replacePathPrefix, forKey: .replacePathPrefix)
        }
        if let retryInterval = retryInterval {
            try encodeContainer.encode(retryInterval, forKey: .retryInterval)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArn {
            try encodeContainer.encode(secretsManagerOracleAsmAccessRoleArn, forKey: .secretsManagerOracleAsmAccessRoleArn)
        }
        if let secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretId {
            try encodeContainer.encode(secretsManagerOracleAsmSecretId, forKey: .secretsManagerOracleAsmSecretId)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let securityDbEncryption = securityDbEncryption {
            try encodeContainer.encode(securityDbEncryption, forKey: .securityDbEncryption)
        }
        if let securityDbEncryptionName = securityDbEncryptionName {
            try encodeContainer.encode(securityDbEncryptionName, forKey: .securityDbEncryptionName)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let spatialDataOptionToGeoJsonFunctionName = spatialDataOptionToGeoJsonFunctionName {
            try encodeContainer.encode(spatialDataOptionToGeoJsonFunctionName, forKey: .spatialDataOptionToGeoJsonFunctionName)
        }
        if let useAlternateFolderForOnline = useAlternateFolderForOnline {
            try encodeContainer.encode(useAlternateFolderForOnline, forKey: .useAlternateFolderForOnline)
        }
        if let usePathPrefix = usePathPrefix {
            try encodeContainer.encode(usePathPrefix, forKey: .usePathPrefix)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addSupplementalLoggingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .addSupplementalLogging)
        addSupplementalLogging = addSupplementalLoggingDecoded
        let archivedLogDestIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .archivedLogDestId)
        archivedLogDestId = archivedLogDestIdDecoded
        let additionalArchivedLogDestIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .additionalArchivedLogDestId)
        additionalArchivedLogDestId = additionalArchivedLogDestIdDecoded
        let allowSelectNestedTablesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowSelectNestedTables)
        allowSelectNestedTables = allowSelectNestedTablesDecoded
        let parallelAsmReadThreadsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelAsmReadThreads)
        parallelAsmReadThreads = parallelAsmReadThreadsDecoded
        let readAheadBlocksDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .readAheadBlocks)
        readAheadBlocks = readAheadBlocksDecoded
        let accessAlternateDirectlyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .accessAlternateDirectly)
        accessAlternateDirectly = accessAlternateDirectlyDecoded
        let useAlternateFolderForOnlineDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useAlternateFolderForOnline)
        useAlternateFolderForOnline = useAlternateFolderForOnlineDecoded
        let oraclePathPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .oraclePathPrefix)
        oraclePathPrefix = oraclePathPrefixDecoded
        let usePathPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usePathPrefix)
        usePathPrefix = usePathPrefixDecoded
        let replacePathPrefixDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .replacePathPrefix)
        replacePathPrefix = replacePathPrefixDecoded
        let enableHomogenousTablespaceDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableHomogenousTablespace)
        enableHomogenousTablespace = enableHomogenousTablespaceDecoded
        let directPathNoLogDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .directPathNoLog)
        directPathNoLog = directPathNoLogDecoded
        let archivedLogsOnlyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .archivedLogsOnly)
        archivedLogsOnly = archivedLogsOnlyDecoded
        let asmPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .asmPassword)
        asmPassword = asmPasswordDecoded
        let asmServerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .asmServer)
        asmServer = asmServerDecoded
        let asmUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .asmUser)
        asmUser = asmUserDecoded
        let charLengthSemanticsDecoded = try containerValues.decodeIfPresent(CharLengthSemantics.self, forKey: .charLengthSemantics)
        charLengthSemantics = charLengthSemanticsDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let directPathParallelLoadDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .directPathParallelLoad)
        directPathParallelLoad = directPathParallelLoadDecoded
        let failTasksOnLobTruncationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .failTasksOnLobTruncation)
        failTasksOnLobTruncation = failTasksOnLobTruncationDecoded
        let numberDatatypeScaleDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberDatatypeScale)
        numberDatatypeScale = numberDatatypeScaleDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let readTableSpaceNameDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .readTableSpaceName)
        readTableSpaceName = readTableSpaceNameDecoded
        let retryIntervalDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retryInterval)
        retryInterval = retryIntervalDecoded
        let securityDbEncryptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityDbEncryption)
        securityDbEncryption = securityDbEncryptionDecoded
        let securityDbEncryptionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityDbEncryptionName)
        securityDbEncryptionName = securityDbEncryptionNameDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let spatialDataOptionToGeoJsonFunctionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .spatialDataOptionToGeoJsonFunctionName)
        spatialDataOptionToGeoJsonFunctionName = spatialDataOptionToGeoJsonFunctionNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
        let secretsManagerOracleAsmAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerOracleAsmAccessRoleArn)
        secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArnDecoded
        let secretsManagerOracleAsmSecretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerOracleAsmSecretId)
        secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretIdDecoded
    }
}
