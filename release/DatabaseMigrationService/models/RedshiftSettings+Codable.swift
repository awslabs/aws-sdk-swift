// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension RedshiftSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptAnyDate = "AcceptAnyDate"
        case afterConnectScript = "AfterConnectScript"
        case bucketFolder = "BucketFolder"
        case bucketName = "BucketName"
        case caseSensitiveNames = "CaseSensitiveNames"
        case compUpdate = "CompUpdate"
        case connectionTimeout = "ConnectionTimeout"
        case databaseName = "DatabaseName"
        case dateFormat = "DateFormat"
        case emptyAsNull = "EmptyAsNull"
        case encryptionMode = "EncryptionMode"
        case explicitIds = "ExplicitIds"
        case fileTransferUploadStreams = "FileTransferUploadStreams"
        case loadTimeout = "LoadTimeout"
        case maxFileSize = "MaxFileSize"
        case password = "Password"
        case port = "Port"
        case removeQuotes = "RemoveQuotes"
        case replaceChars = "ReplaceChars"
        case replaceInvalidChars = "ReplaceInvalidChars"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case timeFormat = "TimeFormat"
        case trimBlanks = "TrimBlanks"
        case truncateColumns = "TruncateColumns"
        case username = "Username"
        case writeBufferSize = "WriteBufferSize"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptAnyDate = acceptAnyDate {
            try encodeContainer.encode(acceptAnyDate, forKey: .acceptAnyDate)
        }
        if let afterConnectScript = afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let bucketFolder = bucketFolder {
            try encodeContainer.encode(bucketFolder, forKey: .bucketFolder)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let caseSensitiveNames = caseSensitiveNames {
            try encodeContainer.encode(caseSensitiveNames, forKey: .caseSensitiveNames)
        }
        if let compUpdate = compUpdate {
            try encodeContainer.encode(compUpdate, forKey: .compUpdate)
        }
        if let connectionTimeout = connectionTimeout {
            try encodeContainer.encode(connectionTimeout, forKey: .connectionTimeout)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dateFormat = dateFormat {
            try encodeContainer.encode(dateFormat, forKey: .dateFormat)
        }
        if let emptyAsNull = emptyAsNull {
            try encodeContainer.encode(emptyAsNull, forKey: .emptyAsNull)
        }
        if let encryptionMode = encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let explicitIds = explicitIds {
            try encodeContainer.encode(explicitIds, forKey: .explicitIds)
        }
        if let fileTransferUploadStreams = fileTransferUploadStreams {
            try encodeContainer.encode(fileTransferUploadStreams, forKey: .fileTransferUploadStreams)
        }
        if let loadTimeout = loadTimeout {
            try encodeContainer.encode(loadTimeout, forKey: .loadTimeout)
        }
        if let maxFileSize = maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let removeQuotes = removeQuotes {
            try encodeContainer.encode(removeQuotes, forKey: .removeQuotes)
        }
        if let replaceChars = replaceChars {
            try encodeContainer.encode(replaceChars, forKey: .replaceChars)
        }
        if let replaceInvalidChars = replaceInvalidChars {
            try encodeContainer.encode(replaceInvalidChars, forKey: .replaceInvalidChars)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId {
            try encodeContainer.encode(serverSideEncryptionKmsKeyId, forKey: .serverSideEncryptionKmsKeyId)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let timeFormat = timeFormat {
            try encodeContainer.encode(timeFormat, forKey: .timeFormat)
        }
        if let trimBlanks = trimBlanks {
            try encodeContainer.encode(trimBlanks, forKey: .trimBlanks)
        }
        if let truncateColumns = truncateColumns {
            try encodeContainer.encode(truncateColumns, forKey: .truncateColumns)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
        if let writeBufferSize = writeBufferSize {
            try encodeContainer.encode(writeBufferSize, forKey: .writeBufferSize)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptAnyDateDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .acceptAnyDate)
        acceptAnyDate = acceptAnyDateDecoded
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let bucketFolderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketFolder)
        bucketFolder = bucketFolderDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let caseSensitiveNamesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .caseSensitiveNames)
        caseSensitiveNames = caseSensitiveNamesDecoded
        let compUpdateDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .compUpdate)
        compUpdate = compUpdateDecoded
        let connectionTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .connectionTimeout)
        connectionTimeout = connectionTimeoutDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dateFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateFormat)
        dateFormat = dateFormatDecoded
        let emptyAsNullDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .emptyAsNull)
        emptyAsNull = emptyAsNullDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(EncryptionModeValue.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let explicitIdsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .explicitIds)
        explicitIds = explicitIdsDecoded
        let fileTransferUploadStreamsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fileTransferUploadStreams)
        fileTransferUploadStreams = fileTransferUploadStreamsDecoded
        let loadTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .loadTimeout)
        loadTimeout = loadTimeoutDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let removeQuotesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .removeQuotes)
        removeQuotes = removeQuotesDecoded
        let replaceInvalidCharsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replaceInvalidChars)
        replaceInvalidChars = replaceInvalidCharsDecoded
        let replaceCharsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replaceChars)
        replaceChars = replaceCharsDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let serverSideEncryptionKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverSideEncryptionKmsKeyId)
        serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyIdDecoded
        let timeFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeFormat)
        timeFormat = timeFormatDecoded
        let trimBlanksDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .trimBlanks)
        trimBlanks = trimBlanksDecoded
        let truncateColumnsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .truncateColumns)
        truncateColumns = truncateColumnsDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let writeBufferSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .writeBufferSize)
        writeBufferSize = writeBufferSizeDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}
