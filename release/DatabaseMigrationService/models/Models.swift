// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedFault(message: \(String(describing: message)))"}
}

extension AccessDeniedFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS DMS was denied access to the endpoint. Check that the
///             role is correctly configured.</p>
public struct AccessDeniedFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedFaultBody: Equatable {
    public let message: String?
}

extension AccessDeniedFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountQuota: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountQuotaName = "AccountQuotaName"
        case max = "Max"
        case used = "Used"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountQuotaName = accountQuotaName {
            try encodeContainer.encode(accountQuotaName, forKey: .accountQuotaName)
        }
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if used != 0 {
            try encodeContainer.encode(used, forKey: .used)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountQuotaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountQuotaName)
        accountQuotaName = accountQuotaNameDecoded
        let usedDecoded = try containerValues.decode(Int.self, forKey: .used)
        used = usedDecoded
        let maxDecoded = try containerValues.decode(Int.self, forKey: .max)
        max = maxDecoded
    }
}

extension AccountQuota: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountQuota(accountQuotaName: \(String(describing: accountQuotaName)), max: \(String(describing: max)), used: \(String(describing: used)))"}
}

/// <p>Describes a quota for an AWS account, for example, the number of replication instances
///          allowed.</p>
public struct AccountQuota: Equatable {
    /// <p>The name of the AWS DMS quota for this AWS account.</p>
    public let accountQuotaName: String?
    /// <p>The maximum allowed value for the quota.</p>
    public let max: Int
    /// <p>The amount currently used toward the quota maximum.</p>
    public let used: Int

    public init (
        accountQuotaName: String? = nil,
        max: Int = 0,
        used: Int = 0
    )
    {
        self.accountQuotaName = accountQuotaName
        self.max = max
        self.used = used
    }
}

public struct AddTagsToResourceInputBodyMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

extension AddTagsToResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension AddTagsToResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct AddTagsToResourceInputHeadersMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

/// <p>Associates a set of tags with an AWS DMS resource.</p>
public struct AddTagsToResourceInput: Equatable {
    /// <p>Identifies the AWS DMS resource to which tags should be added. The value for this parameter is an Amazon Resource Name (ARN).</p>
    ///          <p>For AWS DMS, you can tag a replication instance, an endpoint, or a replication task.</p>
    public let resourceArn: String?
    /// <p>One or more tags to be assigned to the resource.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct AddTagsToResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension AddTagsToResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToResourceOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToResourceOutputResponse()"}
}

extension AddTagsToResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p></p>
public struct AddTagsToResourceOutputResponse: Equatable {

    public init() {}
}

struct AddTagsToResourceOutputResponseBody: Equatable {
}

extension AddTagsToResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ApplyPendingMaintenanceActionInputBodyMiddleware: Middleware {
    public let id: String = "ApplyPendingMaintenanceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplyPendingMaintenanceActionOutputError>
}

extension ApplyPendingMaintenanceActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplyPendingMaintenanceActionInput(applyAction: \(String(describing: applyAction)), optInType: \(String(describing: optInType)), replicationInstanceArn: \(String(describing: replicationInstanceArn)))"}
}

extension ApplyPendingMaintenanceActionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applyAction = "ApplyAction"
        case optInType = "OptInType"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyAction = applyAction {
            try encodeContainer.encode(applyAction, forKey: .applyAction)
        }
        if let optInType = optInType {
            try encodeContainer.encode(optInType, forKey: .optInType)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct ApplyPendingMaintenanceActionInputHeadersMiddleware: Middleware {
    public let id: String = "ApplyPendingMaintenanceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplyPendingMaintenanceActionOutputError>
}

public struct ApplyPendingMaintenanceActionInputQueryItemMiddleware: Middleware {
    public let id: String = "ApplyPendingMaintenanceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplyPendingMaintenanceActionOutputError>
}

/// <p></p>
public struct ApplyPendingMaintenanceActionInput: Equatable {
    /// <p>The pending maintenance action to apply to this resource.</p>
    public let applyAction: String?
    /// <p>A value that specifies the type of opt-in request, or undoes an opt-in request. You can't undo an
    ///          opt-in request of type <code>immediate</code>.</p>
    ///          <p>Valid values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>immediate</code> - Apply the maintenance action immediately.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>next-maintenance</code> - Apply the maintenance action during the next
    ///                maintenance window for the resource.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>undo-opt-in</code> - Cancel any existing <code>next-maintenance</code> opt-in
    ///                requests.</p>
    ///             </li>
    ///          </ul>
    public let optInType: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS DMS resource that the pending maintenance
    ///          action applies to.</p>
    public let replicationInstanceArn: String?

    public init (
        applyAction: String? = nil,
        optInType: String? = nil,
        replicationInstanceArn: String? = nil
    )
    {
        self.applyAction = applyAction
        self.optInType = optInType
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct ApplyPendingMaintenanceActionInputBody: Equatable {
    public let replicationInstanceArn: String?
    public let applyAction: String?
    public let optInType: String?
}

extension ApplyPendingMaintenanceActionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applyAction = "ApplyAction"
        case optInType = "OptInType"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let applyActionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applyAction)
        applyAction = applyActionDecoded
        let optInTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optInType)
        optInType = optInTypeDecoded
    }
}

extension ApplyPendingMaintenanceActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ApplyPendingMaintenanceActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApplyPendingMaintenanceActionOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplyPendingMaintenanceActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplyPendingMaintenanceActionOutputResponse(resourcePendingMaintenanceActions: \(String(describing: resourcePendingMaintenanceActions)))"}
}

extension ApplyPendingMaintenanceActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApplyPendingMaintenanceActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourcePendingMaintenanceActions = output.resourcePendingMaintenanceActions
        } else {
            self.resourcePendingMaintenanceActions = nil
        }
    }
}

/// <p></p>
public struct ApplyPendingMaintenanceActionOutputResponse: Equatable {
    /// <p>The AWS DMS resource that the pending maintenance action will be applied to.</p>
    public let resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions?

    public init (
        resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions? = nil
    )
    {
        self.resourcePendingMaintenanceActions = resourcePendingMaintenanceActions
    }
}

struct ApplyPendingMaintenanceActionOutputResponseBody: Equatable {
    public let resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions?
}

extension ApplyPendingMaintenanceActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourcePendingMaintenanceActions = "ResourcePendingMaintenanceActions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcePendingMaintenanceActionsDecoded = try containerValues.decodeIfPresent(ResourcePendingMaintenanceActions.self, forKey: .resourcePendingMaintenanceActions)
        resourcePendingMaintenanceActions = resourcePendingMaintenanceActionsDecoded
    }
}

public enum AuthMechanismValue {
    case `default`
    case mongodbCr
    case scramSha1
    case sdkUnknown(String)
}

extension AuthMechanismValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthMechanismValue] {
        return [
            .default,
            .mongodbCr,
            .scramSha1,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .default: return "default"
        case .mongodbCr: return "mongodb_cr"
        case .scramSha1: return "scram_sha_1"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthMechanismValue(rawValue: rawValue) ?? AuthMechanismValue.sdkUnknown(rawValue)
    }
}

public enum AuthTypeValue {
    case no
    case password
    case sdkUnknown(String)
}

extension AuthTypeValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthTypeValue] {
        return [
            .no,
            .password,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .no: return "no"
        case .password: return "password"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthTypeValue(rawValue: rawValue) ?? AuthTypeValue.sdkUnknown(rawValue)
    }
}

extension AvailabilityZone: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AvailabilityZone: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AvailabilityZone(name: \(String(describing: name)))"}
}

/// <p>The name of an Availability Zone for use during database migration.
///             <code>AvailabilityZone</code> is an optional parameter to the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationInstance.html">
///                <code>CreateReplicationInstance</code>
///             </a> operation, and it’s value relates to
///          the AWS Region of an endpoint. For example, the availability zone of an endpoint in the
///          us-east-1 region might be us-east-1a, us-east-1b, us-east-1c, or us-east-1d.</p>
public struct AvailabilityZone: Equatable {
    /// <p>The name of the Availability Zone.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

public struct CancelReplicationTaskAssessmentRunInputBodyMiddleware: Middleware {
    public let id: String = "CancelReplicationTaskAssessmentRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelReplicationTaskAssessmentRunInput>
    public typealias MOutput = OperationOutput<CancelReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelReplicationTaskAssessmentRunOutputError>
}

extension CancelReplicationTaskAssessmentRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelReplicationTaskAssessmentRunInput(replicationTaskAssessmentRunArn: \(String(describing: replicationTaskAssessmentRunArn)))"}
}

extension CancelReplicationTaskAssessmentRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
    }
}

public struct CancelReplicationTaskAssessmentRunInputHeadersMiddleware: Middleware {
    public let id: String = "CancelReplicationTaskAssessmentRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelReplicationTaskAssessmentRunInput>
    public typealias MOutput = OperationOutput<CancelReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelReplicationTaskAssessmentRunOutputError>
}

public struct CancelReplicationTaskAssessmentRunInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelReplicationTaskAssessmentRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelReplicationTaskAssessmentRunInput>
    public typealias MOutput = OperationOutput<CancelReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelReplicationTaskAssessmentRunOutputError>
}

/// <p></p>
public struct CancelReplicationTaskAssessmentRunInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the premigration assessment run to be canceled.</p>
    public let replicationTaskAssessmentRunArn: String?

    public init (
        replicationTaskAssessmentRunArn: String? = nil
    )
    {
        self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
    }
}

struct CancelReplicationTaskAssessmentRunInputBody: Equatable {
    public let replicationTaskAssessmentRunArn: String?
}

extension CancelReplicationTaskAssessmentRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
    }
}

extension CancelReplicationTaskAssessmentRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelReplicationTaskAssessmentRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelReplicationTaskAssessmentRunOutputError: Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelReplicationTaskAssessmentRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelReplicationTaskAssessmentRunOutputResponse(replicationTaskAssessmentRun: \(String(describing: replicationTaskAssessmentRun)))"}
}

extension CancelReplicationTaskAssessmentRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelReplicationTaskAssessmentRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationTaskAssessmentRun = output.replicationTaskAssessmentRun
        } else {
            self.replicationTaskAssessmentRun = nil
        }
    }
}

/// <p></p>
public struct CancelReplicationTaskAssessmentRunOutputResponse: Equatable {
    /// <p>The <code>ReplicationTaskAssessmentRun</code> object for the canceled assessment
    ///          run.</p>
    public let replicationTaskAssessmentRun: ReplicationTaskAssessmentRun?

    public init (
        replicationTaskAssessmentRun: ReplicationTaskAssessmentRun? = nil
    )
    {
        self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
    }
}

struct CancelReplicationTaskAssessmentRunOutputResponseBody: Equatable {
    public let replicationTaskAssessmentRun: ReplicationTaskAssessmentRun?
}

extension CancelReplicationTaskAssessmentRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunDecoded = try containerValues.decodeIfPresent(ReplicationTaskAssessmentRun.self, forKey: .replicationTaskAssessmentRun)
        replicationTaskAssessmentRun = replicationTaskAssessmentRunDecoded
    }
}

extension Certificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case certificateCreationDate = "CertificateCreationDate"
        case certificateIdentifier = "CertificateIdentifier"
        case certificateOwner = "CertificateOwner"
        case certificatePem = "CertificatePem"
        case certificateWallet = "CertificateWallet"
        case keyLength = "KeyLength"
        case signingAlgorithm = "SigningAlgorithm"
        case validFromDate = "ValidFromDate"
        case validToDate = "ValidToDate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateCreationDate = certificateCreationDate {
            try encodeContainer.encode(certificateCreationDate.timeIntervalSince1970, forKey: .certificateCreationDate)
        }
        if let certificateIdentifier = certificateIdentifier {
            try encodeContainer.encode(certificateIdentifier, forKey: .certificateIdentifier)
        }
        if let certificateOwner = certificateOwner {
            try encodeContainer.encode(certificateOwner, forKey: .certificateOwner)
        }
        if let certificatePem = certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let certificateWallet = certificateWallet {
            try encodeContainer.encode(certificateWallet.base64EncodedString(), forKey: .certificateWallet)
        }
        if let keyLength = keyLength {
            try encodeContainer.encode(keyLength, forKey: .keyLength)
        }
        if let signingAlgorithm = signingAlgorithm {
            try encodeContainer.encode(signingAlgorithm, forKey: .signingAlgorithm)
        }
        if let validFromDate = validFromDate {
            try encodeContainer.encode(validFromDate.timeIntervalSince1970, forKey: .validFromDate)
        }
        if let validToDate = validToDate {
            try encodeContainer.encode(validToDate.timeIntervalSince1970, forKey: .validToDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateIdentifier)
        certificateIdentifier = certificateIdentifierDecoded
        let certificateCreationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .certificateCreationDate)
        certificateCreationDate = certificateCreationDateDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let certificateWalletDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .certificateWallet)
        certificateWallet = certificateWalletDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateOwner)
        certificateOwner = certificateOwnerDecoded
        let validFromDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .validFromDate)
        validFromDate = validFromDateDecoded
        let validToDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .validToDate)
        validToDate = validToDateDecoded
        let signingAlgorithmDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingAlgorithm)
        signingAlgorithm = signingAlgorithmDecoded
        let keyLengthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .keyLength)
        keyLength = keyLengthDecoded
    }
}

extension Certificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Certificate(certificateArn: \(String(describing: certificateArn)), certificateCreationDate: \(String(describing: certificateCreationDate)), certificateIdentifier: \(String(describing: certificateIdentifier)), certificateOwner: \(String(describing: certificateOwner)), certificatePem: \(String(describing: certificatePem)), certificateWallet: \(String(describing: certificateWallet)), keyLength: \(String(describing: keyLength)), signingAlgorithm: \(String(describing: signingAlgorithm)), validFromDate: \(String(describing: validFromDate)), validToDate: \(String(describing: validToDate)))"}
}

/// <p>The SSL certificate that can be used to encrypt connections between the endpoints and
///          the replication instance.</p>
public struct Certificate: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the certificate.</p>
    public let certificateArn: String?
    /// <p>The date that the certificate was created.</p>
    public let certificateCreationDate: Date?
    /// <p>A customer-assigned name for the certificate. Identifiers must begin with a letter and
    ///          must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or
    ///          contain two consecutive hyphens.</p>
    public let certificateIdentifier: String?
    /// <p>The owner of the certificate.</p>
    public let certificateOwner: String?
    /// <p>The contents of a <code>.pem</code> file, which contains an X.509 certificate.</p>
    public let certificatePem: String?
    /// <p>The location of an imported Oracle Wallet certificate for use with SSL.</p>
    public let certificateWallet: Data?
    /// <p>The key length of the cryptographic algorithm being used.</p>
    public let keyLength: Int?
    /// <p>The signing algorithm for the certificate.</p>
    public let signingAlgorithm: String?
    /// <p>The beginning date that the certificate is valid.</p>
    public let validFromDate: Date?
    /// <p>The final date that the certificate is valid.</p>
    public let validToDate: Date?

    public init (
        certificateArn: String? = nil,
        certificateCreationDate: Date? = nil,
        certificateIdentifier: String? = nil,
        certificateOwner: String? = nil,
        certificatePem: String? = nil,
        certificateWallet: Data? = nil,
        keyLength: Int? = nil,
        signingAlgorithm: String? = nil,
        validFromDate: Date? = nil,
        validToDate: Date? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateCreationDate = certificateCreationDate
        self.certificateIdentifier = certificateIdentifier
        self.certificateOwner = certificateOwner
        self.certificatePem = certificatePem
        self.certificateWallet = certificateWallet
        self.keyLength = keyLength
        self.signingAlgorithm = signingAlgorithm
        self.validFromDate = validFromDate
        self.validToDate = validToDate
    }
}

public enum CharLengthSemantics {
    case byte
    case char
    case `default`
    case sdkUnknown(String)
}

extension CharLengthSemantics : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CharLengthSemantics] {
        return [
            .byte,
            .char,
            .default,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .byte: return "byte"
        case .char: return "char"
        case .default: return "default"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CharLengthSemantics(rawValue: rawValue) ?? CharLengthSemantics.sdkUnknown(rawValue)
    }
}

public enum CompressionTypeValue {
    case gzip
    case `none`
    case sdkUnknown(String)
}

extension CompressionTypeValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CompressionTypeValue] {
        return [
            .gzip,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .gzip: return "gzip"
        case .none: return "none"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CompressionTypeValue(rawValue: rawValue) ?? CompressionTypeValue.sdkUnknown(rawValue)
    }
}

extension Connection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case lastFailureMessage = "LastFailureMessage"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let endpointIdentifier = endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let lastFailureMessage = lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationInstanceIdentifier = replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
    }
}

extension Connection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Connection(endpointArn: \(String(describing: endpointArn)), endpointIdentifier: \(String(describing: endpointIdentifier)), lastFailureMessage: \(String(describing: lastFailureMessage)), replicationInstanceArn: \(String(describing: replicationInstanceArn)), replicationInstanceIdentifier: \(String(describing: replicationInstanceIdentifier)), status: \(String(describing: status)))"}
}

/// <p>Status of the connection between an endpoint and a replication instance, including
///          Amazon Resource Names (ARNs) and the last error message issued.</p>
public struct Connection: Equatable {
    /// <p>The ARN string that uniquely identifies the endpoint.</p>
    public let endpointArn: String?
    /// <p>The identifier of the endpoint. Identifiers must begin with a letter and must contain only
    ///          ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two
    ///          consecutive hyphens.</p>
    public let endpointIdentifier: String?
    /// <p>The error message when the connection last failed.</p>
    public let lastFailureMessage: String?
    /// <p>The ARN of the replication instance.</p>
    public let replicationInstanceArn: String?
    /// <p>The replication instance identifier. This parameter is stored as a lowercase
    ///          string.</p>
    public let replicationInstanceIdentifier: String?
    /// <p>The connection status. This parameter can return one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>"successful"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"testing"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"failed"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"deleting"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        endpointArn: String? = nil,
        endpointIdentifier: String? = nil,
        lastFailureMessage: String? = nil,
        replicationInstanceArn: String? = nil,
        replicationInstanceIdentifier: String? = nil,
        status: String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.endpointIdentifier = endpointIdentifier
        self.lastFailureMessage = lastFailureMessage
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationInstanceIdentifier = replicationInstanceIdentifier
        self.status = status
    }
}

public struct CreateEndpointInputBodyMiddleware: Middleware {
    public let id: String = "CreateEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEndpointInput>
    public typealias MOutput = OperationOutput<CreateEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEndpointOutputError>
}

extension CreateEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEndpointInput(certificateArn: \(String(describing: certificateArn)), databaseName: \(String(describing: databaseName)), dmsTransferSettings: \(String(describing: dmsTransferSettings)), docDbSettings: \(String(describing: docDbSettings)), dynamoDbSettings: \(String(describing: dynamoDbSettings)), elasticsearchSettings: \(String(describing: elasticsearchSettings)), endpointIdentifier: \(String(describing: endpointIdentifier)), endpointType: \(String(describing: endpointType)), engineName: \(String(describing: engineName)), externalTableDefinition: \(String(describing: externalTableDefinition)), extraConnectionAttributes: \(String(describing: extraConnectionAttributes)), iBMDb2Settings: \(String(describing: iBMDb2Settings)), kafkaSettings: \(String(describing: kafkaSettings)), kinesisSettings: \(String(describing: kinesisSettings)), kmsKeyId: \(String(describing: kmsKeyId)), microsoftSQLServerSettings: \(String(describing: microsoftSQLServerSettings)), mongoDbSettings: \(String(describing: mongoDbSettings)), mySQLSettings: \(String(describing: mySQLSettings)), neptuneSettings: \(String(describing: neptuneSettings)), oracleSettings: \(String(describing: oracleSettings)), password: \(String(describing: password)), port: \(String(describing: port)), postgreSQLSettings: \(String(describing: postgreSQLSettings)), redshiftSettings: \(String(describing: redshiftSettings)), resourceIdentifier: \(String(describing: resourceIdentifier)), s3Settings: \(String(describing: s3Settings)), serverName: \(String(describing: serverName)), serviceAccessRoleArn: \(String(describing: serviceAccessRoleArn)), sslMode: \(String(describing: sslMode)), sybaseSettings: \(String(describing: sybaseSettings)), tags: \(String(describing: tags)), username: \(String(describing: username)))"}
}

extension CreateEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case iBMDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case kmsKeyId = "KmsKeyId"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redshiftSettings = "RedshiftSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case tags = "Tags"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dmsTransferSettings = dmsTransferSettings {
            try encodeContainer.encode(dmsTransferSettings, forKey: .dmsTransferSettings)
        }
        if let docDbSettings = docDbSettings {
            try encodeContainer.encode(docDbSettings, forKey: .docDbSettings)
        }
        if let dynamoDbSettings = dynamoDbSettings {
            try encodeContainer.encode(dynamoDbSettings, forKey: .dynamoDbSettings)
        }
        if let elasticsearchSettings = elasticsearchSettings {
            try encodeContainer.encode(elasticsearchSettings, forKey: .elasticsearchSettings)
        }
        if let endpointIdentifier = endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineName = engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let externalTableDefinition = externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let extraConnectionAttributes = extraConnectionAttributes {
            try encodeContainer.encode(extraConnectionAttributes, forKey: .extraConnectionAttributes)
        }
        if let iBMDb2Settings = iBMDb2Settings {
            try encodeContainer.encode(iBMDb2Settings, forKey: .iBMDb2Settings)
        }
        if let kafkaSettings = kafkaSettings {
            try encodeContainer.encode(kafkaSettings, forKey: .kafkaSettings)
        }
        if let kinesisSettings = kinesisSettings {
            try encodeContainer.encode(kinesisSettings, forKey: .kinesisSettings)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let microsoftSQLServerSettings = microsoftSQLServerSettings {
            try encodeContainer.encode(microsoftSQLServerSettings, forKey: .microsoftSQLServerSettings)
        }
        if let mongoDbSettings = mongoDbSettings {
            try encodeContainer.encode(mongoDbSettings, forKey: .mongoDbSettings)
        }
        if let mySQLSettings = mySQLSettings {
            try encodeContainer.encode(mySQLSettings, forKey: .mySQLSettings)
        }
        if let neptuneSettings = neptuneSettings {
            try encodeContainer.encode(neptuneSettings, forKey: .neptuneSettings)
        }
        if let oracleSettings = oracleSettings {
            try encodeContainer.encode(oracleSettings, forKey: .oracleSettings)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let postgreSQLSettings = postgreSQLSettings {
            try encodeContainer.encode(postgreSQLSettings, forKey: .postgreSQLSettings)
        }
        if let redshiftSettings = redshiftSettings {
            try encodeContainer.encode(redshiftSettings, forKey: .redshiftSettings)
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let s3Settings = s3Settings {
            try encodeContainer.encode(s3Settings, forKey: .s3Settings)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let sslMode = sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
        if let sybaseSettings = sybaseSettings {
            try encodeContainer.encode(sybaseSettings, forKey: .sybaseSettings)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct CreateEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEndpointInput>
    public typealias MOutput = OperationOutput<CreateEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEndpointOutputError>
}

public struct CreateEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEndpointInput>
    public typealias MOutput = OperationOutput<CreateEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEndpointOutputError>
}

/// <p></p>
public struct CreateEndpointInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the certificate.</p>
    public let certificateArn: String?
    /// <p>The name of the endpoint database.</p>
    public let databaseName: String?
    /// <p>The settings in JSON format for the DMS transfer type of source endpoint. </p>
    ///          <p>Possible settings include the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ServiceAccessRoleArn</code> - The IAM role that has permission to access the
    ///                Amazon S3 bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BucketName</code> - The name of the S3 bucket to use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CompressionType</code> - An optional parameter to use GZIP to compress the
    ///                target files. To use GZIP, set this value to <code>NONE</code> (the default). To keep
    ///                the files uncompressed, don't use this value.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Shorthand syntax for these settings is as follows:
    ///             <code>ServiceAccessRoleArn=string,BucketName=string,CompressionType=string</code>
    ///          </p>
    ///          <p>JSON syntax for these settings is as follows: <code>{ "ServiceAccessRoleArn":
    ///             "string", "BucketName": "string", "CompressionType": "none"|"gzip" } </code>
    ///          </p>
    public let dmsTransferSettings: DmsTransferSettings?
    /// <p>Provides information that defines a DocumentDB endpoint.</p>
    public let docDbSettings: DocDbSettings?
    /// <p>Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other
    ///             available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.DynamoDB.html">Using Object Mapping to Migrate
    ///             Data to DynamoDB</a> in the <i>AWS Database Migration Service User
    ///             Guide.</i>
    ///          </p>
    public let dynamoDbSettings: DynamoDbSettings?
    /// <p>Settings in JSON format for the target Elasticsearch endpoint. For more information
    ///          about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Elasticsearch.html#CHAP_Target.Elasticsearch.Configuration">Extra Connection Attributes When Using Elasticsearch as a Target for AWS DMS</a> in
    ///          the <i>AWS Database Migration Service User Guide</i>.</p>
    public let elasticsearchSettings: ElasticsearchSettings?
    /// <p>The database endpoint identifier. Identifiers must begin with a letter and must contain
    ///          only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two
    ///          consecutive hyphens.</p>
    public let endpointIdentifier: String?
    /// <p>The type of endpoint.  Valid values are <code>source</code> and <code>target</code>.</p>
    public let endpointType: ReplicationEndpointTypeValue?
    /// <p>The type of engine for the endpoint. Valid values, depending on the
    ///          <code>EndpointType</code> value, include <code>"mysql"</code>, <code>"oracle"</code>,
    ///          <code>"postgres"</code>, <code>"mariadb"</code>, <code>"aurora"</code>,
    ///          <code>"aurora-postgresql"</code>, <code>"redshift"</code>, <code>"s3"</code>,
    ///          <code>"db2"</code>, <code>"azuredb"</code>, <code>"sybase"</code>, <code>"dynamodb"</code>, <code>"mongodb"</code>,
    ///          <code>"kinesis"</code>, <code>"kafka"</code>, <code>"elasticsearch"</code>, <code>"docdb"</code>,
    ///          <code>"sqlserver"</code>, and <code>"neptune"</code>.</p>
    public let engineName: String?
    /// <p>The external table definition. </p>
    public let externalTableDefinition: String?
    /// <p>Additional attributes associated with the connection. Each attribute is specified as a
    ///          name-value pair associated by an equal sign (=). Multiple attributes are separated by a
    ///          semicolon (;) with no additional white space. For information on the attributes available
    ///          for connecting your source or target endpoint, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Endpoints.html">Working with
    ///             AWS DMS Endpoints</a> in the <i>AWS Database Migration Service User
    ///             Guide.</i>
    ///          </p>
    public let extraConnectionAttributes: String?
    /// <p>Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other
    ///          available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DB2.html">Extra connection attributes
    ///             when using Db2 LUW as a source for AWS DMS</a> in the <i>AWS Database
    ///             Migration Service User Guide.</i>
    ///          </p>
    public let iBMDb2Settings: IBMDb2Settings?
    /// <p>Settings in JSON format for the target Apache Kafka endpoint. For more information about
    ///          the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html">Using Apache Kafka as a Target for
    ///             AWS Database Migration Service</a> in the <i>AWS Database Migration Service User
    ///             Guide.</i>
    ///          </p>
    public let kafkaSettings: KafkaSettings?
    /// <p>Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For
    ///          more information about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kinesis.html">Using Amazon Kinesis Data Streams
    ///             as a Target for AWS Database Migration Service</a> in the <i>AWS Database Migration Service User
    ///             Guide.</i>
    ///          </p>
    public let kinesisSettings: KinesisSettings?
    /// <p>An AWS KMS key identifier that is used to encrypt the connection parameters for the endpoint.</p>
    ///          <p>If you don't specify a value for the <code>KmsKeyId</code> parameter, then
    ///            AWS DMS uses your default encryption key.</p>
    ///          <p>AWS KMS creates the default encryption key for your AWS account. Your AWS account has a
    ///          different default encryption key for each AWS Region.</p>
    public let kmsKeyId: String?
    /// <p>Settings in JSON format for the source and target Microsoft SQL Server endpoint. For
    ///          information about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SQLServer.html">Extra connection
    ///             attributes when using SQL Server as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SQLServer.html">
    ///             Extra connection attributes when using SQL Server as a target for AWS DMS</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let microsoftSQLServerSettings: MicrosoftSQLServerSettings?
    /// <p>Settings in JSON format for the source MongoDB endpoint. For more information about the
    ///          available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MongoDB.html#CHAP_Source.MongoDB.Configuration">Using MongoDB as a Target for AWS Database Migration Service</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let mongoDbSettings: MongoDbSettings?
    /// <p>Settings in JSON format for the source and target MySQL endpoint. For information about
    ///          other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MySQL.html">Extra connection attributes
    ///             when using MySQL as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.MySQL.html">Extra connection attributes when using a MySQL-compatible database as a target for AWS DMS</a> in
    ///          the <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let mySQLSettings: MySQLSettings?
    /// <p>Settings in JSON format for the target Amazon Neptune endpoint.
    ///          For more information
    ///          about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.EndpointSettings">Specifying Endpoint Settings for Amazon Neptune as a Target</a>
    ///             in the <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let neptuneSettings: NeptuneSettings?
    /// <p>Settings in JSON format for the source and target Oracle endpoint. For information about
    ///          other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html">Extra connection attributes
    ///             when using Oracle as a source for AWS DMS</a> and
    ///             <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Oracle.html">
    ///             Extra connection attributes when using Oracle as a target for AWS DMS</a>
    ///             in the <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let oracleSettings: OracleSettings?
    /// <p>The password to be used to log in to the endpoint database.</p>
    public let password: String?
    /// <p>The port used by the endpoint database.</p>
    public let port: Int?
    /// <p>Settings in JSON format for the source and target PostgreSQL endpoint. For information
    ///          about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html">Extra connection
    ///             attributes when using PostgreSQL as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.PostgreSQL.html">
    ///                Extra connection attributes when using PostgreSQL as a target for AWS DMS</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let postgreSQLSettings: PostgreSQLSettings?
    /// <p>Provides information that defines an Amazon Redshift endpoint.</p>
    public let redshiftSettings: RedshiftSettings?
    /// <p>A friendly name for the resource identifier at the end of the <code>EndpointArn</code>
    ///          response parameter that is returned in the created <code>Endpoint</code> object. The value
    ///          for this parameter can have up to 31 characters. It can contain only ASCII letters, digits,
    ///          and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens,
    ///          and can only begin with a letter, such as <code>Example-App-ARN1</code>. For example, this
    ///          value might result in the <code>EndpointArn</code> value
    ///             <code>arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1</code>. If you don't
    ///          specify a <code>ResourceIdentifier</code> value, AWS DMS generates a default identifier
    ///          value for the end of <code>EndpointArn</code>.</p>
    public let resourceIdentifier: String?
    /// <p>Settings in JSON format for the target Amazon S3 endpoint. For more information about
    ///          the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring">Extra
    ///             Connection Attributes When Using Amazon S3 as a Target for AWS DMS</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let s3Settings: S3Settings?
    /// <p>The name of the server where the endpoint database resides.</p>
    public let serverName: String?
    /// <p> The Amazon Resource Name (ARN) for the service access role that you want to use to
    ///          create the endpoint. </p>
    public let serviceAccessRoleArn: String?
    /// <p>The Secure Sockets Layer (SSL) mode to use for the SSL connection. The default is <code>none</code>
    ///          </p>
    public let sslMode: DmsSslModeValue?
    /// <p>Settings in JSON format for the source and target SAP ASE endpoint. For information
    ///          about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SAP.html">Extra connection attributes
    ///             when using SAP ASE as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SAP.html">Extra connection attributes
    ///             when using SAP ASE as a target for AWS DMS</a> in the <i>AWS Database
    ///             Migration Service User Guide.</i>
    ///          </p>
    public let sybaseSettings: SybaseSettings?
    /// <p>One or more tags to be assigned to the endpoint.</p>
    public let tags: [Tag]?
    /// <p>The user name to be used to log in to the endpoint database.</p>
    public let username: String?

    public init (
        certificateArn: String? = nil,
        databaseName: String? = nil,
        dmsTransferSettings: DmsTransferSettings? = nil,
        docDbSettings: DocDbSettings? = nil,
        dynamoDbSettings: DynamoDbSettings? = nil,
        elasticsearchSettings: ElasticsearchSettings? = nil,
        endpointIdentifier: String? = nil,
        endpointType: ReplicationEndpointTypeValue? = nil,
        engineName: String? = nil,
        externalTableDefinition: String? = nil,
        extraConnectionAttributes: String? = nil,
        iBMDb2Settings: IBMDb2Settings? = nil,
        kafkaSettings: KafkaSettings? = nil,
        kinesisSettings: KinesisSettings? = nil,
        kmsKeyId: String? = nil,
        microsoftSQLServerSettings: MicrosoftSQLServerSettings? = nil,
        mongoDbSettings: MongoDbSettings? = nil,
        mySQLSettings: MySQLSettings? = nil,
        neptuneSettings: NeptuneSettings? = nil,
        oracleSettings: OracleSettings? = nil,
        password: String? = nil,
        port: Int? = nil,
        postgreSQLSettings: PostgreSQLSettings? = nil,
        redshiftSettings: RedshiftSettings? = nil,
        resourceIdentifier: String? = nil,
        s3Settings: S3Settings? = nil,
        serverName: String? = nil,
        serviceAccessRoleArn: String? = nil,
        sslMode: DmsSslModeValue? = nil,
        sybaseSettings: SybaseSettings? = nil,
        tags: [Tag]? = nil,
        username: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.databaseName = databaseName
        self.dmsTransferSettings = dmsTransferSettings
        self.docDbSettings = docDbSettings
        self.dynamoDbSettings = dynamoDbSettings
        self.elasticsearchSettings = elasticsearchSettings
        self.endpointIdentifier = endpointIdentifier
        self.endpointType = endpointType
        self.engineName = engineName
        self.externalTableDefinition = externalTableDefinition
        self.extraConnectionAttributes = extraConnectionAttributes
        self.iBMDb2Settings = iBMDb2Settings
        self.kafkaSettings = kafkaSettings
        self.kinesisSettings = kinesisSettings
        self.kmsKeyId = kmsKeyId
        self.microsoftSQLServerSettings = microsoftSQLServerSettings
        self.mongoDbSettings = mongoDbSettings
        self.mySQLSettings = mySQLSettings
        self.neptuneSettings = neptuneSettings
        self.oracleSettings = oracleSettings
        self.password = password
        self.port = port
        self.postgreSQLSettings = postgreSQLSettings
        self.redshiftSettings = redshiftSettings
        self.resourceIdentifier = resourceIdentifier
        self.s3Settings = s3Settings
        self.serverName = serverName
        self.serviceAccessRoleArn = serviceAccessRoleArn
        self.sslMode = sslMode
        self.sybaseSettings = sybaseSettings
        self.tags = tags
        self.username = username
    }
}

struct CreateEndpointInputBody: Equatable {
    public let endpointIdentifier: String?
    public let endpointType: ReplicationEndpointTypeValue?
    public let engineName: String?
    public let username: String?
    public let password: String?
    public let serverName: String?
    public let port: Int?
    public let databaseName: String?
    public let extraConnectionAttributes: String?
    public let kmsKeyId: String?
    public let tags: [Tag]?
    public let certificateArn: String?
    public let sslMode: DmsSslModeValue?
    public let serviceAccessRoleArn: String?
    public let externalTableDefinition: String?
    public let dynamoDbSettings: DynamoDbSettings?
    public let s3Settings: S3Settings?
    public let dmsTransferSettings: DmsTransferSettings?
    public let mongoDbSettings: MongoDbSettings?
    public let kinesisSettings: KinesisSettings?
    public let kafkaSettings: KafkaSettings?
    public let elasticsearchSettings: ElasticsearchSettings?
    public let neptuneSettings: NeptuneSettings?
    public let redshiftSettings: RedshiftSettings?
    public let postgreSQLSettings: PostgreSQLSettings?
    public let mySQLSettings: MySQLSettings?
    public let oracleSettings: OracleSettings?
    public let sybaseSettings: SybaseSettings?
    public let microsoftSQLServerSettings: MicrosoftSQLServerSettings?
    public let iBMDb2Settings: IBMDb2Settings?
    public let resourceIdentifier: String?
    public let docDbSettings: DocDbSettings?
}

extension CreateEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case iBMDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case kmsKeyId = "KmsKeyId"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redshiftSettings = "RedshiftSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case tags = "Tags"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let extraConnectionAttributesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extraConnectionAttributes)
        extraConnectionAttributes = extraConnectionAttributesDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let dynamoDbSettingsDecoded = try containerValues.decodeIfPresent(DynamoDbSettings.self, forKey: .dynamoDbSettings)
        dynamoDbSettings = dynamoDbSettingsDecoded
        let s3SettingsDecoded = try containerValues.decodeIfPresent(S3Settings.self, forKey: .s3Settings)
        s3Settings = s3SettingsDecoded
        let dmsTransferSettingsDecoded = try containerValues.decodeIfPresent(DmsTransferSettings.self, forKey: .dmsTransferSettings)
        dmsTransferSettings = dmsTransferSettingsDecoded
        let mongoDbSettingsDecoded = try containerValues.decodeIfPresent(MongoDbSettings.self, forKey: .mongoDbSettings)
        mongoDbSettings = mongoDbSettingsDecoded
        let kinesisSettingsDecoded = try containerValues.decodeIfPresent(KinesisSettings.self, forKey: .kinesisSettings)
        kinesisSettings = kinesisSettingsDecoded
        let kafkaSettingsDecoded = try containerValues.decodeIfPresent(KafkaSettings.self, forKey: .kafkaSettings)
        kafkaSettings = kafkaSettingsDecoded
        let elasticsearchSettingsDecoded = try containerValues.decodeIfPresent(ElasticsearchSettings.self, forKey: .elasticsearchSettings)
        elasticsearchSettings = elasticsearchSettingsDecoded
        let neptuneSettingsDecoded = try containerValues.decodeIfPresent(NeptuneSettings.self, forKey: .neptuneSettings)
        neptuneSettings = neptuneSettingsDecoded
        let redshiftSettingsDecoded = try containerValues.decodeIfPresent(RedshiftSettings.self, forKey: .redshiftSettings)
        redshiftSettings = redshiftSettingsDecoded
        let postgreSQLSettingsDecoded = try containerValues.decodeIfPresent(PostgreSQLSettings.self, forKey: .postgreSQLSettings)
        postgreSQLSettings = postgreSQLSettingsDecoded
        let mySQLSettingsDecoded = try containerValues.decodeIfPresent(MySQLSettings.self, forKey: .mySQLSettings)
        mySQLSettings = mySQLSettingsDecoded
        let oracleSettingsDecoded = try containerValues.decodeIfPresent(OracleSettings.self, forKey: .oracleSettings)
        oracleSettings = oracleSettingsDecoded
        let sybaseSettingsDecoded = try containerValues.decodeIfPresent(SybaseSettings.self, forKey: .sybaseSettings)
        sybaseSettings = sybaseSettingsDecoded
        let microsoftSQLServerSettingsDecoded = try containerValues.decodeIfPresent(MicrosoftSQLServerSettings.self, forKey: .microsoftSQLServerSettings)
        microsoftSQLServerSettings = microsoftSQLServerSettingsDecoded
        let iBMDb2SettingsDecoded = try containerValues.decodeIfPresent(IBMDb2Settings.self, forKey: .iBMDb2Settings)
        iBMDb2Settings = iBMDb2SettingsDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let docDbSettingsDecoded = try containerValues.decodeIfPresent(DocDbSettings.self, forKey: .docDbSettings)
        docDbSettings = docDbSettingsDecoded
    }
}

extension CreateEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3AccessDeniedFault" : self = .s3AccessDeniedFault(try S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEndpointOutputError: Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case s3AccessDeniedFault(S3AccessDeniedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEndpointOutputResponse(endpoint: \(String(describing: endpoint)))"}
}

extension CreateEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

/// <p></p>
public struct CreateEndpointOutputResponse: Equatable {
    /// <p>The endpoint that was created.</p>
    public let endpoint: Endpoint?

    public init (
        endpoint: Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct CreateEndpointOutputResponseBody: Equatable {
    public let endpoint: Endpoint?
}

extension CreateEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpoint = "Endpoint"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

public struct CreateEventSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "CreateEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventSubscriptionOutputError>
}

extension CreateEventSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventSubscriptionInput(enabled: \(String(describing: enabled)), eventCategories: \(String(describing: eventCategories)), snsTopicArn: \(String(describing: snsTopicArn)), sourceIds: \(String(describing: sourceIds)), sourceType: \(String(describing: sourceType)), subscriptionName: \(String(describing: subscriptionName)), tags: \(String(describing: tags)))"}
}

extension CreateEventSubscriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceIds = "SourceIds"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for eventcategorieslist0 in eventCategories {
                try eventCategoriesContainer.encode(eventcategorieslist0)
            }
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sourceIds = sourceIds {
            var sourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceIds)
            for sourceidslist0 in sourceIds {
                try sourceIdsContainer.encode(sourceidslist0)
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let subscriptionName = subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateEventSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventSubscriptionOutputError>
}

public struct CreateEventSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventSubscriptionOutputError>
}

/// <p></p>
public struct CreateEventSubscriptionInput: Equatable {
    /// <p> A Boolean value; set to <code>true</code> to activate the subscription, or set to
    ///             <code>false</code> to create the subscription but not activate it. </p>
    public let enabled: Bool?
    /// <p>A list of event categories for a source type that you want to subscribe to. For more
    ///            information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Events.html">Working with Events and
    ///                Notifications</a> in the <i>AWS Database Migration Service User
    ///                    Guide.</i>
    ///          </p>
    public let eventCategories: [String]?
    /// <p> The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification.
    ///          The ARN is created by Amazon SNS when you create a topic and subscribe to it. </p>
    public let snsTopicArn: String?
    /// <p>A list of identifiers for which AWS DMS provides notification events.</p>
    ///          <p>If you don't specify a value, notifications are provided for all sources.</p>
    ///         <p>If you specify multiple values, they must be of the same type. For example, if you
    ///             specify a database instance ID, then all of the other values must be database instance
    ///             IDs.</p>
    public let sourceIds: [String]?
    /// <p> The type of AWS DMS resource that generates the events. For example, if you want to be
    ///          notified of events generated by a replication instance, you set this parameter to
    ///             <code>replication-instance</code>. If this value isn't specified, all events are
    ///          returned. </p>
    ///          <p>Valid values: <code>replication-instance</code> | <code>replication-task</code>
    ///          </p>
    public let sourceType: String?
    /// <p>The name of the AWS DMS event notification subscription. This name must be less than 255 characters.</p>
    public let subscriptionName: String?
    /// <p>One or more tags to be assigned to the event subscription.</p>
    public let tags: [Tag]?

    public init (
        enabled: Bool? = nil,
        eventCategories: [String]? = nil,
        snsTopicArn: String? = nil,
        sourceIds: [String]? = nil,
        sourceType: String? = nil,
        subscriptionName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceIds = sourceIds
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
        self.tags = tags
    }
}

struct CreateEventSubscriptionInputBody: Equatable {
    public let subscriptionName: String?
    public let snsTopicArn: String?
    public let sourceType: String?
    public let eventCategories: [String]?
    public let sourceIds: [String]?
    public let enabled: Bool?
    public let tags: [Tag]?
}

extension CreateEventSubscriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceIds = "SourceIds"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let sourceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sourceIds)
        var sourceIdsDecoded0:[String]? = nil
        if let sourceIdsContainer = sourceIdsContainer {
            sourceIdsDecoded0 = [String]()
            for string0 in sourceIdsContainer {
                if let string0 = string0 {
                    sourceIdsDecoded0?.append(string0)
                }
            }
        }
        sourceIds = sourceIdsDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEventSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEventSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "KMSAccessDeniedFault" : self = .kMSAccessDeniedFault(try KMSAccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledFault" : self = .kMSDisabledFault(try KMSDisabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateFault" : self = .kMSInvalidStateFault(try KMSInvalidStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundFault" : self = .kMSNotFoundFault(try KMSNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingFault" : self = .kMSThrottlingFault(try KMSThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventSubscriptionOutputError: Equatable {
    case kMSAccessDeniedFault(KMSAccessDeniedFault)
    case kMSDisabledFault(KMSDisabledFault)
    case kMSInvalidStateFault(KMSInvalidStateFault)
    case kMSNotFoundFault(KMSNotFoundFault)
    case kMSThrottlingFault(KMSThrottlingFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventSubscriptionOutputResponse(eventSubscription: \(String(describing: eventSubscription)))"}
}

extension CreateEventSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

/// <p></p>
public struct CreateEventSubscriptionOutputResponse: Equatable {
    /// <p>The event subscription that was created.</p>
    public let eventSubscription: EventSubscription?

    public init (
        eventSubscription: EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct CreateEventSubscriptionOutputResponseBody: Equatable {
    public let eventSubscription: EventSubscription?
}

extension CreateEventSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct CreateReplicationInstanceInputBodyMiddleware: Middleware {
    public let id: String = "CreateReplicationInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationInstanceInput>
    public typealias MOutput = OperationOutput<CreateReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationInstanceOutputError>
}

extension CreateReplicationInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReplicationInstanceInput(allocatedStorage: \(String(describing: allocatedStorage)), autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), availabilityZone: \(String(describing: availabilityZone)), dnsNameServers: \(String(describing: dnsNameServers)), engineVersion: \(String(describing: engineVersion)), kmsKeyId: \(String(describing: kmsKeyId)), multiAZ: \(String(describing: multiAZ)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), publiclyAccessible: \(String(describing: publiclyAccessible)), replicationInstanceClass: \(String(describing: replicationInstanceClass)), replicationInstanceIdentifier: \(String(describing: replicationInstanceIdentifier)), replicationSubnetGroupIdentifier: \(String(describing: replicationSubnetGroupIdentifier)), resourceIdentifier: \(String(describing: resourceIdentifier)), tags: \(String(describing: tags)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension CreateReplicationInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case dnsNameServers = "DnsNameServers"
        case engineVersion = "EngineVersion"
        case kmsKeyId = "KmsKeyId"
        case multiAZ = "MultiAZ"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case resourceIdentifier = "ResourceIdentifier"
        case tags = "Tags"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedStorage = allocatedStorage {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let dnsNameServers = dnsNameServers {
            try encodeContainer.encode(dnsNameServers, forKey: .dnsNameServers)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let multiAZ = multiAZ {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let publiclyAccessible = publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let replicationInstanceClass = replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let replicationInstanceIdentifier = replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for vpcsecuritygroupidlist0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(vpcsecuritygroupidlist0)
            }
        }
    }
}

public struct CreateReplicationInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateReplicationInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationInstanceInput>
    public typealias MOutput = OperationOutput<CreateReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationInstanceOutputError>
}

public struct CreateReplicationInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateReplicationInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationInstanceInput>
    public typealias MOutput = OperationOutput<CreateReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationInstanceOutputError>
}

/// <p></p>
public struct CreateReplicationInstanceInput: Equatable {
    /// <p>The amount of storage (in gigabytes) to be initially allocated for the replication
    ///          instance.</p>
    public let allocatedStorage: Int?
    /// <p>A value that indicates whether minor engine upgrades are applied automatically to the
    ///          replication instance during the maintenance window. This parameter defaults to
    ///             <code>true</code>.</p>
    ///          <p>Default: <code>true</code>
    ///          </p>
    public let autoMinorVersionUpgrade: Bool?
    /// <p>The Availability Zone where the replication instance will be created. The default
    ///          value is a random, system-chosen Availability Zone in the endpoint's AWS Region, for
    ///          example: <code>us-east-1d</code>
    ///          </p>
    public let availabilityZone: String?
    /// <p>A list of custom DNS name servers supported for the replication instance to access your
    ///          on-premise source or target database. This list overrides the default name servers
    ///          supported by the replication instance. You can specify a comma-separated list of internet
    ///          addresses for up to four on-premise DNS name servers. For example:
    ///             <code>"1.1.1.1,2.2.2.2,3.3.3.3,4.4.4.4"</code>
    ///          </p>
    public let dnsNameServers: String?
    /// <p>The engine version number of the replication instance.</p>
    ///          <p>If an engine version number is not specified when a replication
    ///          instance is created, the default is the latest engine version available.</p>
    public let engineVersion: String?
    /// <p>An AWS KMS key identifier that is used to encrypt the data on the replication
    ///            instance.</p>
    ///          <p>If you don't specify a value for the <code>KmsKeyId</code> parameter, then
    ///            AWS DMS uses your default encryption key.</p>
    ///          <p>AWS KMS creates the default encryption key for your AWS account. Your AWS account has a
    ///          different default encryption key for each AWS Region.</p>
    public let kmsKeyId: String?
    /// <p> Specifies whether the replication instance is a Multi-AZ deployment. You can't set the
    ///             <code>AvailabilityZone</code> parameter if the Multi-AZ parameter is set to
    ///             <code>true</code>. </p>
    public let multiAZ: Bool?
    /// <p>The weekly time range during which system maintenance can occur, in Universal
    ///          Coordinated Time (UTC).</p>
    ///          <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///          </p>
    ///          <p>Default: A 30-minute window selected at random from an 8-hour block of time per AWS
    ///          Region, occurring on a random day of the week.</p>
    ///          <p>Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun</p>
    ///          <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: String?
    /// <p> Specifies the accessibility options for the replication instance. A value of
    ///             <code>true</code> represents an instance with a public IP address. A value of
    ///             <code>false</code> represents an instance with a private IP address. The default value
    ///          is <code>true</code>. </p>
    public let publiclyAccessible: Bool?
    /// <p>The compute and memory capacity of the replication instance as defined for the specified
    ///          replication instance class. For example to specify the instance class dms.c4.large, set this parameter to <code>"dms.c4.large"</code>.</p>
    ///          <p>For more information on the settings and capacities for the available replication instance classes, see
    ///          <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth">
    ///             Selecting the right AWS DMS replication instance for your migration</a>.
    ///       </p>
    public let replicationInstanceClass: String?
    /// <p>The replication instance identifier. This parameter is stored as a lowercase
    ///          string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain 1-63 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>myrepinstance</code>
    ///          </p>
    public let replicationInstanceIdentifier: String?
    /// <p>A subnet group to associate with the replication instance.</p>
    public let replicationSubnetGroupIdentifier: String?
    /// <p>A friendly name for the resource identifier at the end of the <code>EndpointArn</code>
    ///          response parameter that is returned in the created <code>Endpoint</code> object. The value
    ///          for this parameter can have up to 31 characters. It can contain only ASCII letters, digits,
    ///          and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens,
    ///          and can only begin with a letter, such as <code>Example-App-ARN1</code>. For example, this
    ///          value might result in the <code>EndpointArn</code> value
    ///          <code>arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1</code>. If you don't
    ///          specify a <code>ResourceIdentifier</code> value, AWS DMS generates a default identifier
    ///          value for the end of <code>EndpointArn</code>.</p>
    public let resourceIdentifier: String?
    /// <p>One or more tags to be assigned to the replication instance.</p>
    public let tags: [Tag]?
    /// <p> Specifies the VPC security group to be used with the replication instance. The VPC
    ///          security group must work with the VPC containing the replication instance. </p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        allocatedStorage: Int? = nil,
        autoMinorVersionUpgrade: Bool? = nil,
        availabilityZone: String? = nil,
        dnsNameServers: String? = nil,
        engineVersion: String? = nil,
        kmsKeyId: String? = nil,
        multiAZ: Bool? = nil,
        preferredMaintenanceWindow: String? = nil,
        publiclyAccessible: Bool? = nil,
        replicationInstanceClass: String? = nil,
        replicationInstanceIdentifier: String? = nil,
        replicationSubnetGroupIdentifier: String? = nil,
        resourceIdentifier: String? = nil,
        tags: [Tag]? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.dnsNameServers = dnsNameServers
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.multiAZ = multiAZ
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.replicationInstanceClass = replicationInstanceClass
        self.replicationInstanceIdentifier = replicationInstanceIdentifier
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.resourceIdentifier = resourceIdentifier
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct CreateReplicationInstanceInputBody: Equatable {
    public let replicationInstanceIdentifier: String?
    public let allocatedStorage: Int?
    public let replicationInstanceClass: String?
    public let vpcSecurityGroupIds: [String]?
    public let availabilityZone: String?
    public let replicationSubnetGroupIdentifier: String?
    public let preferredMaintenanceWindow: String?
    public let multiAZ: Bool?
    public let engineVersion: String?
    public let autoMinorVersionUpgrade: Bool?
    public let tags: [Tag]?
    public let kmsKeyId: String?
    public let publiclyAccessible: Bool?
    public let dnsNameServers: String?
    public let resourceIdentifier: String?
}

extension CreateReplicationInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case dnsNameServers = "DnsNameServers"
        case engineVersion = "EngineVersion"
        case kmsKeyId = "KmsKeyId"
        case multiAZ = "MultiAZ"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case resourceIdentifier = "ResourceIdentifier"
        case tags = "Tags"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let dnsNameServersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dnsNameServers)
        dnsNameServers = dnsNameServersDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
    }
}

extension CreateReplicationInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientResourceCapacityFault" : self = .insufficientResourceCapacityFault(try InsufficientResourceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplicationSubnetGroupDoesNotCoverEnoughAZs" : self = .replicationSubnetGroupDoesNotCoverEnoughAZs(try ReplicationSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReplicationInstanceOutputError: Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case insufficientResourceCapacityFault(InsufficientResourceCapacityFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case invalidSubnet(InvalidSubnet)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case replicationSubnetGroupDoesNotCoverEnoughAZs(ReplicationSubnetGroupDoesNotCoverEnoughAZs)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReplicationInstanceOutputResponse(replicationInstance: \(String(describing: replicationInstance)))"}
}

extension CreateReplicationInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateReplicationInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

/// <p></p>
public struct CreateReplicationInstanceOutputResponse: Equatable {
    /// <p>The replication instance that was created.</p>
    public let replicationInstance: ReplicationInstance?

    public init (
        replicationInstance: ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct CreateReplicationInstanceOutputResponseBody: Equatable {
    public let replicationInstance: ReplicationInstance?
}

extension CreateReplicationInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

public struct CreateReplicationSubnetGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateReplicationSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationSubnetGroupInput>
    public typealias MOutput = OperationOutput<CreateReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationSubnetGroupOutputError>
}

extension CreateReplicationSubnetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReplicationSubnetGroupInput(replicationSubnetGroupDescription: \(String(describing: replicationSubnetGroupDescription)), replicationSubnetGroupIdentifier: \(String(describing: replicationSubnetGroupIdentifier)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)))"}
}

extension CreateReplicationSubnetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupDescription = replicationSubnetGroupDescription {
            try encodeContainer.encode(replicationSubnetGroupDescription, forKey: .replicationSubnetGroupDescription)
        }
        if let replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidentifierlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidentifierlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateReplicationSubnetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateReplicationSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationSubnetGroupInput>
    public typealias MOutput = OperationOutput<CreateReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationSubnetGroupOutputError>
}

public struct CreateReplicationSubnetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateReplicationSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationSubnetGroupInput>
    public typealias MOutput = OperationOutput<CreateReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationSubnetGroupOutputError>
}

/// <p></p>
public struct CreateReplicationSubnetGroupInput: Equatable {
    /// <p>The description for the subnet group.</p>
    public let replicationSubnetGroupDescription: String?
    /// <p>The name for the replication subnet group. This value is stored as a lowercase
    ///          string.</p>
    ///          <p>Constraints: Must contain no more than 255 alphanumeric characters, periods, spaces,
    ///          underscores, or hyphens. Must not be "default".</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let replicationSubnetGroupIdentifier: String?
    /// <p>One or more subnet IDs to be assigned to the subnet group.</p>
    public let subnetIds: [String]?
    /// <p>One or more tags to be assigned to the subnet group.</p>
    public let tags: [Tag]?

    public init (
        replicationSubnetGroupDescription: String? = nil,
        replicationSubnetGroupIdentifier: String? = nil,
        subnetIds: [String]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

struct CreateReplicationSubnetGroupInputBody: Equatable {
    public let replicationSubnetGroupIdentifier: String?
    public let replicationSubnetGroupDescription: String?
    public let subnetIds: [String]?
    public let tags: [Tag]?
}

extension CreateReplicationSubnetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let replicationSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationSubnetGroupDescription)
        replicationSubnetGroupDescription = replicationSubnetGroupDescriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReplicationSubnetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationSubnetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplicationSubnetGroupDoesNotCoverEnoughAZs" : self = .replicationSubnetGroupDoesNotCoverEnoughAZs(try ReplicationSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReplicationSubnetGroupOutputError: Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidSubnet(InvalidSubnet)
    case replicationSubnetGroupDoesNotCoverEnoughAZs(ReplicationSubnetGroupDoesNotCoverEnoughAZs)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationSubnetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReplicationSubnetGroupOutputResponse(replicationSubnetGroup: \(String(describing: replicationSubnetGroup)))"}
}

extension CreateReplicationSubnetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateReplicationSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationSubnetGroup = output.replicationSubnetGroup
        } else {
            self.replicationSubnetGroup = nil
        }
    }
}

/// <p></p>
public struct CreateReplicationSubnetGroupOutputResponse: Equatable {
    /// <p>The replication subnet group that was created.</p>
    public let replicationSubnetGroup: ReplicationSubnetGroup?

    public init (
        replicationSubnetGroup: ReplicationSubnetGroup? = nil
    )
    {
        self.replicationSubnetGroup = replicationSubnetGroup
    }
}

struct CreateReplicationSubnetGroupOutputResponseBody: Equatable {
    public let replicationSubnetGroup: ReplicationSubnetGroup?
}

extension CreateReplicationSubnetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationSubnetGroup = "ReplicationSubnetGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupDecoded = try containerValues.decodeIfPresent(ReplicationSubnetGroup.self, forKey: .replicationSubnetGroup)
        replicationSubnetGroup = replicationSubnetGroupDecoded
    }
}

public struct CreateReplicationTaskInputBodyMiddleware: Middleware {
    public let id: String = "CreateReplicationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationTaskInput>
    public typealias MOutput = OperationOutput<CreateReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationTaskOutputError>
}

extension CreateReplicationTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReplicationTaskInput(cdcStartPosition: \(String(describing: cdcStartPosition)), cdcStartTime: \(String(describing: cdcStartTime)), cdcStopPosition: \(String(describing: cdcStopPosition)), migrationType: \(String(describing: migrationType)), replicationInstanceArn: \(String(describing: replicationInstanceArn)), replicationTaskIdentifier: \(String(describing: replicationTaskIdentifier)), replicationTaskSettings: \(String(describing: replicationTaskSettings)), resourceIdentifier: \(String(describing: resourceIdentifier)), sourceEndpointArn: \(String(describing: sourceEndpointArn)), tableMappings: \(String(describing: tableMappings)), tags: \(String(describing: tags)), targetEndpointArn: \(String(describing: targetEndpointArn)), taskData: \(String(describing: taskData)))"}
}

extension CreateReplicationTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case sourceEndpointArn = "SourceEndpointArn"
        case tableMappings = "TableMappings"
        case tags = "Tags"
        case targetEndpointArn = "TargetEndpointArn"
        case taskData = "TaskData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStartTime = cdcStartTime {
            try encodeContainer.encode(cdcStartTime.timeIntervalSince1970, forKey: .cdcStartTime)
        }
        if let cdcStopPosition = cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let migrationType = migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationTaskIdentifier = replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskSettings = replicationTaskSettings {
            try encodeContainer.encode(replicationTaskSettings, forKey: .replicationTaskSettings)
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let sourceEndpointArn = sourceEndpointArn {
            try encodeContainer.encode(sourceEndpointArn, forKey: .sourceEndpointArn)
        }
        if let tableMappings = tableMappings {
            try encodeContainer.encode(tableMappings, forKey: .tableMappings)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetEndpointArn = targetEndpointArn {
            try encodeContainer.encode(targetEndpointArn, forKey: .targetEndpointArn)
        }
        if let taskData = taskData {
            try encodeContainer.encode(taskData, forKey: .taskData)
        }
    }
}

public struct CreateReplicationTaskInputHeadersMiddleware: Middleware {
    public let id: String = "CreateReplicationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationTaskInput>
    public typealias MOutput = OperationOutput<CreateReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationTaskOutputError>
}

public struct CreateReplicationTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateReplicationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationTaskInput>
    public typealias MOutput = OperationOutput<CreateReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationTaskOutputError>
}

/// <p></p>
public struct CreateReplicationTaskInput: Equatable {
    /// <p>Indicates when you want a change data capture (CDC) operation to start. Use either
    ///          CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start.
    ///          Specifying both values results in an error.</p>
    ///          <p> The value can be in date, checkpoint, or LSN/SCN format.</p>
    ///          <p>Date Example: --cdc-start-position “2018-03-08T12:12:12”</p>
    ///          <p>Checkpoint Example: --cdc-start-position
    ///          "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93"</p>
    ///          <p>LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373”</p>
    ///          <note>
    ///             <p>When you use this task setting with a source PostgreSQL database, a logical
    ///             replication slot should already be created and associated with the source endpoint. You
    ///             can verify this by setting the <code>slotName</code> extra connection attribute to the
    ///             name of this logical replication slot. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib">Extra Connection Attributes When Using PostgreSQL as a Source
    ///                for AWS DMS</a>.</p>
    ///          </note>
    public let cdcStartPosition: String?
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either
    ///          CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start.
    ///          Specifying both values results in an error.</p>
    ///          <p>Timestamp Example: --cdc-start-time “2018-03-08T12:12:12”</p>
    public let cdcStartTime: Date?
    /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be
    ///          either server time or commit time.</p>
    ///          <p>Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12”</p>
    ///          <p>Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “</p>
    public let cdcStopPosition: String?
    /// <p>The migration type. Valid values: <code>full-load</code> | <code>cdc</code> | <code>full-load-and-cdc</code>
    ///          </p>
    public let migrationType: MigrationTypeValue?
    /// <p>The Amazon Resource Name (ARN) of a replication instance.</p>
    public let replicationInstanceArn: String?
    /// <p>An identifier for the replication task.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain 1-255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let replicationTaskIdentifier: String?
    /// <p>Overall settings for the task, in JSON format. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TaskSettings.html">Specifying Task
    ///             Settings for AWS Database Migration Service Tasks</a> in the <i>AWS Database
    ///             Migration User Guide.</i>
    ///          </p>
    public let replicationTaskSettings: String?
    /// <p>A friendly name for the resource identifier at the end of the <code>EndpointArn</code>
    ///          response parameter that is returned in the created <code>Endpoint</code> object. The value
    ///          for this parameter can have up to 31 characters. It can contain only ASCII letters, digits,
    ///          and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens,
    ///          and can only begin with a letter, such as <code>Example-App-ARN1</code>. For example, this
    ///          value might result in the <code>EndpointArn</code> value
    ///          <code>arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1</code>. If you don't
    ///          specify a <code>ResourceIdentifier</code> value, AWS DMS generates a default identifier
    ///          value for the end of <code>EndpointArn</code>.</p>
    public let resourceIdentifier: String?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies the source endpoint.</p>
    public let sourceEndpointArn: String?
    /// <p>The table mappings for the task, in JSON format. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TableMapping.html">Using Table
    ///             Mapping to Specify Task Settings</a> in the <i>AWS Database Migration Service User
    ///             Guide.</i>
    ///          </p>
    public let tableMappings: String?
    /// <p>One or more tags to be assigned to the replication task.</p>
    public let tags: [Tag]?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies the target endpoint.</p>
    public let targetEndpointArn: String?
    /// <p>Supplemental information that the task requires to migrate the data for certain source and target endpoints.
    ///          For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html">Specifying Supplemental Data for Task Settings</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let taskData: String?

    public init (
        cdcStartPosition: String? = nil,
        cdcStartTime: Date? = nil,
        cdcStopPosition: String? = nil,
        migrationType: MigrationTypeValue? = nil,
        replicationInstanceArn: String? = nil,
        replicationTaskIdentifier: String? = nil,
        replicationTaskSettings: String? = nil,
        resourceIdentifier: String? = nil,
        sourceEndpointArn: String? = nil,
        tableMappings: String? = nil,
        tags: [Tag]? = nil,
        targetEndpointArn: String? = nil,
        taskData: String? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.migrationType = migrationType
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationTaskIdentifier = replicationTaskIdentifier
        self.replicationTaskSettings = replicationTaskSettings
        self.resourceIdentifier = resourceIdentifier
        self.sourceEndpointArn = sourceEndpointArn
        self.tableMappings = tableMappings
        self.tags = tags
        self.targetEndpointArn = targetEndpointArn
        self.taskData = taskData
    }
}

struct CreateReplicationTaskInputBody: Equatable {
    public let replicationTaskIdentifier: String?
    public let sourceEndpointArn: String?
    public let targetEndpointArn: String?
    public let replicationInstanceArn: String?
    public let migrationType: MigrationTypeValue?
    public let tableMappings: String?
    public let replicationTaskSettings: String?
    public let cdcStartTime: Date?
    public let cdcStartPosition: String?
    public let cdcStopPosition: String?
    public let tags: [Tag]?
    public let taskData: String?
    public let resourceIdentifier: String?
}

extension CreateReplicationTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case sourceEndpointArn = "SourceEndpointArn"
        case tableMappings = "TableMappings"
        case tags = "Tags"
        case targetEndpointArn = "TargetEndpointArn"
        case taskData = "TaskData"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let sourceEndpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceEndpointArn)
        sourceEndpointArn = sourceEndpointArnDecoded
        let targetEndpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetEndpointArn)
        targetEndpointArn = targetEndpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let tableMappingsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableMappings)
        tableMappings = tableMappingsDecoded
        let replicationTaskSettingsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskSettings)
        replicationTaskSettings = replicationTaskSettingsDecoded
        let cdcStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .cdcStartTime)
        cdcStartTime = cdcStartTimeDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let taskDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskData)
        taskData = taskDataDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
    }
}

extension CreateReplicationTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReplicationTaskOutputError: Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReplicationTaskOutputResponse(replicationTask: \(String(describing: replicationTask)))"}
}

extension CreateReplicationTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

/// <p></p>
public struct CreateReplicationTaskOutputResponse: Equatable {
    /// <p>The replication task that was created.</p>
    public let replicationTask: ReplicationTask?

    public init (
        replicationTask: ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct CreateReplicationTaskOutputResponseBody: Equatable {
    public let replicationTask: ReplicationTask?
}

extension CreateReplicationTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

public enum DataFormatValue {
    case csv
    case parquet
    case sdkUnknown(String)
}

extension DataFormatValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataFormatValue] {
        return [
            .csv,
            .parquet,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "csv"
        case .parquet: return "parquet"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataFormatValue(rawValue: rawValue) ?? DataFormatValue.sdkUnknown(rawValue)
    }
}

public enum DatePartitionDelimiterValue {
    case dash
    case `none`
    case slash
    case underscore
    case sdkUnknown(String)
}

extension DatePartitionDelimiterValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DatePartitionDelimiterValue] {
        return [
            .dash,
            .none,
            .slash,
            .underscore,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dash: return "DASH"
        case .none: return "NONE"
        case .slash: return "SLASH"
        case .underscore: return "UNDERSCORE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DatePartitionDelimiterValue(rawValue: rawValue) ?? DatePartitionDelimiterValue.sdkUnknown(rawValue)
    }
}

public enum DatePartitionSequenceValue {
    case ddmmyyyy
    case mmyyyydd
    case yyyymm
    case yyyymmdd
    case yyyymmddhh
    case sdkUnknown(String)
}

extension DatePartitionSequenceValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DatePartitionSequenceValue] {
        return [
            .ddmmyyyy,
            .mmyyyydd,
            .yyyymm,
            .yyyymmdd,
            .yyyymmddhh,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ddmmyyyy: return "DDMMYYYY"
        case .mmyyyydd: return "MMYYYYDD"
        case .yyyymm: return "YYYYMM"
        case .yyyymmdd: return "YYYYMMDD"
        case .yyyymmddhh: return "YYYYMMDDHH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DatePartitionSequenceValue(rawValue: rawValue) ?? DatePartitionSequenceValue.sdkUnknown(rawValue)
    }
}

public struct DeleteCertificateInputBodyMiddleware: Middleware {
    public let id: String = "DeleteCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCertificateInput>
    public typealias MOutput = OperationOutput<DeleteCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCertificateOutputError>
}

extension DeleteCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCertificateInput(certificateArn: \(String(describing: certificateArn)))"}
}

extension DeleteCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
    }
}

public struct DeleteCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCertificateInput>
    public typealias MOutput = OperationOutput<DeleteCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCertificateOutputError>
}

public struct DeleteCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCertificateInput>
    public typealias MOutput = OperationOutput<DeleteCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCertificateOutputError>
}

public struct DeleteCertificateInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the deleted certificate.</p>
    public let certificateArn: String?

    public init (
        certificateArn: String? = nil
    )
    {
        self.certificateArn = certificateArn
    }
}

struct DeleteCertificateInputBody: Equatable {
    public let certificateArn: String?
}

extension DeleteCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension DeleteCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCertificateOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCertificateOutputResponse(certificate: \(String(describing: certificate)))"}
}

extension DeleteCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

public struct DeleteCertificateOutputResponse: Equatable {
    /// <p>The Secure Sockets Layer (SSL) certificate.</p>
    public let certificate: Certificate?

    public init (
        certificate: Certificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct DeleteCertificateOutputResponseBody: Equatable {
    public let certificate: Certificate?
}

extension DeleteCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

public struct DeleteConnectionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

extension DeleteConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionInput(endpointArn: \(String(describing: endpointArn)), replicationInstanceArn: \(String(describing: replicationInstanceArn)))"}
}

extension DeleteConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct DeleteConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

/// <p></p>
public struct DeleteConnectionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: String?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: String?

    public init (
        endpointArn: String? = nil,
        replicationInstanceArn: String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DeleteConnectionInputBody: Equatable {
    public let endpointArn: String?
    public let replicationInstanceArn: String?
}

extension DeleteConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
    }
}

extension DeleteConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectionOutputError: Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionOutputResponse(connection: \(String(describing: connection)))"}
}

extension DeleteConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

/// <p></p>
public struct DeleteConnectionOutputResponse: Equatable {
    /// <p>The connection that is being deleted.</p>
    public let connection: Connection?

    public init (
        connection: Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct DeleteConnectionOutputResponseBody: Equatable {
    public let connection: Connection?
}

extension DeleteConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

public struct DeleteEndpointInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointOutputError>
}

extension DeleteEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEndpointInput(endpointArn: \(String(describing: endpointArn)))"}
}

extension DeleteEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
    }
}

public struct DeleteEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointOutputError>
}

public struct DeleteEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointOutputError>
}

/// <p></p>
public struct DeleteEndpointInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: String?

    public init (
        endpointArn: String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct DeleteEndpointInputBody: Equatable {
    public let endpointArn: String?
}

extension DeleteEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension DeleteEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEndpointOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEndpointOutputResponse(endpoint: \(String(describing: endpoint)))"}
}

extension DeleteEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

/// <p></p>
public struct DeleteEndpointOutputResponse: Equatable {
    /// <p>The endpoint that was deleted.</p>
    public let endpoint: Endpoint?

    public init (
        endpoint: Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct DeleteEndpointOutputResponseBody: Equatable {
    public let endpoint: Endpoint?
}

extension DeleteEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpoint = "Endpoint"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

public struct DeleteEventSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventSubscriptionOutputError>
}

extension DeleteEventSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventSubscriptionInput(subscriptionName: \(String(describing: subscriptionName)))"}
}

extension DeleteEventSubscriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subscriptionName = "SubscriptionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subscriptionName = subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
    }
}

public struct DeleteEventSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventSubscriptionOutputError>
}

public struct DeleteEventSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventSubscriptionOutputError>
}

/// <p></p>
public struct DeleteEventSubscriptionInput: Equatable {
    /// <p>The name of the DMS event notification subscription to be deleted.</p>
    public let subscriptionName: String?

    public init (
        subscriptionName: String? = nil
    )
    {
        self.subscriptionName = subscriptionName
    }
}

struct DeleteEventSubscriptionInputBody: Equatable {
    public let subscriptionName: String?
}

extension DeleteEventSubscriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case subscriptionName = "SubscriptionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
    }
}

extension DeleteEventSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventSubscriptionOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventSubscriptionOutputResponse(eventSubscription: \(String(describing: eventSubscription)))"}
}

extension DeleteEventSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

/// <p></p>
public struct DeleteEventSubscriptionOutputResponse: Equatable {
    /// <p>The event subscription that was deleted.</p>
    public let eventSubscription: EventSubscription?

    public init (
        eventSubscription: EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct DeleteEventSubscriptionOutputResponseBody: Equatable {
    public let eventSubscription: EventSubscription?
}

extension DeleteEventSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct DeleteReplicationInstanceInputBodyMiddleware: Middleware {
    public let id: String = "DeleteReplicationInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationInstanceInput>
    public typealias MOutput = OperationOutput<DeleteReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationInstanceOutputError>
}

extension DeleteReplicationInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReplicationInstanceInput(replicationInstanceArn: \(String(describing: replicationInstanceArn)))"}
}

extension DeleteReplicationInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct DeleteReplicationInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteReplicationInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationInstanceInput>
    public typealias MOutput = OperationOutput<DeleteReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationInstanceOutputError>
}

public struct DeleteReplicationInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteReplicationInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationInstanceInput>
    public typealias MOutput = OperationOutput<DeleteReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationInstanceOutputError>
}

/// <p></p>
public struct DeleteReplicationInstanceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the replication instance to be deleted.</p>
    public let replicationInstanceArn: String?

    public init (
        replicationInstanceArn: String? = nil
    )
    {
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DeleteReplicationInstanceInputBody: Equatable {
    public let replicationInstanceArn: String?
}

extension DeleteReplicationInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
    }
}

extension DeleteReplicationInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReplicationInstanceOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReplicationInstanceOutputResponse(replicationInstance: \(String(describing: replicationInstance)))"}
}

extension DeleteReplicationInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteReplicationInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

/// <p></p>
public struct DeleteReplicationInstanceOutputResponse: Equatable {
    /// <p>The replication instance that was deleted.</p>
    public let replicationInstance: ReplicationInstance?

    public init (
        replicationInstance: ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct DeleteReplicationInstanceOutputResponseBody: Equatable {
    public let replicationInstance: ReplicationInstance?
}

extension DeleteReplicationInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

public struct DeleteReplicationSubnetGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteReplicationSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationSubnetGroupInput>
    public typealias MOutput = OperationOutput<DeleteReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationSubnetGroupOutputError>
}

extension DeleteReplicationSubnetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReplicationSubnetGroupInput(replicationSubnetGroupIdentifier: \(String(describing: replicationSubnetGroupIdentifier)))"}
}

extension DeleteReplicationSubnetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
    }
}

public struct DeleteReplicationSubnetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteReplicationSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationSubnetGroupInput>
    public typealias MOutput = OperationOutput<DeleteReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationSubnetGroupOutputError>
}

public struct DeleteReplicationSubnetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteReplicationSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationSubnetGroupInput>
    public typealias MOutput = OperationOutput<DeleteReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationSubnetGroupOutputError>
}

/// <p></p>
public struct DeleteReplicationSubnetGroupInput: Equatable {
    /// <p>The subnet group name of the replication instance.</p>
    public let replicationSubnetGroupIdentifier: String?

    public init (
        replicationSubnetGroupIdentifier: String? = nil
    )
    {
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
    }
}

struct DeleteReplicationSubnetGroupInputBody: Equatable {
    public let replicationSubnetGroupIdentifier: String?
}

extension DeleteReplicationSubnetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
    }
}

extension DeleteReplicationSubnetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationSubnetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReplicationSubnetGroupOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationSubnetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReplicationSubnetGroupOutputResponse()"}
}

extension DeleteReplicationSubnetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p></p>
public struct DeleteReplicationSubnetGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteReplicationSubnetGroupOutputResponseBody: Equatable {
}

extension DeleteReplicationSubnetGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteReplicationTaskAssessmentRunInputBodyMiddleware: Middleware {
    public let id: String = "DeleteReplicationTaskAssessmentRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationTaskAssessmentRunInput>
    public typealias MOutput = OperationOutput<DeleteReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationTaskAssessmentRunOutputError>
}

extension DeleteReplicationTaskAssessmentRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReplicationTaskAssessmentRunInput(replicationTaskAssessmentRunArn: \(String(describing: replicationTaskAssessmentRunArn)))"}
}

extension DeleteReplicationTaskAssessmentRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
    }
}

public struct DeleteReplicationTaskAssessmentRunInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteReplicationTaskAssessmentRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationTaskAssessmentRunInput>
    public typealias MOutput = OperationOutput<DeleteReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationTaskAssessmentRunOutputError>
}

public struct DeleteReplicationTaskAssessmentRunInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteReplicationTaskAssessmentRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationTaskAssessmentRunInput>
    public typealias MOutput = OperationOutput<DeleteReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationTaskAssessmentRunOutputError>
}

/// <p></p>
public struct DeleteReplicationTaskAssessmentRunInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the premigration assessment run to be deleted.</p>
    public let replicationTaskAssessmentRunArn: String?

    public init (
        replicationTaskAssessmentRunArn: String? = nil
    )
    {
        self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
    }
}

struct DeleteReplicationTaskAssessmentRunInputBody: Equatable {
    public let replicationTaskAssessmentRunArn: String?
}

extension DeleteReplicationTaskAssessmentRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
    }
}

extension DeleteReplicationTaskAssessmentRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationTaskAssessmentRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReplicationTaskAssessmentRunOutputError: Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationTaskAssessmentRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReplicationTaskAssessmentRunOutputResponse(replicationTaskAssessmentRun: \(String(describing: replicationTaskAssessmentRun)))"}
}

extension DeleteReplicationTaskAssessmentRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteReplicationTaskAssessmentRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationTaskAssessmentRun = output.replicationTaskAssessmentRun
        } else {
            self.replicationTaskAssessmentRun = nil
        }
    }
}

/// <p></p>
public struct DeleteReplicationTaskAssessmentRunOutputResponse: Equatable {
    /// <p>The <code>ReplicationTaskAssessmentRun</code> object for the deleted assessment
    ///          run.</p>
    public let replicationTaskAssessmentRun: ReplicationTaskAssessmentRun?

    public init (
        replicationTaskAssessmentRun: ReplicationTaskAssessmentRun? = nil
    )
    {
        self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
    }
}

struct DeleteReplicationTaskAssessmentRunOutputResponseBody: Equatable {
    public let replicationTaskAssessmentRun: ReplicationTaskAssessmentRun?
}

extension DeleteReplicationTaskAssessmentRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunDecoded = try containerValues.decodeIfPresent(ReplicationTaskAssessmentRun.self, forKey: .replicationTaskAssessmentRun)
        replicationTaskAssessmentRun = replicationTaskAssessmentRunDecoded
    }
}

public struct DeleteReplicationTaskInputBodyMiddleware: Middleware {
    public let id: String = "DeleteReplicationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationTaskInput>
    public typealias MOutput = OperationOutput<DeleteReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationTaskOutputError>
}

extension DeleteReplicationTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReplicationTaskInput(replicationTaskArn: \(String(describing: replicationTaskArn)))"}
}

extension DeleteReplicationTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

public struct DeleteReplicationTaskInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteReplicationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationTaskInput>
    public typealias MOutput = OperationOutput<DeleteReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationTaskOutputError>
}

public struct DeleteReplicationTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteReplicationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationTaskInput>
    public typealias MOutput = OperationOutput<DeleteReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationTaskOutputError>
}

/// <p></p>
public struct DeleteReplicationTaskInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the replication task to be deleted.</p>
    public let replicationTaskArn: String?

    public init (
        replicationTaskArn: String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct DeleteReplicationTaskInputBody: Equatable {
    public let replicationTaskArn: String?
}

extension DeleteReplicationTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

extension DeleteReplicationTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReplicationTaskOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReplicationTaskOutputResponse(replicationTask: \(String(describing: replicationTask)))"}
}

extension DeleteReplicationTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

/// <p></p>
public struct DeleteReplicationTaskOutputResponse: Equatable {
    /// <p>The deleted replication task.</p>
    public let replicationTask: ReplicationTask?

    public init (
        replicationTask: ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct DeleteReplicationTaskOutputResponseBody: Equatable {
    public let replicationTask: ReplicationTask?
}

extension DeleteReplicationTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension DescribeAccountAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAttributesInput()"}
}

extension DescribeAccountAttributesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAccountAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAttributesOutputError>
}

public struct DescribeAccountAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAttributesOutputError>
}

/// <p></p>
public struct DescribeAccountAttributesInput: Equatable {

    public init() {}
}

struct DescribeAccountAttributesInputBody: Equatable {
}

extension DescribeAccountAttributesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAccountAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountAttributesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAttributesOutputResponse(accountQuotas: \(String(describing: accountQuotas)), uniqueAccountIdentifier: \(String(describing: uniqueAccountIdentifier)))"}
}

extension DescribeAccountAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountQuotas = output.accountQuotas
            self.uniqueAccountIdentifier = output.uniqueAccountIdentifier
        } else {
            self.accountQuotas = nil
            self.uniqueAccountIdentifier = nil
        }
    }
}

/// <p></p>
public struct DescribeAccountAttributesOutputResponse: Equatable {
    /// <p>Account quota information.</p>
    public let accountQuotas: [AccountQuota]?
    /// <p>A unique AWS DMS identifier for an account in a particular AWS Region. The value of this
    ///          identifier has the following format: <code>c99999999999</code>. DMS uses this identifier to
    ///          name artifacts. For example, DMS uses this identifier to name the default Amazon S3 bucket
    ///          for storing task assessment reports in a given AWS Region. The format of this S3 bucket
    ///          name is the following:
    ///                <code>dms-<i>AccountNumber</i>-<i>UniqueAccountIdentifier</i>.</code>
    ///          Here is an example name for this default S3 bucket:
    ///             <code>dms-111122223333-c44445555666</code>.</p>
    ///          <note>
    ///             <p>AWS DMS supports the <code>UniqueAccountIdentifier</code> parameter in
    ///             versions 3.1.4 and later.</p>
    ///          </note>
    public let uniqueAccountIdentifier: String?

    public init (
        accountQuotas: [AccountQuota]? = nil,
        uniqueAccountIdentifier: String? = nil
    )
    {
        self.accountQuotas = accountQuotas
        self.uniqueAccountIdentifier = uniqueAccountIdentifier
    }
}

struct DescribeAccountAttributesOutputResponseBody: Equatable {
    public let accountQuotas: [AccountQuota]?
    public let uniqueAccountIdentifier: String?
}

extension DescribeAccountAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountQuotas = "AccountQuotas"
        case uniqueAccountIdentifier = "UniqueAccountIdentifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountQuotasContainer = try containerValues.decodeIfPresent([AccountQuota?].self, forKey: .accountQuotas)
        var accountQuotasDecoded0:[AccountQuota]? = nil
        if let accountQuotasContainer = accountQuotasContainer {
            accountQuotasDecoded0 = [AccountQuota]()
            for structure0 in accountQuotasContainer {
                if let structure0 = structure0 {
                    accountQuotasDecoded0?.append(structure0)
                }
            }
        }
        accountQuotas = accountQuotasDecoded0
        let uniqueAccountIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uniqueAccountIdentifier)
        uniqueAccountIdentifier = uniqueAccountIdentifierDecoded
    }
}

public struct DescribeApplicableIndividualAssessmentsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeApplicableIndividualAssessmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicableIndividualAssessmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicableIndividualAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicableIndividualAssessmentsInput>
    public typealias MOutput = OperationOutput<DescribeApplicableIndividualAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicableIndividualAssessmentsOutputError>
}

extension DescribeApplicableIndividualAssessmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicableIndividualAssessmentsInput(marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), migrationType: \(String(describing: migrationType)), replicationInstanceArn: \(String(describing: replicationInstanceArn)), replicationTaskArn: \(String(describing: replicationTaskArn)), sourceEngineName: \(String(describing: sourceEngineName)), targetEngineName: \(String(describing: targetEngineName)))"}
}

extension DescribeApplicableIndividualAssessmentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskArn = "ReplicationTaskArn"
        case sourceEngineName = "SourceEngineName"
        case targetEngineName = "TargetEngineName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let migrationType = migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let sourceEngineName = sourceEngineName {
            try encodeContainer.encode(sourceEngineName, forKey: .sourceEngineName)
        }
        if let targetEngineName = targetEngineName {
            try encodeContainer.encode(targetEngineName, forKey: .targetEngineName)
        }
    }
}

public struct DescribeApplicableIndividualAssessmentsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeApplicableIndividualAssessmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicableIndividualAssessmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicableIndividualAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicableIndividualAssessmentsInput>
    public typealias MOutput = OperationOutput<DescribeApplicableIndividualAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicableIndividualAssessmentsOutputError>
}

public struct DescribeApplicableIndividualAssessmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeApplicableIndividualAssessmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicableIndividualAssessmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicableIndividualAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicableIndividualAssessmentsInput>
    public typealias MOutput = OperationOutput<DescribeApplicableIndividualAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicableIndividualAssessmentsOutputError>
}

/// <p></p>
public struct DescribeApplicableIndividualAssessmentsInput: Equatable {
    /// <p>Optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>Maximum number of records to include in the response. If more records exist than the
    ///          specified <code>MaxRecords</code> value, a pagination token called a marker is included in
    ///          the response so that the remaining results can be retrieved.</p>
    public let maxRecords: Int?
    /// <p>Name of the migration type that each provided individual assessment must support.</p>
    public let migrationType: MigrationTypeValue?
    /// <p>ARN of a replication instance on which you want to base the default list of individual
    ///          assessments.</p>
    public let replicationInstanceArn: String?
    /// <p>Amazon Resource Name (ARN) of a migration task on which you want to base
    ///          the default list of individual assessments.</p>
    public let replicationTaskArn: String?
    /// <p>Name of a database engine that the specified replication instance supports as a source.</p>
    public let sourceEngineName: String?
    /// <p>Name of a database engine that the specified replication instance supports as a target.</p>
    public let targetEngineName: String?

    public init (
        marker: String? = nil,
        maxRecords: Int? = nil,
        migrationType: MigrationTypeValue? = nil,
        replicationInstanceArn: String? = nil,
        replicationTaskArn: String? = nil,
        sourceEngineName: String? = nil,
        targetEngineName: String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationType = migrationType
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationTaskArn = replicationTaskArn
        self.sourceEngineName = sourceEngineName
        self.targetEngineName = targetEngineName
    }
}

struct DescribeApplicableIndividualAssessmentsInputBody: Equatable {
    public let replicationTaskArn: String?
    public let replicationInstanceArn: String?
    public let sourceEngineName: String?
    public let targetEngineName: String?
    public let migrationType: MigrationTypeValue?
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeApplicableIndividualAssessmentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskArn = "ReplicationTaskArn"
        case sourceEngineName = "SourceEngineName"
        case targetEngineName = "TargetEngineName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let sourceEngineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceEngineName)
        sourceEngineName = sourceEngineNameDecoded
        let targetEngineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetEngineName)
        targetEngineName = targetEngineNameDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeApplicableIndividualAssessmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicableIndividualAssessmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApplicableIndividualAssessmentsOutputError: Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicableIndividualAssessmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicableIndividualAssessmentsOutputResponse(individualAssessmentNames: \(String(describing: individualAssessmentNames)), marker: \(String(describing: marker)))"}
}

extension DescribeApplicableIndividualAssessmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeApplicableIndividualAssessmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.individualAssessmentNames = output.individualAssessmentNames
            self.marker = output.marker
        } else {
            self.individualAssessmentNames = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeApplicableIndividualAssessmentsOutputResponse: Equatable {
    /// <p>List of names for the individual assessments supported by the premigration assessment
    ///          run that you start based on the specified request parameters. For more information on the
    ///          available individual assessments, including compatibility with different migration task
    ///          configurations, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.AssessmentReport.html">Working with premigration assessment runs</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let individualAssessmentNames: [String]?
    /// <p>Pagination token returned for you to pass to a subsequent request. If you pass this
    ///          token as the <code>Marker</code> value in a subsequent request, the response includes only
    ///          records beyond the marker, up to the value specified in the request by
    ///             <code>MaxRecords</code>.</p>
    public let marker: String?

    public init (
        individualAssessmentNames: [String]? = nil,
        marker: String? = nil
    )
    {
        self.individualAssessmentNames = individualAssessmentNames
        self.marker = marker
    }
}

struct DescribeApplicableIndividualAssessmentsOutputResponseBody: Equatable {
    public let individualAssessmentNames: [String]?
    public let marker: String?
}

extension DescribeApplicableIndividualAssessmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case individualAssessmentNames = "IndividualAssessmentNames"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let individualAssessmentNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .individualAssessmentNames)
        var individualAssessmentNamesDecoded0:[String]? = nil
        if let individualAssessmentNamesContainer = individualAssessmentNamesContainer {
            individualAssessmentNamesDecoded0 = [String]()
            for string0 in individualAssessmentNamesContainer {
                if let string0 = string0 {
                    individualAssessmentNamesDecoded0?.append(string0)
                }
            }
        }
        individualAssessmentNames = individualAssessmentNamesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeCertificatesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificatesInput>
    public typealias MOutput = OperationOutput<DescribeCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificatesOutputError>
}

extension DescribeCertificatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCertificatesInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeCertificatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeCertificatesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificatesInput>
    public typealias MOutput = OperationOutput<DescribeCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificatesOutputError>
}

public struct DescribeCertificatesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificatesInput>
    public typealias MOutput = OperationOutput<DescribeCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificatesOutputError>
}

public struct DescribeCertificatesInput: Equatable {
    /// <p>Filters applied to the certificates described in the form of key-value pairs.</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 10</p>
    public let maxRecords: Int?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeCertificatesInputBody: Equatable {
    public let filters: [Filter]?
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeCertificatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeCertificatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCertificatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCertificatesOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCertificatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCertificatesOutputResponse(certificates: \(String(describing: certificates)), marker: \(String(describing: marker)))"}
}

extension DescribeCertificatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificates = output.certificates
            self.marker = output.marker
        } else {
            self.certificates = nil
            self.marker = nil
        }
    }
}

public struct DescribeCertificatesOutputResponse: Equatable {
    /// <p>The Secure Sockets Layer (SSL) certificates associated with the replication
    ///          instance.</p>
    public let certificates: [Certificate]?
    /// <p>The pagination token.</p>
    public let marker: String?

    public init (
        certificates: [Certificate]? = nil,
        marker: String? = nil
    )
    {
        self.certificates = certificates
        self.marker = marker
    }
}

struct DescribeCertificatesOutputResponseBody: Equatable {
    public let marker: String?
    public let certificates: [Certificate]?
}

extension DescribeCertificatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificates = "Certificates"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let certificatesContainer = try containerValues.decodeIfPresent([Certificate?].self, forKey: .certificates)
        var certificatesDecoded0:[Certificate]? = nil
        if let certificatesContainer = certificatesContainer {
            certificatesDecoded0 = [Certificate]()
            for structure0 in certificatesContainer {
                if let structure0 = structure0 {
                    certificatesDecoded0?.append(structure0)
                }
            }
        }
        certificates = certificatesDecoded0
    }
}

public struct DescribeConnectionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConnectionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionsInput>
    public typealias MOutput = OperationOutput<DescribeConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionsOutputError>
}

extension DescribeConnectionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectionsInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeConnectionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeConnectionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConnectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionsInput>
    public typealias MOutput = OperationOutput<DescribeConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionsOutputError>
}

public struct DescribeConnectionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConnectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionsInput>
    public typealias MOutput = OperationOutput<DescribeConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionsOutputError>
}

/// <p></p>
public struct DescribeConnectionsInput: Equatable {
    /// <p>The filters applied to the connection.</p>
    ///          <p>Valid filter names: endpoint-arn | replication-instance-arn</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeConnectionsInputBody: Equatable {
    public let filters: [Filter]?
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeConnectionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeConnectionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectionsOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectionsOutputResponse(connections: \(String(describing: connections)), marker: \(String(describing: marker)))"}
}

extension DescribeConnectionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connections = output.connections
            self.marker = output.marker
        } else {
            self.connections = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeConnectionsOutputResponse: Equatable {
    /// <p>A description of the connections.</p>
    public let connections: [Connection]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?

    public init (
        connections: [Connection]? = nil,
        marker: String? = nil
    )
    {
        self.connections = connections
        self.marker = marker
    }
}

struct DescribeConnectionsOutputResponseBody: Equatable {
    public let marker: String?
    public let connections: [Connection]?
}

extension DescribeConnectionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connections = "Connections"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let connectionsContainer = try containerValues.decodeIfPresent([Connection?].self, forKey: .connections)
        var connectionsDecoded0:[Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
    }
}

public struct DescribeEndpointSettingsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEndpointSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointSettingsInput>
    public typealias MOutput = OperationOutput<DescribeEndpointSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointSettingsOutputError>
}

extension DescribeEndpointSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointSettingsInput(engineName: \(String(describing: engineName)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeEndpointSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case engineName = "EngineName"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineName = engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeEndpointSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEndpointSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointSettingsInput>
    public typealias MOutput = OperationOutput<DescribeEndpointSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointSettingsOutputError>
}

public struct DescribeEndpointSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEndpointSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointSettingsInput>
    public typealias MOutput = OperationOutput<DescribeEndpointSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointSettingsOutputError>
}

public struct DescribeEndpointSettingsInput: Equatable {
    /// <p>The databse engine used for your source or target endpoint.</p>
    public let engineName: String?
    /// <p>An optional pagination token provided by a previous request. If this parameter is specified,
    ///          the response includes only records beyond the marker, up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response
    ///          so that the remaining results can be retrieved.</p>
    public let maxRecords: Int?

    public init (
        engineName: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.engineName = engineName
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeEndpointSettingsInputBody: Equatable {
    public let engineName: String?
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeEndpointSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engineName = "EngineName"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEndpointSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointSettingsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointSettingsOutputResponse(endpointSettings: \(String(describing: endpointSettings)), marker: \(String(describing: marker)))"}
}

extension DescribeEndpointSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEndpointSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointSettings = output.endpointSettings
            self.marker = output.marker
        } else {
            self.endpointSettings = nil
            self.marker = nil
        }
    }
}

public struct DescribeEndpointSettingsOutputResponse: Equatable {
    /// <p>Descriptions of the endpoint settings available for your source or target database engine.</p>
    public let endpointSettings: [EndpointSetting]?
    /// <p>An optional pagination token provided by a previous request. If this parameter is specified,
    ///          the response includes only records beyond the marker, up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: String?

    public init (
        endpointSettings: [EndpointSetting]? = nil,
        marker: String? = nil
    )
    {
        self.endpointSettings = endpointSettings
        self.marker = marker
    }
}

struct DescribeEndpointSettingsOutputResponseBody: Equatable {
    public let marker: String?
    public let endpointSettings: [EndpointSetting]?
}

extension DescribeEndpointSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointSettings = "EndpointSettings"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let endpointSettingsContainer = try containerValues.decodeIfPresent([EndpointSetting?].self, forKey: .endpointSettings)
        var endpointSettingsDecoded0:[EndpointSetting]? = nil
        if let endpointSettingsContainer = endpointSettingsContainer {
            endpointSettingsDecoded0 = [EndpointSetting]()
            for structure0 in endpointSettingsContainer {
                if let structure0 = structure0 {
                    endpointSettingsDecoded0?.append(structure0)
                }
            }
        }
        endpointSettings = endpointSettingsDecoded0
    }
}

public struct DescribeEndpointTypesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEndpointTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointTypesInput>
    public typealias MOutput = OperationOutput<DescribeEndpointTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointTypesOutputError>
}

extension DescribeEndpointTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointTypesInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeEndpointTypesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeEndpointTypesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEndpointTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointTypesInput>
    public typealias MOutput = OperationOutput<DescribeEndpointTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointTypesOutputError>
}

public struct DescribeEndpointTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEndpointTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointTypesInput>
    public typealias MOutput = OperationOutput<DescribeEndpointTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointTypesOutputError>
}

/// <p></p>
public struct DescribeEndpointTypesInput: Equatable {
    /// <p>Filters applied to the endpoint types.</p>
    ///          <p>Valid filter names: engine-name | endpoint-type</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeEndpointTypesInputBody: Equatable {
    public let filters: [Filter]?
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeEndpointTypesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEndpointTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointTypesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointTypesOutputResponse(marker: \(String(describing: marker)), supportedEndpointTypes: \(String(describing: supportedEndpointTypes)))"}
}

extension DescribeEndpointTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEndpointTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.supportedEndpointTypes = output.supportedEndpointTypes
        } else {
            self.marker = nil
            self.supportedEndpointTypes = nil
        }
    }
}

/// <p></p>
public struct DescribeEndpointTypesOutputResponse: Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p>The types of endpoints that are supported.</p>
    public let supportedEndpointTypes: [SupportedEndpointType]?

    public init (
        marker: String? = nil,
        supportedEndpointTypes: [SupportedEndpointType]? = nil
    )
    {
        self.marker = marker
        self.supportedEndpointTypes = supportedEndpointTypes
    }
}

struct DescribeEndpointTypesOutputResponseBody: Equatable {
    public let marker: String?
    public let supportedEndpointTypes: [SupportedEndpointType]?
}

extension DescribeEndpointTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case supportedEndpointTypes = "SupportedEndpointTypes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let supportedEndpointTypesContainer = try containerValues.decodeIfPresent([SupportedEndpointType?].self, forKey: .supportedEndpointTypes)
        var supportedEndpointTypesDecoded0:[SupportedEndpointType]? = nil
        if let supportedEndpointTypesContainer = supportedEndpointTypesContainer {
            supportedEndpointTypesDecoded0 = [SupportedEndpointType]()
            for structure0 in supportedEndpointTypesContainer {
                if let structure0 = structure0 {
                    supportedEndpointTypesDecoded0?.append(structure0)
                }
            }
        }
        supportedEndpointTypes = supportedEndpointTypesDecoded0
    }
}

public struct DescribeEndpointsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointsOutputError>
}

extension DescribeEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointsInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeEndpointsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointsOutputError>
}

public struct DescribeEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointsOutputError>
}

/// <p></p>
public struct DescribeEndpointsInput: Equatable {
    /// <p>Filters applied to the endpoints.</p>
    ///          <p>Valid filter names: endpoint-arn | endpoint-type | endpoint-id | engine-name</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeEndpointsInputBody: Equatable {
    public let filters: [Filter]?
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeEndpointsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointsOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointsOutputResponse(endpoints: \(String(describing: endpoints)), marker: \(String(describing: marker)))"}
}

extension DescribeEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpoints = output.endpoints
            self.marker = output.marker
        } else {
            self.endpoints = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeEndpointsOutputResponse: Equatable {
    /// <p>Endpoint description.</p>
    public let endpoints: [Endpoint]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?

    public init (
        endpoints: [Endpoint]? = nil,
        marker: String? = nil
    )
    {
        self.endpoints = endpoints
        self.marker = marker
    }
}

struct DescribeEndpointsOutputResponseBody: Equatable {
    public let marker: String?
    public let endpoints: [Endpoint]?
}

extension DescribeEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpoints = "Endpoints"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

public struct DescribeEventCategoriesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventCategoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventCategoriesOutputError>
}

extension DescribeEventCategoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventCategoriesInput(filters: \(String(describing: filters)), sourceType: \(String(describing: sourceType)))"}
}

extension DescribeEventCategoriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
    }
}

public struct DescribeEventCategoriesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventCategoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventCategoriesOutputError>
}

public struct DescribeEventCategoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventCategoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventCategoriesOutputError>
}

/// <p></p>
public struct DescribeEventCategoriesInput: Equatable {
    /// <p>Filters applied to the event categories.</p>
    public let filters: [Filter]?
    /// <p> The type of AWS DMS resource that generates events. </p>
    ///          <p>Valid values: replication-instance | replication-task</p>
    public let sourceType: String?

    public init (
        filters: [Filter]? = nil,
        sourceType: String? = nil
    )
    {
        self.filters = filters
        self.sourceType = sourceType
    }
}

struct DescribeEventCategoriesInputBody: Equatable {
    public let sourceType: String?
    public let filters: [Filter]?
}

extension DescribeEventCategoriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case sourceType = "SourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension DescribeEventCategoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventCategoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventCategoriesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventCategoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventCategoriesOutputResponse(eventCategoryGroupList: \(String(describing: eventCategoryGroupList)))"}
}

extension DescribeEventCategoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventCategoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventCategoryGroupList = output.eventCategoryGroupList
        } else {
            self.eventCategoryGroupList = nil
        }
    }
}

/// <p></p>
public struct DescribeEventCategoriesOutputResponse: Equatable {
    /// <p>A list of event categories.</p>
    public let eventCategoryGroupList: [EventCategoryGroup]?

    public init (
        eventCategoryGroupList: [EventCategoryGroup]? = nil
    )
    {
        self.eventCategoryGroupList = eventCategoryGroupList
    }
}

struct DescribeEventCategoriesOutputResponseBody: Equatable {
    public let eventCategoryGroupList: [EventCategoryGroup]?
}

extension DescribeEventCategoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventCategoryGroupList = "EventCategoryGroupList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventCategoryGroupListContainer = try containerValues.decodeIfPresent([EventCategoryGroup?].self, forKey: .eventCategoryGroupList)
        var eventCategoryGroupListDecoded0:[EventCategoryGroup]? = nil
        if let eventCategoryGroupListContainer = eventCategoryGroupListContainer {
            eventCategoryGroupListDecoded0 = [EventCategoryGroup]()
            for structure0 in eventCategoryGroupListContainer {
                if let structure0 = structure0 {
                    eventCategoryGroupListDecoded0?.append(structure0)
                }
            }
        }
        eventCategoryGroupList = eventCategoryGroupListDecoded0
    }
}

public struct DescribeEventSubscriptionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventSubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventSubscriptionsOutputError>
}

extension DescribeEventSubscriptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventSubscriptionsInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), subscriptionName: \(String(describing: subscriptionName)))"}
}

extension DescribeEventSubscriptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case subscriptionName = "SubscriptionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let subscriptionName = subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
    }
}

public struct DescribeEventSubscriptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventSubscriptionsOutputError>
}

public struct DescribeEventSubscriptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventSubscriptionsOutputError>
}

/// <p></p>
public struct DescribeEventSubscriptionsInput: Equatable {
    /// <p>Filters applied to event subscriptions.</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The name of the AWS DMS event subscription to be described.</p>
    public let subscriptionName: String?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        subscriptionName: String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.subscriptionName = subscriptionName
    }
}

struct DescribeEventSubscriptionsInputBody: Equatable {
    public let subscriptionName: String?
    public let filters: [Filter]?
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeEventSubscriptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case subscriptionName = "SubscriptionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEventSubscriptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventSubscriptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventSubscriptionsOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventSubscriptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventSubscriptionsOutputResponse(eventSubscriptionsList: \(String(describing: eventSubscriptionsList)), marker: \(String(describing: marker)))"}
}

extension DescribeEventSubscriptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscriptionsList = output.eventSubscriptionsList
            self.marker = output.marker
        } else {
            self.eventSubscriptionsList = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeEventSubscriptionsOutputResponse: Equatable {
    /// <p>A list of event subscriptions.</p>
    public let eventSubscriptionsList: [EventSubscription]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?

    public init (
        eventSubscriptionsList: [EventSubscription]? = nil,
        marker: String? = nil
    )
    {
        self.eventSubscriptionsList = eventSubscriptionsList
        self.marker = marker
    }
}

struct DescribeEventSubscriptionsOutputResponseBody: Equatable {
    public let marker: String?
    public let eventSubscriptionsList: [EventSubscription]?
}

extension DescribeEventSubscriptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscriptionsList = "EventSubscriptionsList"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let eventSubscriptionsListContainer = try containerValues.decodeIfPresent([EventSubscription?].self, forKey: .eventSubscriptionsList)
        var eventSubscriptionsListDecoded0:[EventSubscription]? = nil
        if let eventSubscriptionsListContainer = eventSubscriptionsListContainer {
            eventSubscriptionsListDecoded0 = [EventSubscription]()
            for structure0 in eventSubscriptionsListContainer {
                if let structure0 = structure0 {
                    eventSubscriptionsListDecoded0?.append(structure0)
                }
            }
        }
        eventSubscriptionsList = eventSubscriptionsListDecoded0
    }
}

public struct DescribeEventsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

extension DescribeEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsInput(duration: \(String(describing: duration)), endTime: \(String(describing: endTime)), eventCategories: \(String(describing: eventCategories)), filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), sourceIdentifier: \(String(describing: sourceIdentifier)), sourceType: \(String(describing: sourceType)), startTime: \(String(describing: startTime)))"}
}

extension DescribeEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case eventCategories = "EventCategories"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for eventcategorieslist0 in eventCategories {
                try eventCategoriesContainer.encode(eventcategorieslist0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let sourceIdentifier = sourceIdentifier {
            try encodeContainer.encode(sourceIdentifier, forKey: .sourceIdentifier)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct DescribeEventsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

/// <p></p>
public struct DescribeEventsInput: Equatable {
    /// <p>The duration of the events to be listed.</p>
    public let duration: Int?
    /// <p>The end time for the events to be listed.</p>
    public let endTime: Date?
    /// <p>A list of event categories for the source type that you've chosen.</p>
    public let eventCategories: [String]?
    /// <p>Filters applied to events.</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p> The identifier of an event source.</p>
    public let sourceIdentifier: String?
    /// <p>The type of AWS DMS resource that generates events.</p>
    ///          <p>Valid values: replication-instance | replication-task</p>
    public let sourceType: SourceType?
    /// <p>The start time for the events to be listed.</p>
    public let startTime: Date?

    public init (
        duration: Int? = nil,
        endTime: Date? = nil,
        eventCategories: [String]? = nil,
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        sourceIdentifier: String? = nil,
        sourceType: SourceType? = nil,
        startTime: Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.eventCategories = eventCategories
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

struct DescribeEventsInputBody: Equatable {
    public let sourceIdentifier: String?
    public let sourceType: SourceType?
    public let startTime: Date?
    public let endTime: Date?
    public let duration: Int?
    public let eventCategories: [String]?
    public let filters: [Filter]?
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case eventCategories = "EventCategories"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .duration)
        duration = durationDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsOutputResponse(events: \(String(describing: events)), marker: \(String(describing: marker)))"}
}

extension DescribeEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.events = output.events
            self.marker = output.marker
        } else {
            self.events = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeEventsOutputResponse: Equatable {
    /// <p>The events described.</p>
    public let events: [Event]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?

    public init (
        events: [Event]? = nil,
        marker: String? = nil
    )
    {
        self.events = events
        self.marker = marker
    }
}

struct DescribeEventsOutputResponseBody: Equatable {
    public let marker: String?
    public let events: [Event]?
}

extension DescribeEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let eventsContainer = try containerValues.decodeIfPresent([Event?].self, forKey: .events)
        var eventsDecoded0:[Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

public struct DescribeOrderableReplicationInstancesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeOrderableReplicationInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrderableReplicationInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrderableReplicationInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrderableReplicationInstancesInput>
    public typealias MOutput = OperationOutput<DescribeOrderableReplicationInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrderableReplicationInstancesOutputError>
}

extension DescribeOrderableReplicationInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrderableReplicationInstancesInput(marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeOrderableReplicationInstancesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeOrderableReplicationInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOrderableReplicationInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrderableReplicationInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrderableReplicationInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrderableReplicationInstancesInput>
    public typealias MOutput = OperationOutput<DescribeOrderableReplicationInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrderableReplicationInstancesOutputError>
}

public struct DescribeOrderableReplicationInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOrderableReplicationInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrderableReplicationInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrderableReplicationInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrderableReplicationInstancesInput>
    public typealias MOutput = OperationOutput<DescribeOrderableReplicationInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrderableReplicationInstancesOutputError>
}

/// <p></p>
public struct DescribeOrderableReplicationInstancesInput: Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeOrderableReplicationInstancesInputBody: Equatable {
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeOrderableReplicationInstancesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeOrderableReplicationInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrderableReplicationInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrderableReplicationInstancesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrderableReplicationInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrderableReplicationInstancesOutputResponse(marker: \(String(describing: marker)), orderableReplicationInstances: \(String(describing: orderableReplicationInstances)))"}
}

extension DescribeOrderableReplicationInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOrderableReplicationInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.orderableReplicationInstances = output.orderableReplicationInstances
        } else {
            self.marker = nil
            self.orderableReplicationInstances = nil
        }
    }
}

/// <p></p>
public struct DescribeOrderableReplicationInstancesOutputResponse: Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p>The order-able replication instances available.</p>
    public let orderableReplicationInstances: [OrderableReplicationInstance]?

    public init (
        marker: String? = nil,
        orderableReplicationInstances: [OrderableReplicationInstance]? = nil
    )
    {
        self.marker = marker
        self.orderableReplicationInstances = orderableReplicationInstances
    }
}

struct DescribeOrderableReplicationInstancesOutputResponseBody: Equatable {
    public let orderableReplicationInstances: [OrderableReplicationInstance]?
    public let marker: String?
}

extension DescribeOrderableReplicationInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case orderableReplicationInstances = "OrderableReplicationInstances"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderableReplicationInstancesContainer = try containerValues.decodeIfPresent([OrderableReplicationInstance?].self, forKey: .orderableReplicationInstances)
        var orderableReplicationInstancesDecoded0:[OrderableReplicationInstance]? = nil
        if let orderableReplicationInstancesContainer = orderableReplicationInstancesContainer {
            orderableReplicationInstancesDecoded0 = [OrderableReplicationInstance]()
            for structure0 in orderableReplicationInstancesContainer {
                if let structure0 = structure0 {
                    orderableReplicationInstancesDecoded0?.append(structure0)
                }
            }
        }
        orderableReplicationInstances = orderableReplicationInstancesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribePendingMaintenanceActionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribePendingMaintenanceActionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePendingMaintenanceActionsOutputError>
}

extension DescribePendingMaintenanceActionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePendingMaintenanceActionsInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), replicationInstanceArn: \(String(describing: replicationInstanceArn)))"}
}

extension DescribePendingMaintenanceActionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct DescribePendingMaintenanceActionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePendingMaintenanceActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePendingMaintenanceActionsOutputError>
}

public struct DescribePendingMaintenanceActionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePendingMaintenanceActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePendingMaintenanceActionsOutputError>
}

/// <p></p>
public struct DescribePendingMaintenanceActionsInput: Equatable {
    /// <p></p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: String?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        replicationInstanceArn: String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DescribePendingMaintenanceActionsInputBody: Equatable {
    public let replicationInstanceArn: String?
    public let filters: [Filter]?
    public let marker: String?
    public let maxRecords: Int?
}

extension DescribePendingMaintenanceActionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribePendingMaintenanceActionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePendingMaintenanceActionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePendingMaintenanceActionsOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePendingMaintenanceActionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePendingMaintenanceActionsOutputResponse(marker: \(String(describing: marker)), pendingMaintenanceActions: \(String(describing: pendingMaintenanceActions)))"}
}

extension DescribePendingMaintenanceActionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePendingMaintenanceActionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.pendingMaintenanceActions = output.pendingMaintenanceActions
        } else {
            self.marker = nil
            self.pendingMaintenanceActions = nil
        }
    }
}

/// <p></p>
public struct DescribePendingMaintenanceActionsOutputResponse: Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p>The pending maintenance action.</p>
    public let pendingMaintenanceActions: [ResourcePendingMaintenanceActions]?

    public init (
        marker: String? = nil,
        pendingMaintenanceActions: [ResourcePendingMaintenanceActions]? = nil
    )
    {
        self.marker = marker
        self.pendingMaintenanceActions = pendingMaintenanceActions
    }
}

struct DescribePendingMaintenanceActionsOutputResponseBody: Equatable {
    public let pendingMaintenanceActions: [ResourcePendingMaintenanceActions]?
    public let marker: String?
}

extension DescribePendingMaintenanceActionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case pendingMaintenanceActions = "PendingMaintenanceActions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pendingMaintenanceActionsContainer = try containerValues.decodeIfPresent([ResourcePendingMaintenanceActions?].self, forKey: .pendingMaintenanceActions)
        var pendingMaintenanceActionsDecoded0:[ResourcePendingMaintenanceActions]? = nil
        if let pendingMaintenanceActionsContainer = pendingMaintenanceActionsContainer {
            pendingMaintenanceActionsDecoded0 = [ResourcePendingMaintenanceActions]()
            for structure0 in pendingMaintenanceActionsContainer {
                if let structure0 = structure0 {
                    pendingMaintenanceActionsDecoded0?.append(structure0)
                }
            }
        }
        pendingMaintenanceActions = pendingMaintenanceActionsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeRefreshSchemasStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRefreshSchemasStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRefreshSchemasStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRefreshSchemasStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRefreshSchemasStatusInput>
    public typealias MOutput = OperationOutput<DescribeRefreshSchemasStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRefreshSchemasStatusOutputError>
}

extension DescribeRefreshSchemasStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRefreshSchemasStatusInput(endpointArn: \(String(describing: endpointArn)))"}
}

extension DescribeRefreshSchemasStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
    }
}

public struct DescribeRefreshSchemasStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRefreshSchemasStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRefreshSchemasStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRefreshSchemasStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRefreshSchemasStatusInput>
    public typealias MOutput = OperationOutput<DescribeRefreshSchemasStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRefreshSchemasStatusOutputError>
}

public struct DescribeRefreshSchemasStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRefreshSchemasStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRefreshSchemasStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRefreshSchemasStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRefreshSchemasStatusInput>
    public typealias MOutput = OperationOutput<DescribeRefreshSchemasStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRefreshSchemasStatusOutputError>
}

/// <p></p>
public struct DescribeRefreshSchemasStatusInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: String?

    public init (
        endpointArn: String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct DescribeRefreshSchemasStatusInputBody: Equatable {
    public let endpointArn: String?
}

extension DescribeRefreshSchemasStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension DescribeRefreshSchemasStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRefreshSchemasStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRefreshSchemasStatusOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRefreshSchemasStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRefreshSchemasStatusOutputResponse(refreshSchemasStatus: \(String(describing: refreshSchemasStatus)))"}
}

extension DescribeRefreshSchemasStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRefreshSchemasStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.refreshSchemasStatus = output.refreshSchemasStatus
        } else {
            self.refreshSchemasStatus = nil
        }
    }
}

/// <p></p>
public struct DescribeRefreshSchemasStatusOutputResponse: Equatable {
    /// <p>The status of the schema.</p>
    public let refreshSchemasStatus: RefreshSchemasStatus?

    public init (
        refreshSchemasStatus: RefreshSchemasStatus? = nil
    )
    {
        self.refreshSchemasStatus = refreshSchemasStatus
    }
}

struct DescribeRefreshSchemasStatusOutputResponseBody: Equatable {
    public let refreshSchemasStatus: RefreshSchemasStatus?
}

extension DescribeRefreshSchemasStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case refreshSchemasStatus = "RefreshSchemasStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refreshSchemasStatusDecoded = try containerValues.decodeIfPresent(RefreshSchemasStatus.self, forKey: .refreshSchemasStatus)
        refreshSchemasStatus = refreshSchemasStatusDecoded
    }
}

public struct DescribeReplicationInstanceTaskLogsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReplicationInstanceTaskLogsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationInstanceTaskLogsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationInstanceTaskLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationInstanceTaskLogsInput>
    public typealias MOutput = OperationOutput<DescribeReplicationInstanceTaskLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationInstanceTaskLogsOutputError>
}

extension DescribeReplicationInstanceTaskLogsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationInstanceTaskLogsInput(marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), replicationInstanceArn: \(String(describing: replicationInstanceArn)))"}
}

extension DescribeReplicationInstanceTaskLogsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct DescribeReplicationInstanceTaskLogsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReplicationInstanceTaskLogsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationInstanceTaskLogsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationInstanceTaskLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationInstanceTaskLogsInput>
    public typealias MOutput = OperationOutput<DescribeReplicationInstanceTaskLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationInstanceTaskLogsOutputError>
}

public struct DescribeReplicationInstanceTaskLogsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReplicationInstanceTaskLogsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationInstanceTaskLogsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationInstanceTaskLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationInstanceTaskLogsInput>
    public typealias MOutput = OperationOutput<DescribeReplicationInstanceTaskLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationInstanceTaskLogsOutputError>
}

public struct DescribeReplicationInstanceTaskLogsInput: Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: String?

    public init (
        marker: String? = nil,
        maxRecords: Int? = nil,
        replicationInstanceArn: String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DescribeReplicationInstanceTaskLogsInputBody: Equatable {
    public let replicationInstanceArn: String?
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeReplicationInstanceTaskLogsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationInstanceTaskLogsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationInstanceTaskLogsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationInstanceTaskLogsOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationInstanceTaskLogsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationInstanceTaskLogsOutputResponse(marker: \(String(describing: marker)), replicationInstanceArn: \(String(describing: replicationInstanceArn)), replicationInstanceTaskLogs: \(String(describing: replicationInstanceTaskLogs)))"}
}

extension DescribeReplicationInstanceTaskLogsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReplicationInstanceTaskLogsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.replicationInstanceArn = output.replicationInstanceArn
            self.replicationInstanceTaskLogs = output.replicationInstanceTaskLogs
        } else {
            self.marker = nil
            self.replicationInstanceArn = nil
            self.replicationInstanceTaskLogs = nil
        }
    }
}

public struct DescribeReplicationInstanceTaskLogsOutputResponse: Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: String?
    /// <p>An array of replication task log metadata. Each member of the array contains the
    ///          replication task name, ARN, and task log size (in bytes). </p>
    public let replicationInstanceTaskLogs: [ReplicationInstanceTaskLog]?

    public init (
        marker: String? = nil,
        replicationInstanceArn: String? = nil,
        replicationInstanceTaskLogs: [ReplicationInstanceTaskLog]? = nil
    )
    {
        self.marker = marker
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationInstanceTaskLogs = replicationInstanceTaskLogs
    }
}

struct DescribeReplicationInstanceTaskLogsOutputResponseBody: Equatable {
    public let replicationInstanceArn: String?
    public let replicationInstanceTaskLogs: [ReplicationInstanceTaskLog]?
    public let marker: String?
}

extension DescribeReplicationInstanceTaskLogsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceTaskLogs = "ReplicationInstanceTaskLogs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let replicationInstanceTaskLogsContainer = try containerValues.decodeIfPresent([ReplicationInstanceTaskLog?].self, forKey: .replicationInstanceTaskLogs)
        var replicationInstanceTaskLogsDecoded0:[ReplicationInstanceTaskLog]? = nil
        if let replicationInstanceTaskLogsContainer = replicationInstanceTaskLogsContainer {
            replicationInstanceTaskLogsDecoded0 = [ReplicationInstanceTaskLog]()
            for structure0 in replicationInstanceTaskLogsContainer {
                if let structure0 = structure0 {
                    replicationInstanceTaskLogsDecoded0?.append(structure0)
                }
            }
        }
        replicationInstanceTaskLogs = replicationInstanceTaskLogsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeReplicationInstancesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReplicationInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationInstancesInput>
    public typealias MOutput = OperationOutput<DescribeReplicationInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationInstancesOutputError>
}

extension DescribeReplicationInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationInstancesInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeReplicationInstancesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeReplicationInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReplicationInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationInstancesInput>
    public typealias MOutput = OperationOutput<DescribeReplicationInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationInstancesOutputError>
}

public struct DescribeReplicationInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReplicationInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationInstancesInput>
    public typealias MOutput = OperationOutput<DescribeReplicationInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationInstancesOutputError>
}

/// <p></p>
public struct DescribeReplicationInstancesInput: Equatable {
    /// <p>Filters applied to replication instances.</p>
    ///          <p>Valid filter names: replication-instance-arn | replication-instance-id |
    ///          replication-instance-class | engine-version</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationInstancesInputBody: Equatable {
    public let filters: [Filter]?
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeReplicationInstancesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationInstancesOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationInstancesOutputResponse(marker: \(String(describing: marker)), replicationInstances: \(String(describing: replicationInstances)))"}
}

extension DescribeReplicationInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReplicationInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.replicationInstances = output.replicationInstances
        } else {
            self.marker = nil
            self.replicationInstances = nil
        }
    }
}

/// <p></p>
public struct DescribeReplicationInstancesOutputResponse: Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p>The replication instances described.</p>
    public let replicationInstances: [ReplicationInstance]?

    public init (
        marker: String? = nil,
        replicationInstances: [ReplicationInstance]? = nil
    )
    {
        self.marker = marker
        self.replicationInstances = replicationInstances
    }
}

struct DescribeReplicationInstancesOutputResponseBody: Equatable {
    public let marker: String?
    public let replicationInstances: [ReplicationInstance]?
}

extension DescribeReplicationInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case replicationInstances = "ReplicationInstances"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let replicationInstancesContainer = try containerValues.decodeIfPresent([ReplicationInstance?].self, forKey: .replicationInstances)
        var replicationInstancesDecoded0:[ReplicationInstance]? = nil
        if let replicationInstancesContainer = replicationInstancesContainer {
            replicationInstancesDecoded0 = [ReplicationInstance]()
            for structure0 in replicationInstancesContainer {
                if let structure0 = structure0 {
                    replicationInstancesDecoded0?.append(structure0)
                }
            }
        }
        replicationInstances = replicationInstancesDecoded0
    }
}

public struct DescribeReplicationSubnetGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReplicationSubnetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationSubnetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationSubnetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeReplicationSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationSubnetGroupsOutputError>
}

extension DescribeReplicationSubnetGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationSubnetGroupsInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeReplicationSubnetGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeReplicationSubnetGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReplicationSubnetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationSubnetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationSubnetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeReplicationSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationSubnetGroupsOutputError>
}

public struct DescribeReplicationSubnetGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReplicationSubnetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationSubnetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationSubnetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeReplicationSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationSubnetGroupsOutputError>
}

/// <p></p>
public struct DescribeReplicationSubnetGroupsInput: Equatable {
    /// <p>Filters applied to replication subnet groups.</p>
    ///          <p>Valid filter names: replication-subnet-group-id</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationSubnetGroupsInputBody: Equatable {
    public let filters: [Filter]?
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeReplicationSubnetGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationSubnetGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationSubnetGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationSubnetGroupsOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationSubnetGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationSubnetGroupsOutputResponse(marker: \(String(describing: marker)), replicationSubnetGroups: \(String(describing: replicationSubnetGroups)))"}
}

extension DescribeReplicationSubnetGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReplicationSubnetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.replicationSubnetGroups = output.replicationSubnetGroups
        } else {
            self.marker = nil
            self.replicationSubnetGroups = nil
        }
    }
}

/// <p></p>
public struct DescribeReplicationSubnetGroupsOutputResponse: Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p>A description of the replication subnet groups.</p>
    public let replicationSubnetGroups: [ReplicationSubnetGroup]?

    public init (
        marker: String? = nil,
        replicationSubnetGroups: [ReplicationSubnetGroup]? = nil
    )
    {
        self.marker = marker
        self.replicationSubnetGroups = replicationSubnetGroups
    }
}

struct DescribeReplicationSubnetGroupsOutputResponseBody: Equatable {
    public let marker: String?
    public let replicationSubnetGroups: [ReplicationSubnetGroup]?
}

extension DescribeReplicationSubnetGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case replicationSubnetGroups = "ReplicationSubnetGroups"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let replicationSubnetGroupsContainer = try containerValues.decodeIfPresent([ReplicationSubnetGroup?].self, forKey: .replicationSubnetGroups)
        var replicationSubnetGroupsDecoded0:[ReplicationSubnetGroup]? = nil
        if let replicationSubnetGroupsContainer = replicationSubnetGroupsContainer {
            replicationSubnetGroupsDecoded0 = [ReplicationSubnetGroup]()
            for structure0 in replicationSubnetGroupsContainer {
                if let structure0 = structure0 {
                    replicationSubnetGroupsDecoded0?.append(structure0)
                }
            }
        }
        replicationSubnetGroups = replicationSubnetGroupsDecoded0
    }
}

public struct DescribeReplicationTaskAssessmentResultsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReplicationTaskAssessmentResultsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationTaskAssessmentResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationTaskAssessmentResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationTaskAssessmentResultsInput>
    public typealias MOutput = OperationOutput<DescribeReplicationTaskAssessmentResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationTaskAssessmentResultsOutputError>
}

extension DescribeReplicationTaskAssessmentResultsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationTaskAssessmentResultsInput(marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), replicationTaskArn: \(String(describing: replicationTaskArn)))"}
}

extension DescribeReplicationTaskAssessmentResultsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

public struct DescribeReplicationTaskAssessmentResultsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReplicationTaskAssessmentResultsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationTaskAssessmentResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationTaskAssessmentResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationTaskAssessmentResultsInput>
    public typealias MOutput = OperationOutput<DescribeReplicationTaskAssessmentResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationTaskAssessmentResultsOutputError>
}

public struct DescribeReplicationTaskAssessmentResultsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReplicationTaskAssessmentResultsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationTaskAssessmentResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationTaskAssessmentResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationTaskAssessmentResultsInput>
    public typealias MOutput = OperationOutput<DescribeReplicationTaskAssessmentResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationTaskAssessmentResultsOutputError>
}

/// <p></p>
public struct DescribeReplicationTaskAssessmentResultsInput: Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the task. When this input
    ///          parameter is specified, the API returns only one result and ignore the values of the
    ///             <code>MaxRecords</code> and <code>Marker</code> parameters. </p>
    public let replicationTaskArn: String?

    public init (
        marker: String? = nil,
        maxRecords: Int? = nil,
        replicationTaskArn: String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationTaskArn = replicationTaskArn
    }
}

struct DescribeReplicationTaskAssessmentResultsInputBody: Equatable {
    public let replicationTaskArn: String?
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeReplicationTaskAssessmentResultsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationTaskAssessmentResultsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationTaskAssessmentResultsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationTaskAssessmentResultsOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationTaskAssessmentResultsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationTaskAssessmentResultsOutputResponse(bucketName: \(String(describing: bucketName)), marker: \(String(describing: marker)), replicationTaskAssessmentResults: \(String(describing: replicationTaskAssessmentResults)))"}
}

extension DescribeReplicationTaskAssessmentResultsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReplicationTaskAssessmentResultsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bucketName = output.bucketName
            self.marker = output.marker
            self.replicationTaskAssessmentResults = output.replicationTaskAssessmentResults
        } else {
            self.bucketName = nil
            self.marker = nil
            self.replicationTaskAssessmentResults = nil
        }
    }
}

/// <p></p>
public struct DescribeReplicationTaskAssessmentResultsOutputResponse: Equatable {
    /// <p>- The Amazon S3 bucket where the task assessment report is located. </p>
    public let bucketName: String?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p> The task assessment report. </p>
    public let replicationTaskAssessmentResults: [ReplicationTaskAssessmentResult]?

    public init (
        bucketName: String? = nil,
        marker: String? = nil,
        replicationTaskAssessmentResults: [ReplicationTaskAssessmentResult]? = nil
    )
    {
        self.bucketName = bucketName
        self.marker = marker
        self.replicationTaskAssessmentResults = replicationTaskAssessmentResults
    }
}

struct DescribeReplicationTaskAssessmentResultsOutputResponseBody: Equatable {
    public let marker: String?
    public let bucketName: String?
    public let replicationTaskAssessmentResults: [ReplicationTaskAssessmentResult]?
}

extension DescribeReplicationTaskAssessmentResultsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucketName = "BucketName"
        case marker = "Marker"
        case replicationTaskAssessmentResults = "ReplicationTaskAssessmentResults"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let replicationTaskAssessmentResultsContainer = try containerValues.decodeIfPresent([ReplicationTaskAssessmentResult?].self, forKey: .replicationTaskAssessmentResults)
        var replicationTaskAssessmentResultsDecoded0:[ReplicationTaskAssessmentResult]? = nil
        if let replicationTaskAssessmentResultsContainer = replicationTaskAssessmentResultsContainer {
            replicationTaskAssessmentResultsDecoded0 = [ReplicationTaskAssessmentResult]()
            for structure0 in replicationTaskAssessmentResultsContainer {
                if let structure0 = structure0 {
                    replicationTaskAssessmentResultsDecoded0?.append(structure0)
                }
            }
        }
        replicationTaskAssessmentResults = replicationTaskAssessmentResultsDecoded0
    }
}

public struct DescribeReplicationTaskAssessmentRunsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReplicationTaskAssessmentRunsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationTaskAssessmentRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationTaskAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationTaskAssessmentRunsInput>
    public typealias MOutput = OperationOutput<DescribeReplicationTaskAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationTaskAssessmentRunsOutputError>
}

extension DescribeReplicationTaskAssessmentRunsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationTaskAssessmentRunsInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeReplicationTaskAssessmentRunsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeReplicationTaskAssessmentRunsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReplicationTaskAssessmentRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationTaskAssessmentRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationTaskAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationTaskAssessmentRunsInput>
    public typealias MOutput = OperationOutput<DescribeReplicationTaskAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationTaskAssessmentRunsOutputError>
}

public struct DescribeReplicationTaskAssessmentRunsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReplicationTaskAssessmentRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationTaskAssessmentRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationTaskAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationTaskAssessmentRunsInput>
    public typealias MOutput = OperationOutput<DescribeReplicationTaskAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationTaskAssessmentRunsOutputError>
}

/// <p></p>
public struct DescribeReplicationTaskAssessmentRunsInput: Equatable {
    /// <p>Filters applied to the premigration assessment runs described in the form of key-value pairs.</p>
    ///          <p>Valid filter names: <code>replication-task-assessment-run-arn</code>, <code>replication-task-arn</code>,
    ///          <code>replication-instance-arn</code>, <code>status</code>
    ///          </p>
    public let filters: [Filter]?
    /// <p>An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response. If more records exist than the
    ///          specified <code>MaxRecords</code> value, a pagination token called a marker is included in
    ///          the response so that the remaining results can be retrieved.</p>
    public let maxRecords: Int?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationTaskAssessmentRunsInputBody: Equatable {
    public let filters: [Filter]?
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeReplicationTaskAssessmentRunsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationTaskAssessmentRunsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationTaskAssessmentRunsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationTaskAssessmentRunsOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationTaskAssessmentRunsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationTaskAssessmentRunsOutputResponse(marker: \(String(describing: marker)), replicationTaskAssessmentRuns: \(String(describing: replicationTaskAssessmentRuns)))"}
}

extension DescribeReplicationTaskAssessmentRunsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReplicationTaskAssessmentRunsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.replicationTaskAssessmentRuns = output.replicationTaskAssessmentRuns
        } else {
            self.marker = nil
            self.replicationTaskAssessmentRuns = nil
        }
    }
}

/// <p></p>
public struct DescribeReplicationTaskAssessmentRunsOutputResponse: Equatable {
    /// <p>A pagination token returned for you to pass to a subsequent request. If you pass this
    ///          token as the <code>Marker</code> value in a subsequent request, the response includes only
    ///          records beyond the marker, up to the value specified in the request by
    ///             <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>One or more premigration assessment runs as specified by <code>Filters</code>.</p>
    public let replicationTaskAssessmentRuns: [ReplicationTaskAssessmentRun]?

    public init (
        marker: String? = nil,
        replicationTaskAssessmentRuns: [ReplicationTaskAssessmentRun]? = nil
    )
    {
        self.marker = marker
        self.replicationTaskAssessmentRuns = replicationTaskAssessmentRuns
    }
}

struct DescribeReplicationTaskAssessmentRunsOutputResponseBody: Equatable {
    public let marker: String?
    public let replicationTaskAssessmentRuns: [ReplicationTaskAssessmentRun]?
}

extension DescribeReplicationTaskAssessmentRunsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case replicationTaskAssessmentRuns = "ReplicationTaskAssessmentRuns"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let replicationTaskAssessmentRunsContainer = try containerValues.decodeIfPresent([ReplicationTaskAssessmentRun?].self, forKey: .replicationTaskAssessmentRuns)
        var replicationTaskAssessmentRunsDecoded0:[ReplicationTaskAssessmentRun]? = nil
        if let replicationTaskAssessmentRunsContainer = replicationTaskAssessmentRunsContainer {
            replicationTaskAssessmentRunsDecoded0 = [ReplicationTaskAssessmentRun]()
            for structure0 in replicationTaskAssessmentRunsContainer {
                if let structure0 = structure0 {
                    replicationTaskAssessmentRunsDecoded0?.append(structure0)
                }
            }
        }
        replicationTaskAssessmentRuns = replicationTaskAssessmentRunsDecoded0
    }
}

public struct DescribeReplicationTaskIndividualAssessmentsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReplicationTaskIndividualAssessmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationTaskIndividualAssessmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationTaskIndividualAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationTaskIndividualAssessmentsInput>
    public typealias MOutput = OperationOutput<DescribeReplicationTaskIndividualAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationTaskIndividualAssessmentsOutputError>
}

extension DescribeReplicationTaskIndividualAssessmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationTaskIndividualAssessmentsInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeReplicationTaskIndividualAssessmentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeReplicationTaskIndividualAssessmentsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReplicationTaskIndividualAssessmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationTaskIndividualAssessmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationTaskIndividualAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationTaskIndividualAssessmentsInput>
    public typealias MOutput = OperationOutput<DescribeReplicationTaskIndividualAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationTaskIndividualAssessmentsOutputError>
}

public struct DescribeReplicationTaskIndividualAssessmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReplicationTaskIndividualAssessmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationTaskIndividualAssessmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationTaskIndividualAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationTaskIndividualAssessmentsInput>
    public typealias MOutput = OperationOutput<DescribeReplicationTaskIndividualAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationTaskIndividualAssessmentsOutputError>
}

/// <p></p>
public struct DescribeReplicationTaskIndividualAssessmentsInput: Equatable {
    /// <p>Filters applied to the individual assessments described in the form of key-value
    ///          pairs.</p>
    ///          <p>Valid filter names: <code>replication-task-assessment-run-arn</code>,
    ///             <code>replication-task-arn</code>, <code>status</code>
    ///          </p>
    public let filters: [Filter]?
    /// <p>An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>The maximum number of records to include in the response. If more records exist than the
    ///          specified <code>MaxRecords</code> value, a pagination token called a marker is included in
    ///          the response so that the remaining results can be retrieved.</p>
    public let maxRecords: Int?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationTaskIndividualAssessmentsInputBody: Equatable {
    public let filters: [Filter]?
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeReplicationTaskIndividualAssessmentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationTaskIndividualAssessmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationTaskIndividualAssessmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationTaskIndividualAssessmentsOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationTaskIndividualAssessmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationTaskIndividualAssessmentsOutputResponse(marker: \(String(describing: marker)), replicationTaskIndividualAssessments: \(String(describing: replicationTaskIndividualAssessments)))"}
}

extension DescribeReplicationTaskIndividualAssessmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReplicationTaskIndividualAssessmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.replicationTaskIndividualAssessments = output.replicationTaskIndividualAssessments
        } else {
            self.marker = nil
            self.replicationTaskIndividualAssessments = nil
        }
    }
}

/// <p></p>
public struct DescribeReplicationTaskIndividualAssessmentsOutputResponse: Equatable {
    /// <p>A pagination token returned for you to pass to a subsequent request. If you pass this
    ///          token as the <code>Marker</code> value in a subsequent request, the response includes only
    ///          records beyond the marker, up to the value specified in the request by
    ///             <code>MaxRecords</code>.</p>
    public let marker: String?
    /// <p>One or more individual assessments as specified by <code>Filters</code>.</p>
    public let replicationTaskIndividualAssessments: [ReplicationTaskIndividualAssessment]?

    public init (
        marker: String? = nil,
        replicationTaskIndividualAssessments: [ReplicationTaskIndividualAssessment]? = nil
    )
    {
        self.marker = marker
        self.replicationTaskIndividualAssessments = replicationTaskIndividualAssessments
    }
}

struct DescribeReplicationTaskIndividualAssessmentsOutputResponseBody: Equatable {
    public let marker: String?
    public let replicationTaskIndividualAssessments: [ReplicationTaskIndividualAssessment]?
}

extension DescribeReplicationTaskIndividualAssessmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case replicationTaskIndividualAssessments = "ReplicationTaskIndividualAssessments"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let replicationTaskIndividualAssessmentsContainer = try containerValues.decodeIfPresent([ReplicationTaskIndividualAssessment?].self, forKey: .replicationTaskIndividualAssessments)
        var replicationTaskIndividualAssessmentsDecoded0:[ReplicationTaskIndividualAssessment]? = nil
        if let replicationTaskIndividualAssessmentsContainer = replicationTaskIndividualAssessmentsContainer {
            replicationTaskIndividualAssessmentsDecoded0 = [ReplicationTaskIndividualAssessment]()
            for structure0 in replicationTaskIndividualAssessmentsContainer {
                if let structure0 = structure0 {
                    replicationTaskIndividualAssessmentsDecoded0?.append(structure0)
                }
            }
        }
        replicationTaskIndividualAssessments = replicationTaskIndividualAssessmentsDecoded0
    }
}

public struct DescribeReplicationTasksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReplicationTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationTasksInput>
    public typealias MOutput = OperationOutput<DescribeReplicationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationTasksOutputError>
}

extension DescribeReplicationTasksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationTasksInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), withoutSettings: \(String(describing: withoutSettings)))"}
}

extension DescribeReplicationTasksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case withoutSettings = "WithoutSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let withoutSettings = withoutSettings {
            try encodeContainer.encode(withoutSettings, forKey: .withoutSettings)
        }
    }
}

public struct DescribeReplicationTasksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReplicationTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationTasksInput>
    public typealias MOutput = OperationOutput<DescribeReplicationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationTasksOutputError>
}

public struct DescribeReplicationTasksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReplicationTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationTasksInput>
    public typealias MOutput = OperationOutput<DescribeReplicationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationTasksOutputError>
}

/// <p></p>
public struct DescribeReplicationTasksInput: Equatable {
    /// <p>Filters applied to replication tasks.</p>
    ///          <p>Valid filter names: replication-task-arn | replication-task-id | migration-type |
    ///          endpoint-arn | replication-instance-arn</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?
    /// <p>An option to set to avoid returning information about settings. Use this to reduce
    ///          overhead when setting information is too large. To use this option, choose
    ///             <code>true</code>; otherwise, choose <code>false</code> (the default).</p>
    public let withoutSettings: Bool?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        withoutSettings: Bool? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.withoutSettings = withoutSettings
    }
}

struct DescribeReplicationTasksInputBody: Equatable {
    public let filters: [Filter]?
    public let maxRecords: Int?
    public let marker: String?
    public let withoutSettings: Bool?
}

extension DescribeReplicationTasksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case withoutSettings = "WithoutSettings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let withoutSettingsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .withoutSettings)
        withoutSettings = withoutSettingsDecoded
    }
}

extension DescribeReplicationTasksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationTasksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationTasksOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationTasksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationTasksOutputResponse(marker: \(String(describing: marker)), replicationTasks: \(String(describing: replicationTasks)))"}
}

extension DescribeReplicationTasksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReplicationTasksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.replicationTasks = output.replicationTasks
        } else {
            self.marker = nil
            self.replicationTasks = nil
        }
    }
}

/// <p></p>
public struct DescribeReplicationTasksOutputResponse: Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p>A description of the replication tasks.</p>
    public let replicationTasks: [ReplicationTask]?

    public init (
        marker: String? = nil,
        replicationTasks: [ReplicationTask]? = nil
    )
    {
        self.marker = marker
        self.replicationTasks = replicationTasks
    }
}

struct DescribeReplicationTasksOutputResponseBody: Equatable {
    public let marker: String?
    public let replicationTasks: [ReplicationTask]?
}

extension DescribeReplicationTasksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case replicationTasks = "ReplicationTasks"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let replicationTasksContainer = try containerValues.decodeIfPresent([ReplicationTask?].self, forKey: .replicationTasks)
        var replicationTasksDecoded0:[ReplicationTask]? = nil
        if let replicationTasksContainer = replicationTasksContainer {
            replicationTasksDecoded0 = [ReplicationTask]()
            for structure0 in replicationTasksContainer {
                if let structure0 = structure0 {
                    replicationTasksDecoded0?.append(structure0)
                }
            }
        }
        replicationTasks = replicationTasksDecoded0
    }
}

public struct DescribeSchemasInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSchemasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSchemasInput>
    public typealias MOutput = OperationOutput<DescribeSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSchemasOutputError>
}

extension DescribeSchemasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSchemasInput(endpointArn: \(String(describing: endpointArn)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)))"}
}

extension DescribeSchemasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeSchemasInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSchemasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSchemasInput>
    public typealias MOutput = OperationOutput<DescribeSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSchemasOutputError>
}

public struct DescribeSchemasInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSchemasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSchemasInput>
    public typealias MOutput = OperationOutput<DescribeSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSchemasOutputError>
}

/// <p></p>
public struct DescribeSchemasInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: String?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Int?

    public init (
        endpointArn: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil
    )
    {
        self.endpointArn = endpointArn
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeSchemasInputBody: Equatable {
    public let endpointArn: String?
    public let maxRecords: Int?
    public let marker: String?
}

extension DescribeSchemasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeSchemasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSchemasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSchemasOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSchemasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSchemasOutputResponse(marker: \(String(describing: marker)), schemas: \(String(describing: schemas)))"}
}

extension DescribeSchemasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSchemasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.schemas = output.schemas
        } else {
            self.marker = nil
            self.schemas = nil
        }
    }
}

/// <p></p>
public struct DescribeSchemasOutputResponse: Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p>The described schema.</p>
    public let schemas: [String]?

    public init (
        marker: String? = nil,
        schemas: [String]? = nil
    )
    {
        self.marker = marker
        self.schemas = schemas
    }
}

struct DescribeSchemasOutputResponseBody: Equatable {
    public let marker: String?
    public let schemas: [String]?
}

extension DescribeSchemasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case schemas = "Schemas"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let schemasContainer = try containerValues.decodeIfPresent([String?].self, forKey: .schemas)
        var schemasDecoded0:[String]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [String]()
            for string0 in schemasContainer {
                if let string0 = string0 {
                    schemasDecoded0?.append(string0)
                }
            }
        }
        schemas = schemasDecoded0
    }
}

public struct DescribeTableStatisticsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTableStatisticsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTableStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTableStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTableStatisticsInput>
    public typealias MOutput = OperationOutput<DescribeTableStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTableStatisticsOutputError>
}

extension DescribeTableStatisticsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTableStatisticsInput(filters: \(String(describing: filters)), marker: \(String(describing: marker)), maxRecords: \(String(describing: maxRecords)), replicationTaskArn: \(String(describing: replicationTaskArn)))"}
}

extension DescribeTableStatisticsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

public struct DescribeTableStatisticsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTableStatisticsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTableStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTableStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTableStatisticsInput>
    public typealias MOutput = OperationOutput<DescribeTableStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTableStatisticsOutputError>
}

public struct DescribeTableStatisticsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTableStatisticsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTableStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTableStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTableStatisticsInput>
    public typealias MOutput = OperationOutput<DescribeTableStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTableStatisticsOutputError>
}

/// <p></p>
public struct DescribeTableStatisticsInput: Equatable {
    /// <p>Filters applied to table statistics.</p>
    ///          <p>Valid filter names: schema-name | table-name | table-state</p>
    ///          <p>A combination of filters creates an AND condition where each record matches all
    ///          specified filters.</p>
    public let filters: [Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 500.</p>
    public let maxRecords: Int?
    /// <p>The Amazon Resource Name (ARN) of the replication task.</p>
    public let replicationTaskArn: String?

    public init (
        filters: [Filter]? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        replicationTaskArn: String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationTaskArn = replicationTaskArn
    }
}

struct DescribeTableStatisticsInputBody: Equatable {
    public let replicationTaskArn: String?
    public let maxRecords: Int?
    public let marker: String?
    public let filters: [Filter]?
}

extension DescribeTableStatisticsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension DescribeTableStatisticsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTableStatisticsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTableStatisticsOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTableStatisticsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTableStatisticsOutputResponse(marker: \(String(describing: marker)), replicationTaskArn: \(String(describing: replicationTaskArn)), tableStatistics: \(String(describing: tableStatistics)))"}
}

extension DescribeTableStatisticsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTableStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.replicationTaskArn = output.replicationTaskArn
            self.tableStatistics = output.tableStatistics
        } else {
            self.marker = nil
            self.replicationTaskArn = nil
            self.tableStatistics = nil
        }
    }
}

/// <p></p>
public struct DescribeTableStatisticsOutputResponse: Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: String?
    /// <p>The Amazon Resource Name (ARN) of the replication task.</p>
    public let replicationTaskArn: String?
    /// <p>The table statistics.</p>
    public let tableStatistics: [TableStatistics]?

    public init (
        marker: String? = nil,
        replicationTaskArn: String? = nil,
        tableStatistics: [TableStatistics]? = nil
    )
    {
        self.marker = marker
        self.replicationTaskArn = replicationTaskArn
        self.tableStatistics = tableStatistics
    }
}

struct DescribeTableStatisticsOutputResponseBody: Equatable {
    public let replicationTaskArn: String?
    public let tableStatistics: [TableStatistics]?
    public let marker: String?
}

extension DescribeTableStatisticsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case replicationTaskArn = "ReplicationTaskArn"
        case tableStatistics = "TableStatistics"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let tableStatisticsContainer = try containerValues.decodeIfPresent([TableStatistics?].self, forKey: .tableStatistics)
        var tableStatisticsDecoded0:[TableStatistics]? = nil
        if let tableStatisticsContainer = tableStatisticsContainer {
            tableStatisticsDecoded0 = [TableStatistics]()
            for structure0 in tableStatisticsContainer {
                if let structure0 = structure0 {
                    tableStatisticsDecoded0?.append(structure0)
                }
            }
        }
        tableStatistics = tableStatisticsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public enum DmsSslModeValue {
    case `none`
    case require
    case verifyCa
    case verifyFull
    case sdkUnknown(String)
}

extension DmsSslModeValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DmsSslModeValue] {
        return [
            .none,
            .require,
            .verifyCa,
            .verifyFull,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "none"
        case .require: return "require"
        case .verifyCa: return "verify-ca"
        case .verifyFull: return "verify-full"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DmsSslModeValue(rawValue: rawValue) ?? DmsSslModeValue.sdkUnknown(rawValue)
    }
}

extension DmsTransferSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName = "BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension DmsTransferSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DmsTransferSettings(bucketName: \(String(describing: bucketName)), serviceAccessRoleArn: \(String(describing: serviceAccessRoleArn)))"}
}

/// <p> The settings in JSON format for the DMS Transfer type source endpoint. </p>
public struct DmsTransferSettings: Equatable {
    /// <p> The name of the S3 bucket to use. </p>
    public let bucketName: String?
    /// <p> The IAM role that has permission to access the Amazon S3 bucket. </p>
    public let serviceAccessRoleArn: String?

    public init (
        bucketName: String? = nil,
        serviceAccessRoleArn: String? = nil
    )
    {
        self.bucketName = bucketName
        self.serviceAccessRoleArn = serviceAccessRoleArn
    }
}

extension DocDbSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case docsToInvestigate = "DocsToInvestigate"
        case extractDocId = "ExtractDocId"
        case kmsKeyId = "KmsKeyId"
        case nestingLevel = "NestingLevel"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let docsToInvestigate = docsToInvestigate {
            try encodeContainer.encode(docsToInvestigate, forKey: .docsToInvestigate)
        }
        if let extractDocId = extractDocId {
            try encodeContainer.encode(extractDocId, forKey: .extractDocId)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let nestingLevel = nestingLevel {
            try encodeContainer.encode(nestingLevel.rawValue, forKey: .nestingLevel)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let nestingLevelDecoded = try containerValues.decodeIfPresent(NestingLevelValue.self, forKey: .nestingLevel)
        nestingLevel = nestingLevelDecoded
        let extractDocIdDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .extractDocId)
        extractDocId = extractDocIdDecoded
        let docsToInvestigateDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .docsToInvestigate)
        docsToInvestigate = docsToInvestigateDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DocDbSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocDbSettings(databaseName: \(String(describing: databaseName)), docsToInvestigate: \(String(describing: docsToInvestigate)), extractDocId: \(String(describing: extractDocId)), kmsKeyId: \(String(describing: kmsKeyId)), nestingLevel: \(String(describing: nestingLevel)), password: \(String(describing: password)), port: \(String(describing: port)), secretsManagerAccessRoleArn: \(String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(String(describing: secretsManagerSecretId)), serverName: \(String(describing: serverName)), username: \(String(describing: username)))"}
}

/// <p>Provides information that defines a DocumentDB endpoint.</p>
public struct DocDbSettings: Equatable {
    /// <p> The database name on the DocumentDB source endpoint. </p>
    public let databaseName: String?
    /// <p> Indicates the number of documents to preview to determine the document organization.
    ///          Use this setting when <code>NestingLevel</code> is set to <code>"one"</code>. </p>
    ///          <p>Must be a positive value greater than <code>0</code>. Default value is
    ///          <code>1000</code>.</p>
    public let docsToInvestigate: Int?
    /// <p> Specifies the document ID. Use this setting when <code>NestingLevel</code> is set to
    ///          <code>"none"</code>. </p>
    ///          <p>Default value is <code>"false"</code>. </p>
    public let extractDocId: Bool?
    /// <p>The AWS KMS key identifier that is used to encrypt the content on the replication
    ///          instance. If you don't specify a value for the <code>KmsKeyId</code> parameter, then
    ///          AWS DMS uses your default encryption key. AWS KMS creates the default encryption key for
    ///          your AWS account. Your AWS account has a different default encryption key for each AWS
    ///          Region.</p>
    public let kmsKeyId: String?
    /// <p> Specifies either document or table mode. </p>
    ///          <p>Default value is <code>"none"</code>. Specify <code>"none"</code> to use document mode.
    ///          Specify <code>"one"</code> to use table mode.</p>
    public let nestingLevel: NestingLevelValue?
    /// <p> The password for the user account you use to access the DocumentDB source endpoint.
    ///       </p>
    public let password: String?
    /// <p> The port value for the DocumentDB source endpoint. </p>
    public let port: Int?
    /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
    ///          trusted entity and grants the required permissions to access the value in
    ///          <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
    ///          Manager secret that allows access to the DocumentDB endpoint.</p>
    ///          <note>
    ///             <p>You can specify one of two sets of values for these permissions. You can specify the
    ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
    ///             clear-text values for <code>UserName</code>, <code>Password</code>,
    ///             <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
    ///             information on creating this <code>SecretsManagerSecret</code> and the
    ///             <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
    ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
    ///                resources</a> in the <i>AWS Database Migration Service User
    ///                   Guide</i>.</p>
    ///          </note>
    public let secretsManagerAccessRoleArn: String?
    /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code>
    ///          that contains the DocumentDB endpoint connection details.</p>
    public let secretsManagerSecretId: String?
    /// <p> The name of the server on the DocumentDB source endpoint. </p>
    public let serverName: String?
    /// <p>The user name you use to access the DocumentDB source endpoint. </p>
    public let username: String?

    public init (
        databaseName: String? = nil,
        docsToInvestigate: Int? = nil,
        extractDocId: Bool? = nil,
        kmsKeyId: String? = nil,
        nestingLevel: NestingLevelValue? = nil,
        password: String? = nil,
        port: Int? = nil,
        secretsManagerAccessRoleArn: String? = nil,
        secretsManagerSecretId: String? = nil,
        serverName: String? = nil,
        username: String? = nil
    )
    {
        self.databaseName = databaseName
        self.docsToInvestigate = docsToInvestigate
        self.extractDocId = extractDocId
        self.kmsKeyId = kmsKeyId
        self.nestingLevel = nestingLevel
        self.password = password
        self.port = port
        self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
        self.secretsManagerSecretId = secretsManagerSecretId
        self.serverName = serverName
        self.username = username
    }
}

extension DynamoDbSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
    }
}

extension DynamoDbSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DynamoDbSettings(serviceAccessRoleArn: \(String(describing: serviceAccessRoleArn)))"}
}

/// <p>Provides the Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM)
///          role used to define an Amazon DynamoDB target endpoint.</p>
public struct DynamoDbSettings: Equatable {
    /// <p> The Amazon Resource Name (ARN) used by the service access IAM role. </p>
    public let serviceAccessRoleArn: String?

    public init (
        serviceAccessRoleArn: String? = nil
    )
    {
        self.serviceAccessRoleArn = serviceAccessRoleArn
    }
}

extension ElasticsearchSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointUri = "EndpointUri"
        case errorRetryDuration = "ErrorRetryDuration"
        case fullLoadErrorPercentage = "FullLoadErrorPercentage"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointUri = endpointUri {
            try encodeContainer.encode(endpointUri, forKey: .endpointUri)
        }
        if let errorRetryDuration = errorRetryDuration {
            try encodeContainer.encode(errorRetryDuration, forKey: .errorRetryDuration)
        }
        if let fullLoadErrorPercentage = fullLoadErrorPercentage {
            try encodeContainer.encode(fullLoadErrorPercentage, forKey: .fullLoadErrorPercentage)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let endpointUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointUri)
        endpointUri = endpointUriDecoded
        let fullLoadErrorPercentageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fullLoadErrorPercentage)
        fullLoadErrorPercentage = fullLoadErrorPercentageDecoded
        let errorRetryDurationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .errorRetryDuration)
        errorRetryDuration = errorRetryDurationDecoded
    }
}

extension ElasticsearchSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ElasticsearchSettings(endpointUri: \(String(describing: endpointUri)), errorRetryDuration: \(String(describing: errorRetryDuration)), fullLoadErrorPercentage: \(String(describing: fullLoadErrorPercentage)), serviceAccessRoleArn: \(String(describing: serviceAccessRoleArn)))"}
}

/// <p>Provides information that defines an Elasticsearch endpoint.</p>
public struct ElasticsearchSettings: Equatable {
    /// <p>The endpoint for the Elasticsearch cluster. AWS DMS uses HTTPS if a transport
    ///          protocol (http/https) is not specified.</p>
    public let endpointUri: String?
    /// <p>The maximum number of seconds for which DMS retries failed API requests to the
    ///          Elasticsearch cluster.</p>
    public let errorRetryDuration: Int?
    /// <p>The maximum percentage of records that can fail to be written before a full load
    ///             operation stops.</p>
    ///          <p>To avoid early failure, this counter is only effective after 1000 records
    ///          are transferred. Elasticsearch also has the concept of error monitoring during the
    ///          last 10 minutes of an Observation Window. If transfer of all records fail in the
    ///          last 10 minutes, the full load operation stops. </p>
    public let fullLoadErrorPercentage: Int?
    /// <p>The Amazon Resource Name (ARN) used by service to access the IAM role.</p>
    public let serviceAccessRoleArn: String?

    public init (
        endpointUri: String? = nil,
        errorRetryDuration: Int? = nil,
        fullLoadErrorPercentage: Int? = nil,
        serviceAccessRoleArn: String? = nil
    )
    {
        self.endpointUri = endpointUri
        self.errorRetryDuration = errorRetryDuration
        self.fullLoadErrorPercentage = fullLoadErrorPercentage
        self.serviceAccessRoleArn = serviceAccessRoleArn
    }
}

public enum EncodingTypeValue {
    case plain
    case plainDictionary
    case rleDictionary
    case sdkUnknown(String)
}

extension EncodingTypeValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncodingTypeValue] {
        return [
            .plain,
            .plainDictionary,
            .rleDictionary,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .plain: return "plain"
        case .plainDictionary: return "plain-dictionary"
        case .rleDictionary: return "rle-dictionary"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncodingTypeValue(rawValue: rawValue) ?? EncodingTypeValue.sdkUnknown(rawValue)
    }
}

public enum EncryptionModeValue {
    case sseKms
    case sseS3
    case sdkUnknown(String)
}

extension EncryptionModeValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionModeValue] {
        return [
            .sseKms,
            .sseS3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sseKms: return "sse-kms"
        case .sseS3: return "sse-s3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionModeValue(rawValue: rawValue) ?? EncryptionModeValue.sdkUnknown(rawValue)
    }
}

extension Endpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineDisplayName = "EngineDisplayName"
        case engineName = "EngineName"
        case externalId = "ExternalId"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case iBMDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case kmsKeyId = "KmsKeyId"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redshiftSettings = "RedshiftSettings"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case status = "Status"
        case sybaseSettings = "SybaseSettings"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dmsTransferSettings = dmsTransferSettings {
            try encodeContainer.encode(dmsTransferSettings, forKey: .dmsTransferSettings)
        }
        if let docDbSettings = docDbSettings {
            try encodeContainer.encode(docDbSettings, forKey: .docDbSettings)
        }
        if let dynamoDbSettings = dynamoDbSettings {
            try encodeContainer.encode(dynamoDbSettings, forKey: .dynamoDbSettings)
        }
        if let elasticsearchSettings = elasticsearchSettings {
            try encodeContainer.encode(elasticsearchSettings, forKey: .elasticsearchSettings)
        }
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let endpointIdentifier = endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineDisplayName = engineDisplayName {
            try encodeContainer.encode(engineDisplayName, forKey: .engineDisplayName)
        }
        if let engineName = engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let externalTableDefinition = externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let extraConnectionAttributes = extraConnectionAttributes {
            try encodeContainer.encode(extraConnectionAttributes, forKey: .extraConnectionAttributes)
        }
        if let iBMDb2Settings = iBMDb2Settings {
            try encodeContainer.encode(iBMDb2Settings, forKey: .iBMDb2Settings)
        }
        if let kafkaSettings = kafkaSettings {
            try encodeContainer.encode(kafkaSettings, forKey: .kafkaSettings)
        }
        if let kinesisSettings = kinesisSettings {
            try encodeContainer.encode(kinesisSettings, forKey: .kinesisSettings)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let microsoftSQLServerSettings = microsoftSQLServerSettings {
            try encodeContainer.encode(microsoftSQLServerSettings, forKey: .microsoftSQLServerSettings)
        }
        if let mongoDbSettings = mongoDbSettings {
            try encodeContainer.encode(mongoDbSettings, forKey: .mongoDbSettings)
        }
        if let mySQLSettings = mySQLSettings {
            try encodeContainer.encode(mySQLSettings, forKey: .mySQLSettings)
        }
        if let neptuneSettings = neptuneSettings {
            try encodeContainer.encode(neptuneSettings, forKey: .neptuneSettings)
        }
        if let oracleSettings = oracleSettings {
            try encodeContainer.encode(oracleSettings, forKey: .oracleSettings)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let postgreSQLSettings = postgreSQLSettings {
            try encodeContainer.encode(postgreSQLSettings, forKey: .postgreSQLSettings)
        }
        if let redshiftSettings = redshiftSettings {
            try encodeContainer.encode(redshiftSettings, forKey: .redshiftSettings)
        }
        if let s3Settings = s3Settings {
            try encodeContainer.encode(s3Settings, forKey: .s3Settings)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let sslMode = sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let sybaseSettings = sybaseSettings {
            try encodeContainer.encode(sybaseSettings, forKey: .sybaseSettings)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let engineDisplayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineDisplayName)
        engineDisplayName = engineDisplayNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let extraConnectionAttributesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extraConnectionAttributes)
        extraConnectionAttributes = extraConnectionAttributesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let dynamoDbSettingsDecoded = try containerValues.decodeIfPresent(DynamoDbSettings.self, forKey: .dynamoDbSettings)
        dynamoDbSettings = dynamoDbSettingsDecoded
        let s3SettingsDecoded = try containerValues.decodeIfPresent(S3Settings.self, forKey: .s3Settings)
        s3Settings = s3SettingsDecoded
        let dmsTransferSettingsDecoded = try containerValues.decodeIfPresent(DmsTransferSettings.self, forKey: .dmsTransferSettings)
        dmsTransferSettings = dmsTransferSettingsDecoded
        let mongoDbSettingsDecoded = try containerValues.decodeIfPresent(MongoDbSettings.self, forKey: .mongoDbSettings)
        mongoDbSettings = mongoDbSettingsDecoded
        let kinesisSettingsDecoded = try containerValues.decodeIfPresent(KinesisSettings.self, forKey: .kinesisSettings)
        kinesisSettings = kinesisSettingsDecoded
        let kafkaSettingsDecoded = try containerValues.decodeIfPresent(KafkaSettings.self, forKey: .kafkaSettings)
        kafkaSettings = kafkaSettingsDecoded
        let elasticsearchSettingsDecoded = try containerValues.decodeIfPresent(ElasticsearchSettings.self, forKey: .elasticsearchSettings)
        elasticsearchSettings = elasticsearchSettingsDecoded
        let neptuneSettingsDecoded = try containerValues.decodeIfPresent(NeptuneSettings.self, forKey: .neptuneSettings)
        neptuneSettings = neptuneSettingsDecoded
        let redshiftSettingsDecoded = try containerValues.decodeIfPresent(RedshiftSettings.self, forKey: .redshiftSettings)
        redshiftSettings = redshiftSettingsDecoded
        let postgreSQLSettingsDecoded = try containerValues.decodeIfPresent(PostgreSQLSettings.self, forKey: .postgreSQLSettings)
        postgreSQLSettings = postgreSQLSettingsDecoded
        let mySQLSettingsDecoded = try containerValues.decodeIfPresent(MySQLSettings.self, forKey: .mySQLSettings)
        mySQLSettings = mySQLSettingsDecoded
        let oracleSettingsDecoded = try containerValues.decodeIfPresent(OracleSettings.self, forKey: .oracleSettings)
        oracleSettings = oracleSettingsDecoded
        let sybaseSettingsDecoded = try containerValues.decodeIfPresent(SybaseSettings.self, forKey: .sybaseSettings)
        sybaseSettings = sybaseSettingsDecoded
        let microsoftSQLServerSettingsDecoded = try containerValues.decodeIfPresent(MicrosoftSQLServerSettings.self, forKey: .microsoftSQLServerSettings)
        microsoftSQLServerSettings = microsoftSQLServerSettingsDecoded
        let iBMDb2SettingsDecoded = try containerValues.decodeIfPresent(IBMDb2Settings.self, forKey: .iBMDb2Settings)
        iBMDb2Settings = iBMDb2SettingsDecoded
        let docDbSettingsDecoded = try containerValues.decodeIfPresent(DocDbSettings.self, forKey: .docDbSettings)
        docDbSettings = docDbSettingsDecoded
    }
}

extension Endpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Endpoint(certificateArn: \(String(describing: certificateArn)), databaseName: \(String(describing: databaseName)), dmsTransferSettings: \(String(describing: dmsTransferSettings)), docDbSettings: \(String(describing: docDbSettings)), dynamoDbSettings: \(String(describing: dynamoDbSettings)), elasticsearchSettings: \(String(describing: elasticsearchSettings)), endpointArn: \(String(describing: endpointArn)), endpointIdentifier: \(String(describing: endpointIdentifier)), endpointType: \(String(describing: endpointType)), engineDisplayName: \(String(describing: engineDisplayName)), engineName: \(String(describing: engineName)), externalId: \(String(describing: externalId)), externalTableDefinition: \(String(describing: externalTableDefinition)), extraConnectionAttributes: \(String(describing: extraConnectionAttributes)), iBMDb2Settings: \(String(describing: iBMDb2Settings)), kafkaSettings: \(String(describing: kafkaSettings)), kinesisSettings: \(String(describing: kinesisSettings)), kmsKeyId: \(String(describing: kmsKeyId)), microsoftSQLServerSettings: \(String(describing: microsoftSQLServerSettings)), mongoDbSettings: \(String(describing: mongoDbSettings)), mySQLSettings: \(String(describing: mySQLSettings)), neptuneSettings: \(String(describing: neptuneSettings)), oracleSettings: \(String(describing: oracleSettings)), port: \(String(describing: port)), postgreSQLSettings: \(String(describing: postgreSQLSettings)), redshiftSettings: \(String(describing: redshiftSettings)), s3Settings: \(String(describing: s3Settings)), serverName: \(String(describing: serverName)), serviceAccessRoleArn: \(String(describing: serviceAccessRoleArn)), sslMode: \(String(describing: sslMode)), status: \(String(describing: status)), sybaseSettings: \(String(describing: sybaseSettings)), username: \(String(describing: username)))"}
}

/// <p>Describes an endpoint of a database instance in response to operations such as the
///          following:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>CreateEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeEndpointTypes</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>ModifyEndpoint</code>
///                </p>
///             </li>
///          </ul>
public struct Endpoint: Equatable {
    /// <p>The Amazon Resource Name (ARN) used for SSL connection to the endpoint.</p>
    public let certificateArn: String?
    /// <p>The name of the database at the endpoint.</p>
    public let databaseName: String?
    /// <p>The settings in JSON format for the DMS transfer type of source endpoint. </p>
    ///          <p>Possible settings include the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ServiceAccessRoleArn</code> - The IAM role that has permission to access the
    ///                Amazon S3 bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BucketName</code> - The name of the S3 bucket to use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CompressionType</code> - An optional parameter to use GZIP to compress the
    ///                target files. To use GZIP, set this value to <code>NONE</code> (the default). To keep
    ///                the files uncompressed, don't use this value.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Shorthand syntax for these settings is as follows:
    ///             <code>ServiceAccessRoleArn=string,BucketName=string,CompressionType=string</code>
    ///          </p>
    ///          <p>JSON syntax for these settings is as follows: <code>{ "ServiceAccessRoleArn":
    ///             "string", "BucketName": "string", "CompressionType": "none"|"gzip" } </code>
    ///          </p>
    public let dmsTransferSettings: DmsTransferSettings?
    /// <p>Provides information that defines a DocumentDB endpoint.</p>
    public let docDbSettings: DocDbSettings?
    /// <p>The settings for the DynamoDB target endpoint. For more information, see the
    ///             <code>DynamoDBSettings</code> structure.</p>
    public let dynamoDbSettings: DynamoDbSettings?
    /// <p>The settings for the Elasticsearch source endpoint. For more information, see the
    ///             <code>ElasticsearchSettings</code> structure.</p>
    public let elasticsearchSettings: ElasticsearchSettings?
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: String?
    /// <p>The database endpoint identifier. Identifiers must begin with a letter and must contain
    ///          only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two
    ///          consecutive hyphens.</p>
    public let endpointIdentifier: String?
    /// <p>The type of endpoint.  Valid values are <code>source</code> and <code>target</code>.</p>
    public let endpointType: ReplicationEndpointTypeValue?
    /// <p>The expanded name for the engine name. For example, if the <code>EngineName</code>
    ///          parameter is "aurora," this value would be "Amazon Aurora MySQL."</p>
    public let engineDisplayName: String?
    /// <p>The database engine name. Valid values, depending on the EndpointType, include
    ///             <code>"mysql"</code>, <code>"oracle"</code>, <code>"postgres"</code>,
    ///             <code>"mariadb"</code>, <code>"aurora"</code>, <code>"aurora-postgresql"</code>,
    ///             <code>"redshift"</code>, <code>"s3"</code>, <code>"db2"</code>, <code>"azuredb"</code>,
    ///             <code>"sybase"</code>, <code>"dynamodb"</code>, <code>"mongodb"</code>,
    ///             <code>"kinesis"</code>, <code>"kafka"</code>, <code>"elasticsearch"</code>,
    ///             <code>"documentdb"</code>, <code>"sqlserver"</code>, and <code>"neptune"</code>.</p>
    public let engineName: String?
    /// <p> Value returned by a call to CreateEndpoint that can be used for cross-account
    ///          validation. Use it on a subsequent call to CreateEndpoint to create the endpoint with a
    ///          cross-account. </p>
    public let externalId: String?
    /// <p>The external table definition.</p>
    public let externalTableDefinition: String?
    /// <p>Additional connection attributes used to connect to the endpoint.</p>
    public let extraConnectionAttributes: String?
    /// <p>The settings for the IBM Db2 LUW source endpoint. For more information, see the
    ///             <code>IBMDb2Settings</code> structure.
    ///       </p>
    public let iBMDb2Settings: IBMDb2Settings?
    /// <p>The settings for the Apache Kafka target endpoint. For more information, see the
    ///          <code>KafkaSettings</code> structure.</p>
    public let kafkaSettings: KafkaSettings?
    /// <p>The settings for the Amazon Kinesis target endpoint. For more information, see the
    ///             <code>KinesisSettings</code> structure.</p>
    public let kinesisSettings: KinesisSettings?
    /// <p>An AWS KMS key identifier that is used to encrypt the connection parameters for the endpoint.</p>
    ///          <p>If you don't specify a value for the <code>KmsKeyId</code> parameter, then
    ///            AWS DMS uses your default encryption key.</p>
    ///          <p>AWS KMS creates the default encryption key for your AWS account. Your AWS account has a
    ///          different default encryption key for each AWS Region.</p>
    public let kmsKeyId: String?
    /// <p>The settings for the Microsoft SQL Server source and target endpoint. For more
    ///          information, see the <code>MicrosoftSQLServerSettings</code> structure.</p>
    public let microsoftSQLServerSettings: MicrosoftSQLServerSettings?
    /// <p>The settings for the MongoDB source endpoint. For more information, see the
    ///             <code>MongoDbSettings</code> structure.</p>
    public let mongoDbSettings: MongoDbSettings?
    /// <p>The settings for the MySQL source and target endpoint. For more information, see the
    ///             <code>MySQLSettings</code> structure.</p>
    public let mySQLSettings: MySQLSettings?
    /// <p>The settings for the Amazon Neptune target endpoint. For more information, see the
    ///          <code>NeptuneSettings</code> structure.</p>
    public let neptuneSettings: NeptuneSettings?
    /// <p>The settings for the Oracle source and target endpoint. For more information, see the
    ///             <code>OracleSettings</code> structure.</p>
    public let oracleSettings: OracleSettings?
    /// <p>The port value used to access the endpoint.</p>
    public let port: Int?
    /// <p>The settings for the PostgreSQL source and target endpoint. For more information, see
    ///          the <code>PostgreSQLSettings</code> structure.</p>
    public let postgreSQLSettings: PostgreSQLSettings?
    /// <p>Settings for the Amazon Redshift endpoint.</p>
    public let redshiftSettings: RedshiftSettings?
    /// <p>The settings for the S3 target endpoint. For more information, see the
    ///             <code>S3Settings</code> structure.</p>
    public let s3Settings: S3Settings?
    /// <p>The name of the server at the endpoint.</p>
    public let serverName: String?
    /// <p>The Amazon Resource Name (ARN) used by the service access IAM role.</p>
    public let serviceAccessRoleArn: String?
    /// <p>The SSL mode used to connect to the endpoint. The default value is <code>none</code>.</p>
    public let sslMode: DmsSslModeValue?
    /// <p>The status of the endpoint.</p>
    public let status: String?
    /// <p>The settings for the SAP ASE source and target endpoint. For more information, see the
    ///             <code>SybaseSettings</code> structure.</p>
    public let sybaseSettings: SybaseSettings?
    /// <p>The user name used to connect to the endpoint.</p>
    public let username: String?

    public init (
        certificateArn: String? = nil,
        databaseName: String? = nil,
        dmsTransferSettings: DmsTransferSettings? = nil,
        docDbSettings: DocDbSettings? = nil,
        dynamoDbSettings: DynamoDbSettings? = nil,
        elasticsearchSettings: ElasticsearchSettings? = nil,
        endpointArn: String? = nil,
        endpointIdentifier: String? = nil,
        endpointType: ReplicationEndpointTypeValue? = nil,
        engineDisplayName: String? = nil,
        engineName: String? = nil,
        externalId: String? = nil,
        externalTableDefinition: String? = nil,
        extraConnectionAttributes: String? = nil,
        iBMDb2Settings: IBMDb2Settings? = nil,
        kafkaSettings: KafkaSettings? = nil,
        kinesisSettings: KinesisSettings? = nil,
        kmsKeyId: String? = nil,
        microsoftSQLServerSettings: MicrosoftSQLServerSettings? = nil,
        mongoDbSettings: MongoDbSettings? = nil,
        mySQLSettings: MySQLSettings? = nil,
        neptuneSettings: NeptuneSettings? = nil,
        oracleSettings: OracleSettings? = nil,
        port: Int? = nil,
        postgreSQLSettings: PostgreSQLSettings? = nil,
        redshiftSettings: RedshiftSettings? = nil,
        s3Settings: S3Settings? = nil,
        serverName: String? = nil,
        serviceAccessRoleArn: String? = nil,
        sslMode: DmsSslModeValue? = nil,
        status: String? = nil,
        sybaseSettings: SybaseSettings? = nil,
        username: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.databaseName = databaseName
        self.dmsTransferSettings = dmsTransferSettings
        self.docDbSettings = docDbSettings
        self.dynamoDbSettings = dynamoDbSettings
        self.elasticsearchSettings = elasticsearchSettings
        self.endpointArn = endpointArn
        self.endpointIdentifier = endpointIdentifier
        self.endpointType = endpointType
        self.engineDisplayName = engineDisplayName
        self.engineName = engineName
        self.externalId = externalId
        self.externalTableDefinition = externalTableDefinition
        self.extraConnectionAttributes = extraConnectionAttributes
        self.iBMDb2Settings = iBMDb2Settings
        self.kafkaSettings = kafkaSettings
        self.kinesisSettings = kinesisSettings
        self.kmsKeyId = kmsKeyId
        self.microsoftSQLServerSettings = microsoftSQLServerSettings
        self.mongoDbSettings = mongoDbSettings
        self.mySQLSettings = mySQLSettings
        self.neptuneSettings = neptuneSettings
        self.oracleSettings = oracleSettings
        self.port = port
        self.postgreSQLSettings = postgreSQLSettings
        self.redshiftSettings = redshiftSettings
        self.s3Settings = s3Settings
        self.serverName = serverName
        self.serviceAccessRoleArn = serviceAccessRoleArn
        self.sslMode = sslMode
        self.status = status
        self.sybaseSettings = sybaseSettings
        self.username = username
    }
}

extension EndpointSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicability = "Applicability"
        case enumValues = "EnumValues"
        case intValueMax = "IntValueMax"
        case intValueMin = "IntValueMin"
        case name = "Name"
        case sensitive = "Sensitive"
        case type = "Type"
        case units = "Units"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicability = applicability {
            try encodeContainer.encode(applicability, forKey: .applicability)
        }
        if let enumValues = enumValues {
            var enumValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enumValues)
            for endpointsettingenumvalues0 in enumValues {
                try enumValuesContainer.encode(endpointsettingenumvalues0)
            }
        }
        if let intValueMax = intValueMax {
            try encodeContainer.encode(intValueMax, forKey: .intValueMax)
        }
        if let intValueMin = intValueMin {
            try encodeContainer.encode(intValueMin, forKey: .intValueMin)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sensitive = sensitive {
            try encodeContainer.encode(sensitive, forKey: .sensitive)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let units = units {
            try encodeContainer.encode(units, forKey: .units)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EndpointSettingTypeValue.self, forKey: .type)
        type = typeDecoded
        let enumValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .enumValues)
        var enumValuesDecoded0:[String]? = nil
        if let enumValuesContainer = enumValuesContainer {
            enumValuesDecoded0 = [String]()
            for string0 in enumValuesContainer {
                if let string0 = string0 {
                    enumValuesDecoded0?.append(string0)
                }
            }
        }
        enumValues = enumValuesDecoded0
        let sensitiveDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sensitive)
        sensitive = sensitiveDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .units)
        units = unitsDecoded
        let applicabilityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicability)
        applicability = applicabilityDecoded
        let intValueMinDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .intValueMin)
        intValueMin = intValueMinDecoded
        let intValueMaxDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .intValueMax)
        intValueMax = intValueMaxDecoded
    }
}

extension EndpointSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointSetting(applicability: \(String(describing: applicability)), enumValues: \(String(describing: enumValues)), intValueMax: \(String(describing: intValueMax)), intValueMin: \(String(describing: intValueMin)), name: \(String(describing: name)), sensitive: \(String(describing: sensitive)), type: \(String(describing: type)), units: \(String(describing: units)))"}
}

/// <p>Endpoint settings.</p>
public struct EndpointSetting: Equatable {
    /// <p>The relevance or validity of an endpoint setting for an engine name and its endpoint type.</p>
    public let applicability: String?
    /// <p>Enumerated values to use for this endpoint.</p>
    public let enumValues: [String]?
    /// <p>The maximum value of an endpoint setting that is of type <code>int</code>.</p>
    public let intValueMax: Int?
    /// <p>The minimum value of an endpoint setting that is of type <code>int</code>.</p>
    public let intValueMin: Int?
    /// <p>The name that you want to give the endpoint settings.</p>
    public let name: String?
    /// <p>A value that marks this endpoint setting as sensitive.</p>
    public let sensitive: Bool?
    /// <p>The type of endpoint.  Valid values are <code>source</code> and <code>target</code>.</p>
    public let type: EndpointSettingTypeValue?
    /// <p>The unit of measure for this endpoint setting.</p>
    public let units: String?

    public init (
        applicability: String? = nil,
        enumValues: [String]? = nil,
        intValueMax: Int? = nil,
        intValueMin: Int? = nil,
        name: String? = nil,
        sensitive: Bool? = nil,
        type: EndpointSettingTypeValue? = nil,
        units: String? = nil
    )
    {
        self.applicability = applicability
        self.enumValues = enumValues
        self.intValueMax = intValueMax
        self.intValueMin = intValueMin
        self.name = name
        self.sensitive = sensitive
        self.type = type
        self.units = units
    }
}

public enum EndpointSettingTypeValue {
    case boolean
    case `enum`
    case integer
    case string
    case sdkUnknown(String)
}

extension EndpointSettingTypeValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EndpointSettingTypeValue] {
        return [
            .boolean,
            .enum,
            .integer,
            .string,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .boolean: return "boolean"
        case .enum: return "enum"
        case .integer: return "integer"
        case .string: return "string"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EndpointSettingTypeValue(rawValue: rawValue) ?? EndpointSettingTypeValue.sdkUnknown(rawValue)
    }
}

extension Event: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case date = "Date"
        case eventCategories = "EventCategories"
        case message = "Message"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = date {
            try encodeContainer.encode(date.timeIntervalSince1970, forKey: .date)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for eventcategorieslist0 in eventCategories {
                try eventCategoriesContainer.encode(eventcategorieslist0)
            }
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let sourceIdentifier = sourceIdentifier {
            try encodeContainer.encode(sourceIdentifier, forKey: .sourceIdentifier)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let dateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .date)
        date = dateDecoded
    }
}

extension Event: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Event(date: \(String(describing: date)), eventCategories: \(String(describing: eventCategories)), message: \(String(describing: message)), sourceIdentifier: \(String(describing: sourceIdentifier)), sourceType: \(String(describing: sourceType)))"}
}

/// <p>Describes an identifiable significant activity that affects a replication instance or
///          task. This object can provide the message, the available event categories, the date and
///          source of the event, and the AWS DMS resource type.</p>
public struct Event: Equatable {
    /// <p>The date of the event.</p>
    public let date: Date?
    /// <p>The event categories available for the specified source type.</p>
    public let eventCategories: [String]?
    /// <p>The event message.</p>
    public let message: String?
    /// <p> The identifier of an event source.</p>
    public let sourceIdentifier: String?
    /// <p> The type of AWS DMS resource that generates events. </p>
    ///          <p>Valid values: replication-instance | endpoint | replication-task</p>
    public let sourceType: SourceType?

    public init (
        date: Date? = nil,
        eventCategories: [String]? = nil,
        message: String? = nil,
        sourceIdentifier: String? = nil,
        sourceType: SourceType? = nil
    )
    {
        self.date = date
        self.eventCategories = eventCategories
        self.message = message
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
    }
}

extension EventCategoryGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventCategories = "EventCategories"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for eventcategorieslist0 in eventCategories {
                try eventCategoriesContainer.encode(eventcategorieslist0)
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
    }
}

extension EventCategoryGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventCategoryGroup(eventCategories: \(String(describing: eventCategories)), sourceType: \(String(describing: sourceType)))"}
}

/// <p>Lists categories of events subscribed to, and generated by, the applicable AWS DMS
///          resource type. This data type appears in response to the
///          <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_EventCategoryGroup.html">
///                <code>DescribeEventCategories</code>
///             </a>
///          action.</p>
public struct EventCategoryGroup: Equatable {
    /// <p> A list of event categories from a source type that you've chosen.</p>
    public let eventCategories: [String]?
    /// <p> The type of AWS DMS resource that generates events. </p>
    ///          <p>Valid values: replication-instance | replication-server | security-group |
    ///          replication-task</p>
    public let sourceType: String?

    public init (
        eventCategories: [String]? = nil,
        sourceType: String? = nil
    )
    {
        self.eventCategories = eventCategories
        self.sourceType = sourceType
    }
}

extension EventSubscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case custSubscriptionId = "CustSubscriptionId"
        case customerAwsId = "CustomerAwsId"
        case enabled = "Enabled"
        case eventCategoriesList = "EventCategoriesList"
        case snsTopicArn = "SnsTopicArn"
        case sourceIdsList = "SourceIdsList"
        case sourceType = "SourceType"
        case status = "Status"
        case subscriptionCreationTime = "SubscriptionCreationTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let custSubscriptionId = custSubscriptionId {
            try encodeContainer.encode(custSubscriptionId, forKey: .custSubscriptionId)
        }
        if let customerAwsId = customerAwsId {
            try encodeContainer.encode(customerAwsId, forKey: .customerAwsId)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventCategoriesList = eventCategoriesList {
            var eventCategoriesListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategoriesList)
            for eventcategorieslist0 in eventCategoriesList {
                try eventCategoriesListContainer.encode(eventcategorieslist0)
            }
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sourceIdsList = sourceIdsList {
            var sourceIdsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceIdsList)
            for sourceidslist0 in sourceIdsList {
                try sourceIdsListContainer.encode(sourceidslist0)
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subscriptionCreationTime = subscriptionCreationTime {
            try encodeContainer.encode(subscriptionCreationTime, forKey: .subscriptionCreationTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerAwsIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerAwsId)
        customerAwsId = customerAwsIdDecoded
        let custSubscriptionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .custSubscriptionId)
        custSubscriptionId = custSubscriptionIdDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let subscriptionCreationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionCreationTime)
        subscriptionCreationTime = subscriptionCreationTimeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceIdsListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sourceIdsList)
        var sourceIdsListDecoded0:[String]? = nil
        if let sourceIdsListContainer = sourceIdsListContainer {
            sourceIdsListDecoded0 = [String]()
            for string0 in sourceIdsListContainer {
                if let string0 = string0 {
                    sourceIdsListDecoded0?.append(string0)
                }
            }
        }
        sourceIdsList = sourceIdsListDecoded0
        let eventCategoriesListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventCategoriesList)
        var eventCategoriesListDecoded0:[String]? = nil
        if let eventCategoriesListContainer = eventCategoriesListContainer {
            eventCategoriesListDecoded0 = [String]()
            for string0 in eventCategoriesListContainer {
                if let string0 = string0 {
                    eventCategoriesListDecoded0?.append(string0)
                }
            }
        }
        eventCategoriesList = eventCategoriesListDecoded0
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension EventSubscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventSubscription(custSubscriptionId: \(String(describing: custSubscriptionId)), customerAwsId: \(String(describing: customerAwsId)), enabled: \(String(describing: enabled)), eventCategoriesList: \(String(describing: eventCategoriesList)), snsTopicArn: \(String(describing: snsTopicArn)), sourceIdsList: \(String(describing: sourceIdsList)), sourceType: \(String(describing: sourceType)), status: \(String(describing: status)), subscriptionCreationTime: \(String(describing: subscriptionCreationTime)))"}
}

/// <p>Describes an event notification subscription created by the <code>CreateEventSubscription</code>
///          operation.</p>
public struct EventSubscription: Equatable {
    /// <p>The AWS DMS event notification subscription Id.</p>
    public let custSubscriptionId: String?
    /// <p>The AWS customer account associated with the AWS DMS event notification
    ///          subscription.</p>
    public let customerAwsId: String?
    /// <p>Boolean value that indicates if the event subscription is enabled.</p>
    public let enabled: Bool
    /// <p>A lists of event categories.</p>
    public let eventCategoriesList: [String]?
    /// <p>The topic ARN of the AWS DMS event notification subscription.</p>
    public let snsTopicArn: String?
    /// <p>A list of source Ids for the event subscription.</p>
    public let sourceIdsList: [String]?
    /// <p> The type of AWS DMS resource that generates events. </p>
    ///          <p>Valid values: replication-instance | replication-server | security-group |
    ///          replication-task</p>
    public let sourceType: String?
    /// <p>The status of the AWS DMS event notification subscription.</p>
    ///          <p>Constraints:</p>
    ///          <p>Can be one of the following: creating | modifying | deleting | active | no-permission |
    ///          topic-not-exist</p>
    ///          <p>The status "no-permission" indicates that AWS DMS no longer has permission to post to
    ///          the SNS topic. The status "topic-not-exist" indicates that the topic was deleted after the
    ///          subscription was created.</p>
    public let status: String?
    /// <p>The time the AWS DMS event notification subscription was created.</p>
    public let subscriptionCreationTime: String?

    public init (
        custSubscriptionId: String? = nil,
        customerAwsId: String? = nil,
        enabled: Bool = false,
        eventCategoriesList: [String]? = nil,
        snsTopicArn: String? = nil,
        sourceIdsList: [String]? = nil,
        sourceType: String? = nil,
        status: String? = nil,
        subscriptionCreationTime: String? = nil
    )
    {
        self.custSubscriptionId = custSubscriptionId
        self.customerAwsId = customerAwsId
        self.enabled = enabled
        self.eventCategoriesList = eventCategoriesList
        self.snsTopicArn = snsTopicArn
        self.sourceIdsList = sourceIdsList
        self.sourceType = sourceType
        self.status = status
        self.subscriptionCreationTime = subscriptionCreationTime
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervaluelist0 in values {
                try valuesContainer.encode(filtervaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>Identifies the name and value of a filter object. This filter is used to limit the
///          number and type of AWS DMS objects that are returned for a particular
///             <code>Describe*</code> call or similar operation. Filters are used as an optional
///          parameter for certain API operations. </p>
public struct Filter: Equatable {
    /// <p>The name of the filter as specified for a <code>Describe*</code> or similar
    ///          operation.</p>
    public let name: String?
    /// <p>The filter value, which can specify one or more values used to narrow the returned results.</p>
    public let values: [String]?

    public init (
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension IBMDb2Settings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentLsn = "CurrentLsn"
        case databaseName = "DatabaseName"
        case maxKBytesPerRead = "MaxKBytesPerRead"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case setDataCaptureChanges = "SetDataCaptureChanges"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentLsn = currentLsn {
            try encodeContainer.encode(currentLsn, forKey: .currentLsn)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let maxKBytesPerRead = maxKBytesPerRead {
            try encodeContainer.encode(maxKBytesPerRead, forKey: .maxKBytesPerRead)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let setDataCaptureChanges = setDataCaptureChanges {
            try encodeContainer.encode(setDataCaptureChanges, forKey: .setDataCaptureChanges)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let setDataCaptureChangesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .setDataCaptureChanges)
        setDataCaptureChanges = setDataCaptureChangesDecoded
        let currentLsnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentLsn)
        currentLsn = currentLsnDecoded
        let maxKBytesPerReadDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxKBytesPerRead)
        maxKBytesPerRead = maxKBytesPerReadDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension IBMDb2Settings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IBMDb2Settings(currentLsn: \(String(describing: currentLsn)), databaseName: \(String(describing: databaseName)), maxKBytesPerRead: \(String(describing: maxKBytesPerRead)), password: \(String(describing: password)), port: \(String(describing: port)), secretsManagerAccessRoleArn: \(String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(String(describing: secretsManagerSecretId)), serverName: \(String(describing: serverName)), setDataCaptureChanges: \(String(describing: setDataCaptureChanges)), username: \(String(describing: username)))"}
}

/// <p>Provides information that defines an IBM Db2 LUW endpoint.</p>
public struct IBMDb2Settings: Equatable {
    /// <p>For ongoing replication (CDC), use CurrentLSN to specify a
    ///          log sequence number (LSN) where you want the replication
    ///          to start.</p>
    public let currentLsn: String?
    /// <p>Database name for the endpoint.</p>
    public let databaseName: String?
    /// <p>Maximum number of bytes per read, as a NUMBER value.
    ///          The default is 64 KB.</p>
    public let maxKBytesPerRead: Int?
    /// <p>Endpoint connection password.</p>
    public let password: String?
    /// <p>Endpoint TCP port.</p>
    public let port: Int?
    /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
    ///          trusted entity and grants the required permissions to access the value in
    ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of
    ///          the AWS Secrets Manager secret that allows access to the Db2 LUW endpoint. </p>
    ///          <note>
    ///             <p>You can specify one of two sets of values for these permissions. You can specify the
    ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
    ///             clear-text values for <code>UserName</code>, <code>Password</code>,
    ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
    ///             information on creating this <code>SecretsManagerSecret</code> and the
    ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
    ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
    ///                resources</a> in the <i>AWS Database Migration Service User
    ///                Guide</i>.</p>
    ///          </note>
    public let secretsManagerAccessRoleArn: String?
    /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the Db2 LUW endpoint connection details.</p>
    public let secretsManagerSecretId: String?
    /// <p>Fully qualified domain name of the endpoint.</p>
    public let serverName: String?
    /// <p>Enables ongoing replication (CDC) as a BOOLEAN value. The
    ///          default is true.</p>
    public let setDataCaptureChanges: Bool?
    /// <p>Endpoint connection user name.</p>
    public let username: String?

    public init (
        currentLsn: String? = nil,
        databaseName: String? = nil,
        maxKBytesPerRead: Int? = nil,
        password: String? = nil,
        port: Int? = nil,
        secretsManagerAccessRoleArn: String? = nil,
        secretsManagerSecretId: String? = nil,
        serverName: String? = nil,
        setDataCaptureChanges: Bool? = nil,
        username: String? = nil
    )
    {
        self.currentLsn = currentLsn
        self.databaseName = databaseName
        self.maxKBytesPerRead = maxKBytesPerRead
        self.password = password
        self.port = port
        self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
        self.secretsManagerSecretId = secretsManagerSecretId
        self.serverName = serverName
        self.setDataCaptureChanges = setDataCaptureChanges
        self.username = username
    }
}

public struct ImportCertificateInputBodyMiddleware: Middleware {
    public let id: String = "ImportCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportCertificateInput>
    public typealias MOutput = OperationOutput<ImportCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportCertificateOutputError>
}

extension ImportCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportCertificateInput(certificateIdentifier: \(String(describing: certificateIdentifier)), certificatePem: \(String(describing: certificatePem)), certificateWallet: \(String(describing: certificateWallet)), tags: \(String(describing: tags)))"}
}

extension ImportCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateIdentifier = "CertificateIdentifier"
        case certificatePem = "CertificatePem"
        case certificateWallet = "CertificateWallet"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateIdentifier = certificateIdentifier {
            try encodeContainer.encode(certificateIdentifier, forKey: .certificateIdentifier)
        }
        if let certificatePem = certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let certificateWallet = certificateWallet {
            try encodeContainer.encode(certificateWallet.base64EncodedString(), forKey: .certificateWallet)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct ImportCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "ImportCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportCertificateInput>
    public typealias MOutput = OperationOutput<ImportCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportCertificateOutputError>
}

public struct ImportCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportCertificateInput>
    public typealias MOutput = OperationOutput<ImportCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportCertificateOutputError>
}

public struct ImportCertificateInput: Equatable {
    /// <p>A customer-assigned name for the certificate. Identifiers must begin with a letter and
    ///          must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or
    ///          contain two consecutive hyphens.</p>
    public let certificateIdentifier: String?
    /// <p>The contents of a <code>.pem</code> file, which contains an X.509 certificate.</p>
    public let certificatePem: String?
    /// <p>The location of an imported Oracle Wallet certificate for use with SSL.</p>
    public let certificateWallet: Data?
    /// <p>The tags associated with the certificate.</p>
    public let tags: [Tag]?

    public init (
        certificateIdentifier: String? = nil,
        certificatePem: String? = nil,
        certificateWallet: Data? = nil,
        tags: [Tag]? = nil
    )
    {
        self.certificateIdentifier = certificateIdentifier
        self.certificatePem = certificatePem
        self.certificateWallet = certificateWallet
        self.tags = tags
    }
}

struct ImportCertificateInputBody: Equatable {
    public let certificateIdentifier: String?
    public let certificatePem: String?
    public let certificateWallet: Data?
    public let tags: [Tag]?
}

extension ImportCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateIdentifier = "CertificateIdentifier"
        case certificatePem = "CertificatePem"
        case certificateWallet = "CertificateWallet"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateIdentifier)
        certificateIdentifier = certificateIdentifierDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let certificateWalletDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .certificateWallet)
        certificateWallet = certificateWalletDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidCertificateFault" : self = .invalidCertificateFault(try InvalidCertificateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportCertificateOutputError: Equatable {
    case invalidCertificateFault(InvalidCertificateFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportCertificateOutputResponse(certificate: \(String(describing: certificate)))"}
}

extension ImportCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImportCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

public struct ImportCertificateOutputResponse: Equatable {
    /// <p>The certificate to be uploaded.</p>
    public let certificate: Certificate?

    public init (
        certificate: Certificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct ImportCertificateOutputResponseBody: Equatable {
    public let certificate: Certificate?
}

extension ImportCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension InsufficientResourceCapacityFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientResourceCapacityFault(message: \(String(describing: message)))"}
}

extension InsufficientResourceCapacityFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InsufficientResourceCapacityFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There are not enough resources allocated to the database migration.</p>
public struct InsufficientResourceCapacityFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientResourceCapacityFaultBody: Equatable {
    public let message: String?
}

extension InsufficientResourceCapacityFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCertificateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCertificateFault(message: \(String(describing: message)))"}
}

extension InvalidCertificateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidCertificateFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The certificate was not valid.</p>
public struct InvalidCertificateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCertificateFaultBody: Equatable {
    public let message: String?
}

extension InvalidCertificateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResourceStateFault(message: \(String(describing: message)))"}
}

extension InvalidResourceStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidResourceStateFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is in a state that prevents it from being used for database migration.</p>
public struct InvalidResourceStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidResourceStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSubnet(message: \(String(describing: message)))"}
}

extension InvalidSubnet: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSubnetBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The subnet provided is invalid.</p>
public struct InvalidSubnet: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetBody: Equatable {
    public let message: String?
}

extension InvalidSubnetBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSAccessDeniedFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSAccessDeniedFault(message: \(String(describing: message)))"}
}

extension KMSAccessDeniedFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSAccessDeniedFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The ciphertext references a key that doesn't exist or that the DMS account doesn't have access to.</p>
public struct KMSAccessDeniedFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSAccessDeniedFaultBody: Equatable {
    public let message: String?
}

extension KMSAccessDeniedFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSDisabledFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSDisabledFault(message: \(String(describing: message)))"}
}

extension KMSDisabledFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSDisabledFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified master key (CMK) isn't enabled.</p>
public struct KMSDisabledFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSDisabledFaultBody: Equatable {
    public let message: String?
}

extension KMSDisabledFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSFault(message: \(String(describing: message)))"}
}

extension KMSFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An AWS Key Management Service (AWS KMS) error is preventing access to AWS KMS.</p>
public struct KMSFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSFaultBody: Equatable {
    public let message: String?
}

extension KMSFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSInvalidStateFault(message: \(String(describing: message)))"}
}

extension KMSInvalidStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSInvalidStateFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state of the specified AWS KMS resource isn't valid for this request.</p>
public struct KMSInvalidStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSInvalidStateFaultBody: Equatable {
    public let message: String?
}

extension KMSInvalidStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSKeyNotAccessibleFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSKeyNotAccessibleFault(message: \(String(describing: message)))"}
}

extension KMSKeyNotAccessibleFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSKeyNotAccessibleFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS DMS cannot access the AWS KMS key.</p>
public struct KMSKeyNotAccessibleFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSKeyNotAccessibleFaultBody: Equatable {
    public let message: String?
}

extension KMSKeyNotAccessibleFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSNotFoundFault(message: \(String(describing: message)))"}
}

extension KMSNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSNotFoundFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified AWS KMS entity or resource can't be found.</p>
public struct KMSNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSNotFoundFaultBody: Equatable {
    public let message: String?
}

extension KMSNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSThrottlingFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSThrottlingFault(message: \(String(describing: message)))"}
}

extension KMSThrottlingFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSThrottlingFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This request triggered AWS KMS request throttling.</p>
public struct KMSThrottlingFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSThrottlingFaultBody: Equatable {
    public let message: String?
}

extension KMSThrottlingFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum KafkaSecurityProtocol {
    case plaintext
    case saslSsl
    case sslAuthentication
    case sslEncryption
    case sdkUnknown(String)
}

extension KafkaSecurityProtocol : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [KafkaSecurityProtocol] {
        return [
            .plaintext,
            .saslSsl,
            .sslAuthentication,
            .sslEncryption,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .plaintext: return "plaintext"
        case .saslSsl: return "sasl-ssl"
        case .sslAuthentication: return "ssl-authentication"
        case .sslEncryption: return "ssl-encryption"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = KafkaSecurityProtocol(rawValue: rawValue) ?? KafkaSecurityProtocol.sdkUnknown(rawValue)
    }
}

extension KafkaSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case broker = "Broker"
        case includeControlDetails = "IncludeControlDetails"
        case includeNullAndEmpty = "IncludeNullAndEmpty"
        case includePartitionValue = "IncludePartitionValue"
        case includeTableAlterOperations = "IncludeTableAlterOperations"
        case includeTransactionDetails = "IncludeTransactionDetails"
        case messageFormat = "MessageFormat"
        case messageMaxBytes = "MessageMaxBytes"
        case partitionIncludeSchemaTable = "PartitionIncludeSchemaTable"
        case saslPassword = "SaslPassword"
        case saslUsername = "SaslUsername"
        case securityProtocol = "SecurityProtocol"
        case sslCaCertificateArn = "SslCaCertificateArn"
        case sslClientCertificateArn = "SslClientCertificateArn"
        case sslClientKeyArn = "SslClientKeyArn"
        case sslClientKeyPassword = "SslClientKeyPassword"
        case topic = "Topic"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let broker = broker {
            try encodeContainer.encode(broker, forKey: .broker)
        }
        if let includeControlDetails = includeControlDetails {
            try encodeContainer.encode(includeControlDetails, forKey: .includeControlDetails)
        }
        if let includeNullAndEmpty = includeNullAndEmpty {
            try encodeContainer.encode(includeNullAndEmpty, forKey: .includeNullAndEmpty)
        }
        if let includePartitionValue = includePartitionValue {
            try encodeContainer.encode(includePartitionValue, forKey: .includePartitionValue)
        }
        if let includeTableAlterOperations = includeTableAlterOperations {
            try encodeContainer.encode(includeTableAlterOperations, forKey: .includeTableAlterOperations)
        }
        if let includeTransactionDetails = includeTransactionDetails {
            try encodeContainer.encode(includeTransactionDetails, forKey: .includeTransactionDetails)
        }
        if let messageFormat = messageFormat {
            try encodeContainer.encode(messageFormat.rawValue, forKey: .messageFormat)
        }
        if let messageMaxBytes = messageMaxBytes {
            try encodeContainer.encode(messageMaxBytes, forKey: .messageMaxBytes)
        }
        if let partitionIncludeSchemaTable = partitionIncludeSchemaTable {
            try encodeContainer.encode(partitionIncludeSchemaTable, forKey: .partitionIncludeSchemaTable)
        }
        if let saslPassword = saslPassword {
            try encodeContainer.encode(saslPassword, forKey: .saslPassword)
        }
        if let saslUsername = saslUsername {
            try encodeContainer.encode(saslUsername, forKey: .saslUsername)
        }
        if let securityProtocol = securityProtocol {
            try encodeContainer.encode(securityProtocol.rawValue, forKey: .securityProtocol)
        }
        if let sslCaCertificateArn = sslCaCertificateArn {
            try encodeContainer.encode(sslCaCertificateArn, forKey: .sslCaCertificateArn)
        }
        if let sslClientCertificateArn = sslClientCertificateArn {
            try encodeContainer.encode(sslClientCertificateArn, forKey: .sslClientCertificateArn)
        }
        if let sslClientKeyArn = sslClientKeyArn {
            try encodeContainer.encode(sslClientKeyArn, forKey: .sslClientKeyArn)
        }
        if let sslClientKeyPassword = sslClientKeyPassword {
            try encodeContainer.encode(sslClientKeyPassword, forKey: .sslClientKeyPassword)
        }
        if let topic = topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .broker)
        broker = brokerDecoded
        let topicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topic)
        topic = topicDecoded
        let messageFormatDecoded = try containerValues.decodeIfPresent(MessageFormatValue.self, forKey: .messageFormat)
        messageFormat = messageFormatDecoded
        let includeTransactionDetailsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeTransactionDetails)
        includeTransactionDetails = includeTransactionDetailsDecoded
        let includePartitionValueDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includePartitionValue)
        includePartitionValue = includePartitionValueDecoded
        let partitionIncludeSchemaTableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .partitionIncludeSchemaTable)
        partitionIncludeSchemaTable = partitionIncludeSchemaTableDecoded
        let includeTableAlterOperationsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeTableAlterOperations)
        includeTableAlterOperations = includeTableAlterOperationsDecoded
        let includeControlDetailsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeControlDetails)
        includeControlDetails = includeControlDetailsDecoded
        let messageMaxBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .messageMaxBytes)
        messageMaxBytes = messageMaxBytesDecoded
        let includeNullAndEmptyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeNullAndEmpty)
        includeNullAndEmpty = includeNullAndEmptyDecoded
        let securityProtocolDecoded = try containerValues.decodeIfPresent(KafkaSecurityProtocol.self, forKey: .securityProtocol)
        securityProtocol = securityProtocolDecoded
        let sslClientCertificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sslClientCertificateArn)
        sslClientCertificateArn = sslClientCertificateArnDecoded
        let sslClientKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sslClientKeyArn)
        sslClientKeyArn = sslClientKeyArnDecoded
        let sslClientKeyPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sslClientKeyPassword)
        sslClientKeyPassword = sslClientKeyPasswordDecoded
        let sslCaCertificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sslCaCertificateArn)
        sslCaCertificateArn = sslCaCertificateArnDecoded
        let saslUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .saslUsername)
        saslUsername = saslUsernameDecoded
        let saslPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .saslPassword)
        saslPassword = saslPasswordDecoded
    }
}

extension KafkaSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KafkaSettings(broker: \(String(describing: broker)), includeControlDetails: \(String(describing: includeControlDetails)), includeNullAndEmpty: \(String(describing: includeNullAndEmpty)), includePartitionValue: \(String(describing: includePartitionValue)), includeTableAlterOperations: \(String(describing: includeTableAlterOperations)), includeTransactionDetails: \(String(describing: includeTransactionDetails)), messageFormat: \(String(describing: messageFormat)), messageMaxBytes: \(String(describing: messageMaxBytes)), partitionIncludeSchemaTable: \(String(describing: partitionIncludeSchemaTable)), saslPassword: \(String(describing: saslPassword)), saslUsername: \(String(describing: saslUsername)), securityProtocol: \(String(describing: securityProtocol)), sslCaCertificateArn: \(String(describing: sslCaCertificateArn)), sslClientCertificateArn: \(String(describing: sslClientCertificateArn)), sslClientKeyArn: \(String(describing: sslClientKeyArn)), sslClientKeyPassword: \(String(describing: sslClientKeyPassword)), topic: \(String(describing: topic)))"}
}

/// <p>Provides information that describes an Apache Kafka endpoint. This
///          information includes the output format of records applied to the endpoint and details of
///          transaction and control table data information.</p>
public struct KafkaSettings: Equatable {
    /// <p>A comma-separated list of one or more broker locations in your Kafka cluster that host your Kafka instance. Specify each broker location
    ///          in the form <code>
    ///                <i>broker-hostname-or-ip</i>:<i>port</i>
    ///             </code>. For example, <code>"ec2-12-345-678-901.compute-1.amazonaws.com:2345"</code>.
    ///          For more information and examples of specifying a list of broker locations,
    ///          see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html">Using Apache Kafka as a target for AWS Database Migration Service</a>
    ///          in the <i>AWS Data Migration Service User Guide</i>.
    ///       </p>
    public let broker: String?
    /// <p>Shows detailed control information for table definition, column definition, and table
    ///          and column changes in the Kafka message output. The default is <code>false</code>.</p>
    public let includeControlDetails: Bool?
    /// <p>Include NULL and empty columns for records migrated to the endpoint. The default is <code>false</code>.</p>
    public let includeNullAndEmpty: Bool?
    /// <p>Shows the partition value within the Kafka message output, unless the partition type is
    ///             <code>schema-table-type</code>. The default is <code>false</code>.</p>
    public let includePartitionValue: Bool?
    /// <p>Includes any data definition language (DDL) operations that change the table in the
    ///          control data, such as <code>rename-table</code>, <code>drop-table</code>,
    ///             <code>add-column</code>, <code>drop-column</code>, and <code>rename-column</code>. The
    ///          default is <code>false</code>.</p>
    public let includeTableAlterOperations: Bool?
    /// <p>Provides detailed transaction information from the source database. This information
    ///          includes a commit timestamp, a log position, and values for <code>transaction_id</code>,
    ///          previous <code>transaction_id</code>, and <code>transaction_record_id</code> (the record
    ///          offset within a transaction). The default is <code>false</code>.</p>
    public let includeTransactionDetails: Bool?
    /// <p>The output format for the records created on the endpoint. The message format is
    ///             <code>JSON</code> (default) or <code>JSON_UNFORMATTED</code> (a single line with no
    ///          tab).</p>
    public let messageFormat: MessageFormatValue?
    /// <p>The maximum size in bytes for records created on the endpoint The default is 1,000,000.</p>
    public let messageMaxBytes: Int?
    /// <p>Prefixes schema and table names to partition values, when the partition type is
    ///             <code>primary-key-type</code>. Doing this increases data distribution among Kafka
    ///          partitions. For example, suppose that a SysBench schema has thousands of tables and each
    ///          table has only limited range for a primary key. In this case, the same primary key is sent
    ///          from thousands of tables to the same partition, which causes throttling. The default is
    ///             <code>false</code>.</p>
    public let partitionIncludeSchemaTable: Bool?
    /// <p>The secure password you created when you first set up your MSK cluster to validate a client identity and
    ///          make an encrypted connection between server and client using SASL-SSL authentication.</p>
    public let saslPassword: String?
    /// <p> The secure username you created when you first set up your MSK cluster to validate a client identity and
    ///          make an encrypted connection between server and client using SASL-SSL authentication.</p>
    public let saslUsername: String?
    /// <p>Set secure connection to a Kafka target endpoint using Transport Layer Security (TLS). Options include
    ///          <code>ssl-encryption</code>, <code>ssl-authentication</code>, and <code>sasl-ssl</code>.
    ///          <code>sasl-ssl</code> requires <code>SaslUsername</code> and <code>SaslPassword</code>.</p>
    public let securityProtocol: KafkaSecurityProtocol?
    /// <p> The Amazon Resource Name (ARN) for the private Certification Authority (CA) cert that AWS DMS uses
    ///          to securely connect to your Kafka target endpoint.</p>
    public let sslCaCertificateArn: String?
    /// <p>The Amazon Resource Name (ARN) of the client certificate used to securely connect to a Kafka target endpoint.</p>
    public let sslClientCertificateArn: String?
    /// <p>The Amazon Resource Name (ARN) for the client private key used to securely connect to a Kafka target endpoint.</p>
    public let sslClientKeyArn: String?
    /// <p> The password for the client private key used to securely connect to a Kafka target endpoint.</p>
    public let sslClientKeyPassword: String?
    /// <p>The topic to which you migrate the data. If you don't specify a topic, AWS DMS
    ///          specifies <code>"kafka-default-topic"</code> as the migration topic.</p>
    public let topic: String?

    public init (
        broker: String? = nil,
        includeControlDetails: Bool? = nil,
        includeNullAndEmpty: Bool? = nil,
        includePartitionValue: Bool? = nil,
        includeTableAlterOperations: Bool? = nil,
        includeTransactionDetails: Bool? = nil,
        messageFormat: MessageFormatValue? = nil,
        messageMaxBytes: Int? = nil,
        partitionIncludeSchemaTable: Bool? = nil,
        saslPassword: String? = nil,
        saslUsername: String? = nil,
        securityProtocol: KafkaSecurityProtocol? = nil,
        sslCaCertificateArn: String? = nil,
        sslClientCertificateArn: String? = nil,
        sslClientKeyArn: String? = nil,
        sslClientKeyPassword: String? = nil,
        topic: String? = nil
    )
    {
        self.broker = broker
        self.includeControlDetails = includeControlDetails
        self.includeNullAndEmpty = includeNullAndEmpty
        self.includePartitionValue = includePartitionValue
        self.includeTableAlterOperations = includeTableAlterOperations
        self.includeTransactionDetails = includeTransactionDetails
        self.messageFormat = messageFormat
        self.messageMaxBytes = messageMaxBytes
        self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
        self.saslPassword = saslPassword
        self.saslUsername = saslUsername
        self.securityProtocol = securityProtocol
        self.sslCaCertificateArn = sslCaCertificateArn
        self.sslClientCertificateArn = sslClientCertificateArn
        self.sslClientKeyArn = sslClientKeyArn
        self.sslClientKeyPassword = sslClientKeyPassword
        self.topic = topic
    }
}

extension KinesisSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case includeControlDetails = "IncludeControlDetails"
        case includeNullAndEmpty = "IncludeNullAndEmpty"
        case includePartitionValue = "IncludePartitionValue"
        case includeTableAlterOperations = "IncludeTableAlterOperations"
        case includeTransactionDetails = "IncludeTransactionDetails"
        case messageFormat = "MessageFormat"
        case partitionIncludeSchemaTable = "PartitionIncludeSchemaTable"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case streamArn = "StreamArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeControlDetails = includeControlDetails {
            try encodeContainer.encode(includeControlDetails, forKey: .includeControlDetails)
        }
        if let includeNullAndEmpty = includeNullAndEmpty {
            try encodeContainer.encode(includeNullAndEmpty, forKey: .includeNullAndEmpty)
        }
        if let includePartitionValue = includePartitionValue {
            try encodeContainer.encode(includePartitionValue, forKey: .includePartitionValue)
        }
        if let includeTableAlterOperations = includeTableAlterOperations {
            try encodeContainer.encode(includeTableAlterOperations, forKey: .includeTableAlterOperations)
        }
        if let includeTransactionDetails = includeTransactionDetails {
            try encodeContainer.encode(includeTransactionDetails, forKey: .includeTransactionDetails)
        }
        if let messageFormat = messageFormat {
            try encodeContainer.encode(messageFormat.rawValue, forKey: .messageFormat)
        }
        if let partitionIncludeSchemaTable = partitionIncludeSchemaTable {
            try encodeContainer.encode(partitionIncludeSchemaTable, forKey: .partitionIncludeSchemaTable)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let streamArn = streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let messageFormatDecoded = try containerValues.decodeIfPresent(MessageFormatValue.self, forKey: .messageFormat)
        messageFormat = messageFormatDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let includeTransactionDetailsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeTransactionDetails)
        includeTransactionDetails = includeTransactionDetailsDecoded
        let includePartitionValueDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includePartitionValue)
        includePartitionValue = includePartitionValueDecoded
        let partitionIncludeSchemaTableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .partitionIncludeSchemaTable)
        partitionIncludeSchemaTable = partitionIncludeSchemaTableDecoded
        let includeTableAlterOperationsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeTableAlterOperations)
        includeTableAlterOperations = includeTableAlterOperationsDecoded
        let includeControlDetailsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeControlDetails)
        includeControlDetails = includeControlDetailsDecoded
        let includeNullAndEmptyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeNullAndEmpty)
        includeNullAndEmpty = includeNullAndEmptyDecoded
    }
}

extension KinesisSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisSettings(includeControlDetails: \(String(describing: includeControlDetails)), includeNullAndEmpty: \(String(describing: includeNullAndEmpty)), includePartitionValue: \(String(describing: includePartitionValue)), includeTableAlterOperations: \(String(describing: includeTableAlterOperations)), includeTransactionDetails: \(String(describing: includeTransactionDetails)), messageFormat: \(String(describing: messageFormat)), partitionIncludeSchemaTable: \(String(describing: partitionIncludeSchemaTable)), serviceAccessRoleArn: \(String(describing: serviceAccessRoleArn)), streamArn: \(String(describing: streamArn)))"}
}

/// <p>Provides information that describes an Amazon Kinesis Data Stream endpoint. This
///          information includes the output format of records applied to the endpoint and details of
///          transaction and control table data information.</p>
public struct KinesisSettings: Equatable {
    /// <p>Shows detailed control information for table definition, column definition, and table
    ///          and column changes in the Kinesis message output. The default is <code>false</code>.</p>
    public let includeControlDetails: Bool?
    /// <p>Include NULL and empty columns for records migrated to the endpoint. The default is <code>false</code>.</p>
    public let includeNullAndEmpty: Bool?
    /// <p>Shows the partition value within the Kinesis message output, unless the partition type
    ///          is <code>schema-table-type</code>. The default is <code>false</code>.</p>
    public let includePartitionValue: Bool?
    /// <p>Includes any data definition language (DDL) operations that change the table in the
    ///          control data, such as <code>rename-table</code>, <code>drop-table</code>,
    ///             <code>add-column</code>, <code>drop-column</code>, and <code>rename-column</code>. The
    ///          default is <code>false</code>.</p>
    public let includeTableAlterOperations: Bool?
    /// <p>Provides detailed transaction information from the source database. This information
    ///          includes a commit timestamp, a log position, and values for <code>transaction_id</code>,
    ///          previous <code>transaction_id</code>, and <code>transaction_record_id</code> (the record
    ///          offset within a transaction). The default is <code>false</code>.</p>
    public let includeTransactionDetails: Bool?
    /// <p>The output format for the records created on the endpoint. The message format is
    ///          <code>JSON</code> (default) or <code>JSON_UNFORMATTED</code> (a single line with no tab).</p>
    public let messageFormat: MessageFormatValue?
    /// <p>Prefixes schema and table names to partition values, when the partition type is
    ///             <code>primary-key-type</code>. Doing this increases data distribution among Kinesis
    ///          shards. For example, suppose that a SysBench schema has thousands of tables and each table
    ///          has only limited range for a primary key. In this case, the same primary key is sent from
    ///          thousands of tables to the same shard, which causes throttling. The default is <code>false</code>.</p>
    public let partitionIncludeSchemaTable: Bool?
    /// <p>The Amazon Resource Name (ARN) for the AWS Identity and Access Management (IAM) role
    ///          that AWS DMS uses to write to the Kinesis data stream.</p>
    public let serviceAccessRoleArn: String?
    /// <p>The Amazon Resource Name (ARN) for the Amazon Kinesis Data Streams endpoint.</p>
    public let streamArn: String?

    public init (
        includeControlDetails: Bool? = nil,
        includeNullAndEmpty: Bool? = nil,
        includePartitionValue: Bool? = nil,
        includeTableAlterOperations: Bool? = nil,
        includeTransactionDetails: Bool? = nil,
        messageFormat: MessageFormatValue? = nil,
        partitionIncludeSchemaTable: Bool? = nil,
        serviceAccessRoleArn: String? = nil,
        streamArn: String? = nil
    )
    {
        self.includeControlDetails = includeControlDetails
        self.includeNullAndEmpty = includeNullAndEmpty
        self.includePartitionValue = includePartitionValue
        self.includeTableAlterOperations = includeTableAlterOperations
        self.includeTransactionDetails = includeTransactionDetails
        self.messageFormat = messageFormat
        self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
        self.serviceAccessRoleArn = serviceAccessRoleArn
        self.streamArn = streamArn
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

/// <p></p>
public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the AWS DMS
    ///          resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tagList: \(String(describing: tagList)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

/// <p></p>
public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A list of tags for the resource.</p>
    public let tagList: [Tag]?

    public init (
        tagList: [Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tagList: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

public enum MessageFormatValue {
    case json
    case jsonUnformatted
    case sdkUnknown(String)
}

extension MessageFormatValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MessageFormatValue] {
        return [
            .json,
            .jsonUnformatted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .json: return "json"
        case .jsonUnformatted: return "json-unformatted"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MessageFormatValue(rawValue: rawValue) ?? MessageFormatValue.sdkUnknown(rawValue)
    }
}

extension MicrosoftSQLServerSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bcpPacketSize = "BcpPacketSize"
        case controlTablesFileGroup = "ControlTablesFileGroup"
        case databaseName = "DatabaseName"
        case password = "Password"
        case port = "Port"
        case querySingleAlwaysOnNode = "QuerySingleAlwaysOnNode"
        case readBackupOnly = "ReadBackupOnly"
        case safeguardPolicy = "SafeguardPolicy"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case useBcpFullLoad = "UseBcpFullLoad"
        case useThirdPartyBackupDevice = "UseThirdPartyBackupDevice"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bcpPacketSize = bcpPacketSize {
            try encodeContainer.encode(bcpPacketSize, forKey: .bcpPacketSize)
        }
        if let controlTablesFileGroup = controlTablesFileGroup {
            try encodeContainer.encode(controlTablesFileGroup, forKey: .controlTablesFileGroup)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let querySingleAlwaysOnNode = querySingleAlwaysOnNode {
            try encodeContainer.encode(querySingleAlwaysOnNode, forKey: .querySingleAlwaysOnNode)
        }
        if let readBackupOnly = readBackupOnly {
            try encodeContainer.encode(readBackupOnly, forKey: .readBackupOnly)
        }
        if let safeguardPolicy = safeguardPolicy {
            try encodeContainer.encode(safeguardPolicy.rawValue, forKey: .safeguardPolicy)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let useBcpFullLoad = useBcpFullLoad {
            try encodeContainer.encode(useBcpFullLoad, forKey: .useBcpFullLoad)
        }
        if let useThirdPartyBackupDevice = useThirdPartyBackupDevice {
            try encodeContainer.encode(useThirdPartyBackupDevice, forKey: .useThirdPartyBackupDevice)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let bcpPacketSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .bcpPacketSize)
        bcpPacketSize = bcpPacketSizeDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let controlTablesFileGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .controlTablesFileGroup)
        controlTablesFileGroup = controlTablesFileGroupDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let querySingleAlwaysOnNodeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .querySingleAlwaysOnNode)
        querySingleAlwaysOnNode = querySingleAlwaysOnNodeDecoded
        let readBackupOnlyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .readBackupOnly)
        readBackupOnly = readBackupOnlyDecoded
        let safeguardPolicyDecoded = try containerValues.decodeIfPresent(SafeguardPolicy.self, forKey: .safeguardPolicy)
        safeguardPolicy = safeguardPolicyDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let useBcpFullLoadDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useBcpFullLoad)
        useBcpFullLoad = useBcpFullLoadDecoded
        let useThirdPartyBackupDeviceDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useThirdPartyBackupDevice)
        useThirdPartyBackupDevice = useThirdPartyBackupDeviceDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension MicrosoftSQLServerSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MicrosoftSQLServerSettings(bcpPacketSize: \(String(describing: bcpPacketSize)), controlTablesFileGroup: \(String(describing: controlTablesFileGroup)), databaseName: \(String(describing: databaseName)), password: \(String(describing: password)), port: \(String(describing: port)), querySingleAlwaysOnNode: \(String(describing: querySingleAlwaysOnNode)), readBackupOnly: \(String(describing: readBackupOnly)), safeguardPolicy: \(String(describing: safeguardPolicy)), secretsManagerAccessRoleArn: \(String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(String(describing: secretsManagerSecretId)), serverName: \(String(describing: serverName)), useBcpFullLoad: \(String(describing: useBcpFullLoad)), useThirdPartyBackupDevice: \(String(describing: useThirdPartyBackupDevice)), username: \(String(describing: username)))"}
}

/// <p>Provides information that defines a Microsoft SQL Server endpoint.</p>
public struct MicrosoftSQLServerSettings: Equatable {
    /// <p>The maximum size of the packets (in bytes) used to transfer
    ///          data using BCP.</p>
    public let bcpPacketSize: Int?
    /// <p>Specifies a file group for the AWS DMS internal tables. When the replication task
    ///          starts, all the internal AWS DMS control tables (awsdms_ apply_exception, awsdms_apply,
    ///          awsdms_changes) are created for the specified file group.</p>
    public let controlTablesFileGroup: String?
    /// <p>Database name for the endpoint.</p>
    public let databaseName: String?
    /// <p>Endpoint connection password.</p>
    public let password: String?
    /// <p>Endpoint TCP port.</p>
    public let port: Int?
    /// <p>Cleans and recreates table metadata information on the replication instance when
    ///          a mismatch occurs. An example is a situation where running an alter DDL statement on
    ///          a table might result in different information about the table cached in the replication
    ///          instance.</p>
    public let querySingleAlwaysOnNode: Bool?
    /// <p>When this attribute is set to <code>Y</code>, AWS DMS only reads changes
    ///          from transaction log backups and doesn't read from the
    ///          active transaction log file during ongoing replication. Setting
    ///          this parameter to <code>Y</code> enables you to control active transaction
    ///          log file growth during full load and ongoing replication
    ///          tasks. However, it can add some source latency to ongoing
    ///          replication.</p>
    public let readBackupOnly: Bool?
    /// <p>Use this attribute to minimize the need to access the
    ///          backup log and enable AWS DMS to prevent truncation using one of the
    ///          following two methods.</p>
    ///          <p>
    ///             <i>Start transactions in the database:</i> This is the default
    ///          method. When this method is used, AWS DMS prevents
    ///          TLOG truncation by mimicking a transaction in the database.
    ///          As long as such a transaction is open, changes that appear
    ///          after the transaction started aren't truncated. If you need
    ///          Microsoft Replication to be enabled in your database, then
    ///          you must choose this method.</p>
    ///          <p>
    ///             <i>Exclusively use sp_repldone within a single task</i>: When
    ///          this method is used, AWS DMS reads the changes and then
    ///          uses sp_repldone to mark the TLOG transactions as ready
    ///          for truncation. Although this method doesn't involve any
    ///          transactional activities, it can only be used when Microsoft
    ///          Replication isn't running. Also, when using this method, only
    ///          one AWS DMS task can access the database at any given
    ///          time. Therefore, if you need to run parallel AWS DMS tasks
    ///          against the same database, use the default method.</p>
    public let safeguardPolicy: SafeguardPolicy?
    /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
    ///          trusted entity and grants the required permissions to access the value in
    ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
    ///          Manager secret that allows access to the SQL Server endpoint.</p>
    ///          <note>
    ///             <p>You can specify one of two sets of values for these permissions. You can specify the
    ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
    ///             clear-text values for <code>UserName</code>, <code>Password</code>,
    ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
    ///             information on creating this <code>SecretsManagerSecret</code> and the
    ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
    ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
    ///                resources</a> in the <i>AWS Database Migration Service User
    ///                Guide</i>.</p>
    ///          </note>
    public let secretsManagerAccessRoleArn: String?
    /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the SQL Server endpoint connection details.</p>
    public let secretsManagerSecretId: String?
    /// <p>Fully qualified domain name of the endpoint.</p>
    public let serverName: String?
    /// <p>Use this to attribute to transfer data for full-load operations
    ///          using BCP. When the target table contains an identity
    ///          column that does not exist in the source table, you must
    ///          disable the use BCP for loading table option.</p>
    public let useBcpFullLoad: Bool?
    /// <p>When this attribute is set to <code>Y</code>, DMS processes third-party
    ///          transaction log backups if they are created in native format.</p>
    public let useThirdPartyBackupDevice: Bool?
    /// <p>Endpoint connection user name.</p>
    public let username: String?

    public init (
        bcpPacketSize: Int? = nil,
        controlTablesFileGroup: String? = nil,
        databaseName: String? = nil,
        password: String? = nil,
        port: Int? = nil,
        querySingleAlwaysOnNode: Bool? = nil,
        readBackupOnly: Bool? = nil,
        safeguardPolicy: SafeguardPolicy? = nil,
        secretsManagerAccessRoleArn: String? = nil,
        secretsManagerSecretId: String? = nil,
        serverName: String? = nil,
        useBcpFullLoad: Bool? = nil,
        useThirdPartyBackupDevice: Bool? = nil,
        username: String? = nil
    )
    {
        self.bcpPacketSize = bcpPacketSize
        self.controlTablesFileGroup = controlTablesFileGroup
        self.databaseName = databaseName
        self.password = password
        self.port = port
        self.querySingleAlwaysOnNode = querySingleAlwaysOnNode
        self.readBackupOnly = readBackupOnly
        self.safeguardPolicy = safeguardPolicy
        self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
        self.secretsManagerSecretId = secretsManagerSecretId
        self.serverName = serverName
        self.useBcpFullLoad = useBcpFullLoad
        self.useThirdPartyBackupDevice = useThirdPartyBackupDevice
        self.username = username
    }
}

public enum MigrationTypeValue {
    case cdc
    case fullLoad
    case fullLoadAndCdc
    case sdkUnknown(String)
}

extension MigrationTypeValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MigrationTypeValue] {
        return [
            .cdc,
            .fullLoad,
            .fullLoadAndCdc,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cdc: return "cdc"
        case .fullLoad: return "full-load"
        case .fullLoadAndCdc: return "full-load-and-cdc"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MigrationTypeValue(rawValue: rawValue) ?? MigrationTypeValue.sdkUnknown(rawValue)
    }
}

public struct ModifyEndpointInputBodyMiddleware: Middleware {
    public let id: String = "ModifyEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEndpointInput>
    public typealias MOutput = OperationOutput<ModifyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEndpointOutputError>
}

extension ModifyEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyEndpointInput(certificateArn: \(String(describing: certificateArn)), databaseName: \(String(describing: databaseName)), dmsTransferSettings: \(String(describing: dmsTransferSettings)), docDbSettings: \(String(describing: docDbSettings)), dynamoDbSettings: \(String(describing: dynamoDbSettings)), elasticsearchSettings: \(String(describing: elasticsearchSettings)), endpointArn: \(String(describing: endpointArn)), endpointIdentifier: \(String(describing: endpointIdentifier)), endpointType: \(String(describing: endpointType)), engineName: \(String(describing: engineName)), externalTableDefinition: \(String(describing: externalTableDefinition)), extraConnectionAttributes: \(String(describing: extraConnectionAttributes)), iBMDb2Settings: \(String(describing: iBMDb2Settings)), kafkaSettings: \(String(describing: kafkaSettings)), kinesisSettings: \(String(describing: kinesisSettings)), microsoftSQLServerSettings: \(String(describing: microsoftSQLServerSettings)), mongoDbSettings: \(String(describing: mongoDbSettings)), mySQLSettings: \(String(describing: mySQLSettings)), neptuneSettings: \(String(describing: neptuneSettings)), oracleSettings: \(String(describing: oracleSettings)), password: \(String(describing: password)), port: \(String(describing: port)), postgreSQLSettings: \(String(describing: postgreSQLSettings)), redshiftSettings: \(String(describing: redshiftSettings)), s3Settings: \(String(describing: s3Settings)), serverName: \(String(describing: serverName)), serviceAccessRoleArn: \(String(describing: serviceAccessRoleArn)), sslMode: \(String(describing: sslMode)), sybaseSettings: \(String(describing: sybaseSettings)), username: \(String(describing: username)))"}
}

extension ModifyEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case iBMDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redshiftSettings = "RedshiftSettings"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dmsTransferSettings = dmsTransferSettings {
            try encodeContainer.encode(dmsTransferSettings, forKey: .dmsTransferSettings)
        }
        if let docDbSettings = docDbSettings {
            try encodeContainer.encode(docDbSettings, forKey: .docDbSettings)
        }
        if let dynamoDbSettings = dynamoDbSettings {
            try encodeContainer.encode(dynamoDbSettings, forKey: .dynamoDbSettings)
        }
        if let elasticsearchSettings = elasticsearchSettings {
            try encodeContainer.encode(elasticsearchSettings, forKey: .elasticsearchSettings)
        }
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let endpointIdentifier = endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineName = engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let externalTableDefinition = externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let extraConnectionAttributes = extraConnectionAttributes {
            try encodeContainer.encode(extraConnectionAttributes, forKey: .extraConnectionAttributes)
        }
        if let iBMDb2Settings = iBMDb2Settings {
            try encodeContainer.encode(iBMDb2Settings, forKey: .iBMDb2Settings)
        }
        if let kafkaSettings = kafkaSettings {
            try encodeContainer.encode(kafkaSettings, forKey: .kafkaSettings)
        }
        if let kinesisSettings = kinesisSettings {
            try encodeContainer.encode(kinesisSettings, forKey: .kinesisSettings)
        }
        if let microsoftSQLServerSettings = microsoftSQLServerSettings {
            try encodeContainer.encode(microsoftSQLServerSettings, forKey: .microsoftSQLServerSettings)
        }
        if let mongoDbSettings = mongoDbSettings {
            try encodeContainer.encode(mongoDbSettings, forKey: .mongoDbSettings)
        }
        if let mySQLSettings = mySQLSettings {
            try encodeContainer.encode(mySQLSettings, forKey: .mySQLSettings)
        }
        if let neptuneSettings = neptuneSettings {
            try encodeContainer.encode(neptuneSettings, forKey: .neptuneSettings)
        }
        if let oracleSettings = oracleSettings {
            try encodeContainer.encode(oracleSettings, forKey: .oracleSettings)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let postgreSQLSettings = postgreSQLSettings {
            try encodeContainer.encode(postgreSQLSettings, forKey: .postgreSQLSettings)
        }
        if let redshiftSettings = redshiftSettings {
            try encodeContainer.encode(redshiftSettings, forKey: .redshiftSettings)
        }
        if let s3Settings = s3Settings {
            try encodeContainer.encode(s3Settings, forKey: .s3Settings)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let sslMode = sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
        if let sybaseSettings = sybaseSettings {
            try encodeContainer.encode(sybaseSettings, forKey: .sybaseSettings)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct ModifyEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEndpointInput>
    public typealias MOutput = OperationOutput<ModifyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEndpointOutputError>
}

public struct ModifyEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEndpointInput>
    public typealias MOutput = OperationOutput<ModifyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEndpointOutputError>
}

/// <p></p>
public struct ModifyEndpointInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the certificate used for SSL connection.</p>
    public let certificateArn: String?
    /// <p>The name of the endpoint database.</p>
    public let databaseName: String?
    /// <p>The settings in JSON format for the DMS transfer type of source endpoint. </p>
    ///          <p>Attributes include the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>serviceAccessRoleArn - The AWS Identity and Access Management (IAM) role that has
    ///                permission to access the Amazon S3 bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>BucketName - The name of the S3 bucket to use.</p>
    ///             </li>
    ///             <li>
    ///                <p>compressionType - An optional parameter to use GZIP to compress the target files.
    ///                Either set this parameter to NONE (the default) or don't use it to leave the
    ///                files uncompressed.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Shorthand syntax for these settings is as follows: <code>ServiceAccessRoleArn=string
    ///             ,BucketName=string,CompressionType=string</code>
    ///          </p>
    ///          <p>JSON syntax for these settings is as follows: <code>{ "ServiceAccessRoleArn": "string",
    ///             "BucketName": "string", "CompressionType": "none"|"gzip" } </code>
    ///          </p>
    public let dmsTransferSettings: DmsTransferSettings?
    /// <p>Settings in JSON format for the source DocumentDB endpoint. For more information about the
    ///          available settings, see the configuration properties section in <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DocumentDB.html"> Using DocumentDB as a Target for AWS
    ///             Database Migration Service</a> in the <i>AWS Database Migration Service User
    ///                Guide.</i>
    ///          </p>
    public let docDbSettings: DocDbSettings?
    /// <p>Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other
    ///             available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.DynamoDB.html">Using Object Mapping to Migrate
    ///             Data to DynamoDB</a> in the <i>AWS Database Migration Service User
    ///             Guide.</i>
    ///          </p>
    public let dynamoDbSettings: DynamoDbSettings?
    /// <p>Settings in JSON format for the target Elasticsearch endpoint. For more information
    ///          about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Elasticsearch.html#CHAP_Target.Elasticsearch.Configuration">Extra Connection Attributes When Using Elasticsearch as a Target for AWS DMS</a> in
    ///          the <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let elasticsearchSettings: ElasticsearchSettings?
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: String?
    /// <p>The database endpoint identifier. Identifiers must begin with a letter and must contain
    ///          only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two
    ///          consecutive hyphens.</p>
    public let endpointIdentifier: String?
    /// <p>The type of endpoint.  Valid values are <code>source</code> and <code>target</code>.</p>
    public let endpointType: ReplicationEndpointTypeValue?
    /// <p>The type of engine for the endpoint. Valid values, depending on the EndpointType,
    ///          include
    ///          <code>"mysql"</code>, <code>"oracle"</code>, <code>"postgres"</code>,
    ///          <code>"mariadb"</code>, <code>"aurora"</code>, <code>"aurora-postgresql"</code>,
    ///          <code>"redshift"</code>, <code>"s3"</code>, <code>"db2"</code>, <code>"azuredb"</code>,
    ///          <code>"sybase"</code>, <code>"dynamodb"</code>, <code>"mongodb"</code>,
    ///          <code>"kinesis"</code>, <code>"kafka"</code>, <code>"elasticsearch"</code>,
    ///          <code>"documentdb"</code>, <code>"sqlserver"</code>, and <code>"neptune"</code>.</p>
    public let engineName: String?
    /// <p>The external table definition.</p>
    public let externalTableDefinition: String?
    /// <p>Additional attributes associated with the connection. To reset this parameter, pass the
    ///          empty string ("") as an argument.</p>
    public let extraConnectionAttributes: String?
    /// <p>Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other
    ///          available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DB2.ConnectionAttrib">Extra connection attributes
    ///             when using Db2 LUW as a source for AWS DMS</a> in the <i>AWS Database
    ///             Migration Service User Guide.</i>
    ///          </p>
    public let iBMDb2Settings: IBMDb2Settings?
    /// <p>Settings in JSON format for the target Apache Kafka endpoint. For more information about
    ///          the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html">Using Apache Kafka as a Target for AWS
    ///             Database Migration Service</a> in the <i>AWS Database Migration Service User
    ///                Guide.</i>
    ///          </p>
    public let kafkaSettings: KafkaSettings?
    /// <p>Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For
    ///          more information about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kinesis.html">Using Amazon Kinesis Data Streams
    ///             as a Target for AWS Database Migration Service</a> in the <i>AWS Database Migration Service User
    ///                Guide.</i>
    ///          </p>
    public let kinesisSettings: KinesisSettings?
    /// <p>Settings in JSON format for the source and target Microsoft SQL Server endpoint. For
    ///          information about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SQLServer.ConnectionAttrib">Extra connection
    ///             attributes when using SQL Server as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SQLServer.ConnectionAttrib">
    ///             Extra connection attributes when using SQL Server as a target for AWS DMS</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let microsoftSQLServerSettings: MicrosoftSQLServerSettings?
    /// <p>Settings in JSON format for the source MongoDB endpoint. For more information about the
    ///          available settings, see the configuration properties section in <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MongoDB.html"> Using MongoDB as a Target for AWS
    ///             Database Migration Service</a> in the <i>AWS Database Migration Service User
    ///             Guide.</i>
    ///          </p>
    public let mongoDbSettings: MongoDbSettings?
    /// <p>Settings in JSON format for the source and target MySQL endpoint. For information about
    ///          other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MySQL.ConnectionAttrib">Extra connection
    ///             attributes when using MySQL as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.MySQL.ConnectionAttrib">Extra
    ///             connection attributes when using a MySQL-compatible database as a target for AWS
    ///             DMS</a> in the <i>AWS Database Migration Service User
    ///          Guide.</i>
    ///          </p>
    public let mySQLSettings: MySQLSettings?
    /// <p>Settings in JSON format for the target Amazon Neptune endpoint. For more information
    ///          about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.EndpointSettings">Specifying Endpoint Settings for Amazon Neptune as a Target</a>
    ///          in the <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let neptuneSettings: NeptuneSettings?
    /// <p>Settings in JSON format for the source and target Oracle endpoint. For information about
    ///          other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.ConnectionAttrib">Extra connection
    ///             attributes when using Oracle as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Oracle.ConnectionAttrib">
    ///             Extra connection attributes when using Oracle as a target for AWS DMS</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let oracleSettings: OracleSettings?
    /// <p>The password to be used to login to the endpoint database.</p>
    public let password: String?
    /// <p>The port used by the endpoint database.</p>
    public let port: Int?
    /// <p>Settings in JSON format for the source and target PostgreSQL endpoint. For information
    ///          about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.ConnectionAttrib">Extra connection
    ///             attributes when using PostgreSQL as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.PostgreSQL.ConnectionAttrib">
    ///             Extra connection attributes when using PostgreSQL as a target for AWS DMS</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let postgreSQLSettings: PostgreSQLSettings?
    /// <p>Provides information that defines an Amazon Redshift endpoint.</p>
    public let redshiftSettings: RedshiftSettings?
    /// <p>Settings in JSON format for the target Amazon S3 endpoint. For more information about
    ///             the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring">Extra
    ///             Connection Attributes When Using Amazon S3 as a Target for AWS DMS</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let s3Settings: S3Settings?
    /// <p>The name of the server where the endpoint database resides.</p>
    public let serverName: String?
    /// <p> The Amazon Resource Name (ARN) for the service access role you want to use to modify
    ///          the endpoint. </p>
    public let serviceAccessRoleArn: String?
    /// <p>The SSL mode used to connect to the endpoint.  The default value is <code>none</code>.</p>
    public let sslMode: DmsSslModeValue?
    /// <p>Settings in JSON format for the source and target SAP ASE endpoint. For information
    ///          about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SAP.ConnectionAttrib">Extra connection attributes
    ///             when using SAP ASE as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SAP.ConnectionAttrib">Extra connection attributes
    ///             when using SAP ASE as a target for AWS DMS</a> in the <i>AWS Database
    ///             Migration Service User Guide.</i>
    ///          </p>
    public let sybaseSettings: SybaseSettings?
    /// <p>The user name to be used to login to the endpoint database.</p>
    public let username: String?

    public init (
        certificateArn: String? = nil,
        databaseName: String? = nil,
        dmsTransferSettings: DmsTransferSettings? = nil,
        docDbSettings: DocDbSettings? = nil,
        dynamoDbSettings: DynamoDbSettings? = nil,
        elasticsearchSettings: ElasticsearchSettings? = nil,
        endpointArn: String? = nil,
        endpointIdentifier: String? = nil,
        endpointType: ReplicationEndpointTypeValue? = nil,
        engineName: String? = nil,
        externalTableDefinition: String? = nil,
        extraConnectionAttributes: String? = nil,
        iBMDb2Settings: IBMDb2Settings? = nil,
        kafkaSettings: KafkaSettings? = nil,
        kinesisSettings: KinesisSettings? = nil,
        microsoftSQLServerSettings: MicrosoftSQLServerSettings? = nil,
        mongoDbSettings: MongoDbSettings? = nil,
        mySQLSettings: MySQLSettings? = nil,
        neptuneSettings: NeptuneSettings? = nil,
        oracleSettings: OracleSettings? = nil,
        password: String? = nil,
        port: Int? = nil,
        postgreSQLSettings: PostgreSQLSettings? = nil,
        redshiftSettings: RedshiftSettings? = nil,
        s3Settings: S3Settings? = nil,
        serverName: String? = nil,
        serviceAccessRoleArn: String? = nil,
        sslMode: DmsSslModeValue? = nil,
        sybaseSettings: SybaseSettings? = nil,
        username: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.databaseName = databaseName
        self.dmsTransferSettings = dmsTransferSettings
        self.docDbSettings = docDbSettings
        self.dynamoDbSettings = dynamoDbSettings
        self.elasticsearchSettings = elasticsearchSettings
        self.endpointArn = endpointArn
        self.endpointIdentifier = endpointIdentifier
        self.endpointType = endpointType
        self.engineName = engineName
        self.externalTableDefinition = externalTableDefinition
        self.extraConnectionAttributes = extraConnectionAttributes
        self.iBMDb2Settings = iBMDb2Settings
        self.kafkaSettings = kafkaSettings
        self.kinesisSettings = kinesisSettings
        self.microsoftSQLServerSettings = microsoftSQLServerSettings
        self.mongoDbSettings = mongoDbSettings
        self.mySQLSettings = mySQLSettings
        self.neptuneSettings = neptuneSettings
        self.oracleSettings = oracleSettings
        self.password = password
        self.port = port
        self.postgreSQLSettings = postgreSQLSettings
        self.redshiftSettings = redshiftSettings
        self.s3Settings = s3Settings
        self.serverName = serverName
        self.serviceAccessRoleArn = serviceAccessRoleArn
        self.sslMode = sslMode
        self.sybaseSettings = sybaseSettings
        self.username = username
    }
}

struct ModifyEndpointInputBody: Equatable {
    public let endpointArn: String?
    public let endpointIdentifier: String?
    public let endpointType: ReplicationEndpointTypeValue?
    public let engineName: String?
    public let username: String?
    public let password: String?
    public let serverName: String?
    public let port: Int?
    public let databaseName: String?
    public let extraConnectionAttributes: String?
    public let certificateArn: String?
    public let sslMode: DmsSslModeValue?
    public let serviceAccessRoleArn: String?
    public let externalTableDefinition: String?
    public let dynamoDbSettings: DynamoDbSettings?
    public let s3Settings: S3Settings?
    public let dmsTransferSettings: DmsTransferSettings?
    public let mongoDbSettings: MongoDbSettings?
    public let kinesisSettings: KinesisSettings?
    public let kafkaSettings: KafkaSettings?
    public let elasticsearchSettings: ElasticsearchSettings?
    public let neptuneSettings: NeptuneSettings?
    public let redshiftSettings: RedshiftSettings?
    public let postgreSQLSettings: PostgreSQLSettings?
    public let mySQLSettings: MySQLSettings?
    public let oracleSettings: OracleSettings?
    public let sybaseSettings: SybaseSettings?
    public let microsoftSQLServerSettings: MicrosoftSQLServerSettings?
    public let iBMDb2Settings: IBMDb2Settings?
    public let docDbSettings: DocDbSettings?
}

extension ModifyEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case iBMDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redshiftSettings = "RedshiftSettings"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let extraConnectionAttributesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extraConnectionAttributes)
        extraConnectionAttributes = extraConnectionAttributesDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let dynamoDbSettingsDecoded = try containerValues.decodeIfPresent(DynamoDbSettings.self, forKey: .dynamoDbSettings)
        dynamoDbSettings = dynamoDbSettingsDecoded
        let s3SettingsDecoded = try containerValues.decodeIfPresent(S3Settings.self, forKey: .s3Settings)
        s3Settings = s3SettingsDecoded
        let dmsTransferSettingsDecoded = try containerValues.decodeIfPresent(DmsTransferSettings.self, forKey: .dmsTransferSettings)
        dmsTransferSettings = dmsTransferSettingsDecoded
        let mongoDbSettingsDecoded = try containerValues.decodeIfPresent(MongoDbSettings.self, forKey: .mongoDbSettings)
        mongoDbSettings = mongoDbSettingsDecoded
        let kinesisSettingsDecoded = try containerValues.decodeIfPresent(KinesisSettings.self, forKey: .kinesisSettings)
        kinesisSettings = kinesisSettingsDecoded
        let kafkaSettingsDecoded = try containerValues.decodeIfPresent(KafkaSettings.self, forKey: .kafkaSettings)
        kafkaSettings = kafkaSettingsDecoded
        let elasticsearchSettingsDecoded = try containerValues.decodeIfPresent(ElasticsearchSettings.self, forKey: .elasticsearchSettings)
        elasticsearchSettings = elasticsearchSettingsDecoded
        let neptuneSettingsDecoded = try containerValues.decodeIfPresent(NeptuneSettings.self, forKey: .neptuneSettings)
        neptuneSettings = neptuneSettingsDecoded
        let redshiftSettingsDecoded = try containerValues.decodeIfPresent(RedshiftSettings.self, forKey: .redshiftSettings)
        redshiftSettings = redshiftSettingsDecoded
        let postgreSQLSettingsDecoded = try containerValues.decodeIfPresent(PostgreSQLSettings.self, forKey: .postgreSQLSettings)
        postgreSQLSettings = postgreSQLSettingsDecoded
        let mySQLSettingsDecoded = try containerValues.decodeIfPresent(MySQLSettings.self, forKey: .mySQLSettings)
        mySQLSettings = mySQLSettingsDecoded
        let oracleSettingsDecoded = try containerValues.decodeIfPresent(OracleSettings.self, forKey: .oracleSettings)
        oracleSettings = oracleSettingsDecoded
        let sybaseSettingsDecoded = try containerValues.decodeIfPresent(SybaseSettings.self, forKey: .sybaseSettings)
        sybaseSettings = sybaseSettingsDecoded
        let microsoftSQLServerSettingsDecoded = try containerValues.decodeIfPresent(MicrosoftSQLServerSettings.self, forKey: .microsoftSQLServerSettings)
        microsoftSQLServerSettings = microsoftSQLServerSettingsDecoded
        let iBMDb2SettingsDecoded = try containerValues.decodeIfPresent(IBMDb2Settings.self, forKey: .iBMDb2Settings)
        iBMDb2Settings = iBMDb2SettingsDecoded
        let docDbSettingsDecoded = try containerValues.decodeIfPresent(DocDbSettings.self, forKey: .docDbSettings)
        docDbSettings = docDbSettingsDecoded
    }
}

extension ModifyEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyEndpointOutputError: Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyEndpointOutputResponse(endpoint: \(String(describing: endpoint)))"}
}

extension ModifyEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

/// <p></p>
public struct ModifyEndpointOutputResponse: Equatable {
    /// <p>The modified endpoint.</p>
    public let endpoint: Endpoint?

    public init (
        endpoint: Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct ModifyEndpointOutputResponseBody: Equatable {
    public let endpoint: Endpoint?
}

extension ModifyEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpoint = "Endpoint"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

public struct ModifyEventSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "ModifyEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEventSubscriptionOutputError>
}

extension ModifyEventSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyEventSubscriptionInput(enabled: \(String(describing: enabled)), eventCategories: \(String(describing: eventCategories)), snsTopicArn: \(String(describing: snsTopicArn)), sourceType: \(String(describing: sourceType)), subscriptionName: \(String(describing: subscriptionName)))"}
}

extension ModifyEventSubscriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for eventcategorieslist0 in eventCategories {
                try eventCategoriesContainer.encode(eventcategorieslist0)
            }
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let subscriptionName = subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
    }
}

public struct ModifyEventSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEventSubscriptionOutputError>
}

public struct ModifyEventSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyEventSubscriptionOutputError>
}

/// <p></p>
public struct ModifyEventSubscriptionInput: Equatable {
    /// <p> A Boolean value; set to <b>true</b> to activate the
    ///          subscription. </p>
    public let enabled: Bool?
    /// <p> A list of event categories for a source type that you want to subscribe to. Use the
    ///             <code>DescribeEventCategories</code> action to see a list of event categories. </p>
    public let eventCategories: [String]?
    /// <p> The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification.
    ///          The ARN is created by Amazon SNS when you create a topic and subscribe to it.</p>
    public let snsTopicArn: String?
    /// <p> The type of AWS DMS resource that generates the events you want to subscribe to. </p>
    ///          <p>Valid values: replication-instance | replication-task</p>
    public let sourceType: String?
    /// <p>The name of the AWS DMS event notification subscription to be modified.</p>
    public let subscriptionName: String?

    public init (
        enabled: Bool? = nil,
        eventCategories: [String]? = nil,
        snsTopicArn: String? = nil,
        sourceType: String? = nil,
        subscriptionName: String? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
    }
}

struct ModifyEventSubscriptionInputBody: Equatable {
    public let subscriptionName: String?
    public let snsTopicArn: String?
    public let sourceType: String?
    public let eventCategories: [String]?
    public let enabled: Bool?
}

extension ModifyEventSubscriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension ModifyEventSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyEventSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "KMSAccessDeniedFault" : self = .kMSAccessDeniedFault(try KMSAccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledFault" : self = .kMSDisabledFault(try KMSDisabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateFault" : self = .kMSInvalidStateFault(try KMSInvalidStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundFault" : self = .kMSNotFoundFault(try KMSNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingFault" : self = .kMSThrottlingFault(try KMSThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyEventSubscriptionOutputError: Equatable {
    case kMSAccessDeniedFault(KMSAccessDeniedFault)
    case kMSDisabledFault(KMSDisabledFault)
    case kMSInvalidStateFault(KMSInvalidStateFault)
    case kMSNotFoundFault(KMSNotFoundFault)
    case kMSThrottlingFault(KMSThrottlingFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyEventSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyEventSubscriptionOutputResponse(eventSubscription: \(String(describing: eventSubscription)))"}
}

extension ModifyEventSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

/// <p></p>
public struct ModifyEventSubscriptionOutputResponse: Equatable {
    /// <p>The modified event subscription.</p>
    public let eventSubscription: EventSubscription?

    public init (
        eventSubscription: EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct ModifyEventSubscriptionOutputResponseBody: Equatable {
    public let eventSubscription: EventSubscription?
}

extension ModifyEventSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct ModifyReplicationInstanceInputBodyMiddleware: Middleware {
    public let id: String = "ModifyReplicationInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyReplicationInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyReplicationInstanceInput>
    public typealias MOutput = OperationOutput<ModifyReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyReplicationInstanceOutputError>
}

extension ModifyReplicationInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyReplicationInstanceInput(allocatedStorage: \(String(describing: allocatedStorage)), allowMajorVersionUpgrade: \(String(describing: allowMajorVersionUpgrade)), applyImmediately: \(String(describing: applyImmediately)), autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), engineVersion: \(String(describing: engineVersion)), multiAZ: \(String(describing: multiAZ)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), replicationInstanceArn: \(String(describing: replicationInstanceArn)), replicationInstanceClass: \(String(describing: replicationInstanceClass)), replicationInstanceIdentifier: \(String(describing: replicationInstanceIdentifier)), vpcSecurityGroupIds: \(String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyReplicationInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
        case applyImmediately = "ApplyImmediately"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case engineVersion = "EngineVersion"
        case multiAZ = "MultiAZ"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedStorage = allocatedStorage {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if allowMajorVersionUpgrade != false {
            try encodeContainer.encode(allowMajorVersionUpgrade, forKey: .allowMajorVersionUpgrade)
        }
        if applyImmediately != false {
            try encodeContainer.encode(applyImmediately, forKey: .applyImmediately)
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let multiAZ = multiAZ {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationInstanceClass = replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let replicationInstanceIdentifier = replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for vpcsecuritygroupidlist0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(vpcsecuritygroupidlist0)
            }
        }
    }
}

public struct ModifyReplicationInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyReplicationInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyReplicationInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyReplicationInstanceInput>
    public typealias MOutput = OperationOutput<ModifyReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyReplicationInstanceOutputError>
}

public struct ModifyReplicationInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyReplicationInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyReplicationInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyReplicationInstanceInput>
    public typealias MOutput = OperationOutput<ModifyReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyReplicationInstanceOutputError>
}

/// <p></p>
public struct ModifyReplicationInstanceInput: Equatable {
    /// <p>The amount of storage (in gigabytes) to be allocated for the replication
    ///          instance.</p>
    public let allocatedStorage: Int?
    /// <p>Indicates that major version upgrades are allowed. Changing this parameter does not
    ///          result in an outage, and the change is asynchronously applied as soon as possible.</p>
    ///          <p>This parameter must be set to <code>true</code> when specifying a value for the
    ///             <code>EngineVersion</code> parameter that is a different major version than the
    ///          replication instance's current version.</p>
    public let allowMajorVersionUpgrade: Bool
    /// <p>Indicates whether the changes should be applied immediately or during the next
    ///          maintenance window.</p>
    public let applyImmediately: Bool
    /// <p>A value that indicates that minor version upgrades are applied automatically to the
    ///          replication instance during the maintenance window. Changing this parameter doesn't result
    ///          in an outage, except in the case described following. The change is asynchronously applied
    ///          as soon as possible. </p>
    ///          <p>An outage does result if these factors apply: </p>
    ///          <ul>
    ///             <li>
    ///                <p>This parameter is set to <code>true</code> during the maintenance window.</p>
    ///             </li>
    ///             <li>
    ///                <p>A newer minor version is available. </p>
    ///             </li>
    ///             <li>
    ///                <p>AWS DMS has enabled automatic patching for the given engine version. </p>
    ///             </li>
    ///          </ul>
    public let autoMinorVersionUpgrade: Bool?
    /// <p>The engine version number of the replication instance.</p>
    ///          <p>When modifying a major engine version of an instance, also set
    ///          <code>AllowMajorVersionUpgrade</code> to <code>true</code>.</p>
    public let engineVersion: String?
    /// <p> Specifies whether the replication instance is a Multi-AZ deployment. You can't set the
    ///             <code>AvailabilityZone</code> parameter if the Multi-AZ parameter is set to
    ///             <code>true</code>. </p>
    public let multiAZ: Bool?
    /// <p>The weekly time range (in UTC) during which system maintenance can occur, which might
    ///          result in an outage. Changing this parameter does not result in an outage, except in the
    ///          following situation, and the change is asynchronously applied as soon as possible. If
    ///          moving this window to the current time, there must be at least 30 minutes between the
    ///          current time and end of the window to ensure pending changes are applied.</p>
    ///          <p>Default: Uses existing setting</p>
    ///          <p>Format: ddd:hh24:mi-ddd:hh24:mi</p>
    ///          <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
    ///          <p>Constraints: Must be at least 30 minutes</p>
    public let preferredMaintenanceWindow: String?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: String?
    /// <p>The compute and memory capacity of the replication instance as defined for the specified
    ///          replication instance class. For example to specify the instance class dms.c4.large, set this parameter to <code>"dms.c4.large"</code>.</p>
    ///          <p>For more information on the settings and capacities for the available replication instance classes, see
    ///          <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth">
    ///             Selecting the right AWS DMS replication instance for your migration</a>.
    ///       </p>
    public let replicationInstanceClass: String?
    /// <p>The replication instance identifier. This parameter is stored as a lowercase
    ///          string.</p>
    public let replicationInstanceIdentifier: String?
    /// <p> Specifies the VPC security group to be used with the replication instance. The VPC
    ///          security group must work with the VPC containing the replication instance. </p>
    public let vpcSecurityGroupIds: [String]?

    public init (
        allocatedStorage: Int? = nil,
        allowMajorVersionUpgrade: Bool = false,
        applyImmediately: Bool = false,
        autoMinorVersionUpgrade: Bool? = nil,
        engineVersion: String? = nil,
        multiAZ: Bool? = nil,
        preferredMaintenanceWindow: String? = nil,
        replicationInstanceArn: String? = nil,
        replicationInstanceClass: String? = nil,
        replicationInstanceIdentifier: String? = nil,
        vpcSecurityGroupIds: [String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.applyImmediately = applyImmediately
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.engineVersion = engineVersion
        self.multiAZ = multiAZ
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationInstanceClass = replicationInstanceClass
        self.replicationInstanceIdentifier = replicationInstanceIdentifier
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct ModifyReplicationInstanceInputBody: Equatable {
    public let replicationInstanceArn: String?
    public let allocatedStorage: Int?
    public let applyImmediately: Bool
    public let replicationInstanceClass: String?
    public let vpcSecurityGroupIds: [String]?
    public let preferredMaintenanceWindow: String?
    public let multiAZ: Bool?
    public let engineVersion: String?
    public let allowMajorVersionUpgrade: Bool
    public let autoMinorVersionUpgrade: Bool?
    public let replicationInstanceIdentifier: String?
}

extension ModifyReplicationInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
        case applyImmediately = "ApplyImmediately"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case engineVersion = "EngineVersion"
        case multiAZ = "MultiAZ"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let applyImmediatelyDecoded = try containerValues.decode(Bool.self, forKey: .applyImmediately)
        applyImmediately = applyImmediatelyDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let allowMajorVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .allowMajorVersionUpgrade)
        allowMajorVersionUpgrade = allowMajorVersionUpgradeDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
    }
}

extension ModifyReplicationInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyReplicationInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientResourceCapacityFault" : self = .insufficientResourceCapacityFault(try InsufficientResourceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UpgradeDependencyFailureFault" : self = .upgradeDependencyFailureFault(try UpgradeDependencyFailureFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyReplicationInstanceOutputError: Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case insufficientResourceCapacityFault(InsufficientResourceCapacityFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case upgradeDependencyFailureFault(UpgradeDependencyFailureFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyReplicationInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyReplicationInstanceOutputResponse(replicationInstance: \(String(describing: replicationInstance)))"}
}

extension ModifyReplicationInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyReplicationInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

/// <p></p>
public struct ModifyReplicationInstanceOutputResponse: Equatable {
    /// <p>The modified replication instance.</p>
    public let replicationInstance: ReplicationInstance?

    public init (
        replicationInstance: ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct ModifyReplicationInstanceOutputResponseBody: Equatable {
    public let replicationInstance: ReplicationInstance?
}

extension ModifyReplicationInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

public struct ModifyReplicationSubnetGroupInputBodyMiddleware: Middleware {
    public let id: String = "ModifyReplicationSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyReplicationSubnetGroupInput>
    public typealias MOutput = OperationOutput<ModifyReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyReplicationSubnetGroupOutputError>
}

extension ModifyReplicationSubnetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyReplicationSubnetGroupInput(replicationSubnetGroupDescription: \(String(describing: replicationSubnetGroupDescription)), replicationSubnetGroupIdentifier: \(String(describing: replicationSubnetGroupIdentifier)), subnetIds: \(String(describing: subnetIds)))"}
}

extension ModifyReplicationSubnetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupDescription = replicationSubnetGroupDescription {
            try encodeContainer.encode(replicationSubnetGroupDescription, forKey: .replicationSubnetGroupDescription)
        }
        if let replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidentifierlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidentifierlist0)
            }
        }
    }
}

public struct ModifyReplicationSubnetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyReplicationSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyReplicationSubnetGroupInput>
    public typealias MOutput = OperationOutput<ModifyReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyReplicationSubnetGroupOutputError>
}

public struct ModifyReplicationSubnetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyReplicationSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyReplicationSubnetGroupInput>
    public typealias MOutput = OperationOutput<ModifyReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyReplicationSubnetGroupOutputError>
}

/// <p></p>
public struct ModifyReplicationSubnetGroupInput: Equatable {
    /// <p>A description for the replication instance subnet group.</p>
    public let replicationSubnetGroupDescription: String?
    /// <p>The name of the replication instance subnet group.</p>
    public let replicationSubnetGroupIdentifier: String?
    /// <p>A list of subnet IDs.</p>
    public let subnetIds: [String]?

    public init (
        replicationSubnetGroupDescription: String? = nil,
        replicationSubnetGroupIdentifier: String? = nil,
        subnetIds: [String]? = nil
    )
    {
        self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.subnetIds = subnetIds
    }
}

struct ModifyReplicationSubnetGroupInputBody: Equatable {
    public let replicationSubnetGroupIdentifier: String?
    public let replicationSubnetGroupDescription: String?
    public let subnetIds: [String]?
}

extension ModifyReplicationSubnetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let replicationSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationSubnetGroupDescription)
        replicationSubnetGroupDescription = replicationSubnetGroupDescriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension ModifyReplicationSubnetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyReplicationSubnetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplicationSubnetGroupDoesNotCoverEnoughAZs" : self = .replicationSubnetGroupDoesNotCoverEnoughAZs(try ReplicationSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetAlreadyInUse" : self = .subnetAlreadyInUse(try SubnetAlreadyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyReplicationSubnetGroupOutputError: Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidSubnet(InvalidSubnet)
    case replicationSubnetGroupDoesNotCoverEnoughAZs(ReplicationSubnetGroupDoesNotCoverEnoughAZs)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case subnetAlreadyInUse(SubnetAlreadyInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyReplicationSubnetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyReplicationSubnetGroupOutputResponse(replicationSubnetGroup: \(String(describing: replicationSubnetGroup)))"}
}

extension ModifyReplicationSubnetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyReplicationSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationSubnetGroup = output.replicationSubnetGroup
        } else {
            self.replicationSubnetGroup = nil
        }
    }
}

/// <p></p>
public struct ModifyReplicationSubnetGroupOutputResponse: Equatable {
    /// <p>The modified replication subnet group.</p>
    public let replicationSubnetGroup: ReplicationSubnetGroup?

    public init (
        replicationSubnetGroup: ReplicationSubnetGroup? = nil
    )
    {
        self.replicationSubnetGroup = replicationSubnetGroup
    }
}

struct ModifyReplicationSubnetGroupOutputResponseBody: Equatable {
    public let replicationSubnetGroup: ReplicationSubnetGroup?
}

extension ModifyReplicationSubnetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationSubnetGroup = "ReplicationSubnetGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupDecoded = try containerValues.decodeIfPresent(ReplicationSubnetGroup.self, forKey: .replicationSubnetGroup)
        replicationSubnetGroup = replicationSubnetGroupDecoded
    }
}

public struct ModifyReplicationTaskInputBodyMiddleware: Middleware {
    public let id: String = "ModifyReplicationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyReplicationTaskInput>
    public typealias MOutput = OperationOutput<ModifyReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyReplicationTaskOutputError>
}

extension ModifyReplicationTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyReplicationTaskInput(cdcStartPosition: \(String(describing: cdcStartPosition)), cdcStartTime: \(String(describing: cdcStartTime)), cdcStopPosition: \(String(describing: cdcStopPosition)), migrationType: \(String(describing: migrationType)), replicationTaskArn: \(String(describing: replicationTaskArn)), replicationTaskIdentifier: \(String(describing: replicationTaskIdentifier)), replicationTaskSettings: \(String(describing: replicationTaskSettings)), tableMappings: \(String(describing: tableMappings)), taskData: \(String(describing: taskData)))"}
}

extension ModifyReplicationTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case tableMappings = "TableMappings"
        case taskData = "TaskData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStartTime = cdcStartTime {
            try encodeContainer.encode(cdcStartTime.timeIntervalSince1970, forKey: .cdcStartTime)
        }
        if let cdcStopPosition = cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let migrationType = migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskIdentifier = replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskSettings = replicationTaskSettings {
            try encodeContainer.encode(replicationTaskSettings, forKey: .replicationTaskSettings)
        }
        if let tableMappings = tableMappings {
            try encodeContainer.encode(tableMappings, forKey: .tableMappings)
        }
        if let taskData = taskData {
            try encodeContainer.encode(taskData, forKey: .taskData)
        }
    }
}

public struct ModifyReplicationTaskInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyReplicationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyReplicationTaskInput>
    public typealias MOutput = OperationOutput<ModifyReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyReplicationTaskOutputError>
}

public struct ModifyReplicationTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyReplicationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyReplicationTaskInput>
    public typealias MOutput = OperationOutput<ModifyReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyReplicationTaskOutputError>
}

/// <p></p>
public struct ModifyReplicationTaskInput: Equatable {
    /// <p>Indicates when you want a change data capture (CDC) operation to start. Use either
    ///          CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start.
    ///          Specifying both values results in an error.</p>
    ///          <p> The value can be in date, checkpoint, or LSN/SCN format.</p>
    ///          <p>Date Example: --cdc-start-position “2018-03-08T12:12:12”</p>
    ///          <p>Checkpoint Example: --cdc-start-position
    ///          "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93"</p>
    ///          <p>LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373”</p>
    ///          <note>
    ///             <p>When you use this task setting with a source PostgreSQL database, a logical
    ///             replication slot should already be created and associated with the source endpoint. You
    ///             can verify this by setting the <code>slotName</code> extra connection attribute to the
    ///             name of this logical replication slot. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib">Extra Connection Attributes When Using PostgreSQL as a Source
    ///                for AWS DMS</a>.</p>
    ///          </note>
    public let cdcStartPosition: String?
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either
    ///          CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start.
    ///          Specifying both values results in an error.</p>
    ///          <p>Timestamp Example: --cdc-start-time “2018-03-08T12:12:12”</p>
    public let cdcStartTime: Date?
    /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be
    ///          either server time or commit time.</p>
    ///          <p>Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12”</p>
    ///          <p>Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “</p>
    public let cdcStopPosition: String?
    /// <p>The migration type. Valid values: <code>full-load</code> | <code>cdc</code> | <code>full-load-and-cdc</code>
    ///          </p>
    public let migrationType: MigrationTypeValue?
    /// <p>The Amazon Resource Name (ARN) of the replication task.</p>
    public let replicationTaskArn: String?
    /// <p>The replication task identifier.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain 1-255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let replicationTaskIdentifier: String?
    /// <p>JSON file that contains settings for the task, such as task metadata settings.</p>
    public let replicationTaskSettings: String?
    /// <p>When using the AWS CLI or boto3, provide the path of the JSON file that contains the
    ///          table mappings. Precede the path with <code>file://</code>.  For example,
    ///          <code>--table-mappings file://mappingfile.json</code>. When working with the DMS API,
    ///          provide the JSON as the parameter value.
    ///     </p>
    public let tableMappings: String?
    /// <p>Supplemental information that the task requires to migrate the data for certain source and target endpoints.
    ///             For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html">Specifying Supplemental Data for Task Settings</a> in the
    ///          <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let taskData: String?

    public init (
        cdcStartPosition: String? = nil,
        cdcStartTime: Date? = nil,
        cdcStopPosition: String? = nil,
        migrationType: MigrationTypeValue? = nil,
        replicationTaskArn: String? = nil,
        replicationTaskIdentifier: String? = nil,
        replicationTaskSettings: String? = nil,
        tableMappings: String? = nil,
        taskData: String? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.migrationType = migrationType
        self.replicationTaskArn = replicationTaskArn
        self.replicationTaskIdentifier = replicationTaskIdentifier
        self.replicationTaskSettings = replicationTaskSettings
        self.tableMappings = tableMappings
        self.taskData = taskData
    }
}

struct ModifyReplicationTaskInputBody: Equatable {
    public let replicationTaskArn: String?
    public let replicationTaskIdentifier: String?
    public let migrationType: MigrationTypeValue?
    public let tableMappings: String?
    public let replicationTaskSettings: String?
    public let cdcStartTime: Date?
    public let cdcStartPosition: String?
    public let cdcStopPosition: String?
    public let taskData: String?
}

extension ModifyReplicationTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case tableMappings = "TableMappings"
        case taskData = "TaskData"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let tableMappingsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableMappings)
        tableMappings = tableMappingsDecoded
        let replicationTaskSettingsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskSettings)
        replicationTaskSettings = replicationTaskSettingsDecoded
        let cdcStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .cdcStartTime)
        cdcStartTime = cdcStartTimeDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
        let taskDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskData)
        taskData = taskDataDecoded
    }
}

extension ModifyReplicationTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyReplicationTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyReplicationTaskOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyReplicationTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyReplicationTaskOutputResponse(replicationTask: \(String(describing: replicationTask)))"}
}

extension ModifyReplicationTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

/// <p></p>
public struct ModifyReplicationTaskOutputResponse: Equatable {
    /// <p>The replication task that was modified.</p>
    public let replicationTask: ReplicationTask?

    public init (
        replicationTask: ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct ModifyReplicationTaskOutputResponseBody: Equatable {
    public let replicationTask: ReplicationTask?
}

extension ModifyReplicationTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension MongoDbSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authMechanism = "AuthMechanism"
        case authSource = "AuthSource"
        case authType = "AuthType"
        case databaseName = "DatabaseName"
        case docsToInvestigate = "DocsToInvestigate"
        case extractDocId = "ExtractDocId"
        case kmsKeyId = "KmsKeyId"
        case nestingLevel = "NestingLevel"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authMechanism = authMechanism {
            try encodeContainer.encode(authMechanism.rawValue, forKey: .authMechanism)
        }
        if let authSource = authSource {
            try encodeContainer.encode(authSource, forKey: .authSource)
        }
        if let authType = authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let docsToInvestigate = docsToInvestigate {
            try encodeContainer.encode(docsToInvestigate, forKey: .docsToInvestigate)
        }
        if let extractDocId = extractDocId {
            try encodeContainer.encode(extractDocId, forKey: .extractDocId)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let nestingLevel = nestingLevel {
            try encodeContainer.encode(nestingLevel.rawValue, forKey: .nestingLevel)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(AuthTypeValue.self, forKey: .authType)
        authType = authTypeDecoded
        let authMechanismDecoded = try containerValues.decodeIfPresent(AuthMechanismValue.self, forKey: .authMechanism)
        authMechanism = authMechanismDecoded
        let nestingLevelDecoded = try containerValues.decodeIfPresent(NestingLevelValue.self, forKey: .nestingLevel)
        nestingLevel = nestingLevelDecoded
        let extractDocIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extractDocId)
        extractDocId = extractDocIdDecoded
        let docsToInvestigateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .docsToInvestigate)
        docsToInvestigate = docsToInvestigateDecoded
        let authSourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authSource)
        authSource = authSourceDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension MongoDbSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MongoDbSettings(authMechanism: \(String(describing: authMechanism)), authSource: \(String(describing: authSource)), authType: \(String(describing: authType)), databaseName: \(String(describing: databaseName)), docsToInvestigate: \(String(describing: docsToInvestigate)), extractDocId: \(String(describing: extractDocId)), kmsKeyId: \(String(describing: kmsKeyId)), nestingLevel: \(String(describing: nestingLevel)), password: \(String(describing: password)), port: \(String(describing: port)), secretsManagerAccessRoleArn: \(String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(String(describing: secretsManagerSecretId)), serverName: \(String(describing: serverName)), username: \(String(describing: username)))"}
}

/// <p>Provides information that defines a MongoDB endpoint.</p>
public struct MongoDbSettings: Equatable {
    /// <p> The authentication mechanism you use to access the MongoDB source endpoint.</p>
    ///          <p>For the default value, in MongoDB version 2.x, <code>"default"</code> is
    ///             <code>"mongodb_cr"</code>. For MongoDB version 3.x or later, <code>"default"</code> is
    ///             <code>"scram_sha_1"</code>. This setting isn't used when <code>AuthType</code> is
    ///          set to <code>"no"</code>.</p>
    public let authMechanism: AuthMechanismValue?
    /// <p> The MongoDB database name. This setting isn't used when <code>AuthType</code> is
    ///          set to <code>"no"</code>. </p>
    ///          <p>The default is <code>"admin"</code>.</p>
    public let authSource: String?
    /// <p> The authentication type you use to access the MongoDB source endpoint.</p>
    ///          <p>When when set to <code>"no"</code>, user name and password parameters are not used and
    ///          can be empty. </p>
    public let authType: AuthTypeValue?
    /// <p> The database name on the MongoDB source endpoint. </p>
    public let databaseName: String?
    /// <p> Indicates the number of documents to preview to determine the document organization.
    ///          Use this setting when <code>NestingLevel</code> is set to <code>"one"</code>. </p>
    ///          <p>Must be a positive value greater than <code>0</code>. Default value is
    ///          <code>1000</code>.</p>
    public let docsToInvestigate: String?
    /// <p> Specifies the document ID. Use this setting when <code>NestingLevel</code> is set to
    ///             <code>"none"</code>. </p>
    ///          <p>Default value is <code>"false"</code>. </p>
    public let extractDocId: String?
    /// <p>The AWS KMS key identifier that is used to encrypt the content on the replication
    ///          instance. If you don't specify a value for the <code>KmsKeyId</code> parameter, then
    ///          AWS DMS uses your default encryption key. AWS KMS creates the default encryption key for
    ///          your AWS account. Your AWS account has a different default encryption key for each AWS
    ///          Region.</p>
    public let kmsKeyId: String?
    /// <p> Specifies either document or table mode. </p>
    ///          <p>Default value is <code>"none"</code>. Specify <code>"none"</code> to use document mode.
    ///          Specify <code>"one"</code> to use table mode.</p>
    public let nestingLevel: NestingLevelValue?
    /// <p> The password for the user account you use to access the MongoDB source endpoint.
    ///       </p>
    public let password: String?
    /// <p> The port value for the MongoDB source endpoint. </p>
    public let port: Int?
    /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
    ///          trusted entity and grants the required permissions to access the value in
    ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
    ///          Manager secret that allows access to the MongoDB endpoint.</p>
    ///          <note>
    ///             <p>You can specify one of two sets of values for these permissions. You can specify the
    ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
    ///             clear-text values for <code>UserName</code>, <code>Password</code>,
    ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
    ///             information on creating this <code>SecretsManagerSecret</code> and the
    ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
    ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
    ///                resources</a> in the <i>AWS Database Migration Service User
    ///                Guide</i>.</p>
    ///          </note>
    public let secretsManagerAccessRoleArn: String?
    /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the MongoDB endpoint connection details.</p>
    public let secretsManagerSecretId: String?
    /// <p> The name of the server on the MongoDB source endpoint. </p>
    public let serverName: String?
    /// <p>The user name you use to access the MongoDB source endpoint. </p>
    public let username: String?

    public init (
        authMechanism: AuthMechanismValue? = nil,
        authSource: String? = nil,
        authType: AuthTypeValue? = nil,
        databaseName: String? = nil,
        docsToInvestigate: String? = nil,
        extractDocId: String? = nil,
        kmsKeyId: String? = nil,
        nestingLevel: NestingLevelValue? = nil,
        password: String? = nil,
        port: Int? = nil,
        secretsManagerAccessRoleArn: String? = nil,
        secretsManagerSecretId: String? = nil,
        serverName: String? = nil,
        username: String? = nil
    )
    {
        self.authMechanism = authMechanism
        self.authSource = authSource
        self.authType = authType
        self.databaseName = databaseName
        self.docsToInvestigate = docsToInvestigate
        self.extractDocId = extractDocId
        self.kmsKeyId = kmsKeyId
        self.nestingLevel = nestingLevel
        self.password = password
        self.port = port
        self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
        self.secretsManagerSecretId = secretsManagerSecretId
        self.serverName = serverName
        self.username = username
    }
}

public struct MoveReplicationTaskInputBodyMiddleware: Middleware {
    public let id: String = "MoveReplicationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MoveReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<MoveReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MoveReplicationTaskInput>
    public typealias MOutput = OperationOutput<MoveReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MoveReplicationTaskOutputError>
}

extension MoveReplicationTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MoveReplicationTaskInput(replicationTaskArn: \(String(describing: replicationTaskArn)), targetReplicationInstanceArn: \(String(describing: targetReplicationInstanceArn)))"}
}

extension MoveReplicationTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
        case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let targetReplicationInstanceArn = targetReplicationInstanceArn {
            try encodeContainer.encode(targetReplicationInstanceArn, forKey: .targetReplicationInstanceArn)
        }
    }
}

public struct MoveReplicationTaskInputHeadersMiddleware: Middleware {
    public let id: String = "MoveReplicationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MoveReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<MoveReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MoveReplicationTaskInput>
    public typealias MOutput = OperationOutput<MoveReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MoveReplicationTaskOutputError>
}

public struct MoveReplicationTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "MoveReplicationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MoveReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<MoveReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MoveReplicationTaskInput>
    public typealias MOutput = OperationOutput<MoveReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MoveReplicationTaskOutputError>
}

/// <p></p>
public struct MoveReplicationTaskInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the task that you want to move.</p>
    public let replicationTaskArn: String?
    /// <p>The ARN of the replication instance where you want to move the task to.</p>
    public let targetReplicationInstanceArn: String?

    public init (
        replicationTaskArn: String? = nil,
        targetReplicationInstanceArn: String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
        self.targetReplicationInstanceArn = targetReplicationInstanceArn
    }
}

struct MoveReplicationTaskInputBody: Equatable {
    public let replicationTaskArn: String?
    public let targetReplicationInstanceArn: String?
}

extension MoveReplicationTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
        case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let targetReplicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetReplicationInstanceArn)
        targetReplicationInstanceArn = targetReplicationInstanceArnDecoded
    }
}

extension MoveReplicationTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MoveReplicationTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MoveReplicationTaskOutputError: Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension MoveReplicationTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MoveReplicationTaskOutputResponse(replicationTask: \(String(describing: replicationTask)))"}
}

extension MoveReplicationTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MoveReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

/// <p></p>
public struct MoveReplicationTaskOutputResponse: Equatable {
    /// <p>The replication task that was moved.</p>
    public let replicationTask: ReplicationTask?

    public init (
        replicationTask: ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct MoveReplicationTaskOutputResponseBody: Equatable {
    public let replicationTask: ReplicationTask?
}

extension MoveReplicationTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension MySQLSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case afterConnectScript = "AfterConnectScript"
        case cleanSourceMetadataOnMismatch = "CleanSourceMetadataOnMismatch"
        case databaseName = "DatabaseName"
        case eventsPollInterval = "EventsPollInterval"
        case maxFileSize = "MaxFileSize"
        case parallelLoadThreads = "ParallelLoadThreads"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case serverTimezone = "ServerTimezone"
        case targetDbType = "TargetDbType"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterConnectScript = afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatch {
            try encodeContainer.encode(cleanSourceMetadataOnMismatch, forKey: .cleanSourceMetadataOnMismatch)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let eventsPollInterval = eventsPollInterval {
            try encodeContainer.encode(eventsPollInterval, forKey: .eventsPollInterval)
        }
        if let maxFileSize = maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let parallelLoadThreads = parallelLoadThreads {
            try encodeContainer.encode(parallelLoadThreads, forKey: .parallelLoadThreads)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serverTimezone = serverTimezone {
            try encodeContainer.encode(serverTimezone, forKey: .serverTimezone)
        }
        if let targetDbType = targetDbType {
            try encodeContainer.encode(targetDbType.rawValue, forKey: .targetDbType)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let cleanSourceMetadataOnMismatchDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .cleanSourceMetadataOnMismatch)
        cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatchDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let eventsPollIntervalDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .eventsPollInterval)
        eventsPollInterval = eventsPollIntervalDecoded
        let targetDbTypeDecoded = try containerValues.decodeIfPresent(TargetDbType.self, forKey: .targetDbType)
        targetDbType = targetDbTypeDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let parallelLoadThreadsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelLoadThreads)
        parallelLoadThreads = parallelLoadThreadsDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serverTimezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverTimezone)
        serverTimezone = serverTimezoneDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension MySQLSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MySQLSettings(afterConnectScript: \(String(describing: afterConnectScript)), cleanSourceMetadataOnMismatch: \(String(describing: cleanSourceMetadataOnMismatch)), databaseName: \(String(describing: databaseName)), eventsPollInterval: \(String(describing: eventsPollInterval)), maxFileSize: \(String(describing: maxFileSize)), parallelLoadThreads: \(String(describing: parallelLoadThreads)), password: \(String(describing: password)), port: \(String(describing: port)), secretsManagerAccessRoleArn: \(String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(String(describing: secretsManagerSecretId)), serverName: \(String(describing: serverName)), serverTimezone: \(String(describing: serverTimezone)), targetDbType: \(String(describing: targetDbType)), username: \(String(describing: username)))"}
}

/// <p>Provides information that defines a MySQL endpoint.</p>
public struct MySQLSettings: Equatable {
    /// <p>Specifies a script to run immediately after AWS DMS
    ///          connects to the endpoint. The migration task continues
    ///          running regardless if the SQL statement succeeds or fails.</p>
    public let afterConnectScript: String?
    /// <p>Adjusts the behavior of DMS when migrating from an SQL Server source database
    ///          that is hosted as part of an Always On availability group cluster.  If you need DMS to poll
    ///          all the nodes in the Always On cluster for transaction backups, set this attribute to
    ///          <code>false</code>.</p>
    public let cleanSourceMetadataOnMismatch: Bool?
    /// <p>Database name for the endpoint.</p>
    public let databaseName: String?
    /// <p>Specifies how often to check the binary log for new
    ///          changes/events when the database is idle.</p>
    ///          <p>Example: <code>eventsPollInterval=5;</code>
    ///          </p>
    ///          <p>In the example, AWS DMS checks for changes in the binary
    ///          logs every five seconds.</p>
    public let eventsPollInterval: Int?
    /// <p>Specifies the maximum size (in KB) of any .csv file used to
    ///          transfer data to a MySQL-compatible database.</p>
    ///          <p>Example: <code>maxFileSize=512</code>
    ///          </p>
    public let maxFileSize: Int?
    /// <p>Improves performance when loading data into the MySQL-compatible target database.
    ///          Specifies how many threads to use to load the data into the MySQL-compatible target
    ///          database. Setting a large number of threads can have an adverse effect on database
    ///          performance, because a separate connection is required for each thread.</p>
    ///          <p>Example: <code>parallelLoadThreads=1</code>
    ///          </p>
    public let parallelLoadThreads: Int?
    /// <p>Endpoint connection password.</p>
    public let password: String?
    /// <p>Endpoint TCP port.</p>
    public let port: Int?
    /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
    ///          trusted entity and grants the required permissions to access the value in
    ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
    ///          Manager secret that allows access to the MySQL endpoint.</p>
    ///          <note>
    ///             <p>You can specify one of two sets of values for these permissions. You can specify the
    ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
    ///             clear-text values for <code>UserName</code>, <code>Password</code>,
    ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
    ///             information on creating this <code>SecretsManagerSecret</code> and the
    ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
    ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
    ///                resources</a> in the <i>AWS Database Migration Service User
    ///                Guide</i>.</p>
    ///          </note>
    public let secretsManagerAccessRoleArn: String?
    /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the MySQL endpoint connection details.</p>
    public let secretsManagerSecretId: String?
    /// <p>Fully qualified domain name of the endpoint.</p>
    public let serverName: String?
    /// <p>Specifies the time zone for the source MySQL database.</p>
    ///          <p>Example: <code>serverTimezone=US/Pacific;</code>
    ///          </p>
    ///          <p>Note: Do not enclose time zones in single quotes.</p>
    public let serverTimezone: String?
    /// <p>Specifies where to migrate source tables on the target, either
    ///          to a single database or multiple databases.</p>
    ///          <p>Example: <code>targetDbType=MULTIPLE_DATABASES</code>
    ///          </p>
    public let targetDbType: TargetDbType?
    /// <p>Endpoint connection user name.</p>
    public let username: String?

    public init (
        afterConnectScript: String? = nil,
        cleanSourceMetadataOnMismatch: Bool? = nil,
        databaseName: String? = nil,
        eventsPollInterval: Int? = nil,
        maxFileSize: Int? = nil,
        parallelLoadThreads: Int? = nil,
        password: String? = nil,
        port: Int? = nil,
        secretsManagerAccessRoleArn: String? = nil,
        secretsManagerSecretId: String? = nil,
        serverName: String? = nil,
        serverTimezone: String? = nil,
        targetDbType: TargetDbType? = nil,
        username: String? = nil
    )
    {
        self.afterConnectScript = afterConnectScript
        self.cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatch
        self.databaseName = databaseName
        self.eventsPollInterval = eventsPollInterval
        self.maxFileSize = maxFileSize
        self.parallelLoadThreads = parallelLoadThreads
        self.password = password
        self.port = port
        self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
        self.secretsManagerSecretId = secretsManagerSecretId
        self.serverName = serverName
        self.serverTimezone = serverTimezone
        self.targetDbType = targetDbType
        self.username = username
    }
}

extension NeptuneSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorRetryDuration = "ErrorRetryDuration"
        case iamAuthEnabled = "IamAuthEnabled"
        case maxFileSize = "MaxFileSize"
        case maxRetryCount = "MaxRetryCount"
        case s3BucketFolder = "S3BucketFolder"
        case s3BucketName = "S3BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorRetryDuration = errorRetryDuration {
            try encodeContainer.encode(errorRetryDuration, forKey: .errorRetryDuration)
        }
        if let iamAuthEnabled = iamAuthEnabled {
            try encodeContainer.encode(iamAuthEnabled, forKey: .iamAuthEnabled)
        }
        if let maxFileSize = maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let maxRetryCount = maxRetryCount {
            try encodeContainer.encode(maxRetryCount, forKey: .maxRetryCount)
        }
        if let s3BucketFolder = s3BucketFolder {
            try encodeContainer.encode(s3BucketFolder, forKey: .s3BucketFolder)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3BucketFolderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketFolder)
        s3BucketFolder = s3BucketFolderDecoded
        let errorRetryDurationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .errorRetryDuration)
        errorRetryDuration = errorRetryDurationDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let maxRetryCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRetryCount)
        maxRetryCount = maxRetryCountDecoded
        let iamAuthEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .iamAuthEnabled)
        iamAuthEnabled = iamAuthEnabledDecoded
    }
}

extension NeptuneSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NeptuneSettings(errorRetryDuration: \(String(describing: errorRetryDuration)), iamAuthEnabled: \(String(describing: iamAuthEnabled)), maxFileSize: \(String(describing: maxFileSize)), maxRetryCount: \(String(describing: maxRetryCount)), s3BucketFolder: \(String(describing: s3BucketFolder)), s3BucketName: \(String(describing: s3BucketName)), serviceAccessRoleArn: \(String(describing: serviceAccessRoleArn)))"}
}

/// <p>Provides information that defines an Amazon Neptune endpoint.</p>
public struct NeptuneSettings: Equatable {
    /// <p>The number of milliseconds for AWS DMS to wait to retry a bulk-load of migrated graph
    ///          data to the Neptune target database before raising an error. The default is 250.</p>
    public let errorRetryDuration: Int?
    /// <p>If you want AWS Identity and Access Management (IAM) authorization enabled for this
    ///          endpoint, set this parameter to <code>true</code>. Then attach the appropriate IAM policy
    ///          document to your service role specified by <code>ServiceAccessRoleArn</code>. The default
    ///          is <code>false</code>.</p>
    public let iamAuthEnabled: Bool?
    /// <p>The maximum size in kilobytes of migrated graph data stored in a .csv file before AWS
    ///          DMS bulk-loads the data to the Neptune target database. The default is 1,048,576 KB. If the
    ///          bulk load is successful, AWS DMS clears the bucket, ready to store the next batch of
    ///          migrated graph data.</p>
    public let maxFileSize: Int?
    /// <p>The number of times for AWS DMS to retry a bulk load of migrated graph data to the
    ///          Neptune target database before raising an error. The default is 5.</p>
    public let maxRetryCount: Int?
    /// <p>A folder path where you want AWS DMS to store migrated graph data in the S3 bucket
    ///          specified by <code>S3BucketName</code>
    ///          </p>
    public let s3BucketFolder: String?
    /// <p>The name of the Amazon S3 bucket where AWS DMS can temporarily store migrated graph data
    ///          in .csv files before bulk-loading it to the Neptune target database. AWS DMS maps the SQL
    ///          source data to graph data before storing it in these .csv files.</p>
    public let s3BucketName: String?
    /// <p>The Amazon Resource Name (ARN) of the service role that you created for the Neptune
    ///          target endpoint.
    ///          For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.ServiceRole">Creating an IAM Service Role for Accessing Amazon Neptune as a Target</a> in the <i>AWS Database Migration Service User
    ///             Guide. </i>
    ///          </p>
    public let serviceAccessRoleArn: String?

    public init (
        errorRetryDuration: Int? = nil,
        iamAuthEnabled: Bool? = nil,
        maxFileSize: Int? = nil,
        maxRetryCount: Int? = nil,
        s3BucketFolder: String? = nil,
        s3BucketName: String? = nil,
        serviceAccessRoleArn: String? = nil
    )
    {
        self.errorRetryDuration = errorRetryDuration
        self.iamAuthEnabled = iamAuthEnabled
        self.maxFileSize = maxFileSize
        self.maxRetryCount = maxRetryCount
        self.s3BucketFolder = s3BucketFolder
        self.s3BucketName = s3BucketName
        self.serviceAccessRoleArn = serviceAccessRoleArn
    }
}

public enum NestingLevelValue {
    case `none`
    case one
    case sdkUnknown(String)
}

extension NestingLevelValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NestingLevelValue] {
        return [
            .none,
            .one,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "none"
        case .one: return "one"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NestingLevelValue(rawValue: rawValue) ?? NestingLevelValue.sdkUnknown(rawValue)
    }
}

extension OracleSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessAlternateDirectly = "AccessAlternateDirectly"
        case addSupplementalLogging = "AddSupplementalLogging"
        case additionalArchivedLogDestId = "AdditionalArchivedLogDestId"
        case allowSelectNestedTables = "AllowSelectNestedTables"
        case archivedLogDestId = "ArchivedLogDestId"
        case archivedLogsOnly = "ArchivedLogsOnly"
        case asmPassword = "AsmPassword"
        case asmServer = "AsmServer"
        case asmUser = "AsmUser"
        case charLengthSemantics = "CharLengthSemantics"
        case databaseName = "DatabaseName"
        case directPathNoLog = "DirectPathNoLog"
        case directPathParallelLoad = "DirectPathParallelLoad"
        case enableHomogenousTablespace = "EnableHomogenousTablespace"
        case failTasksOnLobTruncation = "FailTasksOnLobTruncation"
        case numberDatatypeScale = "NumberDatatypeScale"
        case oraclePathPrefix = "OraclePathPrefix"
        case parallelAsmReadThreads = "ParallelAsmReadThreads"
        case password = "Password"
        case port = "Port"
        case readAheadBlocks = "ReadAheadBlocks"
        case readTableSpaceName = "ReadTableSpaceName"
        case replacePathPrefix = "ReplacePathPrefix"
        case retryInterval = "RetryInterval"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerOracleAsmAccessRoleArn = "SecretsManagerOracleAsmAccessRoleArn"
        case secretsManagerOracleAsmSecretId = "SecretsManagerOracleAsmSecretId"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case securityDbEncryption = "SecurityDbEncryption"
        case securityDbEncryptionName = "SecurityDbEncryptionName"
        case serverName = "ServerName"
        case spatialDataOptionToGeoJsonFunctionName = "SpatialDataOptionToGeoJsonFunctionName"
        case useAlternateFolderForOnline = "UseAlternateFolderForOnline"
        case usePathPrefix = "UsePathPrefix"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessAlternateDirectly = accessAlternateDirectly {
            try encodeContainer.encode(accessAlternateDirectly, forKey: .accessAlternateDirectly)
        }
        if let addSupplementalLogging = addSupplementalLogging {
            try encodeContainer.encode(addSupplementalLogging, forKey: .addSupplementalLogging)
        }
        if let additionalArchivedLogDestId = additionalArchivedLogDestId {
            try encodeContainer.encode(additionalArchivedLogDestId, forKey: .additionalArchivedLogDestId)
        }
        if let allowSelectNestedTables = allowSelectNestedTables {
            try encodeContainer.encode(allowSelectNestedTables, forKey: .allowSelectNestedTables)
        }
        if let archivedLogDestId = archivedLogDestId {
            try encodeContainer.encode(archivedLogDestId, forKey: .archivedLogDestId)
        }
        if let archivedLogsOnly = archivedLogsOnly {
            try encodeContainer.encode(archivedLogsOnly, forKey: .archivedLogsOnly)
        }
        if let asmPassword = asmPassword {
            try encodeContainer.encode(asmPassword, forKey: .asmPassword)
        }
        if let asmServer = asmServer {
            try encodeContainer.encode(asmServer, forKey: .asmServer)
        }
        if let asmUser = asmUser {
            try encodeContainer.encode(asmUser, forKey: .asmUser)
        }
        if let charLengthSemantics = charLengthSemantics {
            try encodeContainer.encode(charLengthSemantics.rawValue, forKey: .charLengthSemantics)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let directPathNoLog = directPathNoLog {
            try encodeContainer.encode(directPathNoLog, forKey: .directPathNoLog)
        }
        if let directPathParallelLoad = directPathParallelLoad {
            try encodeContainer.encode(directPathParallelLoad, forKey: .directPathParallelLoad)
        }
        if let enableHomogenousTablespace = enableHomogenousTablespace {
            try encodeContainer.encode(enableHomogenousTablespace, forKey: .enableHomogenousTablespace)
        }
        if let failTasksOnLobTruncation = failTasksOnLobTruncation {
            try encodeContainer.encode(failTasksOnLobTruncation, forKey: .failTasksOnLobTruncation)
        }
        if let numberDatatypeScale = numberDatatypeScale {
            try encodeContainer.encode(numberDatatypeScale, forKey: .numberDatatypeScale)
        }
        if let oraclePathPrefix = oraclePathPrefix {
            try encodeContainer.encode(oraclePathPrefix, forKey: .oraclePathPrefix)
        }
        if let parallelAsmReadThreads = parallelAsmReadThreads {
            try encodeContainer.encode(parallelAsmReadThreads, forKey: .parallelAsmReadThreads)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let readAheadBlocks = readAheadBlocks {
            try encodeContainer.encode(readAheadBlocks, forKey: .readAheadBlocks)
        }
        if let readTableSpaceName = readTableSpaceName {
            try encodeContainer.encode(readTableSpaceName, forKey: .readTableSpaceName)
        }
        if let replacePathPrefix = replacePathPrefix {
            try encodeContainer.encode(replacePathPrefix, forKey: .replacePathPrefix)
        }
        if let retryInterval = retryInterval {
            try encodeContainer.encode(retryInterval, forKey: .retryInterval)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArn {
            try encodeContainer.encode(secretsManagerOracleAsmAccessRoleArn, forKey: .secretsManagerOracleAsmAccessRoleArn)
        }
        if let secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretId {
            try encodeContainer.encode(secretsManagerOracleAsmSecretId, forKey: .secretsManagerOracleAsmSecretId)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let securityDbEncryption = securityDbEncryption {
            try encodeContainer.encode(securityDbEncryption, forKey: .securityDbEncryption)
        }
        if let securityDbEncryptionName = securityDbEncryptionName {
            try encodeContainer.encode(securityDbEncryptionName, forKey: .securityDbEncryptionName)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let spatialDataOptionToGeoJsonFunctionName = spatialDataOptionToGeoJsonFunctionName {
            try encodeContainer.encode(spatialDataOptionToGeoJsonFunctionName, forKey: .spatialDataOptionToGeoJsonFunctionName)
        }
        if let useAlternateFolderForOnline = useAlternateFolderForOnline {
            try encodeContainer.encode(useAlternateFolderForOnline, forKey: .useAlternateFolderForOnline)
        }
        if let usePathPrefix = usePathPrefix {
            try encodeContainer.encode(usePathPrefix, forKey: .usePathPrefix)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addSupplementalLoggingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .addSupplementalLogging)
        addSupplementalLogging = addSupplementalLoggingDecoded
        let archivedLogDestIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .archivedLogDestId)
        archivedLogDestId = archivedLogDestIdDecoded
        let additionalArchivedLogDestIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .additionalArchivedLogDestId)
        additionalArchivedLogDestId = additionalArchivedLogDestIdDecoded
        let allowSelectNestedTablesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowSelectNestedTables)
        allowSelectNestedTables = allowSelectNestedTablesDecoded
        let parallelAsmReadThreadsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelAsmReadThreads)
        parallelAsmReadThreads = parallelAsmReadThreadsDecoded
        let readAheadBlocksDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .readAheadBlocks)
        readAheadBlocks = readAheadBlocksDecoded
        let accessAlternateDirectlyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .accessAlternateDirectly)
        accessAlternateDirectly = accessAlternateDirectlyDecoded
        let useAlternateFolderForOnlineDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useAlternateFolderForOnline)
        useAlternateFolderForOnline = useAlternateFolderForOnlineDecoded
        let oraclePathPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .oraclePathPrefix)
        oraclePathPrefix = oraclePathPrefixDecoded
        let usePathPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usePathPrefix)
        usePathPrefix = usePathPrefixDecoded
        let replacePathPrefixDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .replacePathPrefix)
        replacePathPrefix = replacePathPrefixDecoded
        let enableHomogenousTablespaceDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableHomogenousTablespace)
        enableHomogenousTablespace = enableHomogenousTablespaceDecoded
        let directPathNoLogDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .directPathNoLog)
        directPathNoLog = directPathNoLogDecoded
        let archivedLogsOnlyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .archivedLogsOnly)
        archivedLogsOnly = archivedLogsOnlyDecoded
        let asmPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .asmPassword)
        asmPassword = asmPasswordDecoded
        let asmServerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .asmServer)
        asmServer = asmServerDecoded
        let asmUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .asmUser)
        asmUser = asmUserDecoded
        let charLengthSemanticsDecoded = try containerValues.decodeIfPresent(CharLengthSemantics.self, forKey: .charLengthSemantics)
        charLengthSemantics = charLengthSemanticsDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let directPathParallelLoadDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .directPathParallelLoad)
        directPathParallelLoad = directPathParallelLoadDecoded
        let failTasksOnLobTruncationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .failTasksOnLobTruncation)
        failTasksOnLobTruncation = failTasksOnLobTruncationDecoded
        let numberDatatypeScaleDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberDatatypeScale)
        numberDatatypeScale = numberDatatypeScaleDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let readTableSpaceNameDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .readTableSpaceName)
        readTableSpaceName = readTableSpaceNameDecoded
        let retryIntervalDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retryInterval)
        retryInterval = retryIntervalDecoded
        let securityDbEncryptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityDbEncryption)
        securityDbEncryption = securityDbEncryptionDecoded
        let securityDbEncryptionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityDbEncryptionName)
        securityDbEncryptionName = securityDbEncryptionNameDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let spatialDataOptionToGeoJsonFunctionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .spatialDataOptionToGeoJsonFunctionName)
        spatialDataOptionToGeoJsonFunctionName = spatialDataOptionToGeoJsonFunctionNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
        let secretsManagerOracleAsmAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerOracleAsmAccessRoleArn)
        secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArnDecoded
        let secretsManagerOracleAsmSecretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerOracleAsmSecretId)
        secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretIdDecoded
    }
}

extension OracleSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OracleSettings(accessAlternateDirectly: \(String(describing: accessAlternateDirectly)), addSupplementalLogging: \(String(describing: addSupplementalLogging)), additionalArchivedLogDestId: \(String(describing: additionalArchivedLogDestId)), allowSelectNestedTables: \(String(describing: allowSelectNestedTables)), archivedLogDestId: \(String(describing: archivedLogDestId)), archivedLogsOnly: \(String(describing: archivedLogsOnly)), asmPassword: \(String(describing: asmPassword)), asmServer: \(String(describing: asmServer)), asmUser: \(String(describing: asmUser)), charLengthSemantics: \(String(describing: charLengthSemantics)), databaseName: \(String(describing: databaseName)), directPathNoLog: \(String(describing: directPathNoLog)), directPathParallelLoad: \(String(describing: directPathParallelLoad)), enableHomogenousTablespace: \(String(describing: enableHomogenousTablespace)), failTasksOnLobTruncation: \(String(describing: failTasksOnLobTruncation)), numberDatatypeScale: \(String(describing: numberDatatypeScale)), oraclePathPrefix: \(String(describing: oraclePathPrefix)), parallelAsmReadThreads: \(String(describing: parallelAsmReadThreads)), password: \(String(describing: password)), port: \(String(describing: port)), readAheadBlocks: \(String(describing: readAheadBlocks)), readTableSpaceName: \(String(describing: readTableSpaceName)), replacePathPrefix: \(String(describing: replacePathPrefix)), retryInterval: \(String(describing: retryInterval)), secretsManagerAccessRoleArn: \(String(describing: secretsManagerAccessRoleArn)), secretsManagerOracleAsmAccessRoleArn: \(String(describing: secretsManagerOracleAsmAccessRoleArn)), secretsManagerOracleAsmSecretId: \(String(describing: secretsManagerOracleAsmSecretId)), secretsManagerSecretId: \(String(describing: secretsManagerSecretId)), securityDbEncryption: \(String(describing: securityDbEncryption)), securityDbEncryptionName: \(String(describing: securityDbEncryptionName)), serverName: \(String(describing: serverName)), spatialDataOptionToGeoJsonFunctionName: \(String(describing: spatialDataOptionToGeoJsonFunctionName)), useAlternateFolderForOnline: \(String(describing: useAlternateFolderForOnline)), usePathPrefix: \(String(describing: usePathPrefix)), username: \(String(describing: username)))"}
}

/// <p>Provides information that defines an Oracle endpoint.</p>
public struct OracleSettings: Equatable {
    /// <p>Set this attribute to <code>false</code> in order to use the Binary Reader
    ///          to capture change data for an Amazon RDS for Oracle as the
    ///          source. This tells the DMS instance to not access redo logs
    ///          through any specified path prefix replacement using direct
    ///          file access.</p>
    public let accessAlternateDirectly: Bool?
    /// <p>Set this attribute to set up table-level supplemental logging
    ///          for the Oracle database. This attribute enables PRIMARY KEY
    ///          supplemental logging on all tables selected for a migration
    ///          task.</p>
    ///          <p>If you use this option, you still need to enable
    ///          database-level supplemental logging.</p>
    public let addSupplementalLogging: Bool?
    /// <p>Set this attribute with <code>archivedLogDestId</code> in a primary/
    ///          standby setup. This attribute is useful in the case of a
    ///          switchover. In this case, AWS DMS needs to know which
    ///          destination to get archive redo logs from to read changes.
    ///          This need arises because the previous primary instance is
    ///          now a standby instance after switchover.</p>
    public let additionalArchivedLogDestId: Int?
    /// <p>Set this attribute to <code>true</code> to enable replication of Oracle
    ///          tables containing columns that are nested tables or defined
    ///          types.</p>
    public let allowSelectNestedTables: Bool?
    /// <p>Specifies the destination of the archived redo logs. The
    ///          value should be the same as the DEST_ID number in the
    ///          v$archived_log table. When working with multiple log
    ///          destinations (DEST_ID), we recommend that you to specify
    ///          an archived redo logs location identifier. Doing this improves
    ///          performance by ensuring that the correct logs are accessed
    ///          from the outset.</p>
    public let archivedLogDestId: Int?
    /// <p>When this field is set to <code>Y</code>, AWS DMS only accesses the
    ///          archived redo logs. If the archived redo logs are stored on
    ///          Oracle ASM only, the AWS DMS user account needs to be
    ///          granted ASM privileges.</p>
    public let archivedLogsOnly: Bool?
    /// <p>For an Oracle source endpoint, your Oracle Automatic Storage Management (ASM) password.
    ///          You can set this value from the <code>
    ///                <i>asm_user_password</i>
    ///             </code> value.
    ///          You set this value as part of the comma-separated value that you set to the
    ///             <code>Password</code> request parameter when you create the endpoint to access
    ///          transaction logs using Binary Reader. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration">Configuration for change data capture (CDC) on an Oracle source
    ///             database</a>.</p>
    public let asmPassword: String?
    /// <p>For an Oracle source endpoint, your ASM server address. You can set this value from the
    ///             <code>asm_server</code> value. You set <code>asm_server</code> as part of the extra
    ///          connection attribute string to access an Oracle server with Binary Reader that uses ASM.
    ///          For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration">Configuration for change data capture (CDC) on an Oracle source
    ///             database</a>.</p>
    public let asmServer: String?
    /// <p>For an Oracle source endpoint, your ASM user name. You can set this value from the
    ///             <code>asm_user</code> value. You set <code>asm_user</code> as part of the extra
    ///          connection attribute string to access an Oracle server with Binary Reader that uses ASM.
    ///          For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration">Configuration for change data capture (CDC) on an Oracle source
    ///             database</a>.</p>
    public let asmUser: String?
    /// <p>Specifies whether the length of a character column is in
    ///          bytes or in characters. To indicate that the character column
    ///          length is in characters, set this attribute to <code>CHAR</code>. Otherwise,
    ///          the character column length is in bytes.</p>
    ///          <p>Example: <code>charLengthSemantics=CHAR;</code>
    ///          </p>
    public let charLengthSemantics: CharLengthSemantics?
    /// <p>Database name for the endpoint.</p>
    public let databaseName: String?
    /// <p>When set to <code>true</code>, this attribute helps to increase the
    ///          commit rate on the Oracle target database by writing
    ///          directly to tables and not writing a trail to database logs.</p>
    public let directPathNoLog: Bool?
    /// <p>When set to <code>true</code>, this attribute specifies a parallel load
    ///          when <code>useDirectPathFullLoad</code> is set to <code>Y</code>. This attribute
    ///          also only applies when you use the AWS DMS parallel load
    ///          feature.  Note that the target table cannot have any constraints or indexes.</p>
    public let directPathParallelLoad: Bool?
    /// <p>Set this attribute to enable homogenous tablespace
    ///          replication and create existing tables or indexes under the
    ///          same tablespace on the target.</p>
    public let enableHomogenousTablespace: Bool?
    /// <p>When set to <code>true</code>, this attribute causes a task to fail if the
    ///          actual size of an LOB column is greater than the specified
    ///          <code>LobMaxSize</code>.</p>
    ///          <p>If a task is set to limited LOB mode and this option is set to
    ///          <code>true</code>, the task fails instead of truncating the LOB data.</p>
    public let failTasksOnLobTruncation: Bool?
    /// <p>Specifies the number scale. You can select a scale up to 38,
    ///          or you can select FLOAT. By default, the NUMBER data type
    ///          is converted to precision 38, scale 10.</p>
    ///          <p>Example: <code>numberDataTypeScale=12</code>
    ///          </p>
    public let numberDatatypeScale: Int?
    /// <p>Set this string attribute to the required value in order to use
    ///          the Binary Reader to capture change data for an Amazon
    ///          RDS for Oracle as the source. This value specifies the
    ///          default Oracle root used to access the redo logs.</p>
    public let oraclePathPrefix: String?
    /// <p>Set this attribute to change the number of threads that
    ///          DMS configures to perform a Change Data Capture (CDC)
    ///          load using Oracle Automatic Storage Management (ASM).
    ///          You can specify an integer value between 2 (the default)
    ///          and 8 (the maximum). Use this attribute together with the
    ///          <code>readAheadBlocks</code> attribute.</p>
    public let parallelAsmReadThreads: Int?
    /// <p>Endpoint connection password.</p>
    public let password: String?
    /// <p>Endpoint TCP port.</p>
    public let port: Int?
    /// <p>Set this attribute to change the number of read-ahead
    ///          blocks that DMS configures to perform a Change Data
    ///          Capture (CDC) load using Oracle Automatic Storage
    ///          Management (ASM). You can specify an integer value
    ///          between 1000 (the default) and 200,000 (the maximum).</p>
    public let readAheadBlocks: Int?
    /// <p>When set to <code>true</code>, this attribute supports tablespace
    ///          replication.</p>
    public let readTableSpaceName: Bool?
    /// <p>Set this attribute to true in order to use the Binary Reader
    ///          to capture change data for an Amazon RDS for Oracle as the
    ///          source. This setting tells DMS instance to replace the default
    ///          Oracle root with the specified <code>usePathPrefix</code> setting to
    ///          access the redo logs.</p>
    public let replacePathPrefix: Bool?
    /// <p>Specifies the number of seconds that the system waits
    ///          before resending a query.</p>
    ///          <p>Example: <code>retryInterval=6;</code>
    ///          </p>
    public let retryInterval: Int?
    /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
    ///          trusted entity and grants the required permissions to access the value in
    ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
    ///          Manager secret that allows access to the Oracle endpoint.</p>
    ///          <note>
    ///             <p>You can specify one of two sets of values for these permissions. You can specify the
    ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
    ///             clear-text values for <code>UserName</code>, <code>Password</code>,
    ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
    ///             information on creating this <code>SecretsManagerSecret</code> and the
    ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
    ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
    ///                resources</a> in the <i>AWS Database Migration Service User
    ///                Guide</i>.</p>
    ///          </note>
    public let secretsManagerAccessRoleArn: String?
    /// <p>Required only if your Oracle endpoint uses Advanced Storage Manager (ASM). The full ARN
    ///          of the IAM role that specifies AWS DMS as the trusted entity and grants the required
    ///          permissions to access the <code>SecretsManagerOracleAsmSecret</code>. This
    ///             <code>SecretsManagerOracleAsmSecret</code> has the secret value that allows access to
    ///          the Oracle ASM of the endpoint.</p>
    ///          <note>
    ///             <p>You can specify one of two sets of values for these permissions. You can specify the
    ///             values for this setting and <code>SecretsManagerOracleAsmSecretId</code>. Or you can
    ///             specify clear-text values for <code>AsmUserName</code>, <code>AsmPassword</code>, and
    ///                <code>AsmServerName</code>. You can't specify both. For more information on
    ///             creating this <code>SecretsManagerOracleAsmSecret</code> and the
    ///                <code>SecretsManagerOracleAsmAccessRoleArn</code> and
    ///                <code>SecretsManagerOracleAsmSecretId</code> required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
    ///                resources</a> in the <i>AWS Database Migration Service User
    ///                Guide</i>.</p>
    ///          </note>
    public let secretsManagerOracleAsmAccessRoleArn: String?
    /// <p>Required only if your Oracle endpoint uses Advanced Storage Manager (ASM). The full ARN, partial ARN, or friendly name of the <code>SecretsManagerOracleAsmSecret</code>
    ///          that contains the Oracle ASM connection details for the Oracle endpoint.</p>
    public let secretsManagerOracleAsmSecretId: String?
    /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the Oracle endpoint connection details.</p>
    public let secretsManagerSecretId: String?
    /// <p>For an Oracle source endpoint, the transparent data encryption (TDE) password required
    ///          by AWM DMS to access Oracle redo logs encrypted by TDE using Binary Reader. It is also the
    ///                <code>
    ///                <i>TDE_Password</i>
    ///             </code> part of the comma-separated value you
    ///          set to the <code>Password</code> request parameter when you create the endpoint. The
    ///             <code>SecurityDbEncryptian</code> setting is related to this
    ///             <code>SecurityDbEncryptionName</code> setting. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.Encryption"> Supported encryption methods for using Oracle as a source for AWS
    ///             DMS</a> in the <i>AWS Database Migration Service User Guide</i>. </p>
    public let securityDbEncryption: String?
    /// <p>For an Oracle source endpoint, the name of a key used for the transparent data
    ///          encryption (TDE) of the columns and tablespaces in an Oracle source database that is
    ///          encrypted using TDE. The key value is the value of the <code>SecurityDbEncryption</code>
    ///          setting. For more information on setting the key name value of
    ///             <code>SecurityDbEncryptionName</code>, see the information and example for setting the
    ///             <code>securityDbEncryptionName</code> extra connection attribute in <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.Encryption"> Supported encryption methods for using Oracle as a source for AWS
    ///             DMS</a> in the <i>AWS Database Migration Service User
    ///          Guide</i>.</p>
    public let securityDbEncryptionName: String?
    /// <p>Fully qualified domain name of the endpoint.</p>
    public let serverName: String?
    /// <p>Use this attribute to convert <code>SDO_GEOMETRY</code> to
    ///          <code>GEOJSON</code> format. By default, DMS calls the
    ///          <code>SDO2GEOJSON</code> custom function if present and accessible.
    ///          Or you can create your own custom function that mimics the operation of
    ///          <code>SDOGEOJSON</code> and set
    ///          <code>SpatialDataOptionToGeoJsonFunctionName</code> to call it instead. </p>
    public let spatialDataOptionToGeoJsonFunctionName: String?
    /// <p>Set this attribute to <code>true</code> in order to use the Binary Reader
    ///          to capture change data for an Amazon RDS for Oracle as
    ///          the source. This tells the DMS instance to use any specified
    ///          prefix replacement to access all online redo logs.</p>
    public let useAlternateFolderForOnline: Bool?
    /// <p>Set this string attribute to the required value in order to use
    ///          the Binary Reader to capture change data for an Amazon
    ///          RDS for Oracle as the source. This value specifies the path
    ///          prefix used to replace the default Oracle root to access the
    ///          redo logs.</p>
    public let usePathPrefix: String?
    /// <p>Endpoint connection user name.</p>
    public let username: String?

    public init (
        accessAlternateDirectly: Bool? = nil,
        addSupplementalLogging: Bool? = nil,
        additionalArchivedLogDestId: Int? = nil,
        allowSelectNestedTables: Bool? = nil,
        archivedLogDestId: Int? = nil,
        archivedLogsOnly: Bool? = nil,
        asmPassword: String? = nil,
        asmServer: String? = nil,
        asmUser: String? = nil,
        charLengthSemantics: CharLengthSemantics? = nil,
        databaseName: String? = nil,
        directPathNoLog: Bool? = nil,
        directPathParallelLoad: Bool? = nil,
        enableHomogenousTablespace: Bool? = nil,
        failTasksOnLobTruncation: Bool? = nil,
        numberDatatypeScale: Int? = nil,
        oraclePathPrefix: String? = nil,
        parallelAsmReadThreads: Int? = nil,
        password: String? = nil,
        port: Int? = nil,
        readAheadBlocks: Int? = nil,
        readTableSpaceName: Bool? = nil,
        replacePathPrefix: Bool? = nil,
        retryInterval: Int? = nil,
        secretsManagerAccessRoleArn: String? = nil,
        secretsManagerOracleAsmAccessRoleArn: String? = nil,
        secretsManagerOracleAsmSecretId: String? = nil,
        secretsManagerSecretId: String? = nil,
        securityDbEncryption: String? = nil,
        securityDbEncryptionName: String? = nil,
        serverName: String? = nil,
        spatialDataOptionToGeoJsonFunctionName: String? = nil,
        useAlternateFolderForOnline: Bool? = nil,
        usePathPrefix: String? = nil,
        username: String? = nil
    )
    {
        self.accessAlternateDirectly = accessAlternateDirectly
        self.addSupplementalLogging = addSupplementalLogging
        self.additionalArchivedLogDestId = additionalArchivedLogDestId
        self.allowSelectNestedTables = allowSelectNestedTables
        self.archivedLogDestId = archivedLogDestId
        self.archivedLogsOnly = archivedLogsOnly
        self.asmPassword = asmPassword
        self.asmServer = asmServer
        self.asmUser = asmUser
        self.charLengthSemantics = charLengthSemantics
        self.databaseName = databaseName
        self.directPathNoLog = directPathNoLog
        self.directPathParallelLoad = directPathParallelLoad
        self.enableHomogenousTablespace = enableHomogenousTablespace
        self.failTasksOnLobTruncation = failTasksOnLobTruncation
        self.numberDatatypeScale = numberDatatypeScale
        self.oraclePathPrefix = oraclePathPrefix
        self.parallelAsmReadThreads = parallelAsmReadThreads
        self.password = password
        self.port = port
        self.readAheadBlocks = readAheadBlocks
        self.readTableSpaceName = readTableSpaceName
        self.replacePathPrefix = replacePathPrefix
        self.retryInterval = retryInterval
        self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
        self.secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArn
        self.secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretId
        self.secretsManagerSecretId = secretsManagerSecretId
        self.securityDbEncryption = securityDbEncryption
        self.securityDbEncryptionName = securityDbEncryptionName
        self.serverName = serverName
        self.spatialDataOptionToGeoJsonFunctionName = spatialDataOptionToGeoJsonFunctionName
        self.useAlternateFolderForOnline = useAlternateFolderForOnline
        self.usePathPrefix = usePathPrefix
        self.username = username
    }
}

extension OrderableReplicationInstance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case defaultAllocatedStorage = "DefaultAllocatedStorage"
        case engineVersion = "EngineVersion"
        case includedAllocatedStorage = "IncludedAllocatedStorage"
        case maxAllocatedStorage = "MaxAllocatedStorage"
        case minAllocatedStorage = "MinAllocatedStorage"
        case releaseStatus = "ReleaseStatus"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzoneslist0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzoneslist0)
            }
        }
        if defaultAllocatedStorage != 0 {
            try encodeContainer.encode(defaultAllocatedStorage, forKey: .defaultAllocatedStorage)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if includedAllocatedStorage != 0 {
            try encodeContainer.encode(includedAllocatedStorage, forKey: .includedAllocatedStorage)
        }
        if maxAllocatedStorage != 0 {
            try encodeContainer.encode(maxAllocatedStorage, forKey: .maxAllocatedStorage)
        }
        if minAllocatedStorage != 0 {
            try encodeContainer.encode(minAllocatedStorage, forKey: .minAllocatedStorage)
        }
        if let releaseStatus = releaseStatus {
            try encodeContainer.encode(releaseStatus.rawValue, forKey: .releaseStatus)
        }
        if let replicationInstanceClass = replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType, forKey: .storageType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let minAllocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .minAllocatedStorage)
        minAllocatedStorage = minAllocatedStorageDecoded
        let maxAllocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .maxAllocatedStorage)
        maxAllocatedStorage = maxAllocatedStorageDecoded
        let defaultAllocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .defaultAllocatedStorage)
        defaultAllocatedStorage = defaultAllocatedStorageDecoded
        let includedAllocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .includedAllocatedStorage)
        includedAllocatedStorage = includedAllocatedStorageDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let releaseStatusDecoded = try containerValues.decodeIfPresent(ReleaseStatusValues.self, forKey: .releaseStatus)
        releaseStatus = releaseStatusDecoded
    }
}

extension OrderableReplicationInstance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrderableReplicationInstance(availabilityZones: \(String(describing: availabilityZones)), defaultAllocatedStorage: \(String(describing: defaultAllocatedStorage)), engineVersion: \(String(describing: engineVersion)), includedAllocatedStorage: \(String(describing: includedAllocatedStorage)), maxAllocatedStorage: \(String(describing: maxAllocatedStorage)), minAllocatedStorage: \(String(describing: minAllocatedStorage)), releaseStatus: \(String(describing: releaseStatus)), replicationInstanceClass: \(String(describing: replicationInstanceClass)), storageType: \(String(describing: storageType)))"}
}

/// <p>In response to the <code>DescribeOrderableReplicationInstances</code> operation, this
///          object describes an available replication instance. This description includes the
///          replication instance's type, engine version, and allocated storage.</p>
public struct OrderableReplicationInstance: Equatable {
    /// <p>List of Availability Zones for this replication instance.</p>
    public let availabilityZones: [String]?
    /// <p>The default amount of storage (in gigabytes) that is allocated for the replication
    ///          instance.</p>
    public let defaultAllocatedStorage: Int
    /// <p>The version of the replication engine.</p>
    public let engineVersion: String?
    /// <p>The amount of storage (in gigabytes) that is allocated for the replication
    ///          instance.</p>
    public let includedAllocatedStorage: Int
    /// <p>The minimum amount of storage (in gigabytes) that can be allocated for the replication
    ///          instance.</p>
    public let maxAllocatedStorage: Int
    /// <p>The minimum amount of storage (in gigabytes) that can be allocated for the replication
    ///          instance.</p>
    public let minAllocatedStorage: Int
    /// <p>The value returned when the specified <code>EngineVersion</code> of the replication
    ///          instance is in Beta or test mode. This indicates some features might not work as expected.</p>
    ///          <note>
    ///             <p>AWS DMS supports the <code>ReleaseStatus</code> parameter in versions 3.1.4 and later.</p>
    ///          </note>
    public let releaseStatus: ReleaseStatusValues?
    /// <p>The compute and memory capacity of the replication instance as defined for the specified
    ///          replication instance class. For example to specify the instance class dms.c4.large, set this parameter to <code>"dms.c4.large"</code>.</p>
    ///          <p>For more information on the settings and capacities for the available replication instance classes, see
    ///          <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth">
    ///             Selecting the right AWS DMS replication instance for your migration</a>.
    ///       </p>
    public let replicationInstanceClass: String?
    /// <p>The type of storage used by the replication instance.</p>
    public let storageType: String?

    public init (
        availabilityZones: [String]? = nil,
        defaultAllocatedStorage: Int = 0,
        engineVersion: String? = nil,
        includedAllocatedStorage: Int = 0,
        maxAllocatedStorage: Int = 0,
        minAllocatedStorage: Int = 0,
        releaseStatus: ReleaseStatusValues? = nil,
        replicationInstanceClass: String? = nil,
        storageType: String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.defaultAllocatedStorage = defaultAllocatedStorage
        self.engineVersion = engineVersion
        self.includedAllocatedStorage = includedAllocatedStorage
        self.maxAllocatedStorage = maxAllocatedStorage
        self.minAllocatedStorage = minAllocatedStorage
        self.releaseStatus = releaseStatus
        self.replicationInstanceClass = replicationInstanceClass
        self.storageType = storageType
    }
}

public enum ParquetVersionValue {
    case parquet10
    case parquet20
    case sdkUnknown(String)
}

extension ParquetVersionValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ParquetVersionValue] {
        return [
            .parquet10,
            .parquet20,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .parquet10: return "parquet-1-0"
        case .parquet20: return "parquet-2-0"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ParquetVersionValue(rawValue: rawValue) ?? ParquetVersionValue.sdkUnknown(rawValue)
    }
}

extension PendingMaintenanceAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case autoAppliedAfterDate = "AutoAppliedAfterDate"
        case currentApplyDate = "CurrentApplyDate"
        case description = "Description"
        case forcedApplyDate = "ForcedApplyDate"
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let autoAppliedAfterDate = autoAppliedAfterDate {
            try encodeContainer.encode(autoAppliedAfterDate.timeIntervalSince1970, forKey: .autoAppliedAfterDate)
        }
        if let currentApplyDate = currentApplyDate {
            try encodeContainer.encode(currentApplyDate.timeIntervalSince1970, forKey: .currentApplyDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forcedApplyDate = forcedApplyDate {
            try encodeContainer.encode(forcedApplyDate.timeIntervalSince1970, forKey: .forcedApplyDate)
        }
        if let optInStatus = optInStatus {
            try encodeContainer.encode(optInStatus, forKey: .optInStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .action)
        action = actionDecoded
        let autoAppliedAfterDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .autoAppliedAfterDate)
        autoAppliedAfterDate = autoAppliedAfterDateDecoded
        let forcedApplyDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .forcedApplyDate)
        forcedApplyDate = forcedApplyDateDecoded
        let optInStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
        let currentApplyDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .currentApplyDate)
        currentApplyDate = currentApplyDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension PendingMaintenanceAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PendingMaintenanceAction(action: \(String(describing: action)), autoAppliedAfterDate: \(String(describing: autoAppliedAfterDate)), currentApplyDate: \(String(describing: currentApplyDate)), description: \(String(describing: description)), forcedApplyDate: \(String(describing: forcedApplyDate)), optInStatus: \(String(describing: optInStatus)))"}
}

/// <p>Describes a maintenance action pending for an AWS DMS resource, including when and how
///          it will be applied. This data type is a response element to the
///             <code>DescribePendingMaintenanceActions</code> operation.</p>
public struct PendingMaintenanceAction: Equatable {
    /// <p>The type of pending maintenance action that is available for the resource.</p>
    public let action: String?
    /// <p>The date of the maintenance window when the action is to be applied. The maintenance
    ///          action is applied to the resource during its first maintenance window after this date. If
    ///          this date is specified, any <code>next-maintenance</code> opt-in requests are
    ///          ignored.</p>
    public let autoAppliedAfterDate: Date?
    /// <p>The effective date when the pending maintenance action will be applied to the resource.
    ///          This date takes into account opt-in requests received from the
    ///             <code>ApplyPendingMaintenanceAction</code> API operation, and also the
    ///             <code>AutoAppliedAfterDate</code> and <code>ForcedApplyDate</code> parameter values.
    ///          This value is blank if an opt-in request has not been received and nothing has been
    ///          specified for <code>AutoAppliedAfterDate</code> or <code>ForcedApplyDate</code>.</p>
    public let currentApplyDate: Date?
    /// <p>A description providing more detail about the maintenance action.</p>
    public let description: String?
    /// <p>The date when the maintenance action will be automatically applied. The maintenance
    ///          action is applied to the resource on this date regardless of the maintenance window for the
    ///          resource. If this date is specified, any <code>immediate</code> opt-in requests are
    ///          ignored.</p>
    public let forcedApplyDate: Date?
    /// <p>The type of opt-in request that has been received for the resource.</p>
    public let optInStatus: String?

    public init (
        action: String? = nil,
        autoAppliedAfterDate: Date? = nil,
        currentApplyDate: Date? = nil,
        description: String? = nil,
        forcedApplyDate: Date? = nil,
        optInStatus: String? = nil
    )
    {
        self.action = action
        self.autoAppliedAfterDate = autoAppliedAfterDate
        self.currentApplyDate = currentApplyDate
        self.description = description
        self.forcedApplyDate = forcedApplyDate
        self.optInStatus = optInStatus
    }
}

extension PostgreSQLSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case afterConnectScript = "AfterConnectScript"
        case captureDdls = "CaptureDdls"
        case databaseName = "DatabaseName"
        case ddlArtifactsSchema = "DdlArtifactsSchema"
        case executeTimeout = "ExecuteTimeout"
        case failTasksOnLobTruncation = "FailTasksOnLobTruncation"
        case maxFileSize = "MaxFileSize"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case slotName = "SlotName"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterConnectScript = afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let captureDdls = captureDdls {
            try encodeContainer.encode(captureDdls, forKey: .captureDdls)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let ddlArtifactsSchema = ddlArtifactsSchema {
            try encodeContainer.encode(ddlArtifactsSchema, forKey: .ddlArtifactsSchema)
        }
        if let executeTimeout = executeTimeout {
            try encodeContainer.encode(executeTimeout, forKey: .executeTimeout)
        }
        if let failTasksOnLobTruncation = failTasksOnLobTruncation {
            try encodeContainer.encode(failTasksOnLobTruncation, forKey: .failTasksOnLobTruncation)
        }
        if let maxFileSize = maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let slotName = slotName {
            try encodeContainer.encode(slotName, forKey: .slotName)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let captureDdlsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .captureDdls)
        captureDdls = captureDdlsDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let ddlArtifactsSchemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ddlArtifactsSchema)
        ddlArtifactsSchema = ddlArtifactsSchemaDecoded
        let executeTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .executeTimeout)
        executeTimeout = executeTimeoutDecoded
        let failTasksOnLobTruncationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .failTasksOnLobTruncation)
        failTasksOnLobTruncation = failTasksOnLobTruncationDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension PostgreSQLSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PostgreSQLSettings(afterConnectScript: \(String(describing: afterConnectScript)), captureDdls: \(String(describing: captureDdls)), databaseName: \(String(describing: databaseName)), ddlArtifactsSchema: \(String(describing: ddlArtifactsSchema)), executeTimeout: \(String(describing: executeTimeout)), failTasksOnLobTruncation: \(String(describing: failTasksOnLobTruncation)), maxFileSize: \(String(describing: maxFileSize)), password: \(String(describing: password)), port: \(String(describing: port)), secretsManagerAccessRoleArn: \(String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(String(describing: secretsManagerSecretId)), serverName: \(String(describing: serverName)), slotName: \(String(describing: slotName)), username: \(String(describing: username)))"}
}

/// <p>Provides information that defines a PostgreSQL endpoint.</p>
public struct PostgreSQLSettings: Equatable {
    /// <p>For use with change data capture (CDC) only, this attribute
    ///          has AWS DMS bypass foreign keys and user triggers to
    ///          reduce the time it takes to bulk load data.</p>
    ///          <p>Example: <code>afterConnectScript=SET
    ///          session_replication_role='replica'</code>
    ///          </p>
    public let afterConnectScript: String?
    /// <p>To capture DDL events, AWS DMS creates various artifacts in
    ///          the PostgreSQL database when the task starts. You can later
    ///          remove these artifacts.</p>
    ///          <p>If this value is set to <code>N</code>, you don't have to create tables or
    ///          triggers on the source database.</p>
    public let captureDdls: Bool?
    /// <p>Database name for the endpoint.</p>
    public let databaseName: String?
    /// <p>The schema in which the operational DDL database artifacts
    ///          are created.</p>
    ///          <p>Example: <code>ddlArtifactsSchema=xyzddlschema;</code>
    ///          </p>
    public let ddlArtifactsSchema: String?
    /// <p>Sets the client statement timeout for the PostgreSQL
    ///          instance, in seconds. The default value is 60 seconds.</p>
    ///          <p>Example: <code>executeTimeout=100;</code>
    ///          </p>
    public let executeTimeout: Int?
    /// <p>When set to <code>true</code>, this value causes a task to fail if the
    ///          actual size of a LOB column is greater than the specified
    ///          <code>LobMaxSize</code>.</p>
    ///          <p>If task is set to Limited LOB mode and this option is set to
    ///          true, the task fails instead of truncating the LOB data.</p>
    public let failTasksOnLobTruncation: Bool?
    /// <p>Specifies the maximum size (in KB) of any .csv file used to
    ///          transfer data to PostgreSQL.</p>
    ///          <p>Example: <code>maxFileSize=512</code>
    ///          </p>
    public let maxFileSize: Int?
    /// <p>Endpoint connection password.</p>
    public let password: String?
    /// <p>Endpoint TCP port.</p>
    public let port: Int?
    /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
    ///          trusted entity and grants the required permissions to access the value in
    ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
    ///          Manager secret that allows access to the PostgreSQL endpoint.</p>
    ///          <note>
    ///             <p>You can specify one of two sets of values for these permissions. You can specify the
    ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
    ///             clear-text values for <code>UserName</code>, <code>Password</code>,
    ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
    ///             information on creating this <code>SecretsManagerSecret</code> and the
    ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
    ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
    ///                resources</a> in the <i>AWS Database Migration Service User
    ///                Guide</i>.</p>
    ///          </note>
    public let secretsManagerAccessRoleArn: String?
    /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the PostgreSQL endpoint connection details.</p>
    public let secretsManagerSecretId: String?
    /// <p>Fully qualified domain name of the endpoint.</p>
    public let serverName: String?
    /// <p>Sets the name of a previously created logical replication slot
    ///          for a CDC load of the PostgreSQL source instance.</p>
    ///          <p>When used with the AWS DMS API <code>CdcStartPosition</code>
    ///          request parameter, this attribute also enables using native
    ///          CDC start points.</p>
    public let slotName: String?
    /// <p>Endpoint connection user name.</p>
    public let username: String?

    public init (
        afterConnectScript: String? = nil,
        captureDdls: Bool? = nil,
        databaseName: String? = nil,
        ddlArtifactsSchema: String? = nil,
        executeTimeout: Int? = nil,
        failTasksOnLobTruncation: Bool? = nil,
        maxFileSize: Int? = nil,
        password: String? = nil,
        port: Int? = nil,
        secretsManagerAccessRoleArn: String? = nil,
        secretsManagerSecretId: String? = nil,
        serverName: String? = nil,
        slotName: String? = nil,
        username: String? = nil
    )
    {
        self.afterConnectScript = afterConnectScript
        self.captureDdls = captureDdls
        self.databaseName = databaseName
        self.ddlArtifactsSchema = ddlArtifactsSchema
        self.executeTimeout = executeTimeout
        self.failTasksOnLobTruncation = failTasksOnLobTruncation
        self.maxFileSize = maxFileSize
        self.password = password
        self.port = port
        self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
        self.secretsManagerSecretId = secretsManagerSecretId
        self.serverName = serverName
        self.slotName = slotName
        self.username = username
    }
}

public struct RebootReplicationInstanceInputBodyMiddleware: Middleware {
    public let id: String = "RebootReplicationInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootReplicationInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootReplicationInstanceInput>
    public typealias MOutput = OperationOutput<RebootReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootReplicationInstanceOutputError>
}

extension RebootReplicationInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootReplicationInstanceInput(forceFailover: \(String(describing: forceFailover)), replicationInstanceArn: \(String(describing: replicationInstanceArn)))"}
}

extension RebootReplicationInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case forceFailover = "ForceFailover"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forceFailover = forceFailover {
            try encodeContainer.encode(forceFailover, forKey: .forceFailover)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct RebootReplicationInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "RebootReplicationInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootReplicationInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootReplicationInstanceInput>
    public typealias MOutput = OperationOutput<RebootReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootReplicationInstanceOutputError>
}

public struct RebootReplicationInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "RebootReplicationInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootReplicationInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootReplicationInstanceInput>
    public typealias MOutput = OperationOutput<RebootReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootReplicationInstanceOutputError>
}

public struct RebootReplicationInstanceInput: Equatable {
    /// <p>If this parameter is <code>true</code>, the reboot is conducted through a Multi-AZ
    ///          failover. (If the instance isn't configured for Multi-AZ, then you can't specify
    ///             <code>true</code>.)</p>
    public let forceFailover: Bool?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: String?

    public init (
        forceFailover: Bool? = nil,
        replicationInstanceArn: String? = nil
    )
    {
        self.forceFailover = forceFailover
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct RebootReplicationInstanceInputBody: Equatable {
    public let replicationInstanceArn: String?
    public let forceFailover: Bool?
}

extension RebootReplicationInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forceFailover = "ForceFailover"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let forceFailoverDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .forceFailover)
        forceFailover = forceFailoverDecoded
    }
}

extension RebootReplicationInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootReplicationInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootReplicationInstanceOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootReplicationInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootReplicationInstanceOutputResponse(replicationInstance: \(String(describing: replicationInstance)))"}
}

extension RebootReplicationInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RebootReplicationInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

public struct RebootReplicationInstanceOutputResponse: Equatable {
    /// <p>The replication instance that is being rebooted. </p>
    public let replicationInstance: ReplicationInstance?

    public init (
        replicationInstance: ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct RebootReplicationInstanceOutputResponseBody: Equatable {
    public let replicationInstance: ReplicationInstance?
}

extension RebootReplicationInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

extension RedshiftSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptAnyDate = "AcceptAnyDate"
        case afterConnectScript = "AfterConnectScript"
        case bucketFolder = "BucketFolder"
        case bucketName = "BucketName"
        case caseSensitiveNames = "CaseSensitiveNames"
        case compUpdate = "CompUpdate"
        case connectionTimeout = "ConnectionTimeout"
        case databaseName = "DatabaseName"
        case dateFormat = "DateFormat"
        case emptyAsNull = "EmptyAsNull"
        case encryptionMode = "EncryptionMode"
        case explicitIds = "ExplicitIds"
        case fileTransferUploadStreams = "FileTransferUploadStreams"
        case loadTimeout = "LoadTimeout"
        case maxFileSize = "MaxFileSize"
        case password = "Password"
        case port = "Port"
        case removeQuotes = "RemoveQuotes"
        case replaceChars = "ReplaceChars"
        case replaceInvalidChars = "ReplaceInvalidChars"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case timeFormat = "TimeFormat"
        case trimBlanks = "TrimBlanks"
        case truncateColumns = "TruncateColumns"
        case username = "Username"
        case writeBufferSize = "WriteBufferSize"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptAnyDate = acceptAnyDate {
            try encodeContainer.encode(acceptAnyDate, forKey: .acceptAnyDate)
        }
        if let afterConnectScript = afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let bucketFolder = bucketFolder {
            try encodeContainer.encode(bucketFolder, forKey: .bucketFolder)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let caseSensitiveNames = caseSensitiveNames {
            try encodeContainer.encode(caseSensitiveNames, forKey: .caseSensitiveNames)
        }
        if let compUpdate = compUpdate {
            try encodeContainer.encode(compUpdate, forKey: .compUpdate)
        }
        if let connectionTimeout = connectionTimeout {
            try encodeContainer.encode(connectionTimeout, forKey: .connectionTimeout)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dateFormat = dateFormat {
            try encodeContainer.encode(dateFormat, forKey: .dateFormat)
        }
        if let emptyAsNull = emptyAsNull {
            try encodeContainer.encode(emptyAsNull, forKey: .emptyAsNull)
        }
        if let encryptionMode = encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let explicitIds = explicitIds {
            try encodeContainer.encode(explicitIds, forKey: .explicitIds)
        }
        if let fileTransferUploadStreams = fileTransferUploadStreams {
            try encodeContainer.encode(fileTransferUploadStreams, forKey: .fileTransferUploadStreams)
        }
        if let loadTimeout = loadTimeout {
            try encodeContainer.encode(loadTimeout, forKey: .loadTimeout)
        }
        if let maxFileSize = maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let removeQuotes = removeQuotes {
            try encodeContainer.encode(removeQuotes, forKey: .removeQuotes)
        }
        if let replaceChars = replaceChars {
            try encodeContainer.encode(replaceChars, forKey: .replaceChars)
        }
        if let replaceInvalidChars = replaceInvalidChars {
            try encodeContainer.encode(replaceInvalidChars, forKey: .replaceInvalidChars)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId {
            try encodeContainer.encode(serverSideEncryptionKmsKeyId, forKey: .serverSideEncryptionKmsKeyId)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let timeFormat = timeFormat {
            try encodeContainer.encode(timeFormat, forKey: .timeFormat)
        }
        if let trimBlanks = trimBlanks {
            try encodeContainer.encode(trimBlanks, forKey: .trimBlanks)
        }
        if let truncateColumns = truncateColumns {
            try encodeContainer.encode(truncateColumns, forKey: .truncateColumns)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
        if let writeBufferSize = writeBufferSize {
            try encodeContainer.encode(writeBufferSize, forKey: .writeBufferSize)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptAnyDateDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .acceptAnyDate)
        acceptAnyDate = acceptAnyDateDecoded
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let bucketFolderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketFolder)
        bucketFolder = bucketFolderDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let caseSensitiveNamesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .caseSensitiveNames)
        caseSensitiveNames = caseSensitiveNamesDecoded
        let compUpdateDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .compUpdate)
        compUpdate = compUpdateDecoded
        let connectionTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .connectionTimeout)
        connectionTimeout = connectionTimeoutDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dateFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateFormat)
        dateFormat = dateFormatDecoded
        let emptyAsNullDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .emptyAsNull)
        emptyAsNull = emptyAsNullDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(EncryptionModeValue.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let explicitIdsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .explicitIds)
        explicitIds = explicitIdsDecoded
        let fileTransferUploadStreamsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fileTransferUploadStreams)
        fileTransferUploadStreams = fileTransferUploadStreamsDecoded
        let loadTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .loadTimeout)
        loadTimeout = loadTimeoutDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let removeQuotesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .removeQuotes)
        removeQuotes = removeQuotesDecoded
        let replaceInvalidCharsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replaceInvalidChars)
        replaceInvalidChars = replaceInvalidCharsDecoded
        let replaceCharsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replaceChars)
        replaceChars = replaceCharsDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let serverSideEncryptionKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverSideEncryptionKmsKeyId)
        serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyIdDecoded
        let timeFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeFormat)
        timeFormat = timeFormatDecoded
        let trimBlanksDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .trimBlanks)
        trimBlanks = trimBlanksDecoded
        let truncateColumnsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .truncateColumns)
        truncateColumns = truncateColumnsDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let writeBufferSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .writeBufferSize)
        writeBufferSize = writeBufferSizeDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension RedshiftSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RedshiftSettings(acceptAnyDate: \(String(describing: acceptAnyDate)), afterConnectScript: \(String(describing: afterConnectScript)), bucketFolder: \(String(describing: bucketFolder)), bucketName: \(String(describing: bucketName)), caseSensitiveNames: \(String(describing: caseSensitiveNames)), compUpdate: \(String(describing: compUpdate)), connectionTimeout: \(String(describing: connectionTimeout)), databaseName: \(String(describing: databaseName)), dateFormat: \(String(describing: dateFormat)), emptyAsNull: \(String(describing: emptyAsNull)), encryptionMode: \(String(describing: encryptionMode)), explicitIds: \(String(describing: explicitIds)), fileTransferUploadStreams: \(String(describing: fileTransferUploadStreams)), loadTimeout: \(String(describing: loadTimeout)), maxFileSize: \(String(describing: maxFileSize)), password: \(String(describing: password)), port: \(String(describing: port)), removeQuotes: \(String(describing: removeQuotes)), replaceChars: \(String(describing: replaceChars)), replaceInvalidChars: \(String(describing: replaceInvalidChars)), secretsManagerAccessRoleArn: \(String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(String(describing: secretsManagerSecretId)), serverName: \(String(describing: serverName)), serverSideEncryptionKmsKeyId: \(String(describing: serverSideEncryptionKmsKeyId)), serviceAccessRoleArn: \(String(describing: serviceAccessRoleArn)), timeFormat: \(String(describing: timeFormat)), trimBlanks: \(String(describing: trimBlanks)), truncateColumns: \(String(describing: truncateColumns)), username: \(String(describing: username)), writeBufferSize: \(String(describing: writeBufferSize)))"}
}

/// <p>Provides information that defines an Amazon Redshift endpoint.</p>
public struct RedshiftSettings: Equatable {
    /// <p>A value that indicates to allow any date format, including invalid formats such as
    ///          00/00/00 00:00:00, to be loaded without generating an error. You can choose
    ///             <code>true</code> or <code>false</code> (the default).</p>
    ///          <p>This parameter applies only to TIMESTAMP and DATE columns. Always use ACCEPTANYDATE with
    ///          the DATEFORMAT parameter. If the date format for the data doesn't match the DATEFORMAT
    ///          specification, Amazon Redshift inserts a NULL value into that field. </p>
    public let acceptAnyDate: Bool?
    /// <p>Code to run after connecting. This parameter should contain the code itself, not the
    ///          name of a file containing the code.</p>
    public let afterConnectScript: String?
    /// <p>An S3 folder where the comma-separated-value (.csv) files are stored before being
    ///          uploaded to the target Redshift cluster. </p>
    ///          <p>For full load mode, AWS DMS converts source records into .csv files and loads them to
    ///          the <i>BucketFolder/TableID</i> path. AWS DMS uses the Redshift
    ///             <code>COPY</code> command to upload the .csv files to the target table. The files are
    ///          deleted once the <code>COPY</code> operation has finished. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_COPY.html">COPY</a> in the
    ///             <i>Amazon Redshift Database Developer Guide</i>.</p>
    ///          <p>For change-data-capture (CDC) mode, AWS DMS creates a <i>NetChanges</i> table,
    ///          and loads the .csv files to this <i>BucketFolder/NetChangesTableID</i> path.</p>
    public let bucketFolder: String?
    /// <p>The name of the intermediate S3 bucket used to store .csv files before uploading data to Redshift.</p>
    public let bucketName: String?
    /// <p>If Amazon Redshift is configured to support case sensitive schema names, set
    ///             <code>CaseSensitiveNames</code> to <code>true</code>. The default is
    ///          <code>false</code>.</p>
    public let caseSensitiveNames: Bool?
    /// <p>If you set <code>CompUpdate</code> to <code>true</code> Amazon Redshift applies
    ///          automatic compression if the table is empty. This applies even if the table columns already
    ///          have encodings other than <code>RAW</code>. If you set <code>CompUpdate</code> to
    ///             <code>false</code>, automatic compression is disabled and existing column encodings
    ///          aren't changed. The default is <code>true</code>.</p>
    public let compUpdate: Bool?
    /// <p>A value that sets the amount of time to wait (in milliseconds) before timing out,
    ///          beginning from when you initially establish a connection.</p>
    public let connectionTimeout: Int?
    /// <p>The name of the Amazon Redshift data warehouse (service) that you are working
    ///          with.</p>
    public let databaseName: String?
    /// <p>The date format that you are using. Valid values are <code>auto</code> (case-sensitive),
    ///          your date format string enclosed in quotes, or NULL. If this parameter is left unset
    ///          (NULL), it defaults to a format of 'YYYY-MM-DD'. Using <code>auto</code> recognizes most
    ///          strings, even some that aren't supported when you use a date format string. </p>
    ///          <p>If your date and time values use formats different from each other, set this to
    ///          <code>auto</code>. </p>
    public let dateFormat: String?
    /// <p>A value that specifies whether AWS DMS should migrate empty CHAR and VARCHAR fields as
    ///          NULL. A value of <code>true</code> sets empty CHAR and VARCHAR fields to null. The default
    ///          is <code>false</code>.</p>
    public let emptyAsNull: Bool?
    /// <p>The type of server-side encryption that you want to use for your data. This encryption
    ///          type is part of the endpoint settings or the extra connections attributes for Amazon S3.
    ///          You can choose either <code>SSE_S3</code> (the default) or <code>SSE_KMS</code>. </p>
    ///          <note>
    ///             <p>For the <code>ModifyEndpoint</code> operation, you can change the existing value of the
    ///                <code>EncryptionMode</code> parameter from <code>SSE_KMS</code> to
    ///                <code>SSE_S3</code>. But you can’t change the existing value from <code>SSE_S3</code>
    ///             to <code>SSE_KMS</code>.</p>
    ///          </note>
    ///          <p>To use <code>SSE_S3</code>, create an AWS Identity and Access Management (IAM) role with
    ///          a policy that allows <code>"arn:aws:s3:::*"</code> to use the following actions:
    ///             <code>"s3:PutObject", "s3:ListBucket"</code>
    ///          </p>
    public let encryptionMode: EncryptionModeValue?
    /// <p>This setting is only valid for a full-load migration task. Set <code>ExplicitIds</code>
    ///          to <code>true</code> to have tables with <code>IDENTITY</code> columns override their
    ///          auto-generated values with explicit values loaded from the source data files used to
    ///          populate the tables. The default is <code>false</code>.</p>
    public let explicitIds: Bool?
    /// <p>The number of threads used to upload a single file. This parameter accepts a value from
    ///          1 through 64. It defaults to 10.</p>
    ///          <p>The number of parallel streams used to upload a single .csv file to an S3 bucket using
    ///          S3 Multipart Upload. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html">Multipart upload
    ///             overview</a>. </p>
    ///          <p>
    ///             <code>FileTransferUploadStreams</code> accepts a value from 1 through 64. It
    ///          defaults to 10.</p>
    public let fileTransferUploadStreams: Int?
    /// <p>The amount of time to wait (in milliseconds) before timing out of operations performed
    ///             by AWS DMS on a Redshift cluster, such as Redshift COPY, INSERT, DELETE, and UPDATE.</p>
    public let loadTimeout: Int?
    /// <p>The maximum size (in KB) of any .csv file used to load data on an S3 bucket and transfer
    ///             data to Amazon Redshift. It defaults to 1048576KB (1 GB).</p>
    public let maxFileSize: Int?
    /// <p>The password for the user named in the <code>username</code> property.</p>
    public let password: String?
    /// <p>The port number for Amazon Redshift. The default value is 5439.</p>
    public let port: Int?
    /// <p>A value that specifies to remove surrounding quotation marks from strings in the
    ///          incoming data. All characters within the quotation marks, including delimiters, are
    ///          retained. Choose <code>true</code> to remove quotation marks. The default is
    ///             <code>false</code>.</p>
    public let removeQuotes: Bool?
    /// <p>A value that specifies to replaces the invalid characters specified in
    ///          <code>ReplaceInvalidChars</code>, substituting the specified characters instead. The
    ///          default is <code>"?"</code>.</p>
    public let replaceChars: String?
    /// <p>A list of characters that you want to replace. Use with
    ///          <code>ReplaceChars</code>.</p>
    public let replaceInvalidChars: String?
    /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
    ///          trusted entity and grants the required permissions to access the value in
    ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
    ///          Manager secret that allows access to the Amazon Redshift endpoint.</p>
    ///          <note>
    ///             <p>You can specify one of two sets of values for these permissions. You can specify the
    ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
    ///             clear-text values for <code>UserName</code>, <code>Password</code>,
    ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
    ///             information on creating this <code>SecretsManagerSecret</code> and the
    ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
    ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
    ///                resources</a> in the <i>AWS Database Migration Service User
    ///                Guide</i>.</p>
    ///          </note>
    public let secretsManagerAccessRoleArn: String?
    /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the Amazon Redshift endpoint connection details.</p>
    public let secretsManagerSecretId: String?
    /// <p>The name of the Amazon Redshift cluster you are using.</p>
    public let serverName: String?
    /// <p>The AWS KMS key ID. If you are using <code>SSE_KMS</code> for the <code>EncryptionMode</code>,
    ///          provide this key ID. The key that you use needs an attached policy that enables IAM user
    ///          permissions and allows use of the key.</p>
    public let serverSideEncryptionKmsKeyId: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role that has access to the Amazon Redshift
    ///          service.</p>
    public let serviceAccessRoleArn: String?
    /// <p>The time format that you want to use. Valid values are <code>auto</code>
    ///          (case-sensitive), <code>'timeformat_string'</code>, <code>'epochsecs'</code>, or
    ///          <code>'epochmillisecs'</code>. It defaults to 10. Using <code>auto</code> recognizes
    ///          most strings, even some that aren't supported when you use a time format string. </p>
    ///          <p>If your date and time values use formats different from each other, set this parameter
    ///          to <code>auto</code>. </p>
    public let timeFormat: String?
    /// <p>A value that specifies to remove the trailing white space characters from a VARCHAR
    ///          string. This parameter applies only to columns with a VARCHAR data type. Choose
    ///             <code>true</code> to remove unneeded white space. The default is
    ///          <code>false</code>.</p>
    public let trimBlanks: Bool?
    /// <p>A value that specifies to truncate data in columns to the appropriate number of
    ///          characters, so that the data fits in the column. This parameter applies only to columns
    ///          with a VARCHAR or CHAR data type, and rows with a size of 4 MB or less. Choose
    ///             <code>true</code> to truncate data. The default is <code>false</code>.</p>
    public let truncateColumns: Bool?
    /// <p>An Amazon Redshift user name for a registered user.</p>
    public let username: String?
    /// <p>The size (in KB) of the in-memory file write buffer used when generating .csv files
    ///          on the local disk at the DMS replication instance. The default value is 1000
    ///          (buffer size is 1000KB).</p>
    public let writeBufferSize: Int?

    public init (
        acceptAnyDate: Bool? = nil,
        afterConnectScript: String? = nil,
        bucketFolder: String? = nil,
        bucketName: String? = nil,
        caseSensitiveNames: Bool? = nil,
        compUpdate: Bool? = nil,
        connectionTimeout: Int? = nil,
        databaseName: String? = nil,
        dateFormat: String? = nil,
        emptyAsNull: Bool? = nil,
        encryptionMode: EncryptionModeValue? = nil,
        explicitIds: Bool? = nil,
        fileTransferUploadStreams: Int? = nil,
        loadTimeout: Int? = nil,
        maxFileSize: Int? = nil,
        password: String? = nil,
        port: Int? = nil,
        removeQuotes: Bool? = nil,
        replaceChars: String? = nil,
        replaceInvalidChars: String? = nil,
        secretsManagerAccessRoleArn: String? = nil,
        secretsManagerSecretId: String? = nil,
        serverName: String? = nil,
        serverSideEncryptionKmsKeyId: String? = nil,
        serviceAccessRoleArn: String? = nil,
        timeFormat: String? = nil,
        trimBlanks: Bool? = nil,
        truncateColumns: Bool? = nil,
        username: String? = nil,
        writeBufferSize: Int? = nil
    )
    {
        self.acceptAnyDate = acceptAnyDate
        self.afterConnectScript = afterConnectScript
        self.bucketFolder = bucketFolder
        self.bucketName = bucketName
        self.caseSensitiveNames = caseSensitiveNames
        self.compUpdate = compUpdate
        self.connectionTimeout = connectionTimeout
        self.databaseName = databaseName
        self.dateFormat = dateFormat
        self.emptyAsNull = emptyAsNull
        self.encryptionMode = encryptionMode
        self.explicitIds = explicitIds
        self.fileTransferUploadStreams = fileTransferUploadStreams
        self.loadTimeout = loadTimeout
        self.maxFileSize = maxFileSize
        self.password = password
        self.port = port
        self.removeQuotes = removeQuotes
        self.replaceChars = replaceChars
        self.replaceInvalidChars = replaceInvalidChars
        self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
        self.secretsManagerSecretId = secretsManagerSecretId
        self.serverName = serverName
        self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
        self.serviceAccessRoleArn = serviceAccessRoleArn
        self.timeFormat = timeFormat
        self.trimBlanks = trimBlanks
        self.truncateColumns = truncateColumns
        self.username = username
        self.writeBufferSize = writeBufferSize
    }
}

public struct RefreshSchemasInputBodyMiddleware: Middleware {
    public let id: String = "RefreshSchemasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RefreshSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<RefreshSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RefreshSchemasInput>
    public typealias MOutput = OperationOutput<RefreshSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RefreshSchemasOutputError>
}

extension RefreshSchemasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RefreshSchemasInput(endpointArn: \(String(describing: endpointArn)), replicationInstanceArn: \(String(describing: replicationInstanceArn)))"}
}

extension RefreshSchemasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct RefreshSchemasInputHeadersMiddleware: Middleware {
    public let id: String = "RefreshSchemasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RefreshSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<RefreshSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RefreshSchemasInput>
    public typealias MOutput = OperationOutput<RefreshSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RefreshSchemasOutputError>
}

public struct RefreshSchemasInputQueryItemMiddleware: Middleware {
    public let id: String = "RefreshSchemasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RefreshSchemasInput>,
                  next: H) -> Swift.Result<OperationOutput<RefreshSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RefreshSchemasInput>
    public typealias MOutput = OperationOutput<RefreshSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RefreshSchemasOutputError>
}

/// <p></p>
public struct RefreshSchemasInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: String?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: String?

    public init (
        endpointArn: String? = nil,
        replicationInstanceArn: String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct RefreshSchemasInputBody: Equatable {
    public let endpointArn: String?
    public let replicationInstanceArn: String?
}

extension RefreshSchemasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
    }
}

extension RefreshSchemasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RefreshSchemasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RefreshSchemasOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RefreshSchemasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RefreshSchemasOutputResponse(refreshSchemasStatus: \(String(describing: refreshSchemasStatus)))"}
}

extension RefreshSchemasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RefreshSchemasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.refreshSchemasStatus = output.refreshSchemasStatus
        } else {
            self.refreshSchemasStatus = nil
        }
    }
}

/// <p></p>
public struct RefreshSchemasOutputResponse: Equatable {
    /// <p>The status of the refreshed schema.</p>
    public let refreshSchemasStatus: RefreshSchemasStatus?

    public init (
        refreshSchemasStatus: RefreshSchemasStatus? = nil
    )
    {
        self.refreshSchemasStatus = refreshSchemasStatus
    }
}

struct RefreshSchemasOutputResponseBody: Equatable {
    public let refreshSchemasStatus: RefreshSchemasStatus?
}

extension RefreshSchemasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case refreshSchemasStatus = "RefreshSchemasStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refreshSchemasStatusDecoded = try containerValues.decodeIfPresent(RefreshSchemasStatus.self, forKey: .refreshSchemasStatus)
        refreshSchemasStatus = refreshSchemasStatusDecoded
    }
}

extension RefreshSchemasStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
        case lastFailureMessage = "LastFailureMessage"
        case lastRefreshDate = "LastRefreshDate"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let lastFailureMessage = lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let lastRefreshDate = lastRefreshDate {
            try encodeContainer.encode(lastRefreshDate.timeIntervalSince1970, forKey: .lastRefreshDate)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RefreshSchemasStatusTypeValue.self, forKey: .status)
        status = statusDecoded
        let lastRefreshDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastRefreshDate)
        lastRefreshDate = lastRefreshDateDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
    }
}

extension RefreshSchemasStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RefreshSchemasStatus(endpointArn: \(String(describing: endpointArn)), lastFailureMessage: \(String(describing: lastFailureMessage)), lastRefreshDate: \(String(describing: lastRefreshDate)), replicationInstanceArn: \(String(describing: replicationInstanceArn)), status: \(String(describing: status)))"}
}

/// <p>Provides information that describes status of a schema at an endpoint specified by the
///          <code>DescribeRefreshSchemaStatus</code> operation.</p>
public struct RefreshSchemasStatus: Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: String?
    /// <p>The last failure message for the schema.</p>
    public let lastFailureMessage: String?
    /// <p>The date the schema was last refreshed.</p>
    public let lastRefreshDate: Date?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: String?
    /// <p>The status of the schema.</p>
    public let status: RefreshSchemasStatusTypeValue?

    public init (
        endpointArn: String? = nil,
        lastFailureMessage: String? = nil,
        lastRefreshDate: Date? = nil,
        replicationInstanceArn: String? = nil,
        status: RefreshSchemasStatusTypeValue? = nil
    )
    {
        self.endpointArn = endpointArn
        self.lastFailureMessage = lastFailureMessage
        self.lastRefreshDate = lastRefreshDate
        self.replicationInstanceArn = replicationInstanceArn
        self.status = status
    }
}

public enum RefreshSchemasStatusTypeValue {
    case failed
    case refreshing
    case successful
    case sdkUnknown(String)
}

extension RefreshSchemasStatusTypeValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RefreshSchemasStatusTypeValue] {
        return [
            .failed,
            .refreshing,
            .successful,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "failed"
        case .refreshing: return "refreshing"
        case .successful: return "successful"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RefreshSchemasStatusTypeValue(rawValue: rawValue) ?? RefreshSchemasStatusTypeValue.sdkUnknown(rawValue)
    }
}

public enum ReleaseStatusValues {
    case beta
    case sdkUnknown(String)
}

extension ReleaseStatusValues : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReleaseStatusValues] {
        return [
            .beta,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .beta: return "beta"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReleaseStatusValues(rawValue: rawValue) ?? ReleaseStatusValues.sdkUnknown(rawValue)
    }
}

public enum ReloadOptionValue {
    case dataReload
    case validateOnly
    case sdkUnknown(String)
}

extension ReloadOptionValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReloadOptionValue] {
        return [
            .dataReload,
            .validateOnly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dataReload: return "data-reload"
        case .validateOnly: return "validate-only"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReloadOptionValue(rawValue: rawValue) ?? ReloadOptionValue.sdkUnknown(rawValue)
    }
}

public struct ReloadTablesInputBodyMiddleware: Middleware {
    public let id: String = "ReloadTablesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReloadTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<ReloadTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReloadTablesInput>
    public typealias MOutput = OperationOutput<ReloadTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReloadTablesOutputError>
}

extension ReloadTablesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReloadTablesInput(reloadOption: \(String(describing: reloadOption)), replicationTaskArn: \(String(describing: replicationTaskArn)), tablesToReload: \(String(describing: tablesToReload)))"}
}

extension ReloadTablesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reloadOption = "ReloadOption"
        case replicationTaskArn = "ReplicationTaskArn"
        case tablesToReload = "TablesToReload"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reloadOption = reloadOption {
            try encodeContainer.encode(reloadOption.rawValue, forKey: .reloadOption)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let tablesToReload = tablesToReload {
            var tablesToReloadContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tablesToReload)
            for tablelisttoreload0 in tablesToReload {
                try tablesToReloadContainer.encode(tablelisttoreload0)
            }
        }
    }
}

public struct ReloadTablesInputHeadersMiddleware: Middleware {
    public let id: String = "ReloadTablesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReloadTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<ReloadTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReloadTablesInput>
    public typealias MOutput = OperationOutput<ReloadTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReloadTablesOutputError>
}

public struct ReloadTablesInputQueryItemMiddleware: Middleware {
    public let id: String = "ReloadTablesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReloadTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<ReloadTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReloadTablesInput>
    public typealias MOutput = OperationOutput<ReloadTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReloadTablesOutputError>
}

public struct ReloadTablesInput: Equatable {
    /// <p>Options for reload. Specify <code>data-reload</code> to reload the data and re-validate
    ///          it if validation is enabled. Specify <code>validate-only</code> to re-validate the table.
    ///          This option applies only when validation is enabled for the task. </p>
    ///          <p>Valid values: data-reload, validate-only</p>
    ///          <p>Default value is data-reload.</p>
    public let reloadOption: ReloadOptionValue?
    /// <p>The Amazon Resource Name (ARN) of the replication task. </p>
    public let replicationTaskArn: String?
    /// <p>The name and schema of the table to be reloaded. </p>
    public let tablesToReload: [TableToReload]?

    public init (
        reloadOption: ReloadOptionValue? = nil,
        replicationTaskArn: String? = nil,
        tablesToReload: [TableToReload]? = nil
    )
    {
        self.reloadOption = reloadOption
        self.replicationTaskArn = replicationTaskArn
        self.tablesToReload = tablesToReload
    }
}

struct ReloadTablesInputBody: Equatable {
    public let replicationTaskArn: String?
    public let tablesToReload: [TableToReload]?
    public let reloadOption: ReloadOptionValue?
}

extension ReloadTablesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reloadOption = "ReloadOption"
        case replicationTaskArn = "ReplicationTaskArn"
        case tablesToReload = "TablesToReload"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let tablesToReloadContainer = try containerValues.decodeIfPresent([TableToReload?].self, forKey: .tablesToReload)
        var tablesToReloadDecoded0:[TableToReload]? = nil
        if let tablesToReloadContainer = tablesToReloadContainer {
            tablesToReloadDecoded0 = [TableToReload]()
            for structure0 in tablesToReloadContainer {
                if let structure0 = structure0 {
                    tablesToReloadDecoded0?.append(structure0)
                }
            }
        }
        tablesToReload = tablesToReloadDecoded0
        let reloadOptionDecoded = try containerValues.decodeIfPresent(ReloadOptionValue.self, forKey: .reloadOption)
        reloadOption = reloadOptionDecoded
    }
}

extension ReloadTablesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReloadTablesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReloadTablesOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReloadTablesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReloadTablesOutputResponse(replicationTaskArn: \(String(describing: replicationTaskArn)))"}
}

extension ReloadTablesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReloadTablesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationTaskArn = output.replicationTaskArn
        } else {
            self.replicationTaskArn = nil
        }
    }
}

public struct ReloadTablesOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the replication task. </p>
    public let replicationTaskArn: String?

    public init (
        replicationTaskArn: String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct ReloadTablesOutputResponseBody: Equatable {
    public let replicationTaskArn: String?
}

extension ReloadTablesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

public struct RemoveTagsFromResourceInputBodyMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

extension RemoveTagsFromResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension RemoveTagsFromResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for keylist0 in tagKeys {
                try tagKeysContainer.encode(keylist0)
            }
        }
    }
}

public struct RemoveTagsFromResourceInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

/// <p>Removes one or more tags from an AWS DMS resource.</p>
public struct RemoveTagsFromResourceInput: Equatable {
    /// <p>An AWS DMS resource from which you want to remove tag(s). The value for this parameter is an Amazon Resource Name (ARN).</p>
    public let resourceArn: String?
    /// <p>The tag key (name) of the tag to be removed.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsFromResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension RemoveTagsFromResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromResourceOutputResponse()"}
}

extension RemoveTagsFromResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p></p>
public struct RemoveTagsFromResourceOutputResponse: Equatable {

    public init() {}
}

struct RemoveTagsFromResourceOutputResponseBody: Equatable {
}

extension RemoveTagsFromResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum ReplicationEndpointTypeValue {
    case source
    case target
    case sdkUnknown(String)
}

extension ReplicationEndpointTypeValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicationEndpointTypeValue] {
        return [
            .source,
            .target,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .source: return "source"
        case .target: return "target"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicationEndpointTypeValue(rawValue: rawValue) ?? ReplicationEndpointTypeValue.sdkUnknown(rawValue)
    }
}

extension ReplicationInstance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case dnsNameServers = "DnsNameServers"
        case engineVersion = "EngineVersion"
        case freeUntil = "FreeUntil"
        case instanceCreateTime = "InstanceCreateTime"
        case kmsKeyId = "KmsKeyId"
        case multiAZ = "MultiAZ"
        case pendingModifiedValues = "PendingModifiedValues"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case replicationInstancePrivateIpAddress = "ReplicationInstancePrivateIpAddress"
        case replicationInstancePrivateIpAddresses = "ReplicationInstancePrivateIpAddresses"
        case replicationInstancePublicIpAddress = "ReplicationInstancePublicIpAddress"
        case replicationInstancePublicIpAddresses = "ReplicationInstancePublicIpAddresses"
        case replicationInstanceStatus = "ReplicationInstanceStatus"
        case replicationSubnetGroup = "ReplicationSubnetGroup"
        case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedStorage != 0 {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if autoMinorVersionUpgrade != false {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let dnsNameServers = dnsNameServers {
            try encodeContainer.encode(dnsNameServers, forKey: .dnsNameServers)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let freeUntil = freeUntil {
            try encodeContainer.encode(freeUntil.timeIntervalSince1970, forKey: .freeUntil)
        }
        if let instanceCreateTime = instanceCreateTime {
            try encodeContainer.encode(instanceCreateTime.timeIntervalSince1970, forKey: .instanceCreateTime)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if multiAZ != false {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try encodeContainer.encode(pendingModifiedValues, forKey: .pendingModifiedValues)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if publiclyAccessible != false {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationInstanceClass = replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let replicationInstanceIdentifier = replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let replicationInstancePrivateIpAddress = replicationInstancePrivateIpAddress {
            try encodeContainer.encode(replicationInstancePrivateIpAddress, forKey: .replicationInstancePrivateIpAddress)
        }
        if let replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses {
            var replicationInstancePrivateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationInstancePrivateIpAddresses)
            for replicationinstanceprivateipaddresslist0 in replicationInstancePrivateIpAddresses {
                try replicationInstancePrivateIpAddressesContainer.encode(replicationinstanceprivateipaddresslist0)
            }
        }
        if let replicationInstancePublicIpAddress = replicationInstancePublicIpAddress {
            try encodeContainer.encode(replicationInstancePublicIpAddress, forKey: .replicationInstancePublicIpAddress)
        }
        if let replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses {
            var replicationInstancePublicIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationInstancePublicIpAddresses)
            for replicationinstancepublicipaddresslist0 in replicationInstancePublicIpAddresses {
                try replicationInstancePublicIpAddressesContainer.encode(replicationinstancepublicipaddresslist0)
            }
        }
        if let replicationInstanceStatus = replicationInstanceStatus {
            try encodeContainer.encode(replicationInstanceStatus, forKey: .replicationInstanceStatus)
        }
        if let replicationSubnetGroup = replicationSubnetGroup {
            try encodeContainer.encode(replicationSubnetGroup, forKey: .replicationSubnetGroup)
        }
        if let secondaryAvailabilityZone = secondaryAvailabilityZone {
            try encodeContainer.encode(secondaryAvailabilityZone, forKey: .secondaryAvailabilityZone)
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroups)
            for vpcsecuritygroupmembershiplist0 in vpcSecurityGroups {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembershiplist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let replicationInstanceStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceStatus)
        replicationInstanceStatus = replicationInstanceStatusDecoded
        let allocatedStorageDecoded = try containerValues.decode(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .instanceCreateTime)
        instanceCreateTime = instanceCreateTimeDecoded
        let vpcSecurityGroupsContainer = try containerValues.decodeIfPresent([VpcSecurityGroupMembership?].self, forKey: .vpcSecurityGroups)
        var vpcSecurityGroupsDecoded0:[VpcSecurityGroupMembership]? = nil
        if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
            vpcSecurityGroupsDecoded0 = [VpcSecurityGroupMembership]()
            for structure0 in vpcSecurityGroupsContainer {
                if let structure0 = structure0 {
                    vpcSecurityGroupsDecoded0?.append(structure0)
                }
            }
        }
        vpcSecurityGroups = vpcSecurityGroupsDecoded0
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let replicationSubnetGroupDecoded = try containerValues.decodeIfPresent(ReplicationSubnetGroup.self, forKey: .replicationSubnetGroup)
        replicationSubnetGroup = replicationSubnetGroupDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(ReplicationPendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let multiAZDecoded = try containerValues.decode(Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let replicationInstancePublicIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstancePublicIpAddress)
        replicationInstancePublicIpAddress = replicationInstancePublicIpAddressDecoded
        let replicationInstancePrivateIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstancePrivateIpAddress)
        replicationInstancePrivateIpAddress = replicationInstancePrivateIpAddressDecoded
        let replicationInstancePublicIpAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replicationInstancePublicIpAddresses)
        var replicationInstancePublicIpAddressesDecoded0:[String]? = nil
        if let replicationInstancePublicIpAddressesContainer = replicationInstancePublicIpAddressesContainer {
            replicationInstancePublicIpAddressesDecoded0 = [String]()
            for string0 in replicationInstancePublicIpAddressesContainer {
                if let string0 = string0 {
                    replicationInstancePublicIpAddressesDecoded0?.append(string0)
                }
            }
        }
        replicationInstancePublicIpAddresses = replicationInstancePublicIpAddressesDecoded0
        let replicationInstancePrivateIpAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replicationInstancePrivateIpAddresses)
        var replicationInstancePrivateIpAddressesDecoded0:[String]? = nil
        if let replicationInstancePrivateIpAddressesContainer = replicationInstancePrivateIpAddressesContainer {
            replicationInstancePrivateIpAddressesDecoded0 = [String]()
            for string0 in replicationInstancePrivateIpAddressesContainer {
                if let string0 = string0 {
                    replicationInstancePrivateIpAddressesDecoded0?.append(string0)
                }
            }
        }
        replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddressesDecoded0
        let publiclyAccessibleDecoded = try containerValues.decode(Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let secondaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secondaryAvailabilityZone)
        secondaryAvailabilityZone = secondaryAvailabilityZoneDecoded
        let freeUntilDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .freeUntil)
        freeUntil = freeUntilDecoded
        let dnsNameServersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dnsNameServers)
        dnsNameServers = dnsNameServersDecoded
    }
}

extension ReplicationInstance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationInstance(allocatedStorage: \(String(describing: allocatedStorage)), autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), availabilityZone: \(String(describing: availabilityZone)), dnsNameServers: \(String(describing: dnsNameServers)), engineVersion: \(String(describing: engineVersion)), freeUntil: \(String(describing: freeUntil)), instanceCreateTime: \(String(describing: instanceCreateTime)), kmsKeyId: \(String(describing: kmsKeyId)), multiAZ: \(String(describing: multiAZ)), pendingModifiedValues: \(String(describing: pendingModifiedValues)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), publiclyAccessible: \(String(describing: publiclyAccessible)), replicationInstanceArn: \(String(describing: replicationInstanceArn)), replicationInstanceClass: \(String(describing: replicationInstanceClass)), replicationInstanceIdentifier: \(String(describing: replicationInstanceIdentifier)), replicationInstancePrivateIpAddress: \(String(describing: replicationInstancePrivateIpAddress)), replicationInstancePrivateIpAddresses: \(String(describing: replicationInstancePrivateIpAddresses)), replicationInstancePublicIpAddress: \(String(describing: replicationInstancePublicIpAddress)), replicationInstancePublicIpAddresses: \(String(describing: replicationInstancePublicIpAddresses)), replicationInstanceStatus: \(String(describing: replicationInstanceStatus)), replicationSubnetGroup: \(String(describing: replicationSubnetGroup)), secondaryAvailabilityZone: \(String(describing: secondaryAvailabilityZone)), vpcSecurityGroups: \(String(describing: vpcSecurityGroups)))"}
}

/// <p>Provides information that defines a replication instance.</p>
public struct ReplicationInstance: Equatable {
    /// <p>The amount of storage (in gigabytes) that is allocated for the replication
    ///          instance.</p>
    public let allocatedStorage: Int
    /// <p>Boolean value indicating if minor version upgrades will be automatically applied to the
    ///          instance.</p>
    public let autoMinorVersionUpgrade: Bool
    /// <p>The Availability Zone for the instance.</p>
    public let availabilityZone: String?
    /// <p>The DNS name servers supported for the replication instance to access your on-premise source or target database.</p>
    public let dnsNameServers: String?
    /// <p>The engine version number of the replication instance.</p>
    ///          <p>If an engine version number is not specified when a replication
    ///          instance is created, the default is the latest engine version available.</p>
    ///          <p>When modifying a major engine version of an instance, also set
    ///          <code>AllowMajorVersionUpgrade</code> to <code>true</code>.</p>
    public let engineVersion: String?
    /// <p> The expiration date of the free replication instance that is part of the Free DMS
    ///          program. </p>
    public let freeUntil: Date?
    /// <p>The time the replication instance was created.</p>
    public let instanceCreateTime: Date?
    /// <p>An AWS KMS key identifier that is used to encrypt the data on the replication
    ///            instance.</p>
    ///          <p>If you don't specify a value for the <code>KmsKeyId</code> parameter, then
    ///            AWS DMS uses your default encryption key.</p>
    ///          <p>AWS KMS creates the default encryption key for your AWS account. Your AWS account has a
    ///          different default encryption key for each AWS Region.</p>
    public let kmsKeyId: String?
    /// <p> Specifies whether the replication instance is a Multi-AZ deployment. You can't set the
    ///             <code>AvailabilityZone</code> parameter if the Multi-AZ parameter is set to
    ///             <code>true</code>. </p>
    public let multiAZ: Bool
    /// <p>The pending modification values.</p>
    public let pendingModifiedValues: ReplicationPendingModifiedValues?
    /// <p>The maintenance window times for the replication instance. Any pending upgrades to the
    ///          replication instance are performed during this time.</p>
    public let preferredMaintenanceWindow: String?
    /// <p> Specifies the accessibility options for the replication instance. A value of
    ///             <code>true</code> represents an instance with a public IP address. A value of
    ///             <code>false</code> represents an instance with a private IP address. The default value
    ///          is <code>true</code>. </p>
    public let publiclyAccessible: Bool
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: String?
    /// <p>The compute and memory capacity of the replication instance as defined for the specified
    ///          replication instance class. It is a required parameter, although a defualt value is
    ///          pre-selected in the DMS console.</p>
    ///          <p>For more information on the settings and capacities for the available replication instance classes, see
    ///          <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth">
    ///             Selecting the right AWS DMS replication instance for your migration</a>.
    ///       </p>
    public let replicationInstanceClass: String?
    /// <p>The replication instance identifier is a required parameter. This parameter is stored as
    ///          a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain 1-63 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>myrepinstance</code>
    ///          </p>
    public let replicationInstanceIdentifier: String?
    /// <p>The private IP address of the replication instance.</p>
    @available(*, deprecated)
    public let replicationInstancePrivateIpAddress: String?
    /// <p>One or more private IP addresses for the replication instance.</p>
    public let replicationInstancePrivateIpAddresses: [String]?
    /// <p>The public IP address of the replication instance.</p>
    @available(*, deprecated)
    public let replicationInstancePublicIpAddress: String?
    /// <p>One or more public IP addresses for the replication instance.</p>
    public let replicationInstancePublicIpAddresses: [String]?
    /// <p>The status of the replication instance. The possible return values include:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>"available"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"creating"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"deleted"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"deleting"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"failed"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"modifying"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"upgrading"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"rebooting"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"resetting-master-credentials"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"storage-full"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"incompatible-credentials"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"incompatible-network"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"maintenance"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let replicationInstanceStatus: String?
    /// <p>The subnet group for the replication instance.</p>
    public let replicationSubnetGroup: ReplicationSubnetGroup?
    /// <p>The Availability Zone of the standby replication instance in a Multi-AZ
    ///          deployment.</p>
    public let secondaryAvailabilityZone: String?
    /// <p>The VPC security group for the instance.</p>
    public let vpcSecurityGroups: [VpcSecurityGroupMembership]?

    public init (
        allocatedStorage: Int = 0,
        autoMinorVersionUpgrade: Bool = false,
        availabilityZone: String? = nil,
        dnsNameServers: String? = nil,
        engineVersion: String? = nil,
        freeUntil: Date? = nil,
        instanceCreateTime: Date? = nil,
        kmsKeyId: String? = nil,
        multiAZ: Bool = false,
        pendingModifiedValues: ReplicationPendingModifiedValues? = nil,
        preferredMaintenanceWindow: String? = nil,
        publiclyAccessible: Bool = false,
        replicationInstanceArn: String? = nil,
        replicationInstanceClass: String? = nil,
        replicationInstanceIdentifier: String? = nil,
        replicationInstancePrivateIpAddress: String? = nil,
        replicationInstancePrivateIpAddresses: [String]? = nil,
        replicationInstancePublicIpAddress: String? = nil,
        replicationInstancePublicIpAddresses: [String]? = nil,
        replicationInstanceStatus: String? = nil,
        replicationSubnetGroup: ReplicationSubnetGroup? = nil,
        secondaryAvailabilityZone: String? = nil,
        vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.dnsNameServers = dnsNameServers
        self.engineVersion = engineVersion
        self.freeUntil = freeUntil
        self.instanceCreateTime = instanceCreateTime
        self.kmsKeyId = kmsKeyId
        self.multiAZ = multiAZ
        self.pendingModifiedValues = pendingModifiedValues
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationInstanceClass = replicationInstanceClass
        self.replicationInstanceIdentifier = replicationInstanceIdentifier
        self.replicationInstancePrivateIpAddress = replicationInstancePrivateIpAddress
        self.replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses
        self.replicationInstancePublicIpAddress = replicationInstancePublicIpAddress
        self.replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses
        self.replicationInstanceStatus = replicationInstanceStatus
        self.replicationSubnetGroup = replicationSubnetGroup
        self.secondaryAvailabilityZone = secondaryAvailabilityZone
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

extension ReplicationInstanceTaskLog: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationInstanceTaskLogSize = "ReplicationInstanceTaskLogSize"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskName = "ReplicationTaskName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if replicationInstanceTaskLogSize != 0 {
            try encodeContainer.encode(replicationInstanceTaskLogSize, forKey: .replicationInstanceTaskLogSize)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskName = replicationTaskName {
            try encodeContainer.encode(replicationTaskName, forKey: .replicationTaskName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskName)
        replicationTaskName = replicationTaskNameDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationInstanceTaskLogSizeDecoded = try containerValues.decode(Int.self, forKey: .replicationInstanceTaskLogSize)
        replicationInstanceTaskLogSize = replicationInstanceTaskLogSizeDecoded
    }
}

extension ReplicationInstanceTaskLog: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationInstanceTaskLog(replicationInstanceTaskLogSize: \(String(describing: replicationInstanceTaskLogSize)), replicationTaskArn: \(String(describing: replicationTaskArn)), replicationTaskName: \(String(describing: replicationTaskName)))"}
}

/// <p>Contains metadata for a replication instance task log.</p>
public struct ReplicationInstanceTaskLog: Equatable {
    /// <p>The size, in bytes, of the replication task log.</p>
    public let replicationInstanceTaskLogSize: Int
    /// <p>The Amazon Resource Name (ARN) of the replication task.</p>
    public let replicationTaskArn: String?
    /// <p>The name of the replication task.</p>
    public let replicationTaskName: String?

    public init (
        replicationInstanceTaskLogSize: Int = 0,
        replicationTaskArn: String? = nil,
        replicationTaskName: String? = nil
    )
    {
        self.replicationInstanceTaskLogSize = replicationInstanceTaskLogSize
        self.replicationTaskArn = replicationTaskArn
        self.replicationTaskName = replicationTaskName
    }
}

extension ReplicationPendingModifiedValues: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case engineVersion = "EngineVersion"
        case multiAZ = "MultiAZ"
        case replicationInstanceClass = "ReplicationInstanceClass"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedStorage = allocatedStorage {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let multiAZ = multiAZ {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let replicationInstanceClass = replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension ReplicationPendingModifiedValues: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationPendingModifiedValues(allocatedStorage: \(String(describing: allocatedStorage)), engineVersion: \(String(describing: engineVersion)), multiAZ: \(String(describing: multiAZ)), replicationInstanceClass: \(String(describing: replicationInstanceClass)))"}
}

/// <p>Provides information about the values of pending modifications to a replication
///          instance. This data type is an object of the
///          <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_ReplicationInstance.html">
///                <code>ReplicationInstance</code>
///             </a> user-defined
///          data type. </p>
public struct ReplicationPendingModifiedValues: Equatable {
    /// <p>The amount of storage (in gigabytes) that is allocated for the replication
    ///          instance.</p>
    public let allocatedStorage: Int?
    /// <p>The engine version number of the replication instance.</p>
    public let engineVersion: String?
    /// <p> Specifies whether the replication instance is a Multi-AZ deployment. You can't set the
    ///             <code>AvailabilityZone</code> parameter if the Multi-AZ parameter is set to
    ///             <code>true</code>. </p>
    public let multiAZ: Bool?
    /// <p>The compute and memory capacity of the replication instance as defined for the specified
    ///          replication instance class.</p>
    ///          <p>For more information on the settings and capacities for the available replication instance classes, see
    ///          <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth">
    ///             Selecting the right AWS DMS replication instance for your migration</a>.
    ///       </p>
    public let replicationInstanceClass: String?

    public init (
        allocatedStorage: Int? = nil,
        engineVersion: String? = nil,
        multiAZ: Bool? = nil,
        replicationInstanceClass: String? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.engineVersion = engineVersion
        self.multiAZ = multiAZ
        self.replicationInstanceClass = replicationInstanceClass
    }
}

extension ReplicationSubnetGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetGroupStatus = "SubnetGroupStatus"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupDescription = replicationSubnetGroupDescription {
            try encodeContainer.encode(replicationSubnetGroupDescription, forKey: .replicationSubnetGroupDescription)
        }
        if let replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let subnetGroupStatus = subnetGroupStatus {
            try encodeContainer.encode(subnetGroupStatus, forKey: .subnetGroupStatus)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnetlist0 in subnets {
                try subnetsContainer.encode(subnetlist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let replicationSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationSubnetGroupDescription)
        replicationSubnetGroupDescription = replicationSubnetGroupDescriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetGroupStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetGroupStatus)
        subnetGroupStatus = subnetGroupStatusDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([Subnet?].self, forKey: .subnets)
        var subnetsDecoded0:[Subnet]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Subnet]()
            for structure0 in subnetsContainer {
                if let structure0 = structure0 {
                    subnetsDecoded0?.append(structure0)
                }
            }
        }
        subnets = subnetsDecoded0
    }
}

extension ReplicationSubnetGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationSubnetGroup(replicationSubnetGroupDescription: \(String(describing: replicationSubnetGroupDescription)), replicationSubnetGroupIdentifier: \(String(describing: replicationSubnetGroupIdentifier)), subnetGroupStatus: \(String(describing: subnetGroupStatus)), subnets: \(String(describing: subnets)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Describes a subnet group in response to a request by the
///             <code>DescribeReplicationSubnetGroups</code> operation.</p>
public struct ReplicationSubnetGroup: Equatable {
    /// <p>A description for the replication subnet group.</p>
    public let replicationSubnetGroupDescription: String?
    /// <p>The identifier of the replication instance subnet group.</p>
    public let replicationSubnetGroupIdentifier: String?
    /// <p>The status of the subnet group.</p>
    public let subnetGroupStatus: String?
    /// <p>The subnets that are in the subnet group.</p>
    public let subnets: [Subnet]?
    /// <p>The ID of the VPC.</p>
    public let vpcId: String?

    public init (
        replicationSubnetGroupDescription: String? = nil,
        replicationSubnetGroupIdentifier: String? = nil,
        subnetGroupStatus: String? = nil,
        subnets: [Subnet]? = nil,
        vpcId: String? = nil
    )
    {
        self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.subnetGroupStatus = subnetGroupStatus
        self.subnets = subnets
        self.vpcId = vpcId
    }
}

extension ReplicationSubnetGroupDoesNotCoverEnoughAZs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationSubnetGroupDoesNotCoverEnoughAZs(message: \(String(describing: message)))"}
}

extension ReplicationSubnetGroupDoesNotCoverEnoughAZs: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReplicationSubnetGroupDoesNotCoverEnoughAZsBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The replication subnet group does not cover enough Availability Zones (AZs). Edit the replication subnet group and add more AZs.</p>
public struct ReplicationSubnetGroupDoesNotCoverEnoughAZs: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReplicationSubnetGroupDoesNotCoverEnoughAZsBody: Equatable {
    public let message: String?
}

extension ReplicationSubnetGroupDoesNotCoverEnoughAZsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReplicationTask: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStopPosition = "CdcStopPosition"
        case lastFailureMessage = "LastFailureMessage"
        case migrationType = "MigrationType"
        case recoveryCheckpoint = "RecoveryCheckpoint"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskCreationDate = "ReplicationTaskCreationDate"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case replicationTaskStartDate = "ReplicationTaskStartDate"
        case replicationTaskStats = "ReplicationTaskStats"
        case sourceEndpointArn = "SourceEndpointArn"
        case status = "Status"
        case stopReason = "StopReason"
        case tableMappings = "TableMappings"
        case targetEndpointArn = "TargetEndpointArn"
        case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
        case taskData = "TaskData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStopPosition = cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let lastFailureMessage = lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let migrationType = migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let recoveryCheckpoint = recoveryCheckpoint {
            try encodeContainer.encode(recoveryCheckpoint, forKey: .recoveryCheckpoint)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskCreationDate = replicationTaskCreationDate {
            try encodeContainer.encode(replicationTaskCreationDate.timeIntervalSince1970, forKey: .replicationTaskCreationDate)
        }
        if let replicationTaskIdentifier = replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskSettings = replicationTaskSettings {
            try encodeContainer.encode(replicationTaskSettings, forKey: .replicationTaskSettings)
        }
        if let replicationTaskStartDate = replicationTaskStartDate {
            try encodeContainer.encode(replicationTaskStartDate.timeIntervalSince1970, forKey: .replicationTaskStartDate)
        }
        if let replicationTaskStats = replicationTaskStats {
            try encodeContainer.encode(replicationTaskStats, forKey: .replicationTaskStats)
        }
        if let sourceEndpointArn = sourceEndpointArn {
            try encodeContainer.encode(sourceEndpointArn, forKey: .sourceEndpointArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let stopReason = stopReason {
            try encodeContainer.encode(stopReason, forKey: .stopReason)
        }
        if let tableMappings = tableMappings {
            try encodeContainer.encode(tableMappings, forKey: .tableMappings)
        }
        if let targetEndpointArn = targetEndpointArn {
            try encodeContainer.encode(targetEndpointArn, forKey: .targetEndpointArn)
        }
        if let targetReplicationInstanceArn = targetReplicationInstanceArn {
            try encodeContainer.encode(targetReplicationInstanceArn, forKey: .targetReplicationInstanceArn)
        }
        if let taskData = taskData {
            try encodeContainer.encode(taskData, forKey: .taskData)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let sourceEndpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceEndpointArn)
        sourceEndpointArn = sourceEndpointArnDecoded
        let targetEndpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetEndpointArn)
        targetEndpointArn = targetEndpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let tableMappingsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableMappings)
        tableMappings = tableMappingsDecoded
        let replicationTaskSettingsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskSettings)
        replicationTaskSettings = replicationTaskSettingsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
        let stopReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stopReason)
        stopReason = stopReasonDecoded
        let replicationTaskCreationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .replicationTaskCreationDate)
        replicationTaskCreationDate = replicationTaskCreationDateDecoded
        let replicationTaskStartDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .replicationTaskStartDate)
        replicationTaskStartDate = replicationTaskStartDateDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
        let recoveryCheckpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recoveryCheckpoint)
        recoveryCheckpoint = recoveryCheckpointDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationTaskStatsDecoded = try containerValues.decodeIfPresent(ReplicationTaskStats.self, forKey: .replicationTaskStats)
        replicationTaskStats = replicationTaskStatsDecoded
        let taskDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskData)
        taskData = taskDataDecoded
        let targetReplicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetReplicationInstanceArn)
        targetReplicationInstanceArn = targetReplicationInstanceArnDecoded
    }
}

extension ReplicationTask: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationTask(cdcStartPosition: \(String(describing: cdcStartPosition)), cdcStopPosition: \(String(describing: cdcStopPosition)), lastFailureMessage: \(String(describing: lastFailureMessage)), migrationType: \(String(describing: migrationType)), recoveryCheckpoint: \(String(describing: recoveryCheckpoint)), replicationInstanceArn: \(String(describing: replicationInstanceArn)), replicationTaskArn: \(String(describing: replicationTaskArn)), replicationTaskCreationDate: \(String(describing: replicationTaskCreationDate)), replicationTaskIdentifier: \(String(describing: replicationTaskIdentifier)), replicationTaskSettings: \(String(describing: replicationTaskSettings)), replicationTaskStartDate: \(String(describing: replicationTaskStartDate)), replicationTaskStats: \(String(describing: replicationTaskStats)), sourceEndpointArn: \(String(describing: sourceEndpointArn)), status: \(String(describing: status)), stopReason: \(String(describing: stopReason)), tableMappings: \(String(describing: tableMappings)), targetEndpointArn: \(String(describing: targetEndpointArn)), targetReplicationInstanceArn: \(String(describing: targetReplicationInstanceArn)), taskData: \(String(describing: taskData)))"}
}

/// <p>Provides information that describes a replication task created by the
///             <code>CreateReplicationTask</code> operation.</p>
public struct ReplicationTask: Equatable {
    /// <p>Indicates when you want a change data capture (CDC) operation to start. Use either
    ///          <code>CdcStartPosition</code> or <code>CdcStartTime</code> to specify when you want the CDC operation to start.
    ///          Specifying both values results in an error.</p>
    ///          <p>The value can be in date, checkpoint, or LSN/SCN format.</p>
    ///          <p>Date Example: --cdc-start-position “2018-03-08T12:12:12”</p>
    ///          <p>Checkpoint Example: --cdc-start-position
    ///          "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93"</p>
    ///          <p>LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373”</p>
    public let cdcStartPosition: String?
    /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be
    ///          either server time or commit time.</p>
    ///          <p>Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12”</p>
    ///          <p>Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “</p>
    public let cdcStopPosition: String?
    /// <p>The last error (failure) message generated for the replication task.</p>
    public let lastFailureMessage: String?
    /// <p>The type of migration.</p>
    public let migrationType: MigrationTypeValue?
    /// <p>Indicates the last checkpoint that occurred during a change data capture (CDC)
    ///          operation. You can provide this value to the <code>CdcStartPosition</code> parameter to
    ///          start a CDC operation that begins at that checkpoint.</p>
    public let recoveryCheckpoint: String?
    /// <p>The ARN of the replication instance.</p>
    public let replicationInstanceArn: String?
    /// <p>The Amazon Resource Name (ARN) of the replication task.</p>
    public let replicationTaskArn: String?
    /// <p>The date the replication task was created.</p>
    public let replicationTaskCreationDate: Date?
    /// <p>The user-assigned replication task identifier or name.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain 1-255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let replicationTaskIdentifier: String?
    /// <p>The settings for the replication task.</p>
    public let replicationTaskSettings: String?
    /// <p>The date the replication task is scheduled to start.</p>
    public let replicationTaskStartDate: Date?
    /// <p>The statistics for the task, including elapsed time, tables loaded, and table
    ///          errors.</p>
    public let replicationTaskStats: ReplicationTaskStats?
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the endpoint.</p>
    public let sourceEndpointArn: String?
    /// <p>The status of the replication task. This response parameter can return one of
    ///          the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>"moving"</code> – The task is being moved in response to running the
    ///                   <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_MoveReplicationTask.html">
    ///                      <code>MoveReplicationTask</code>
    ///                   </a> operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"creating"</code> – The task is being created in response to running
    ///                the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationTask.html">
    ///                      <code>CreateReplicationTask</code>
    ///                   </a> operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"deleting"</code> – The task is being deleted in response to running
    ///                the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_DeleteReplicationTask.html">
    ///                      <code>DeleteReplicationTask</code>
    ///                   </a> operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"failed"</code> – The task failed to successfully complete the database
    ///                migration in response to running the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html">
    ///                      <code>StartReplicationTask</code>
    ///                   </a> operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"failed-move"</code> – The task failed to move in response to running
    ///                the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_MoveReplicationTask.html">
    ///                      <code>MoveReplicationTask</code>
    ///                   </a> operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"modifying"</code> – The task definition is being modified in response
    ///                to running the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_ModifyReplicationTask.html">
    ///                      <code>ModifyReplicationTask</code>
    ///                   </a> operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"ready"</code> – The task is in a <code>ready</code> state where it can
    ///                respond to other task operations, such as <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html">
    ///                      <code>StartReplicationTask</code>
    ///                   </a> or <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_DeleteReplicationTask.html">
    ///                      <code>DeleteReplicationTask</code>
    ///                   </a>. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"running"</code> – The task is performing a database migration in
    ///                response to running the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html">
    ///                      <code>StartReplicationTask</code>
    ///                   </a> operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"starting"</code> – The task is preparing to perform a database
    ///                migration in response to running the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html">
    ///                      <code>StartReplicationTask</code>
    ///                   </a> operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"stopped"</code> – The task has stopped in response to running the
    ///                   <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StopReplicationTask.html">
    ///                      <code>StopReplicationTask</code>
    ///                   </a> operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"stopping"</code> – The task is preparing to stop in response to
    ///                running the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StopReplicationTask.html">
    ///                      <code>StopReplicationTask</code>
    ///                   </a> operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"testing"</code> – The database migration specified for this task is
    ///                being tested in response to running either the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessmentRun.html">
    ///                      <code>StartReplicationTaskAssessmentRun</code>
    ///                   </a> or the
    ///                   <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessment.html">
    ///                      <code>StartReplicationTaskAssessment</code>
    ///                   </a>
    ///                operation.</p>
    ///                <note>
    ///                   <p>
    ///                      <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessmentRun.html">
    ///                         <code>StartReplicationTaskAssessmentRun</code>
    ///                      </a> is
    ///                   an improved premigration task assessment operation. The <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessment.html">
    ///                         <code>StartReplicationTaskAssessment</code>
    ///                      </a>
    ///                   operation assesses data type compatibility only between the source and target
    ///                   database of a given migration task. In contrast, <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessmentRun.html">
    ///                         <code>StartReplicationTaskAssessmentRun</code>
    ///                      </a>
    ///                   enables you to specify a variety of premigration task assessments in addition to
    ///                   data type compatibility. These assessments include ones for the validity of primary key definitions and
    ///                   likely issues with database migration performance, among others.</p>
    ///                </note>
    ///             </li>
    ///          </ul>
    public let status: String?
    /// <p>The reason the replication task was stopped. This response parameter can return one of
    ///          the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>"STOP_REASON_FULL_LOAD_COMPLETED"</code> – Full-load migration
    ///                completed.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"STOP_REASON_CACHED_CHANGES_APPLIED"</code> – Change data capture (CDC)
    ///                load completed.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"STOP_REASON_CACHED_CHANGES_NOT_APPLIED"</code> – In a
    ///                full-load and CDC migration, the full load stopped as specified before starting the
    ///                CDC migration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"STOP_REASON_SERVER_TIME"</code> – The migration stopped at the
    ///                specified server time.</p>
    ///             </li>
    ///          </ul>
    public let stopReason: String?
    /// <p>Table mappings specified in the task.</p>
    public let tableMappings: String?
    /// <p>The ARN that uniquely identifies the endpoint.</p>
    public let targetEndpointArn: String?
    /// <p>The ARN of the replication instance to which this task is moved in response to running
    ///          the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_MoveReplicationTask.html">
    ///                <code>MoveReplicationTask</code>
    ///             </a> operation. Otherwise, this response
    ///          parameter isn't a member of the <code>ReplicationTask</code> object.</p>
    public let targetReplicationInstanceArn: String?
    /// <p>Supplemental information that the task requires to migrate the data for certain source and target endpoints.
    ///             For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html">Specifying Supplemental Data for Task Settings</a> in the
    ///          <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let taskData: String?

    public init (
        cdcStartPosition: String? = nil,
        cdcStopPosition: String? = nil,
        lastFailureMessage: String? = nil,
        migrationType: MigrationTypeValue? = nil,
        recoveryCheckpoint: String? = nil,
        replicationInstanceArn: String? = nil,
        replicationTaskArn: String? = nil,
        replicationTaskCreationDate: Date? = nil,
        replicationTaskIdentifier: String? = nil,
        replicationTaskSettings: String? = nil,
        replicationTaskStartDate: Date? = nil,
        replicationTaskStats: ReplicationTaskStats? = nil,
        sourceEndpointArn: String? = nil,
        status: String? = nil,
        stopReason: String? = nil,
        tableMappings: String? = nil,
        targetEndpointArn: String? = nil,
        targetReplicationInstanceArn: String? = nil,
        taskData: String? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStopPosition = cdcStopPosition
        self.lastFailureMessage = lastFailureMessage
        self.migrationType = migrationType
        self.recoveryCheckpoint = recoveryCheckpoint
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationTaskArn = replicationTaskArn
        self.replicationTaskCreationDate = replicationTaskCreationDate
        self.replicationTaskIdentifier = replicationTaskIdentifier
        self.replicationTaskSettings = replicationTaskSettings
        self.replicationTaskStartDate = replicationTaskStartDate
        self.replicationTaskStats = replicationTaskStats
        self.sourceEndpointArn = sourceEndpointArn
        self.status = status
        self.stopReason = stopReason
        self.tableMappings = tableMappings
        self.targetEndpointArn = targetEndpointArn
        self.targetReplicationInstanceArn = targetReplicationInstanceArn
        self.taskData = taskData
    }
}

extension ReplicationTaskAssessmentResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentResults = "AssessmentResults"
        case assessmentResultsFile = "AssessmentResultsFile"
        case assessmentStatus = "AssessmentStatus"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskLastAssessmentDate = "ReplicationTaskLastAssessmentDate"
        case s3ObjectUrl = "S3ObjectUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentResults = assessmentResults {
            try encodeContainer.encode(assessmentResults, forKey: .assessmentResults)
        }
        if let assessmentResultsFile = assessmentResultsFile {
            try encodeContainer.encode(assessmentResultsFile, forKey: .assessmentResultsFile)
        }
        if let assessmentStatus = assessmentStatus {
            try encodeContainer.encode(assessmentStatus, forKey: .assessmentStatus)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskIdentifier = replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskLastAssessmentDate = replicationTaskLastAssessmentDate {
            try encodeContainer.encode(replicationTaskLastAssessmentDate.timeIntervalSince1970, forKey: .replicationTaskLastAssessmentDate)
        }
        if let s3ObjectUrl = s3ObjectUrl {
            try encodeContainer.encode(s3ObjectUrl, forKey: .s3ObjectUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationTaskLastAssessmentDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .replicationTaskLastAssessmentDate)
        replicationTaskLastAssessmentDate = replicationTaskLastAssessmentDateDecoded
        let assessmentStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentStatus)
        assessmentStatus = assessmentStatusDecoded
        let assessmentResultsFileDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentResultsFile)
        assessmentResultsFile = assessmentResultsFileDecoded
        let assessmentResultsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentResults)
        assessmentResults = assessmentResultsDecoded
        let s3ObjectUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3ObjectUrl)
        s3ObjectUrl = s3ObjectUrlDecoded
    }
}

extension ReplicationTaskAssessmentResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationTaskAssessmentResult(assessmentResults: \(String(describing: assessmentResults)), assessmentResultsFile: \(String(describing: assessmentResultsFile)), assessmentStatus: \(String(describing: assessmentStatus)), replicationTaskArn: \(String(describing: replicationTaskArn)), replicationTaskIdentifier: \(String(describing: replicationTaskIdentifier)), replicationTaskLastAssessmentDate: \(String(describing: replicationTaskLastAssessmentDate)), s3ObjectUrl: \(String(describing: s3ObjectUrl)))"}
}

/// <p> The task assessment report in JSON format. </p>
public struct ReplicationTaskAssessmentResult: Equatable {
    /// <p> The task assessment results in JSON format. </p>
    public let assessmentResults: String?
    /// <p> The file containing the results of the task assessment. </p>
    public let assessmentResultsFile: String?
    /// <p> The status of the task assessment. </p>
    public let assessmentStatus: String?
    /// <p>The Amazon Resource Name (ARN) of the replication task. </p>
    public let replicationTaskArn: String?
    /// <p> The replication task identifier of the task on which the task assessment was run.
    ///       </p>
    public let replicationTaskIdentifier: String?
    /// <p>The date the task assessment was completed. </p>
    public let replicationTaskLastAssessmentDate: Date?
    /// <p> The URL of the S3 object containing the task assessment results. </p>
    public let s3ObjectUrl: String?

    public init (
        assessmentResults: String? = nil,
        assessmentResultsFile: String? = nil,
        assessmentStatus: String? = nil,
        replicationTaskArn: String? = nil,
        replicationTaskIdentifier: String? = nil,
        replicationTaskLastAssessmentDate: Date? = nil,
        s3ObjectUrl: String? = nil
    )
    {
        self.assessmentResults = assessmentResults
        self.assessmentResultsFile = assessmentResultsFile
        self.assessmentStatus = assessmentStatus
        self.replicationTaskArn = replicationTaskArn
        self.replicationTaskIdentifier = replicationTaskIdentifier
        self.replicationTaskLastAssessmentDate = replicationTaskLastAssessmentDate
        self.s3ObjectUrl = s3ObjectUrl
    }
}

extension ReplicationTaskAssessmentRun: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentProgress = "AssessmentProgress"
        case assessmentRunName = "AssessmentRunName"
        case lastFailureMessage = "LastFailureMessage"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
        case replicationTaskAssessmentRunCreationDate = "ReplicationTaskAssessmentRunCreationDate"
        case resultEncryptionMode = "ResultEncryptionMode"
        case resultKmsKeyArn = "ResultKmsKeyArn"
        case resultLocationBucket = "ResultLocationBucket"
        case resultLocationFolder = "ResultLocationFolder"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentProgress = assessmentProgress {
            try encodeContainer.encode(assessmentProgress, forKey: .assessmentProgress)
        }
        if let assessmentRunName = assessmentRunName {
            try encodeContainer.encode(assessmentRunName, forKey: .assessmentRunName)
        }
        if let lastFailureMessage = lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
        if let replicationTaskAssessmentRunCreationDate = replicationTaskAssessmentRunCreationDate {
            try encodeContainer.encode(replicationTaskAssessmentRunCreationDate.timeIntervalSince1970, forKey: .replicationTaskAssessmentRunCreationDate)
        }
        if let resultEncryptionMode = resultEncryptionMode {
            try encodeContainer.encode(resultEncryptionMode, forKey: .resultEncryptionMode)
        }
        if let resultKmsKeyArn = resultKmsKeyArn {
            try encodeContainer.encode(resultKmsKeyArn, forKey: .resultKmsKeyArn)
        }
        if let resultLocationBucket = resultLocationBucket {
            try encodeContainer.encode(resultLocationBucket, forKey: .resultLocationBucket)
        }
        if let resultLocationFolder = resultLocationFolder {
            try encodeContainer.encode(resultLocationFolder, forKey: .resultLocationFolder)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let replicationTaskAssessmentRunCreationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .replicationTaskAssessmentRunCreationDate)
        replicationTaskAssessmentRunCreationDate = replicationTaskAssessmentRunCreationDateDecoded
        let assessmentProgressDecoded = try containerValues.decodeIfPresent(ReplicationTaskAssessmentRunProgress.self, forKey: .assessmentProgress)
        assessmentProgress = assessmentProgressDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let resultLocationBucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resultLocationBucket)
        resultLocationBucket = resultLocationBucketDecoded
        let resultLocationFolderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resultLocationFolder)
        resultLocationFolder = resultLocationFolderDecoded
        let resultEncryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resultEncryptionMode)
        resultEncryptionMode = resultEncryptionModeDecoded
        let resultKmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resultKmsKeyArn)
        resultKmsKeyArn = resultKmsKeyArnDecoded
        let assessmentRunNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentRunName)
        assessmentRunName = assessmentRunNameDecoded
    }
}

extension ReplicationTaskAssessmentRun: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationTaskAssessmentRun(assessmentProgress: \(String(describing: assessmentProgress)), assessmentRunName: \(String(describing: assessmentRunName)), lastFailureMessage: \(String(describing: lastFailureMessage)), replicationTaskArn: \(String(describing: replicationTaskArn)), replicationTaskAssessmentRunArn: \(String(describing: replicationTaskAssessmentRunArn)), replicationTaskAssessmentRunCreationDate: \(String(describing: replicationTaskAssessmentRunCreationDate)), resultEncryptionMode: \(String(describing: resultEncryptionMode)), resultKmsKeyArn: \(String(describing: resultKmsKeyArn)), resultLocationBucket: \(String(describing: resultLocationBucket)), resultLocationFolder: \(String(describing: resultLocationFolder)), serviceAccessRoleArn: \(String(describing: serviceAccessRoleArn)), status: \(String(describing: status)))"}
}

/// <p>Provides information that describes a premigration assessment run that you have started
///          using the <code>StartReplicationTaskAssessmentRun</code> operation.</p>
///          <p>Some of the information appears based on other operations that can return the
///             <code>ReplicationTaskAssessmentRun</code> object.</p>
public struct ReplicationTaskAssessmentRun: Equatable {
    /// <p>Indication of the completion progress for the individual assessments specified to
    ///          run.</p>
    public let assessmentProgress: ReplicationTaskAssessmentRunProgress?
    /// <p>Unique name of the assessment run.</p>
    public let assessmentRunName: String?
    /// <p>Last message generated by an individual assessment failure.</p>
    public let lastFailureMessage: String?
    /// <p>ARN of the migration task associated with this premigration
    ///          assessment run.</p>
    public let replicationTaskArn: String?
    /// <p>Amazon Resource Name (ARN) of this assessment run.</p>
    public let replicationTaskAssessmentRunArn: String?
    /// <p>Date on which the assessment run was created using the
    ///             <code>StartReplicationTaskAssessmentRun</code> operation.</p>
    public let replicationTaskAssessmentRunCreationDate: Date?
    /// <p>Encryption mode used to encrypt the assessment run results.</p>
    public let resultEncryptionMode: String?
    /// <p>ARN of the AWS KMS encryption key used to encrypt the assessment run results.</p>
    public let resultKmsKeyArn: String?
    /// <p>Amazon S3 bucket where AWS DMS stores the results of this assessment run.</p>
    public let resultLocationBucket: String?
    /// <p>Folder in an Amazon S3 bucket where AWS DMS stores the results of this assessment
    ///          run.</p>
    public let resultLocationFolder: String?
    /// <p>ARN of the service role used to start the assessment run using the
    ///             <code>StartReplicationTaskAssessmentRun</code> operation.</p>
    public let serviceAccessRoleArn: String?
    /// <p>Assessment run status. </p>
    ///          <p>This status can have one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>"cancelling"</code> – The assessment run was canceled by the
    ///                   <code>CancelReplicationTaskAssessmentRun</code> operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"deleting"</code> – The assessment run was deleted by the
    ///                   <code>DeleteReplicationTaskAssessmentRun</code> operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"failed"</code> – At least one individual assessment completed with a
    ///                   <code>failed</code> status.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"error-provisioning"</code> – An internal error occurred while
    ///                resources were provisioned (during <code>provisioning</code> status).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"error-executing"</code> – An internal error occurred while
    ///                individual assessments ran (during <code>running</code> status).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"invalid state"</code> – The assessment run is in an unknown state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"passed"</code> – All individual assessments have completed, and none
    ///                has a <code>failed</code> status.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"provisioning"</code> – Resources required to run individual
    ///                assessments are being provisioned.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"running"</code> – Individual assessments are being run.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"starting"</code> – The assessment run is starting, but resources are not yet
    ///                being provisioned for individual assessments.</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        assessmentProgress: ReplicationTaskAssessmentRunProgress? = nil,
        assessmentRunName: String? = nil,
        lastFailureMessage: String? = nil,
        replicationTaskArn: String? = nil,
        replicationTaskAssessmentRunArn: String? = nil,
        replicationTaskAssessmentRunCreationDate: Date? = nil,
        resultEncryptionMode: String? = nil,
        resultKmsKeyArn: String? = nil,
        resultLocationBucket: String? = nil,
        resultLocationFolder: String? = nil,
        serviceAccessRoleArn: String? = nil,
        status: String? = nil
    )
    {
        self.assessmentProgress = assessmentProgress
        self.assessmentRunName = assessmentRunName
        self.lastFailureMessage = lastFailureMessage
        self.replicationTaskArn = replicationTaskArn
        self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
        self.replicationTaskAssessmentRunCreationDate = replicationTaskAssessmentRunCreationDate
        self.resultEncryptionMode = resultEncryptionMode
        self.resultKmsKeyArn = resultKmsKeyArn
        self.resultLocationBucket = resultLocationBucket
        self.resultLocationFolder = resultLocationFolder
        self.serviceAccessRoleArn = serviceAccessRoleArn
        self.status = status
    }
}

extension ReplicationTaskAssessmentRunProgress: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case individualAssessmentCompletedCount = "IndividualAssessmentCompletedCount"
        case individualAssessmentCount = "IndividualAssessmentCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if individualAssessmentCompletedCount != 0 {
            try encodeContainer.encode(individualAssessmentCompletedCount, forKey: .individualAssessmentCompletedCount)
        }
        if individualAssessmentCount != 0 {
            try encodeContainer.encode(individualAssessmentCount, forKey: .individualAssessmentCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let individualAssessmentCountDecoded = try containerValues.decode(Int.self, forKey: .individualAssessmentCount)
        individualAssessmentCount = individualAssessmentCountDecoded
        let individualAssessmentCompletedCountDecoded = try containerValues.decode(Int.self, forKey: .individualAssessmentCompletedCount)
        individualAssessmentCompletedCount = individualAssessmentCompletedCountDecoded
    }
}

extension ReplicationTaskAssessmentRunProgress: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationTaskAssessmentRunProgress(individualAssessmentCompletedCount: \(String(describing: individualAssessmentCompletedCount)), individualAssessmentCount: \(String(describing: individualAssessmentCount)))"}
}

/// <p>The progress values reported by the <code>AssessmentProgress</code> response
///          element.</p>
public struct ReplicationTaskAssessmentRunProgress: Equatable {
    /// <p>The number of individual assessments that have completed, successfully or not.</p>
    public let individualAssessmentCompletedCount: Int
    /// <p>The number of individual assessments that are specified to run.</p>
    public let individualAssessmentCount: Int

    public init (
        individualAssessmentCompletedCount: Int = 0,
        individualAssessmentCount: Int = 0
    )
    {
        self.individualAssessmentCompletedCount = individualAssessmentCompletedCount
        self.individualAssessmentCount = individualAssessmentCount
    }
}

extension ReplicationTaskIndividualAssessment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case individualAssessmentName = "IndividualAssessmentName"
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
        case replicationTaskIndividualAssessmentArn = "ReplicationTaskIndividualAssessmentArn"
        case replicationTaskIndividualAssessmentStartDate = "ReplicationTaskIndividualAssessmentStartDate"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let individualAssessmentName = individualAssessmentName {
            try encodeContainer.encode(individualAssessmentName, forKey: .individualAssessmentName)
        }
        if let replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
        if let replicationTaskIndividualAssessmentArn = replicationTaskIndividualAssessmentArn {
            try encodeContainer.encode(replicationTaskIndividualAssessmentArn, forKey: .replicationTaskIndividualAssessmentArn)
        }
        if let replicationTaskIndividualAssessmentStartDate = replicationTaskIndividualAssessmentStartDate {
            try encodeContainer.encode(replicationTaskIndividualAssessmentStartDate.timeIntervalSince1970, forKey: .replicationTaskIndividualAssessmentStartDate)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIndividualAssessmentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskIndividualAssessmentArn)
        replicationTaskIndividualAssessmentArn = replicationTaskIndividualAssessmentArnDecoded
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
        let individualAssessmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .individualAssessmentName)
        individualAssessmentName = individualAssessmentNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let replicationTaskIndividualAssessmentStartDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .replicationTaskIndividualAssessmentStartDate)
        replicationTaskIndividualAssessmentStartDate = replicationTaskIndividualAssessmentStartDateDecoded
    }
}

extension ReplicationTaskIndividualAssessment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationTaskIndividualAssessment(individualAssessmentName: \(String(describing: individualAssessmentName)), replicationTaskAssessmentRunArn: \(String(describing: replicationTaskAssessmentRunArn)), replicationTaskIndividualAssessmentArn: \(String(describing: replicationTaskIndividualAssessmentArn)), replicationTaskIndividualAssessmentStartDate: \(String(describing: replicationTaskIndividualAssessmentStartDate)), status: \(String(describing: status)))"}
}

/// <p>Provides information that describes an individual assessment from a premigration
///          assessment run.</p>
public struct ReplicationTaskIndividualAssessment: Equatable {
    /// <p>Name of this individual assessment.</p>
    public let individualAssessmentName: String?
    /// <p>ARN of the premigration assessment run that is created to run this individual
    ///          assessment.</p>
    public let replicationTaskAssessmentRunArn: String?
    /// <p>Amazon Resource Name (ARN) of this individual assessment.</p>
    public let replicationTaskIndividualAssessmentArn: String?
    /// <p>Date when this individual assessment was started as part of running the
    ///             <code>StartReplicationTaskAssessmentRun</code> operation.</p>
    public let replicationTaskIndividualAssessmentStartDate: Date?
    /// <p>Individual assessment status.</p>
    ///          <p>This status can have one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>"cancelled"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"error"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"failed"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"passed"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"pending"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"running"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        individualAssessmentName: String? = nil,
        replicationTaskAssessmentRunArn: String? = nil,
        replicationTaskIndividualAssessmentArn: String? = nil,
        replicationTaskIndividualAssessmentStartDate: Date? = nil,
        status: String? = nil
    )
    {
        self.individualAssessmentName = individualAssessmentName
        self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
        self.replicationTaskIndividualAssessmentArn = replicationTaskIndividualAssessmentArn
        self.replicationTaskIndividualAssessmentStartDate = replicationTaskIndividualAssessmentStartDate
        self.status = status
    }
}

extension ReplicationTaskStats: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case elapsedTimeMillis = "ElapsedTimeMillis"
        case freshStartDate = "FreshStartDate"
        case fullLoadFinishDate = "FullLoadFinishDate"
        case fullLoadProgressPercent = "FullLoadProgressPercent"
        case fullLoadStartDate = "FullLoadStartDate"
        case startDate = "StartDate"
        case stopDate = "StopDate"
        case tablesErrored = "TablesErrored"
        case tablesLoaded = "TablesLoaded"
        case tablesLoading = "TablesLoading"
        case tablesQueued = "TablesQueued"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if elapsedTimeMillis != 0 {
            try encodeContainer.encode(elapsedTimeMillis, forKey: .elapsedTimeMillis)
        }
        if let freshStartDate = freshStartDate {
            try encodeContainer.encode(freshStartDate.timeIntervalSince1970, forKey: .freshStartDate)
        }
        if let fullLoadFinishDate = fullLoadFinishDate {
            try encodeContainer.encode(fullLoadFinishDate.timeIntervalSince1970, forKey: .fullLoadFinishDate)
        }
        if fullLoadProgressPercent != 0 {
            try encodeContainer.encode(fullLoadProgressPercent, forKey: .fullLoadProgressPercent)
        }
        if let fullLoadStartDate = fullLoadStartDate {
            try encodeContainer.encode(fullLoadStartDate.timeIntervalSince1970, forKey: .fullLoadStartDate)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate.timeIntervalSince1970, forKey: .startDate)
        }
        if let stopDate = stopDate {
            try encodeContainer.encode(stopDate.timeIntervalSince1970, forKey: .stopDate)
        }
        if tablesErrored != 0 {
            try encodeContainer.encode(tablesErrored, forKey: .tablesErrored)
        }
        if tablesLoaded != 0 {
            try encodeContainer.encode(tablesLoaded, forKey: .tablesLoaded)
        }
        if tablesLoading != 0 {
            try encodeContainer.encode(tablesLoading, forKey: .tablesLoading)
        }
        if tablesQueued != 0 {
            try encodeContainer.encode(tablesQueued, forKey: .tablesQueued)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullLoadProgressPercentDecoded = try containerValues.decode(Int.self, forKey: .fullLoadProgressPercent)
        fullLoadProgressPercent = fullLoadProgressPercentDecoded
        let elapsedTimeMillisDecoded = try containerValues.decode(Int.self, forKey: .elapsedTimeMillis)
        elapsedTimeMillis = elapsedTimeMillisDecoded
        let tablesLoadedDecoded = try containerValues.decode(Int.self, forKey: .tablesLoaded)
        tablesLoaded = tablesLoadedDecoded
        let tablesLoadingDecoded = try containerValues.decode(Int.self, forKey: .tablesLoading)
        tablesLoading = tablesLoadingDecoded
        let tablesQueuedDecoded = try containerValues.decode(Int.self, forKey: .tablesQueued)
        tablesQueued = tablesQueuedDecoded
        let tablesErroredDecoded = try containerValues.decode(Int.self, forKey: .tablesErrored)
        tablesErrored = tablesErroredDecoded
        let freshStartDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .freshStartDate)
        freshStartDate = freshStartDateDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let stopDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopDate)
        stopDate = stopDateDecoded
        let fullLoadStartDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .fullLoadStartDate)
        fullLoadStartDate = fullLoadStartDateDecoded
        let fullLoadFinishDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .fullLoadFinishDate)
        fullLoadFinishDate = fullLoadFinishDateDecoded
    }
}

extension ReplicationTaskStats: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationTaskStats(elapsedTimeMillis: \(String(describing: elapsedTimeMillis)), freshStartDate: \(String(describing: freshStartDate)), fullLoadFinishDate: \(String(describing: fullLoadFinishDate)), fullLoadProgressPercent: \(String(describing: fullLoadProgressPercent)), fullLoadStartDate: \(String(describing: fullLoadStartDate)), startDate: \(String(describing: startDate)), stopDate: \(String(describing: stopDate)), tablesErrored: \(String(describing: tablesErrored)), tablesLoaded: \(String(describing: tablesLoaded)), tablesLoading: \(String(describing: tablesLoading)), tablesQueued: \(String(describing: tablesQueued)))"}
}

/// <p>In response to a request by the <code>DescribeReplicationTasks</code> operation, this object provides
///          a collection of statistics about a replication task.</p>
public struct ReplicationTaskStats: Equatable {
    /// <p>The elapsed time of the task, in milliseconds.</p>
    public let elapsedTimeMillis: Int
    /// <p>The date the replication task was started either with a fresh start or a target reload.</p>
    public let freshStartDate: Date?
    /// <p>The date the replication task full load was completed.</p>
    public let fullLoadFinishDate: Date?
    /// <p>The percent complete for the full load migration task.</p>
    public let fullLoadProgressPercent: Int
    /// <p>The date the replication task full load was started.</p>
    public let fullLoadStartDate: Date?
    /// <p>The date the replication task was started either with a fresh start or a resume. For more information, see
    ///          <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html#DMS-StartReplicationTask-request-StartReplicationTaskType">StartReplicationTaskType</a>.</p>
    public let startDate: Date?
    /// <p>The date the replication task was stopped.</p>
    public let stopDate: Date?
    /// <p>The number of errors that have occurred during this task.</p>
    public let tablesErrored: Int
    /// <p>The number of tables loaded for this task.</p>
    public let tablesLoaded: Int
    /// <p>The number of tables currently loading for this task.</p>
    public let tablesLoading: Int
    /// <p>The number of tables queued for this task.</p>
    public let tablesQueued: Int

    public init (
        elapsedTimeMillis: Int = 0,
        freshStartDate: Date? = nil,
        fullLoadFinishDate: Date? = nil,
        fullLoadProgressPercent: Int = 0,
        fullLoadStartDate: Date? = nil,
        startDate: Date? = nil,
        stopDate: Date? = nil,
        tablesErrored: Int = 0,
        tablesLoaded: Int = 0,
        tablesLoading: Int = 0,
        tablesQueued: Int = 0
    )
    {
        self.elapsedTimeMillis = elapsedTimeMillis
        self.freshStartDate = freshStartDate
        self.fullLoadFinishDate = fullLoadFinishDate
        self.fullLoadProgressPercent = fullLoadProgressPercent
        self.fullLoadStartDate = fullLoadStartDate
        self.startDate = startDate
        self.stopDate = stopDate
        self.tablesErrored = tablesErrored
        self.tablesLoaded = tablesLoaded
        self.tablesLoading = tablesLoading
        self.tablesQueued = tablesQueued
    }
}

extension ResourceAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsFault(message: \(String(describing: message)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ResourceAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceArn = output.resourceArn
        } else {
            self.message = nil
            self.resourceArn = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource you are attempting to create already exists.</p>
public struct ResourceAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?
    public var resourceArn: String?

    public init (
        message: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
    }
}

struct ResourceAlreadyExistsFaultBody: Equatable {
    public let message: String?
    public let resourceArn: String?
}

extension ResourceAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ResourceNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundFault(message: \(String(describing: message)))"}
}

extension ResourceNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource could not be found.</p>
public struct ResourceNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourcePendingMaintenanceActions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pendingMaintenanceActionDetails = "PendingMaintenanceActionDetails"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pendingMaintenanceActionDetails = pendingMaintenanceActionDetails {
            var pendingMaintenanceActionDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pendingMaintenanceActionDetails)
            for pendingmaintenanceactiondetails0 in pendingMaintenanceActionDetails {
                try pendingMaintenanceActionDetailsContainer.encode(pendingmaintenanceactiondetails0)
            }
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let pendingMaintenanceActionDetailsContainer = try containerValues.decodeIfPresent([PendingMaintenanceAction?].self, forKey: .pendingMaintenanceActionDetails)
        var pendingMaintenanceActionDetailsDecoded0:[PendingMaintenanceAction]? = nil
        if let pendingMaintenanceActionDetailsContainer = pendingMaintenanceActionDetailsContainer {
            pendingMaintenanceActionDetailsDecoded0 = [PendingMaintenanceAction]()
            for structure0 in pendingMaintenanceActionDetailsContainer {
                if let structure0 = structure0 {
                    pendingMaintenanceActionDetailsDecoded0?.append(structure0)
                }
            }
        }
        pendingMaintenanceActionDetails = pendingMaintenanceActionDetailsDecoded0
    }
}

extension ResourcePendingMaintenanceActions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourcePendingMaintenanceActions(pendingMaintenanceActionDetails: \(String(describing: pendingMaintenanceActionDetails)), resourceIdentifier: \(String(describing: resourceIdentifier)))"}
}

/// <p>Identifies an AWS DMS resource and any pending actions for it.</p>
public struct ResourcePendingMaintenanceActions: Equatable {
    /// <p>Detailed information about the pending maintenance action.</p>
    public let pendingMaintenanceActionDetails: [PendingMaintenanceAction]?
    /// <p>The Amazon Resource Name (ARN) of the DMS resource that the pending maintenance action
    ///          applies to. For information about creating an ARN, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Introduction.AWS.ARN.html"> Constructing an Amazon
    ///             Resource Name (ARN) for AWS DMS</a> in the DMS documentation.</p>
    public let resourceIdentifier: String?

    public init (
        pendingMaintenanceActionDetails: [PendingMaintenanceAction]? = nil,
        resourceIdentifier: String? = nil
    )
    {
        self.pendingMaintenanceActionDetails = pendingMaintenanceActionDetails
        self.resourceIdentifier = resourceIdentifier
    }
}

extension ResourceQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceQuotaExceededFault(message: \(String(describing: message)))"}
}

extension ResourceQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceQuotaExceededFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The quota for this resource quota has been exceeded.</p>
public struct ResourceQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension ResourceQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3AccessDeniedFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3AccessDeniedFault(message: \(String(describing: message)))"}
}

extension S3AccessDeniedFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: S3AccessDeniedFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Insufficient privileges are preventing access to an Amazon S3 object.</p>
public struct S3AccessDeniedFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct S3AccessDeniedFaultBody: Equatable {
    public let message: String?
}

extension S3AccessDeniedFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ResourceNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ResourceNotFoundFault(message: \(String(describing: message)))"}
}

extension S3ResourceNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: S3ResourceNotFoundFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified Amazon S3 bucket, bucket folder, or other object can't be
///             found.</p>
public struct S3ResourceNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct S3ResourceNotFoundFaultBody: Equatable {
    public let message: String?
}

extension S3ResourceNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3Settings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketFolder = "BucketFolder"
        case bucketName = "BucketName"
        case cdcInsertsAndUpdates = "CdcInsertsAndUpdates"
        case cdcInsertsOnly = "CdcInsertsOnly"
        case cdcPath = "CdcPath"
        case compressionType = "CompressionType"
        case csvDelimiter = "CsvDelimiter"
        case csvNoSupValue = "CsvNoSupValue"
        case csvRowDelimiter = "CsvRowDelimiter"
        case dataFormat = "DataFormat"
        case dataPageSize = "DataPageSize"
        case datePartitionDelimiter = "DatePartitionDelimiter"
        case datePartitionEnabled = "DatePartitionEnabled"
        case datePartitionSequence = "DatePartitionSequence"
        case dictPageSizeLimit = "DictPageSizeLimit"
        case enableStatistics = "EnableStatistics"
        case encodingType = "EncodingType"
        case encryptionMode = "EncryptionMode"
        case externalTableDefinition = "ExternalTableDefinition"
        case includeOpForFullLoad = "IncludeOpForFullLoad"
        case parquetTimestampInMillisecond = "ParquetTimestampInMillisecond"
        case parquetVersion = "ParquetVersion"
        case preserveTransactions = "PreserveTransactions"
        case rowGroupLength = "RowGroupLength"
        case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case timestampColumnName = "TimestampColumnName"
        case useCsvNoSupValue = "UseCsvNoSupValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketFolder = bucketFolder {
            try encodeContainer.encode(bucketFolder, forKey: .bucketFolder)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let cdcInsertsAndUpdates = cdcInsertsAndUpdates {
            try encodeContainer.encode(cdcInsertsAndUpdates, forKey: .cdcInsertsAndUpdates)
        }
        if let cdcInsertsOnly = cdcInsertsOnly {
            try encodeContainer.encode(cdcInsertsOnly, forKey: .cdcInsertsOnly)
        }
        if let cdcPath = cdcPath {
            try encodeContainer.encode(cdcPath, forKey: .cdcPath)
        }
        if let compressionType = compressionType {
            try encodeContainer.encode(compressionType.rawValue, forKey: .compressionType)
        }
        if let csvDelimiter = csvDelimiter {
            try encodeContainer.encode(csvDelimiter, forKey: .csvDelimiter)
        }
        if let csvNoSupValue = csvNoSupValue {
            try encodeContainer.encode(csvNoSupValue, forKey: .csvNoSupValue)
        }
        if let csvRowDelimiter = csvRowDelimiter {
            try encodeContainer.encode(csvRowDelimiter, forKey: .csvRowDelimiter)
        }
        if let dataFormat = dataFormat {
            try encodeContainer.encode(dataFormat.rawValue, forKey: .dataFormat)
        }
        if let dataPageSize = dataPageSize {
            try encodeContainer.encode(dataPageSize, forKey: .dataPageSize)
        }
        if let datePartitionDelimiter = datePartitionDelimiter {
            try encodeContainer.encode(datePartitionDelimiter.rawValue, forKey: .datePartitionDelimiter)
        }
        if let datePartitionEnabled = datePartitionEnabled {
            try encodeContainer.encode(datePartitionEnabled, forKey: .datePartitionEnabled)
        }
        if let datePartitionSequence = datePartitionSequence {
            try encodeContainer.encode(datePartitionSequence.rawValue, forKey: .datePartitionSequence)
        }
        if let dictPageSizeLimit = dictPageSizeLimit {
            try encodeContainer.encode(dictPageSizeLimit, forKey: .dictPageSizeLimit)
        }
        if let enableStatistics = enableStatistics {
            try encodeContainer.encode(enableStatistics, forKey: .enableStatistics)
        }
        if let encodingType = encodingType {
            try encodeContainer.encode(encodingType.rawValue, forKey: .encodingType)
        }
        if let encryptionMode = encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let externalTableDefinition = externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let includeOpForFullLoad = includeOpForFullLoad {
            try encodeContainer.encode(includeOpForFullLoad, forKey: .includeOpForFullLoad)
        }
        if let parquetTimestampInMillisecond = parquetTimestampInMillisecond {
            try encodeContainer.encode(parquetTimestampInMillisecond, forKey: .parquetTimestampInMillisecond)
        }
        if let parquetVersion = parquetVersion {
            try encodeContainer.encode(parquetVersion.rawValue, forKey: .parquetVersion)
        }
        if let preserveTransactions = preserveTransactions {
            try encodeContainer.encode(preserveTransactions, forKey: .preserveTransactions)
        }
        if let rowGroupLength = rowGroupLength {
            try encodeContainer.encode(rowGroupLength, forKey: .rowGroupLength)
        }
        if let serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId {
            try encodeContainer.encode(serverSideEncryptionKmsKeyId, forKey: .serverSideEncryptionKmsKeyId)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let timestampColumnName = timestampColumnName {
            try encodeContainer.encode(timestampColumnName, forKey: .timestampColumnName)
        }
        if let useCsvNoSupValue = useCsvNoSupValue {
            try encodeContainer.encode(useCsvNoSupValue, forKey: .useCsvNoSupValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let csvRowDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .csvRowDelimiter)
        csvRowDelimiter = csvRowDelimiterDecoded
        let csvDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .csvDelimiter)
        csvDelimiter = csvDelimiterDecoded
        let bucketFolderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketFolder)
        bucketFolder = bucketFolderDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let compressionTypeDecoded = try containerValues.decodeIfPresent(CompressionTypeValue.self, forKey: .compressionType)
        compressionType = compressionTypeDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(EncryptionModeValue.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let serverSideEncryptionKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverSideEncryptionKmsKeyId)
        serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyIdDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(DataFormatValue.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let encodingTypeDecoded = try containerValues.decodeIfPresent(EncodingTypeValue.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
        let dictPageSizeLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dictPageSizeLimit)
        dictPageSizeLimit = dictPageSizeLimitDecoded
        let rowGroupLengthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .rowGroupLength)
        rowGroupLength = rowGroupLengthDecoded
        let dataPageSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dataPageSize)
        dataPageSize = dataPageSizeDecoded
        let parquetVersionDecoded = try containerValues.decodeIfPresent(ParquetVersionValue.self, forKey: .parquetVersion)
        parquetVersion = parquetVersionDecoded
        let enableStatisticsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableStatistics)
        enableStatistics = enableStatisticsDecoded
        let includeOpForFullLoadDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeOpForFullLoad)
        includeOpForFullLoad = includeOpForFullLoadDecoded
        let cdcInsertsOnlyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .cdcInsertsOnly)
        cdcInsertsOnly = cdcInsertsOnlyDecoded
        let timestampColumnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestampColumnName)
        timestampColumnName = timestampColumnNameDecoded
        let parquetTimestampInMillisecondDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .parquetTimestampInMillisecond)
        parquetTimestampInMillisecond = parquetTimestampInMillisecondDecoded
        let cdcInsertsAndUpdatesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .cdcInsertsAndUpdates)
        cdcInsertsAndUpdates = cdcInsertsAndUpdatesDecoded
        let datePartitionEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .datePartitionEnabled)
        datePartitionEnabled = datePartitionEnabledDecoded
        let datePartitionSequenceDecoded = try containerValues.decodeIfPresent(DatePartitionSequenceValue.self, forKey: .datePartitionSequence)
        datePartitionSequence = datePartitionSequenceDecoded
        let datePartitionDelimiterDecoded = try containerValues.decodeIfPresent(DatePartitionDelimiterValue.self, forKey: .datePartitionDelimiter)
        datePartitionDelimiter = datePartitionDelimiterDecoded
        let useCsvNoSupValueDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useCsvNoSupValue)
        useCsvNoSupValue = useCsvNoSupValueDecoded
        let csvNoSupValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .csvNoSupValue)
        csvNoSupValue = csvNoSupValueDecoded
        let preserveTransactionsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .preserveTransactions)
        preserveTransactions = preserveTransactionsDecoded
        let cdcPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cdcPath)
        cdcPath = cdcPathDecoded
    }
}

extension S3Settings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Settings(bucketFolder: \(String(describing: bucketFolder)), bucketName: \(String(describing: bucketName)), cdcInsertsAndUpdates: \(String(describing: cdcInsertsAndUpdates)), cdcInsertsOnly: \(String(describing: cdcInsertsOnly)), cdcPath: \(String(describing: cdcPath)), compressionType: \(String(describing: compressionType)), csvDelimiter: \(String(describing: csvDelimiter)), csvNoSupValue: \(String(describing: csvNoSupValue)), csvRowDelimiter: \(String(describing: csvRowDelimiter)), dataFormat: \(String(describing: dataFormat)), dataPageSize: \(String(describing: dataPageSize)), datePartitionDelimiter: \(String(describing: datePartitionDelimiter)), datePartitionEnabled: \(String(describing: datePartitionEnabled)), datePartitionSequence: \(String(describing: datePartitionSequence)), dictPageSizeLimit: \(String(describing: dictPageSizeLimit)), enableStatistics: \(String(describing: enableStatistics)), encodingType: \(String(describing: encodingType)), encryptionMode: \(String(describing: encryptionMode)), externalTableDefinition: \(String(describing: externalTableDefinition)), includeOpForFullLoad: \(String(describing: includeOpForFullLoad)), parquetTimestampInMillisecond: \(String(describing: parquetTimestampInMillisecond)), parquetVersion: \(String(describing: parquetVersion)), preserveTransactions: \(String(describing: preserveTransactions)), rowGroupLength: \(String(describing: rowGroupLength)), serverSideEncryptionKmsKeyId: \(String(describing: serverSideEncryptionKmsKeyId)), serviceAccessRoleArn: \(String(describing: serviceAccessRoleArn)), timestampColumnName: \(String(describing: timestampColumnName)), useCsvNoSupValue: \(String(describing: useCsvNoSupValue)))"}
}

/// <p>Settings for exporting data to Amazon S3. </p>
public struct S3Settings: Equatable {
    /// <p> An optional parameter to set a folder name in the S3 bucket. If provided, tables are
    ///          created in the path
    ///                <code>
    ///                <i>bucketFolder</i>/<i>schema_name</i>/<i>table_name</i>/</code>.
    ///          If this parameter isn't specified, then the path used is
    ///                <code>
    ///                <i>schema_name</i>/<i>table_name</i>/</code>. </p>
    public let bucketFolder: String?
    /// <p> The name of the S3 bucket. </p>
    public let bucketName: String?
    /// <p>A value that enables a change data capture (CDC) load to write INSERT and UPDATE
    ///          operations to .csv or .parquet (columnar storage) output files. The default setting is
    ///             <code>false</code>, but when <code>CdcInsertsAndUpdates</code> is set to
    ///             <code>true</code> or <code>y</code>, only INSERTs and UPDATEs from the source database
    ///          are migrated to the .csv or .parquet file. </p>
    ///          <p>For .csv file format only, how these INSERTs and UPDATEs are recorded depends on the
    ///          value of the <code>IncludeOpForFullLoad</code> parameter. If
    ///             <code>IncludeOpForFullLoad</code> is set to <code>true</code>, the first field of every
    ///          CDC record is set to either <code>I</code> or <code>U</code> to indicate INSERT and UPDATE
    ///          operations at the source. But if <code>IncludeOpForFullLoad</code> is set to
    ///             <code>false</code>, CDC records are written without an indication of INSERT or UPDATE
    ///          operations at the source. For more information about how these settings work together, see
    ///             <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring.InsertOps">Indicating Source DB Operations in Migrated S3 Data</a> in the <i>AWS
    ///             Database Migration Service User Guide.</i>.</p>
    ///          <note>
    ///
    ///             <p>AWS DMS supports the use of the <code>CdcInsertsAndUpdates</code> parameter in
    ///             versions 3.3.1 and later.</p>
    ///
    ///             <p>
    ///                <code>CdcInsertsOnly</code> and <code>CdcInsertsAndUpdates</code> can't
    ///             both be set to <code>true</code> for the same endpoint. Set either
    ///             <code>CdcInsertsOnly</code> or <code>CdcInsertsAndUpdates</code> to <code>true</code>
    ///             for the same endpoint, but not both.</p>
    ///
    ///          </note>
    public let cdcInsertsAndUpdates: Bool?
    /// <p>A value that enables a change data capture (CDC) load to write only INSERT operations to
    ///          .csv or columnar storage (.parquet) output files. By default (the
    ///             <code>false</code> setting), the first field in a .csv or .parquet record contains the
    ///          letter I (INSERT), U (UPDATE), or D (DELETE). These values indicate whether the row was
    ///          inserted, updated, or deleted at the source database for a CDC load to the target.</p>
    ///          <p>If <code>CdcInsertsOnly</code> is set to <code>true</code> or <code>y</code>, only
    ///          INSERTs from the source database are migrated to the .csv or .parquet file. For .csv format
    ///          only, how these INSERTs are recorded depends on the value of
    ///             <code>IncludeOpForFullLoad</code>. If <code>IncludeOpForFullLoad</code> is set to
    ///             <code>true</code>, the first field of every CDC record is set to I to indicate the
    ///          INSERT operation at the source. If <code>IncludeOpForFullLoad</code> is set to
    ///             <code>false</code>, every CDC record is written without a first field to indicate the
    ///          INSERT operation at the source. For more information about how these settings work
    ///          together, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring.InsertOps">Indicating Source DB Operations in Migrated S3 Data</a> in the <i>AWS
    ///             Database Migration Service User Guide.</i>.</p>
    ///
    ///          <note>
    ///
    ///                <p>AWS DMS supports the interaction described preceding between the
    ///                <code>CdcInsertsOnly</code> and <code>IncludeOpForFullLoad</code> parameters in
    ///             versions 3.1.4 and later. </p>
    ///
    ///                <p>
    ///                <code>CdcInsertsOnly</code> and <code>CdcInsertsAndUpdates</code> can't
    ///             both be set to <code>true</code> for the same endpoint. Set either
    ///                <code>CdcInsertsOnly</code> or <code>CdcInsertsAndUpdates</code> to <code>true</code>
    ///             for the same endpoint, but not both.</p>
    ///
    ///          </note>
    public let cdcInsertsOnly: Bool?
    /// <p>Specifies the folder path of CDC files. For an S3 source, this setting is required if a
    ///          task captures change data; otherwise, it's optional. If <code>CdcPath</code> is set, AWS
    ///          DMS reads CDC files from this path and replicates the data changes to the target endpoint.
    ///          For an S3 target if you set <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-PreserveTransactions">
    ///                <code>PreserveTransactions</code>
    ///             </a> to <code>true</code>, AWS
    ///          DMS verifies that you have set this parameter to a folder path on your S3 target where AWS
    ///          DMS can save the transaction order for the CDC load. AWS DMS creates this CDC folder path
    ///          in either your S3 target working directory or the S3 target location specified by <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-BucketFolder">
    ///                <code>BucketFolder</code>
    ///             </a> and <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-BucketName">
    ///                <code>BucketName</code>
    ///             </a>.</p>
    ///          <p>For example, if you specify <code>CdcPath</code> as <code>MyChangedData</code>, and you
    ///          specify <code>BucketName</code> as <code>MyTargetBucket</code> but do not specify
    ///             <code>BucketFolder</code>, AWS DMS creates the CDC folder path following:
    ///             <code>MyTargetBucket/MyChangedData</code>.</p>
    ///          <p>If you specify the same <code>CdcPath</code>, and you specify <code>BucketName</code> as
    ///             <code>MyTargetBucket</code> and <code>BucketFolder</code> as <code>MyTargetData</code>,
    ///          AWS DMS creates the CDC folder path following:
    ///             <code>MyTargetBucket/MyTargetData/MyChangedData</code>.</p>
    ///          <p>For more information on CDC including transaction order on an S3 target, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.EndpointSettings.CdcPath">Capturing data changes (CDC) including transaction order on the S3
    ///             target</a>.</p>
    ///          <note>
    ///             <p>This setting is supported in AWS DMS versions 3.4.2 and later.</p>
    ///          </note>
    public let cdcPath: String?
    /// <p>An optional parameter to use GZIP to compress the target files. Set to GZIP to compress
    ///          the target files. Either set this parameter to NONE (the default) or don't use it to leave the files uncompressed.
    ///          This parameter applies to both .csv and .parquet file formats. </p>
    public let compressionType: CompressionTypeValue?
    /// <p> The delimiter used to separate columns in the .csv file for both source and target. The default is a comma.
    ///       </p>
    public let csvDelimiter: String?
    /// <p>This setting only applies if your Amazon S3 output files during a change data capture
    ///          (CDC) load are written in .csv format. If <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-UseCsvNoSupValue">
    ///                <code>UseCsvNoSupValue</code>
    ///             </a> is set to true, specify a
    ///          string value that you want AWS DMS to use for all columns not included in the supplemental
    ///          log. If you do not specify a string value, AWS DMS uses the null value for these columns
    ///          regardless of the <code>UseCsvNoSupValue</code> setting.</p>
    ///          <note>
    ///             <p>This setting is supported in AWS DMS versions 3.4.1 and later.</p>
    ///          </note>
    public let csvNoSupValue: String?
    /// <p> The delimiter used to separate rows in the .csv file for both source and target. The default is a carriage
    ///          return (<code>\n</code>). </p>
    public let csvRowDelimiter: String?
    /// <p>The format of the data that you want to use for output. You can choose one of the
    ///          following: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>csv</code> : This is a row-based file format with comma-separated values
    ///                (.csv). </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>parquet</code> : Apache Parquet (.parquet) is a columnar storage file format
    ///                that features efficient compression and provides faster query response. </p>
    ///             </li>
    ///          </ul>
    public let dataFormat: DataFormatValue?
    /// <p>The size of one data page in bytes. This parameter defaults to 1024 * 1024 bytes (1 MiB).
    ///          This number is used for .parquet file format only. </p>
    public let dataPageSize: Int?
    /// <p>Specifies a date separating delimiter to use during folder partitioning. The default value is
    ///          <code>SLASH</code>. Use this parameter when <code>DatePartitionedEnabled</code> is set to <code>true</code>.</p>
    public let datePartitionDelimiter: DatePartitionDelimiterValue?
    /// <p>When set to <code>true</code>, this parameter partitions S3 bucket folders based on transaction commit
    ///          dates. The default value is <code>false</code>. For more information about date-based folder partitoning,
    ///          see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.DatePartitioning">Using date-based folder partitioning</a>.</p>
    public let datePartitionEnabled: Bool?
    /// <p>Identifies the sequence of the date format to use during folder partitioning. The default value is
    ///          <code>YYYYMMDD</code>. Use this parameter when <code>DatePartitionedEnabled</code> is set to <code>true</code>.</p>
    public let datePartitionSequence: DatePartitionSequenceValue?
    /// <p>The maximum size of an encoded dictionary page of a column. If the dictionary page
    ///          exceeds this, this column is stored using an encoding type of <code>PLAIN</code>. This
    ///          parameter defaults to 1024 * 1024 bytes (1 MiB), the maximum size of a dictionary page
    ///          before it reverts to <code>PLAIN</code> encoding. This size is used for
    ///            .parquet file format only. </p>
    public let dictPageSizeLimit: Int?
    /// <p>A value that enables statistics for Parquet pages and row groups. Choose
    ///             <code>true</code> to enable statistics, <code>false</code> to disable. Statistics
    ///          include <code>NULL</code>, <code>DISTINCT</code>, <code>MAX</code>, and <code>MIN</code>
    ///          values. This parameter defaults to <code>true</code>. This value is used for
    ///             .parquet file format only.</p>
    public let enableStatistics: Bool?
    /// <p>The type of encoding you are using: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>RLE_DICTIONARY</code> uses a combination of bit-packing and run-length
    ///                encoding to store repeated values more efficiently. This is the default.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PLAIN</code> doesn't use encoding at all. Values are stored as they
    ///                are.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PLAIN_DICTIONARY</code> builds a dictionary of the values encountered in a
    ///                given column. The dictionary is stored in a dictionary page for each column
    ///                chunk.</p>
    ///             </li>
    ///          </ul>
    public let encodingType: EncodingTypeValue?
    /// <p>The type of server-side encryption that you want to use for your data. This encryption
    ///          type is part of the endpoint settings or the extra connections attributes for Amazon S3.
    ///          You can choose either <code>SSE_S3</code> (the default) or <code>SSE_KMS</code>. </p>
    ///          <note>
    ///             <p>For the <code>ModifyEndpoint</code> operation, you can change the existing value of
    ///             the <code>EncryptionMode</code> parameter from <code>SSE_KMS</code> to
    ///                <code>SSE_S3</code>. But you can’t change the existing value from <code>SSE_S3</code>
    ///             to <code>SSE_KMS</code>.</p>
    ///          </note>
    ///          <p>To use <code>SSE_S3</code>, you need an AWS Identity and Access Management (IAM) role
    ///          with permission to allow <code>"arn:aws:s3:::dms-*"</code> to use the following
    ///          actions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>s3:CreateBucket</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>s3:ListBucket</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>s3:DeleteBucket</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>s3:GetBucketLocation</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>s3:GetObject</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>s3:PutObject</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>s3:DeleteObject</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>s3:GetObjectVersion</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>s3:GetBucketPolicy</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>s3:PutBucketPolicy</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>s3:DeleteBucketPolicy</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let encryptionMode: EncryptionModeValue?
    /// <p> Specifies how tables are defined in the S3 source files only. </p>
    public let externalTableDefinition: String?
    /// <p>A value that enables a full load to write INSERT operations to the comma-separated value
    ///          (.csv) output files only to indicate how the rows were added to the source database.</p>
    ///          <note>
    ///             <p>AWS DMS supports the <code>IncludeOpForFullLoad</code> parameter in versions 3.1.4 and
    ///             later.</p>
    ///          </note>
    ///          <p>For full load, records can only be inserted. By default (the <code>false</code>
    ///          setting), no information is recorded in these output files for a full load to indicate that
    ///          the rows were inserted at the source database. If <code>IncludeOpForFullLoad</code> is set
    ///          to <code>true</code> or <code>y</code>, the INSERT is recorded as an I annotation in the
    ///          first field of the .csv file. This allows the format of your target records from a full
    ///          load to be consistent with the target records from a CDC load.</p>
    ///          <note>
    ///             <p>This setting works together with the <code>CdcInsertsOnly</code> and the
    ///                <code>CdcInsertsAndUpdates</code> parameters for output to .csv files only. For more
    ///             information about how these settings work together, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring.InsertOps">Indicating Source DB Operations in Migrated S3 Data</a> in the <i>AWS
    ///                Database Migration Service User Guide.</i>.</p>
    ///          </note>
    public let includeOpForFullLoad: Bool?
    /// <p>A value that specifies the precision of any <code>TIMESTAMP</code> column values that
    ///          are written to an Amazon S3 object file in .parquet format.</p>
    ///          <note>
    ///             <p>AWS DMS supports the <code>ParquetTimestampInMillisecond</code> parameter in versions
    ///             3.1.4 and later.</p>
    ///          </note>
    ///          <p>When <code>ParquetTimestampInMillisecond</code> is set to <code>true</code> or
    ///             <code>y</code>, AWS DMS writes all <code>TIMESTAMP</code> columns in a .parquet
    ///          formatted file with millisecond precision. Otherwise, DMS writes them with microsecond
    ///          precision.</p>
    ///          <p>Currently, Amazon Athena and AWS Glue can handle only
    ///          millisecond precision for <code>TIMESTAMP</code> values. Set
    ///          this parameter to <code>true</code> for S3 endpoint object
    ///          files that are .parquet formatted only if you plan to query or process the data with Athena or AWS Glue.</p>
    ///          <note>
    ///
    ///                <p>AWS DMS writes any <code>TIMESTAMP</code> column
    ///                   values written to an S3 file in .csv format with
    ///                   microsecond precision.</p>
    ///
    ///                <p>Setting <code>ParquetTimestampInMillisecond</code> has no effect on the string
    ///             format of the timestamp column value that is inserted by setting the
    ///                <code>TimestampColumnName</code> parameter.</p>
    ///
    ///          </note>
    public let parquetTimestampInMillisecond: Bool?
    /// <p>The version of the Apache Parquet format that you want to use: <code>parquet_1_0</code>
    ///          (the default) or <code>parquet_2_0</code>.</p>
    public let parquetVersion: ParquetVersionValue?
    /// <p>If set to <code>true</code>, AWS DMS saves the transaction order for a change data
    ///          capture (CDC) load on the Amazon S3 target specified by <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-CdcPath">
    ///                <code>CdcPath</code>
    ///             </a>. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.EndpointSettings.CdcPath">Capturing data changes (CDC) including transaction order on the S3
    ///             target</a>.</p>
    ///          <note>
    ///             <p>This setting is supported in AWS DMS versions 3.4.2 and later.</p>
    ///          </note>
    public let preserveTransactions: Bool?
    /// <p>The number of rows in a row group. A smaller row group size provides faster reads. But
    ///          as the number of row groups grows, the slower writes become. This parameter defaults to
    ///          10,000 rows. This number is used for .parquet file format only. </p>
    ///          <p>If you choose a value larger than the maximum, <code>RowGroupLength</code> is set to the
    ///          max row group length in bytes (64 * 1024 * 1024). </p>
    public let rowGroupLength: Int?
    /// <p>If you are using <code>SSE_KMS</code> for the <code>EncryptionMode</code>, provide the
    ///          AWS KMS key ID. The key that you use needs an attached policy that enables AWS Identity and
    ///          Access Management (IAM) user permissions and allows use of the key.</p>
    ///          <p>Here is a CLI example: <code>aws dms create-endpoint --endpoint-identifier
    ///                <i>value</i> --endpoint-type target --engine-name s3 --s3-settings
    ///                ServiceAccessRoleArn=<i>value</i>,BucketFolder=<i>value</i>,BucketName=<i>value</i>,EncryptionMode=SSE_KMS,ServerSideEncryptionKmsKeyId=<i>value</i>
    ///             </code>
    ///          </p>
    public let serverSideEncryptionKmsKeyId: String?
    /// <p> The Amazon Resource Name (ARN) used by the service access IAM role. It is a required
    ///          parameter that enables DMS to write and read objects from an S3 bucket.</p>
    public let serviceAccessRoleArn: String?
    /// <p>A value that when nonblank causes AWS DMS to add a column with timestamp information to
    ///          the endpoint data for an Amazon S3 target.</p>
    ///          <note>
    ///             <p>AWS DMS supports the <code>TimestampColumnName</code> parameter in versions 3.1.4 and later.</p>
    ///          </note>
    ///          <p>DMS includes an additional <code>STRING</code> column in the
    ///          .csv or .parquet object files of your migrated data when you set
    ///          <code>TimestampColumnName</code> to a nonblank value.</p>
    ///          <p>For a full load, each row of this timestamp column contains a
    ///          timestamp for when the data was transferred from the source to
    ///          the target by DMS. </p>
    ///          <p>For a change data capture (CDC) load, each row of the timestamp column contains the
    ///          timestamp for the commit of that row in the source
    ///          database.</p>
    ///          <p>The string format for this timestamp column value is
    ///          <code>yyyy-MM-dd HH:mm:ss.SSSSSS</code>. By default, the
    ///          precision of this value is in microseconds. For a CDC load, the
    ///          rounding of the precision depends on the commit timestamp
    ///          supported by DMS for the source database.</p>
    ///          <p>When the <code>AddColumnName</code> parameter is set to <code>true</code>, DMS also
    ///          includes a name for the timestamp column that you set with
    ///          <code>TimestampColumnName</code>.</p>
    public let timestampColumnName: String?
    /// <p>This setting applies if the S3 output files during a change data capture (CDC) load are
    ///          written in .csv format. If set to <code>true</code> for columns not included in the
    ///          supplemental log, AWS DMS uses the value specified by <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-CsvNoSupValue">
    ///                <code>CsvNoSupValue</code>
    ///             </a>. If not set or set to
    ///             <code>false</code>, AWS DMS uses the null value for these columns.</p>
    ///          <note>
    ///             <p>This setting is supported in AWS DMS versions 3.4.1 and later.</p>
    ///          </note>
    public let useCsvNoSupValue: Bool?

    public init (
        bucketFolder: String? = nil,
        bucketName: String? = nil,
        cdcInsertsAndUpdates: Bool? = nil,
        cdcInsertsOnly: Bool? = nil,
        cdcPath: String? = nil,
        compressionType: CompressionTypeValue? = nil,
        csvDelimiter: String? = nil,
        csvNoSupValue: String? = nil,
        csvRowDelimiter: String? = nil,
        dataFormat: DataFormatValue? = nil,
        dataPageSize: Int? = nil,
        datePartitionDelimiter: DatePartitionDelimiterValue? = nil,
        datePartitionEnabled: Bool? = nil,
        datePartitionSequence: DatePartitionSequenceValue? = nil,
        dictPageSizeLimit: Int? = nil,
        enableStatistics: Bool? = nil,
        encodingType: EncodingTypeValue? = nil,
        encryptionMode: EncryptionModeValue? = nil,
        externalTableDefinition: String? = nil,
        includeOpForFullLoad: Bool? = nil,
        parquetTimestampInMillisecond: Bool? = nil,
        parquetVersion: ParquetVersionValue? = nil,
        preserveTransactions: Bool? = nil,
        rowGroupLength: Int? = nil,
        serverSideEncryptionKmsKeyId: String? = nil,
        serviceAccessRoleArn: String? = nil,
        timestampColumnName: String? = nil,
        useCsvNoSupValue: Bool? = nil
    )
    {
        self.bucketFolder = bucketFolder
        self.bucketName = bucketName
        self.cdcInsertsAndUpdates = cdcInsertsAndUpdates
        self.cdcInsertsOnly = cdcInsertsOnly
        self.cdcPath = cdcPath
        self.compressionType = compressionType
        self.csvDelimiter = csvDelimiter
        self.csvNoSupValue = csvNoSupValue
        self.csvRowDelimiter = csvRowDelimiter
        self.dataFormat = dataFormat
        self.dataPageSize = dataPageSize
        self.datePartitionDelimiter = datePartitionDelimiter
        self.datePartitionEnabled = datePartitionEnabled
        self.datePartitionSequence = datePartitionSequence
        self.dictPageSizeLimit = dictPageSizeLimit
        self.enableStatistics = enableStatistics
        self.encodingType = encodingType
        self.encryptionMode = encryptionMode
        self.externalTableDefinition = externalTableDefinition
        self.includeOpForFullLoad = includeOpForFullLoad
        self.parquetTimestampInMillisecond = parquetTimestampInMillisecond
        self.parquetVersion = parquetVersion
        self.preserveTransactions = preserveTransactions
        self.rowGroupLength = rowGroupLength
        self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
        self.serviceAccessRoleArn = serviceAccessRoleArn
        self.timestampColumnName = timestampColumnName
        self.useCsvNoSupValue = useCsvNoSupValue
    }
}

extension SNSInvalidTopicFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SNSInvalidTopicFault(message: \(String(describing: message)))"}
}

extension SNSInvalidTopicFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SNSInvalidTopicFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The SNS topic is invalid.</p>
public struct SNSInvalidTopicFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SNSInvalidTopicFaultBody: Equatable {
    public let message: String?
}

extension SNSInvalidTopicFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSNoAuthorizationFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SNSNoAuthorizationFault(message: \(String(describing: message)))"}
}

extension SNSNoAuthorizationFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SNSNoAuthorizationFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are not authorized for the SNS subscription.</p>
public struct SNSNoAuthorizationFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SNSNoAuthorizationFaultBody: Equatable {
    public let message: String?
}

extension SNSNoAuthorizationFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SafeguardPolicy {
    case exclusiveAutomaticTruncation
    case relyOnSqlServerReplicationAgent
    case sharedAutomaticTruncation
    case sdkUnknown(String)
}

extension SafeguardPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SafeguardPolicy] {
        return [
            .exclusiveAutomaticTruncation,
            .relyOnSqlServerReplicationAgent,
            .sharedAutomaticTruncation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .exclusiveAutomaticTruncation: return "exclusive-automatic-truncation"
        case .relyOnSqlServerReplicationAgent: return "rely-on-sql-server-replication-agent"
        case .sharedAutomaticTruncation: return "shared-automatic-truncation"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SafeguardPolicy(rawValue: rawValue) ?? SafeguardPolicy.sdkUnknown(rawValue)
    }
}

public enum SourceType {
    case replicationInstance
    case sdkUnknown(String)
}

extension SourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceType] {
        return [
            .replicationInstance,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .replicationInstance: return "replication-instance"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
    }
}

public struct StartReplicationTaskAssessmentInputBodyMiddleware: Middleware {
    public let id: String = "StartReplicationTaskAssessmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartReplicationTaskAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartReplicationTaskAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartReplicationTaskAssessmentInput>
    public typealias MOutput = OperationOutput<StartReplicationTaskAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartReplicationTaskAssessmentOutputError>
}

extension StartReplicationTaskAssessmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartReplicationTaskAssessmentInput(replicationTaskArn: \(String(describing: replicationTaskArn)))"}
}

extension StartReplicationTaskAssessmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

public struct StartReplicationTaskAssessmentInputHeadersMiddleware: Middleware {
    public let id: String = "StartReplicationTaskAssessmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartReplicationTaskAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartReplicationTaskAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartReplicationTaskAssessmentInput>
    public typealias MOutput = OperationOutput<StartReplicationTaskAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartReplicationTaskAssessmentOutputError>
}

public struct StartReplicationTaskAssessmentInputQueryItemMiddleware: Middleware {
    public let id: String = "StartReplicationTaskAssessmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartReplicationTaskAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartReplicationTaskAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartReplicationTaskAssessmentInput>
    public typealias MOutput = OperationOutput<StartReplicationTaskAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartReplicationTaskAssessmentOutputError>
}

/// <p></p>
public struct StartReplicationTaskAssessmentInput: Equatable {
    /// <p> The Amazon Resource Name (ARN) of the replication task. </p>
    public let replicationTaskArn: String?

    public init (
        replicationTaskArn: String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct StartReplicationTaskAssessmentInputBody: Equatable {
    public let replicationTaskArn: String?
}

extension StartReplicationTaskAssessmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

extension StartReplicationTaskAssessmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReplicationTaskAssessmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartReplicationTaskAssessmentOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReplicationTaskAssessmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartReplicationTaskAssessmentOutputResponse(replicationTask: \(String(describing: replicationTask)))"}
}

extension StartReplicationTaskAssessmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartReplicationTaskAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

/// <p></p>
public struct StartReplicationTaskAssessmentOutputResponse: Equatable {
    /// <p> The assessed replication task. </p>
    public let replicationTask: ReplicationTask?

    public init (
        replicationTask: ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct StartReplicationTaskAssessmentOutputResponseBody: Equatable {
    public let replicationTask: ReplicationTask?
}

extension StartReplicationTaskAssessmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

public struct StartReplicationTaskAssessmentRunInputBodyMiddleware: Middleware {
    public let id: String = "StartReplicationTaskAssessmentRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartReplicationTaskAssessmentRunInput>
    public typealias MOutput = OperationOutput<StartReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartReplicationTaskAssessmentRunOutputError>
}

extension StartReplicationTaskAssessmentRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartReplicationTaskAssessmentRunInput(assessmentRunName: \(String(describing: assessmentRunName)), exclude: \(String(describing: exclude)), includeOnly: \(String(describing: includeOnly)), replicationTaskArn: \(String(describing: replicationTaskArn)), resultEncryptionMode: \(String(describing: resultEncryptionMode)), resultKmsKeyArn: \(String(describing: resultKmsKeyArn)), resultLocationBucket: \(String(describing: resultLocationBucket)), resultLocationFolder: \(String(describing: resultLocationFolder)), serviceAccessRoleArn: \(String(describing: serviceAccessRoleArn)))"}
}

extension StartReplicationTaskAssessmentRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentRunName = "AssessmentRunName"
        case exclude = "Exclude"
        case includeOnly = "IncludeOnly"
        case replicationTaskArn = "ReplicationTaskArn"
        case resultEncryptionMode = "ResultEncryptionMode"
        case resultKmsKeyArn = "ResultKmsKeyArn"
        case resultLocationBucket = "ResultLocationBucket"
        case resultLocationFolder = "ResultLocationFolder"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunName = assessmentRunName {
            try encodeContainer.encode(assessmentRunName, forKey: .assessmentRunName)
        }
        if let exclude = exclude {
            var excludeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclude)
            for excludetestlist0 in exclude {
                try excludeContainer.encode(excludetestlist0)
            }
        }
        if let includeOnly = includeOnly {
            var includeOnlyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includeOnly)
            for includetestlist0 in includeOnly {
                try includeOnlyContainer.encode(includetestlist0)
            }
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let resultEncryptionMode = resultEncryptionMode {
            try encodeContainer.encode(resultEncryptionMode, forKey: .resultEncryptionMode)
        }
        if let resultKmsKeyArn = resultKmsKeyArn {
            try encodeContainer.encode(resultKmsKeyArn, forKey: .resultKmsKeyArn)
        }
        if let resultLocationBucket = resultLocationBucket {
            try encodeContainer.encode(resultLocationBucket, forKey: .resultLocationBucket)
        }
        if let resultLocationFolder = resultLocationFolder {
            try encodeContainer.encode(resultLocationFolder, forKey: .resultLocationFolder)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }
}

public struct StartReplicationTaskAssessmentRunInputHeadersMiddleware: Middleware {
    public let id: String = "StartReplicationTaskAssessmentRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartReplicationTaskAssessmentRunInput>
    public typealias MOutput = OperationOutput<StartReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartReplicationTaskAssessmentRunOutputError>
}

public struct StartReplicationTaskAssessmentRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StartReplicationTaskAssessmentRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartReplicationTaskAssessmentRunInput>
    public typealias MOutput = OperationOutput<StartReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartReplicationTaskAssessmentRunOutputError>
}

/// <p></p>
public struct StartReplicationTaskAssessmentRunInput: Equatable {
    /// <p>Unique name to identify the assessment run.</p>
    public let assessmentRunName: String?
    /// <p>Space-separated list of names for specific individual assessments that you want to
    ///          exclude. These names come from the default list of individual assessments that AWS DMS
    ///          supports for the associated migration task. This task is specified by
    ///             <code>ReplicationTaskArn</code>.</p>
    ///          <note>
    ///             <p>You can't set a value for <code>Exclude</code> if you also set a value for
    ///             <code>IncludeOnly</code> in the API operation.</p>
    ///             <p>To identify the names of the default individual assessments that AWS DMS
    ///             supports for the associated migration task, run the
    ///             <code>DescribeApplicableIndividualAssessments</code> operation using its own
    ///             <code>ReplicationTaskArn</code> request parameter.</p>
    ///          </note>
    public let exclude: [String]?
    /// <p>Space-separated list of names for specific individual assessments that you want to
    ///          include. These names come from the default list of individual assessments that AWS DMS
    ///          supports for the associated migration task. This task is specified by
    ///             <code>ReplicationTaskArn</code>.</p>
    ///          <note>
    ///             <p>You can't set a value for <code>IncludeOnly</code> if you also set a value for
    ///             <code>Exclude</code> in the API operation. </p>
    ///             <p>To identify the names of the default individual assessments that AWS DMS
    ///             supports for the associated migration task, run the
    ///             <code>DescribeApplicableIndividualAssessments</code> operation using its own
    ///             <code>ReplicationTaskArn</code> request parameter.</p>
    ///          </note>
    public let includeOnly: [String]?
    /// <p>Amazon Resource Name (ARN) of the migration task associated with the premigration
    ///          assessment run that you want to start.</p>
    public let replicationTaskArn: String?
    /// <p>Encryption mode that you can specify to encrypt the results of this assessment run. If
    ///          you don't specify this request parameter, AWS DMS stores the assessment run results
    ///          without encryption. You can specify one of the options following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>"SSE_S3"</code> – The server-side encryption provided as a default by
    ///                Amazon S3.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"SSE_KMS"</code> – AWS Key Management Service (AWS KMS) encryption.
    ///                This encryption can use either a custom KMS encryption key that you specify or the
    ///                default KMS encryption key that DMS provides.</p>
    ///             </li>
    ///          </ul>
    public let resultEncryptionMode: String?
    /// <p>ARN of a custom KMS encryption key that you specify when you set
    ///             <code>ResultEncryptionMode</code> to <code>"SSE_KMS</code>".</p>
    public let resultKmsKeyArn: String?
    /// <p>Amazon S3 bucket where you want AWS DMS to store the results of this assessment
    ///          run.</p>
    public let resultLocationBucket: String?
    /// <p>Folder within an Amazon S3 bucket where you want AWS DMS to store the results of this assessment
    ///          run.</p>
    public let resultLocationFolder: String?
    /// <p>ARN of a service role needed to start the assessment run.</p>
    public let serviceAccessRoleArn: String?

    public init (
        assessmentRunName: String? = nil,
        exclude: [String]? = nil,
        includeOnly: [String]? = nil,
        replicationTaskArn: String? = nil,
        resultEncryptionMode: String? = nil,
        resultKmsKeyArn: String? = nil,
        resultLocationBucket: String? = nil,
        resultLocationFolder: String? = nil,
        serviceAccessRoleArn: String? = nil
    )
    {
        self.assessmentRunName = assessmentRunName
        self.exclude = exclude
        self.includeOnly = includeOnly
        self.replicationTaskArn = replicationTaskArn
        self.resultEncryptionMode = resultEncryptionMode
        self.resultKmsKeyArn = resultKmsKeyArn
        self.resultLocationBucket = resultLocationBucket
        self.resultLocationFolder = resultLocationFolder
        self.serviceAccessRoleArn = serviceAccessRoleArn
    }
}

struct StartReplicationTaskAssessmentRunInputBody: Equatable {
    public let replicationTaskArn: String?
    public let serviceAccessRoleArn: String?
    public let resultLocationBucket: String?
    public let resultLocationFolder: String?
    public let resultEncryptionMode: String?
    public let resultKmsKeyArn: String?
    public let assessmentRunName: String?
    public let includeOnly: [String]?
    public let exclude: [String]?
}

extension StartReplicationTaskAssessmentRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentRunName = "AssessmentRunName"
        case exclude = "Exclude"
        case includeOnly = "IncludeOnly"
        case replicationTaskArn = "ReplicationTaskArn"
        case resultEncryptionMode = "ResultEncryptionMode"
        case resultKmsKeyArn = "ResultKmsKeyArn"
        case resultLocationBucket = "ResultLocationBucket"
        case resultLocationFolder = "ResultLocationFolder"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let resultLocationBucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resultLocationBucket)
        resultLocationBucket = resultLocationBucketDecoded
        let resultLocationFolderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resultLocationFolder)
        resultLocationFolder = resultLocationFolderDecoded
        let resultEncryptionModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resultEncryptionMode)
        resultEncryptionMode = resultEncryptionModeDecoded
        let resultKmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resultKmsKeyArn)
        resultKmsKeyArn = resultKmsKeyArnDecoded
        let assessmentRunNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentRunName)
        assessmentRunName = assessmentRunNameDecoded
        let includeOnlyContainer = try containerValues.decodeIfPresent([String?].self, forKey: .includeOnly)
        var includeOnlyDecoded0:[String]? = nil
        if let includeOnlyContainer = includeOnlyContainer {
            includeOnlyDecoded0 = [String]()
            for string0 in includeOnlyContainer {
                if let string0 = string0 {
                    includeOnlyDecoded0?.append(string0)
                }
            }
        }
        includeOnly = includeOnlyDecoded0
        let excludeContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exclude)
        var excludeDecoded0:[String]? = nil
        if let excludeContainer = excludeContainer {
            excludeDecoded0 = [String]()
            for string0 in excludeContainer {
                if let string0 = string0 {
                    excludeDecoded0?.append(string0)
                }
            }
        }
        exclude = excludeDecoded0
    }
}

extension StartReplicationTaskAssessmentRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReplicationTaskAssessmentRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedFault" : self = .kMSAccessDeniedFault(try KMSAccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledFault" : self = .kMSDisabledFault(try KMSDisabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSFault" : self = .kMSFault(try KMSFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateFault" : self = .kMSInvalidStateFault(try KMSInvalidStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundFault" : self = .kMSNotFoundFault(try KMSNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3AccessDeniedFault" : self = .s3AccessDeniedFault(try S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3ResourceNotFoundFault" : self = .s3ResourceNotFoundFault(try S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartReplicationTaskAssessmentRunOutputError: Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSAccessDeniedFault(KMSAccessDeniedFault)
    case kMSDisabledFault(KMSDisabledFault)
    case kMSFault(KMSFault)
    case kMSInvalidStateFault(KMSInvalidStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case kMSNotFoundFault(KMSNotFoundFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case s3AccessDeniedFault(S3AccessDeniedFault)
    case s3ResourceNotFoundFault(S3ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReplicationTaskAssessmentRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartReplicationTaskAssessmentRunOutputResponse(replicationTaskAssessmentRun: \(String(describing: replicationTaskAssessmentRun)))"}
}

extension StartReplicationTaskAssessmentRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartReplicationTaskAssessmentRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationTaskAssessmentRun = output.replicationTaskAssessmentRun
        } else {
            self.replicationTaskAssessmentRun = nil
        }
    }
}

/// <p></p>
public struct StartReplicationTaskAssessmentRunOutputResponse: Equatable {
    /// <p>The premigration assessment run that was started.</p>
    public let replicationTaskAssessmentRun: ReplicationTaskAssessmentRun?

    public init (
        replicationTaskAssessmentRun: ReplicationTaskAssessmentRun? = nil
    )
    {
        self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
    }
}

struct StartReplicationTaskAssessmentRunOutputResponseBody: Equatable {
    public let replicationTaskAssessmentRun: ReplicationTaskAssessmentRun?
}

extension StartReplicationTaskAssessmentRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunDecoded = try containerValues.decodeIfPresent(ReplicationTaskAssessmentRun.self, forKey: .replicationTaskAssessmentRun)
        replicationTaskAssessmentRun = replicationTaskAssessmentRunDecoded
    }
}

public struct StartReplicationTaskInputBodyMiddleware: Middleware {
    public let id: String = "StartReplicationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartReplicationTaskInput>
    public typealias MOutput = OperationOutput<StartReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartReplicationTaskOutputError>
}

extension StartReplicationTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartReplicationTaskInput(cdcStartPosition: \(String(describing: cdcStartPosition)), cdcStartTime: \(String(describing: cdcStartTime)), cdcStopPosition: \(String(describing: cdcStopPosition)), replicationTaskArn: \(String(describing: replicationTaskArn)), startReplicationTaskType: \(String(describing: startReplicationTaskType)))"}
}

extension StartReplicationTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case replicationTaskArn = "ReplicationTaskArn"
        case startReplicationTaskType = "StartReplicationTaskType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStartTime = cdcStartTime {
            try encodeContainer.encode(cdcStartTime.timeIntervalSince1970, forKey: .cdcStartTime)
        }
        if let cdcStopPosition = cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let startReplicationTaskType = startReplicationTaskType {
            try encodeContainer.encode(startReplicationTaskType.rawValue, forKey: .startReplicationTaskType)
        }
    }
}

public struct StartReplicationTaskInputHeadersMiddleware: Middleware {
    public let id: String = "StartReplicationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartReplicationTaskInput>
    public typealias MOutput = OperationOutput<StartReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartReplicationTaskOutputError>
}

public struct StartReplicationTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "StartReplicationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartReplicationTaskInput>
    public typealias MOutput = OperationOutput<StartReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartReplicationTaskOutputError>
}

/// <p></p>
public struct StartReplicationTaskInput: Equatable {
    /// <p>Indicates when you want a change data capture (CDC) operation to start. Use either
    ///          CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start.
    ///          Specifying both values results in an error.</p>
    ///          <p> The value can be in date, checkpoint, or LSN/SCN format.</p>
    ///          <p>Date Example: --cdc-start-position “2018-03-08T12:12:12”</p>
    ///          <p>Checkpoint Example: --cdc-start-position
    ///          "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93"</p>
    ///          <p>LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373”</p>
    ///          <note>
    ///             <p>When you use this task setting with a source PostgreSQL database, a logical
    ///             replication slot should already be created and associated with the source endpoint. You
    ///             can verify this by setting the <code>slotName</code> extra connection attribute to the
    ///             name of this logical replication slot. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib">Extra Connection Attributes When Using PostgreSQL as a Source
    ///                for AWS DMS</a>.</p>
    ///          </note>
    public let cdcStartPosition: String?
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either
    ///          CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start.
    ///          Specifying both values results in an error.</p>
    ///          <p>Timestamp Example: --cdc-start-time “2018-03-08T12:12:12”</p>
    public let cdcStartTime: Date?
    /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be
    ///          either server time or commit time.</p>
    ///          <p>Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12”</p>
    ///          <p>Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “</p>
    public let cdcStopPosition: String?
    /// <p>The Amazon Resource Name (ARN) of the replication task to be started.</p>
    public let replicationTaskArn: String?
    /// <p>A type of replication task.</p>
    public let startReplicationTaskType: StartReplicationTaskTypeValue?

    public init (
        cdcStartPosition: String? = nil,
        cdcStartTime: Date? = nil,
        cdcStopPosition: String? = nil,
        replicationTaskArn: String? = nil,
        startReplicationTaskType: StartReplicationTaskTypeValue? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.replicationTaskArn = replicationTaskArn
        self.startReplicationTaskType = startReplicationTaskType
    }
}

struct StartReplicationTaskInputBody: Equatable {
    public let replicationTaskArn: String?
    public let startReplicationTaskType: StartReplicationTaskTypeValue?
    public let cdcStartTime: Date?
    public let cdcStartPosition: String?
    public let cdcStopPosition: String?
}

extension StartReplicationTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case replicationTaskArn = "ReplicationTaskArn"
        case startReplicationTaskType = "StartReplicationTaskType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let startReplicationTaskTypeDecoded = try containerValues.decodeIfPresent(StartReplicationTaskTypeValue.self, forKey: .startReplicationTaskType)
        startReplicationTaskType = startReplicationTaskTypeDecoded
        let cdcStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .cdcStartTime)
        cdcStartTime = cdcStartTimeDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
    }
}

extension StartReplicationTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReplicationTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartReplicationTaskOutputError: Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReplicationTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartReplicationTaskOutputResponse(replicationTask: \(String(describing: replicationTask)))"}
}

extension StartReplicationTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

/// <p></p>
public struct StartReplicationTaskOutputResponse: Equatable {
    /// <p>The replication task started.</p>
    public let replicationTask: ReplicationTask?

    public init (
        replicationTask: ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct StartReplicationTaskOutputResponseBody: Equatable {
    public let replicationTask: ReplicationTask?
}

extension StartReplicationTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

public enum StartReplicationTaskTypeValue {
    case reloadTarget
    case resumeProcessing
    case startReplication
    case sdkUnknown(String)
}

extension StartReplicationTaskTypeValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StartReplicationTaskTypeValue] {
        return [
            .reloadTarget,
            .resumeProcessing,
            .startReplication,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .reloadTarget: return "reload-target"
        case .resumeProcessing: return "resume-processing"
        case .startReplication: return "start-replication"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StartReplicationTaskTypeValue(rawValue: rawValue) ?? StartReplicationTaskTypeValue.sdkUnknown(rawValue)
    }
}

public struct StopReplicationTaskInputBodyMiddleware: Middleware {
    public let id: String = "StopReplicationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StopReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopReplicationTaskInput>
    public typealias MOutput = OperationOutput<StopReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopReplicationTaskOutputError>
}

extension StopReplicationTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopReplicationTaskInput(replicationTaskArn: \(String(describing: replicationTaskArn)))"}
}

extension StopReplicationTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

public struct StopReplicationTaskInputHeadersMiddleware: Middleware {
    public let id: String = "StopReplicationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StopReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopReplicationTaskInput>
    public typealias MOutput = OperationOutput<StopReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopReplicationTaskOutputError>
}

public struct StopReplicationTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "StopReplicationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopReplicationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StopReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopReplicationTaskInput>
    public typealias MOutput = OperationOutput<StopReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopReplicationTaskOutputError>
}

/// <p></p>
public struct StopReplicationTaskInput: Equatable {
    /// <p>The Amazon Resource Name(ARN) of the replication task to be stopped.</p>
    public let replicationTaskArn: String?

    public init (
        replicationTaskArn: String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct StopReplicationTaskInputBody: Equatable {
    public let replicationTaskArn: String?
}

extension StopReplicationTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

extension StopReplicationTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopReplicationTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopReplicationTaskOutputError: Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopReplicationTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopReplicationTaskOutputResponse(replicationTask: \(String(describing: replicationTask)))"}
}

extension StopReplicationTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

/// <p></p>
public struct StopReplicationTaskOutputResponse: Equatable {
    /// <p>The replication task stopped.</p>
    public let replicationTask: ReplicationTask?

    public init (
        replicationTask: ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct StopReplicationTaskOutputResponseBody: Equatable {
    public let replicationTask: ReplicationTask?
}

extension StopReplicationTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension StorageQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageQuotaExceededFault(message: \(String(describing: message)))"}
}

extension StorageQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StorageQuotaExceededFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The storage quota has been exceeded.</p>
public struct StorageQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StorageQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension StorageQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Subnet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
        case subnetStatus = "SubnetStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetAvailabilityZone = subnetAvailabilityZone {
            try encodeContainer.encode(subnetAvailabilityZone, forKey: .subnetAvailabilityZone)
        }
        if let subnetIdentifier = subnetIdentifier {
            try encodeContainer.encode(subnetIdentifier, forKey: .subnetIdentifier)
        }
        if let subnetStatus = subnetStatus {
            try encodeContainer.encode(subnetStatus, forKey: .subnetStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(AvailabilityZone.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetStatus)
        subnetStatus = subnetStatusDecoded
    }
}

extension Subnet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Subnet(subnetAvailabilityZone: \(String(describing: subnetAvailabilityZone)), subnetIdentifier: \(String(describing: subnetIdentifier)), subnetStatus: \(String(describing: subnetStatus)))"}
}

/// <p>In response to a request by the <code>DescribeReplicationSubnetGroups</code> operation,
///          this object identifies a subnet by its given Availability Zone, subnet identifier, and
///          status.</p>
public struct Subnet: Equatable {
    /// <p>The Availability Zone of the subnet.</p>
    public let subnetAvailabilityZone: AvailabilityZone?
    /// <p>The subnet identifier.</p>
    public let subnetIdentifier: String?
    /// <p>The status of the subnet.</p>
    public let subnetStatus: String?

    public init (
        subnetAvailabilityZone: AvailabilityZone? = nil,
        subnetIdentifier: String? = nil,
        subnetStatus: String? = nil
    )
    {
        self.subnetAvailabilityZone = subnetAvailabilityZone
        self.subnetIdentifier = subnetIdentifier
        self.subnetStatus = subnetStatus
    }
}

extension SubnetAlreadyInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetAlreadyInUse(message: \(String(describing: message)))"}
}

extension SubnetAlreadyInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SubnetAlreadyInUseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified subnet is already in use.</p>
public struct SubnetAlreadyInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetAlreadyInUseBody: Equatable {
    public let message: String?
}

extension SubnetAlreadyInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SupportedEndpointType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointType = "EndpointType"
        case engineDisplayName = "EngineDisplayName"
        case engineName = "EngineName"
        case replicationInstanceEngineMinimumVersion = "ReplicationInstanceEngineMinimumVersion"
        case supportsCDC = "SupportsCDC"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineDisplayName = engineDisplayName {
            try encodeContainer.encode(engineDisplayName, forKey: .engineDisplayName)
        }
        if let engineName = engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let replicationInstanceEngineMinimumVersion = replicationInstanceEngineMinimumVersion {
            try encodeContainer.encode(replicationInstanceEngineMinimumVersion, forKey: .replicationInstanceEngineMinimumVersion)
        }
        if supportsCDC != false {
            try encodeContainer.encode(supportsCDC, forKey: .supportsCDC)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let supportsCDCDecoded = try containerValues.decode(Bool.self, forKey: .supportsCDC)
        supportsCDC = supportsCDCDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let replicationInstanceEngineMinimumVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceEngineMinimumVersion)
        replicationInstanceEngineMinimumVersion = replicationInstanceEngineMinimumVersionDecoded
        let engineDisplayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineDisplayName)
        engineDisplayName = engineDisplayNameDecoded
    }
}

extension SupportedEndpointType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SupportedEndpointType(endpointType: \(String(describing: endpointType)), engineDisplayName: \(String(describing: engineDisplayName)), engineName: \(String(describing: engineName)), replicationInstanceEngineMinimumVersion: \(String(describing: replicationInstanceEngineMinimumVersion)), supportsCDC: \(String(describing: supportsCDC)))"}
}

/// <p>Provides information about types of supported endpoints in response to a request by the
///             <code>DescribeEndpointTypes</code> operation. This information includes the type of
///          endpoint, the database engine name, and whether change data capture (CDC) is
///          supported.</p>
public struct SupportedEndpointType: Equatable {
    /// <p>The type of endpoint.  Valid values are <code>source</code> and <code>target</code>.</p>
    public let endpointType: ReplicationEndpointTypeValue?
    /// <p>The expanded name for the engine name. For example, if the <code>EngineName</code>
    ///          parameter is "aurora," this value would be "Amazon Aurora MySQL."</p>
    public let engineDisplayName: String?
    /// <p>The database engine name. Valid values, depending on the EndpointType,  include
    ///          <code>"mysql"</code>, <code>"oracle"</code>, <code>"postgres"</code>,
    ///          <code>"mariadb"</code>, <code>"aurora"</code>, <code>"aurora-postgresql"</code>,
    ///          <code>"redshift"</code>, <code>"s3"</code>, <code>"db2"</code>, <code>"azuredb"</code>,
    ///          <code>"sybase"</code>, <code>"dynamodb"</code>, <code>"mongodb"</code>,
    ///          <code>"kinesis"</code>, <code>"kafka"</code>, <code>"elasticsearch"</code>,
    ///          <code>"documentdb"</code>, <code>"sqlserver"</code>, and <code>"neptune"</code>.</p>
    public let engineName: String?
    /// <p>The earliest AWS DMS engine version that supports this endpoint engine. Note that endpoint engines released with AWS DMS versions earlier than 3.1.1 do not return a value for this parameter.</p>
    public let replicationInstanceEngineMinimumVersion: String?
    /// <p>Indicates if Change Data Capture (CDC) is supported.</p>
    public let supportsCDC: Bool

    public init (
        endpointType: ReplicationEndpointTypeValue? = nil,
        engineDisplayName: String? = nil,
        engineName: String? = nil,
        replicationInstanceEngineMinimumVersion: String? = nil,
        supportsCDC: Bool = false
    )
    {
        self.endpointType = endpointType
        self.engineDisplayName = engineDisplayName
        self.engineName = engineName
        self.replicationInstanceEngineMinimumVersion = replicationInstanceEngineMinimumVersion
        self.supportsCDC = supportsCDC
    }
}

extension SybaseSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension SybaseSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SybaseSettings(databaseName: \(String(describing: databaseName)), password: \(String(describing: password)), port: \(String(describing: port)), secretsManagerAccessRoleArn: \(String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(String(describing: secretsManagerSecretId)), serverName: \(String(describing: serverName)), username: \(String(describing: username)))"}
}

/// <p>Provides information that defines a SAP ASE endpoint.</p>
public struct SybaseSettings: Equatable {
    /// <p>Database name for the endpoint.</p>
    public let databaseName: String?
    /// <p>Endpoint connection password.</p>
    public let password: String?
    /// <p>Endpoint TCP port.</p>
    public let port: Int?
    /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
    ///          trusted entity and grants the required permissions to access the value in
    ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
    ///          Manager secret that allows access to the SAP ASE endpoint.</p>
    ///          <note>
    ///             <p>You can specify one of two sets of values for these permissions. You can specify the
    ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
    ///             clear-text values for <code>UserName</code>, <code>Password</code>,
    ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
    ///             information on creating this <code>SecretsManagerSecret</code> and the
    ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
    ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
    ///                resources</a> in the <i>AWS Database Migration Service User
    ///                Guide</i>.</p>
    ///          </note>
    public let secretsManagerAccessRoleArn: String?
    /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the SAP SAE endpoint connection details.</p>
    public let secretsManagerSecretId: String?
    /// <p>Fully qualified domain name of the endpoint.</p>
    public let serverName: String?
    /// <p>Endpoint connection user name.</p>
    public let username: String?

    public init (
        databaseName: String? = nil,
        password: String? = nil,
        port: Int? = nil,
        secretsManagerAccessRoleArn: String? = nil,
        secretsManagerSecretId: String? = nil,
        serverName: String? = nil,
        username: String? = nil
    )
    {
        self.databaseName = databaseName
        self.password = password
        self.port = port
        self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
        self.secretsManagerSecretId = secretsManagerSecretId
        self.serverName = serverName
        self.username = username
    }
}

extension TableStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ddls = "Ddls"
        case deletes = "Deletes"
        case fullLoadCondtnlChkFailedRows = "FullLoadCondtnlChkFailedRows"
        case fullLoadEndTime = "FullLoadEndTime"
        case fullLoadErrorRows = "FullLoadErrorRows"
        case fullLoadReloaded = "FullLoadReloaded"
        case fullLoadRows = "FullLoadRows"
        case fullLoadStartTime = "FullLoadStartTime"
        case inserts = "Inserts"
        case lastUpdateTime = "LastUpdateTime"
        case schemaName = "SchemaName"
        case tableName = "TableName"
        case tableState = "TableState"
        case updates = "Updates"
        case validationFailedRecords = "ValidationFailedRecords"
        case validationPendingRecords = "ValidationPendingRecords"
        case validationState = "ValidationState"
        case validationStateDetails = "ValidationStateDetails"
        case validationSuspendedRecords = "ValidationSuspendedRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if ddls != 0 {
            try encodeContainer.encode(ddls, forKey: .ddls)
        }
        if deletes != 0 {
            try encodeContainer.encode(deletes, forKey: .deletes)
        }
        if fullLoadCondtnlChkFailedRows != 0 {
            try encodeContainer.encode(fullLoadCondtnlChkFailedRows, forKey: .fullLoadCondtnlChkFailedRows)
        }
        if let fullLoadEndTime = fullLoadEndTime {
            try encodeContainer.encode(fullLoadEndTime.timeIntervalSince1970, forKey: .fullLoadEndTime)
        }
        if fullLoadErrorRows != 0 {
            try encodeContainer.encode(fullLoadErrorRows, forKey: .fullLoadErrorRows)
        }
        if let fullLoadReloaded = fullLoadReloaded {
            try encodeContainer.encode(fullLoadReloaded, forKey: .fullLoadReloaded)
        }
        if fullLoadRows != 0 {
            try encodeContainer.encode(fullLoadRows, forKey: .fullLoadRows)
        }
        if let fullLoadStartTime = fullLoadStartTime {
            try encodeContainer.encode(fullLoadStartTime.timeIntervalSince1970, forKey: .fullLoadStartTime)
        }
        if inserts != 0 {
            try encodeContainer.encode(inserts, forKey: .inserts)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tableState = tableState {
            try encodeContainer.encode(tableState, forKey: .tableState)
        }
        if updates != 0 {
            try encodeContainer.encode(updates, forKey: .updates)
        }
        if validationFailedRecords != 0 {
            try encodeContainer.encode(validationFailedRecords, forKey: .validationFailedRecords)
        }
        if validationPendingRecords != 0 {
            try encodeContainer.encode(validationPendingRecords, forKey: .validationPendingRecords)
        }
        if let validationState = validationState {
            try encodeContainer.encode(validationState, forKey: .validationState)
        }
        if let validationStateDetails = validationStateDetails {
            try encodeContainer.encode(validationStateDetails, forKey: .validationStateDetails)
        }
        if validationSuspendedRecords != 0 {
            try encodeContainer.encode(validationSuspendedRecords, forKey: .validationSuspendedRecords)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let insertsDecoded = try containerValues.decode(Int.self, forKey: .inserts)
        inserts = insertsDecoded
        let deletesDecoded = try containerValues.decode(Int.self, forKey: .deletes)
        deletes = deletesDecoded
        let updatesDecoded = try containerValues.decode(Int.self, forKey: .updates)
        updates = updatesDecoded
        let ddlsDecoded = try containerValues.decode(Int.self, forKey: .ddls)
        ddls = ddlsDecoded
        let fullLoadRowsDecoded = try containerValues.decode(Int.self, forKey: .fullLoadRows)
        fullLoadRows = fullLoadRowsDecoded
        let fullLoadCondtnlChkFailedRowsDecoded = try containerValues.decode(Int.self, forKey: .fullLoadCondtnlChkFailedRows)
        fullLoadCondtnlChkFailedRows = fullLoadCondtnlChkFailedRowsDecoded
        let fullLoadErrorRowsDecoded = try containerValues.decode(Int.self, forKey: .fullLoadErrorRows)
        fullLoadErrorRows = fullLoadErrorRowsDecoded
        let fullLoadStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .fullLoadStartTime)
        fullLoadStartTime = fullLoadStartTimeDecoded
        let fullLoadEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .fullLoadEndTime)
        fullLoadEndTime = fullLoadEndTimeDecoded
        let fullLoadReloadedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .fullLoadReloaded)
        fullLoadReloaded = fullLoadReloadedDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tableStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableState)
        tableState = tableStateDecoded
        let validationPendingRecordsDecoded = try containerValues.decode(Int.self, forKey: .validationPendingRecords)
        validationPendingRecords = validationPendingRecordsDecoded
        let validationFailedRecordsDecoded = try containerValues.decode(Int.self, forKey: .validationFailedRecords)
        validationFailedRecords = validationFailedRecordsDecoded
        let validationSuspendedRecordsDecoded = try containerValues.decode(Int.self, forKey: .validationSuspendedRecords)
        validationSuspendedRecords = validationSuspendedRecordsDecoded
        let validationStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validationState)
        validationState = validationStateDecoded
        let validationStateDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validationStateDetails)
        validationStateDetails = validationStateDetailsDecoded
    }
}

extension TableStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableStatistics(ddls: \(String(describing: ddls)), deletes: \(String(describing: deletes)), fullLoadCondtnlChkFailedRows: \(String(describing: fullLoadCondtnlChkFailedRows)), fullLoadEndTime: \(String(describing: fullLoadEndTime)), fullLoadErrorRows: \(String(describing: fullLoadErrorRows)), fullLoadReloaded: \(String(describing: fullLoadReloaded)), fullLoadRows: \(String(describing: fullLoadRows)), fullLoadStartTime: \(String(describing: fullLoadStartTime)), inserts: \(String(describing: inserts)), lastUpdateTime: \(String(describing: lastUpdateTime)), schemaName: \(String(describing: schemaName)), tableName: \(String(describing: tableName)), tableState: \(String(describing: tableState)), updates: \(String(describing: updates)), validationFailedRecords: \(String(describing: validationFailedRecords)), validationPendingRecords: \(String(describing: validationPendingRecords)), validationState: \(String(describing: validationState)), validationStateDetails: \(String(describing: validationStateDetails)), validationSuspendedRecords: \(String(describing: validationSuspendedRecords)))"}
}

/// <p>Provides a collection of table statistics in response to a request by the
///          <code>DescribeTableStatistics</code> operation.</p>
public struct TableStatistics: Equatable {
    /// <p>The data definition language (DDL) used to build and modify the structure of your tables.</p>
    public let ddls: Int
    /// <p>The number of delete actions performed on a table.</p>
    public let deletes: Int
    /// <p>The number of rows that failed conditional checks during the full load operation (valid
    ///          only for migrations where DynamoDB is the target).</p>
    public let fullLoadCondtnlChkFailedRows: Int
    /// <p>The time when the full load operation completed.</p>
    public let fullLoadEndTime: Date?
    /// <p>The number of rows that failed to load during the full load operation (valid only for
    ///          migrations where DynamoDB is the target).</p>
    public let fullLoadErrorRows: Int
    /// <p>A value that indicates if the table was reloaded (<code>true</code>)
    ///          or loaded as part of a new full load operation (<code>false</code>).</p>
    public let fullLoadReloaded: Bool?
    /// <p>The number of rows added during the full load operation.</p>
    public let fullLoadRows: Int
    /// <p>The time when the full load operation started.</p>
    public let fullLoadStartTime: Date?
    /// <p>The number of insert actions performed on a table.</p>
    public let inserts: Int
    /// <p>The last time a table was updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The schema name.</p>
    public let schemaName: String?
    /// <p>The name of the table.</p>
    public let tableName: String?
    /// <p>The state of the tables described.</p>
    ///          <p>Valid states: Table does not exist | Before load | Full load | Table completed | Table
    ///          cancelled | Table error | Table all | Table updates | Table is being reloaded</p>
    public let tableState: String?
    /// <p>The number of update actions performed on a table.</p>
    public let updates: Int
    /// <p>The number of records that failed validation.</p>
    public let validationFailedRecords: Int
    /// <p>The number of records that have yet to be validated.</p>
    public let validationPendingRecords: Int
    /// <p>The validation state of the table.</p>
    ///          <p>This parameter can have the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Not enabled – Validation isn't enabled for the table in the migration
    ///                task.</p>
    ///             </li>
    ///             <li>
    ///                <p>Pending records – Some records in the table are waiting for validation.</p>
    ///             </li>
    ///             <li>
    ///                <p>Mismatched records – Some records in the table don't match between the source
    ///                and target.</p>
    ///             </li>
    ///             <li>
    ///                <p>Suspended records – Some records in the table couldn't be validated.</p>
    ///             </li>
    ///             <li>
    ///                <p>No primary key  –The table couldn't be validated because it has no primary
    ///                key.</p>
    ///             </li>
    ///             <li>
    ///                <p>Table error – The table wasn't validated because it's in an error state
    ///                and some data wasn't migrated.</p>
    ///             </li>
    ///             <li>
    ///                <p>Validated – All rows in the table are validated. If the table is updated, the
    ///                status can change from Validated.</p>
    ///             </li>
    ///             <li>
    ///                <p>Error – The table couldn't be validated because of an unexpected
    ///                error.</p>
    ///             </li>
    ///             <li>
    ///                <p>Pending validation – The table is waiting validation.</p>
    ///             </li>
    ///             <li>
    ///                <p>Preparing table – Preparing the table enabled in the migration task for validation.</p>
    ///             </li>
    ///             <li>
    ///                <p>Pending revalidation – All rows in the table are pending validation after the table was updated.</p>
    ///             </li>
    ///          </ul>
    public let validationState: String?
    /// <p>Additional details about the state of validation.</p>
    public let validationStateDetails: String?
    /// <p>The number of records that couldn't be validated.</p>
    public let validationSuspendedRecords: Int

    public init (
        ddls: Int = 0,
        deletes: Int = 0,
        fullLoadCondtnlChkFailedRows: Int = 0,
        fullLoadEndTime: Date? = nil,
        fullLoadErrorRows: Int = 0,
        fullLoadReloaded: Bool? = nil,
        fullLoadRows: Int = 0,
        fullLoadStartTime: Date? = nil,
        inserts: Int = 0,
        lastUpdateTime: Date? = nil,
        schemaName: String? = nil,
        tableName: String? = nil,
        tableState: String? = nil,
        updates: Int = 0,
        validationFailedRecords: Int = 0,
        validationPendingRecords: Int = 0,
        validationState: String? = nil,
        validationStateDetails: String? = nil,
        validationSuspendedRecords: Int = 0
    )
    {
        self.ddls = ddls
        self.deletes = deletes
        self.fullLoadCondtnlChkFailedRows = fullLoadCondtnlChkFailedRows
        self.fullLoadEndTime = fullLoadEndTime
        self.fullLoadErrorRows = fullLoadErrorRows
        self.fullLoadReloaded = fullLoadReloaded
        self.fullLoadRows = fullLoadRows
        self.fullLoadStartTime = fullLoadStartTime
        self.inserts = inserts
        self.lastUpdateTime = lastUpdateTime
        self.schemaName = schemaName
        self.tableName = tableName
        self.tableState = tableState
        self.updates = updates
        self.validationFailedRecords = validationFailedRecords
        self.validationPendingRecords = validationPendingRecords
        self.validationState = validationState
        self.validationStateDetails = validationStateDetails
        self.validationSuspendedRecords = validationSuspendedRecords
    }
}

extension TableToReload: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case schemaName = "SchemaName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension TableToReload: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableToReload(schemaName: \(String(describing: schemaName)), tableName: \(String(describing: tableName)))"}
}

/// <p>Provides the name of the schema and table to be reloaded.</p>
public struct TableToReload: Equatable {
    /// <p>The schema name of the table to be reloaded.</p>
    public let schemaName: String?
    /// <p>The table name of the table to be reloaded.</p>
    public let tableName: String?

    public init (
        schemaName: String? = nil,
        tableName: String? = nil
    )
    {
        self.schemaName = schemaName
        self.tableName = tableName
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A user-defined key-value pair that describes metadata added to an AWS DMS resource and
///          that is used by operations such as the following:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>AddTagsToResource</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>ListTagsForResource</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>RemoveTagsFromResource</code>
///                </p>
///             </li>
///          </ul>
public struct Tag: Equatable {
    /// <p>A key is the required name of the tag. The string value can be 1-128 Unicode characters
    ///          in length and can't be prefixed with "aws:" or "dms:". The string can only contain
    ///          only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java
    ///          regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").</p>
    public let key: String?
    /// <p>A value is the optional value of the tag. The string value can be 1-256 Unicode
    ///          characters in length and can't be prefixed with "aws:" or "dms:". The string can only
    ///          contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-'
    ///          (Java regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public enum TargetDbType {
    case multipleDatabases
    case specificDatabase
    case sdkUnknown(String)
}

extension TargetDbType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetDbType] {
        return [
            .multipleDatabases,
            .specificDatabase,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .multipleDatabases: return "multiple-databases"
        case .specificDatabase: return "specific-database"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetDbType(rawValue: rawValue) ?? TargetDbType.sdkUnknown(rawValue)
    }
}

public struct TestConnectionInputBodyMiddleware: Middleware {
    public let id: String = "TestConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<TestConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestConnectionInput>
    public typealias MOutput = OperationOutput<TestConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestConnectionOutputError>
}

extension TestConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestConnectionInput(endpointArn: \(String(describing: endpointArn)), replicationInstanceArn: \(String(describing: replicationInstanceArn)))"}
}

extension TestConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct TestConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "TestConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<TestConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestConnectionInput>
    public typealias MOutput = OperationOutput<TestConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestConnectionOutputError>
}

public struct TestConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "TestConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<TestConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestConnectionInput>
    public typealias MOutput = OperationOutput<TestConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestConnectionOutputError>
}

/// <p></p>
public struct TestConnectionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: String?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: String?

    public init (
        endpointArn: String? = nil,
        replicationInstanceArn: String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct TestConnectionInputBody: Equatable {
    public let replicationInstanceArn: String?
    public let endpointArn: String?
}

extension TestConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension TestConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestConnectionOutputError: Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestConnectionOutputResponse(connection: \(String(describing: connection)))"}
}

extension TestConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TestConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

/// <p></p>
public struct TestConnectionOutputResponse: Equatable {
    /// <p>The connection tested.</p>
    public let connection: Connection?

    public init (
        connection: Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct TestConnectionOutputResponseBody: Equatable {
    public let connection: Connection?
}

extension TestConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension UpgradeDependencyFailureFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpgradeDependencyFailureFault(message: \(String(describing: message)))"}
}

extension UpgradeDependencyFailureFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpgradeDependencyFailureFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An upgrade dependency is preventing the database migration.</p>
public struct UpgradeDependencyFailureFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UpgradeDependencyFailureFaultBody: Equatable {
    public let message: String?
}

extension UpgradeDependencyFailureFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VpcSecurityGroupMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
        case vpcSecurityGroupId = "VpcSecurityGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let vpcSecurityGroupId = vpcSecurityGroupId {
            try encodeContainer.encode(vpcSecurityGroupId, forKey: .vpcSecurityGroupId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension VpcSecurityGroupMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcSecurityGroupMembership(status: \(String(describing: status)), vpcSecurityGroupId: \(String(describing: vpcSecurityGroupId)))"}
}

/// <p>Describes the status of a security group associated with the virtual private cloud (VPC)
///          hosting your replication and DB instances.</p>
public struct VpcSecurityGroupMembership: Equatable {
    /// <p>The status of the VPC security group.</p>
    public let status: String?
    /// <p>The VPC security group ID.</p>
    public let vpcSecurityGroupId: String?

    public init (
        status: String? = nil,
        vpcSecurityGroupId: String? = nil
    )
    {
        self.status = status
        self.vpcSecurityGroupId = vpcSecurityGroupId
    }
}
