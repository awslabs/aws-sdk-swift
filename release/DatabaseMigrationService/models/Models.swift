// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedFault(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS DMS was denied access to the endpoint. Check that the
///             role is correctly configured.</p>
public struct AccessDeniedFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p></p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.AccountQuota: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountQuotaName = "AccountQuotaName"
        case max = "Max"
        case used = "Used"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountQuotaName = accountQuotaName {
            try encodeContainer.encode(accountQuotaName, forKey: .accountQuotaName)
        }
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if used != 0 {
            try encodeContainer.encode(used, forKey: .used)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountQuotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountQuotaName)
        accountQuotaName = accountQuotaNameDecoded
        let usedDecoded = try containerValues.decode(Swift.Int.self, forKey: .used)
        used = usedDecoded
        let maxDecoded = try containerValues.decode(Swift.Int.self, forKey: .max)
        max = maxDecoded
    }
}

extension DatabaseMigrationClientTypes.AccountQuota: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountQuota(accountQuotaName: \(Swift.String(describing: accountQuotaName)), max: \(Swift.String(describing: max)), used: \(Swift.String(describing: used)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Describes a quota for an AWS account, for example, the number of replication instances
    ///          allowed.</p>
    public struct AccountQuota: Swift.Equatable {
        /// <p>The name of the AWS DMS quota for this AWS account.</p>
        public let accountQuotaName: Swift.String?
        /// <p>The maximum allowed value for the quota.</p>
        public let max: Swift.Int
        /// <p>The amount currently used toward the quota maximum.</p>
        public let used: Swift.Int

        public init (
            accountQuotaName: Swift.String? = nil,
            max: Swift.Int = 0,
            used: Swift.Int = 0
        )
        {
            self.accountQuotaName = accountQuotaName
            self.max = max
            self.used = used
        }
    }

}

public struct AddTagsToResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

extension AddTagsToResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension AddTagsToResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct AddTagsToResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

/// <p>Associates a set of tags with an AWS DMS resource.</p>
public struct AddTagsToResourceInput: Swift.Equatable {
    /// <p>Identifies the AWS DMS resource to which tags should be added. The value for this parameter is an Amazon Resource Name (ARN).</p>
    ///          <p>For AWS DMS, you can tag a replication instance, an endpoint, or a replication task.</p>
    public let resourceArn: Swift.String?
    /// <p>One or more tags to be assigned to the resource.</p>
    public let tags: [DatabaseMigrationClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct AddTagsToResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [DatabaseMigrationClientTypes.Tag]?
}

extension AddTagsToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToResourceOutputResponse()"}
}

extension AddTagsToResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p></p>
public struct AddTagsToResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct AddTagsToResourceOutputResponseBody: Swift.Equatable {
}

extension AddTagsToResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct ApplyPendingMaintenanceActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplyPendingMaintenanceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplyPendingMaintenanceActionOutputError>
}

extension ApplyPendingMaintenanceActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplyPendingMaintenanceActionInput(applyAction: \(Swift.String(describing: applyAction)), optInType: \(Swift.String(describing: optInType)), replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)))"}
}

extension ApplyPendingMaintenanceActionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyAction = "ApplyAction"
        case optInType = "OptInType"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyAction = applyAction {
            try encodeContainer.encode(applyAction, forKey: .applyAction)
        }
        if let optInType = optInType {
            try encodeContainer.encode(optInType, forKey: .optInType)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct ApplyPendingMaintenanceActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplyPendingMaintenanceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplyPendingMaintenanceActionOutputError>
}

public struct ApplyPendingMaintenanceActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplyPendingMaintenanceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplyPendingMaintenanceActionOutputError>
}

/// <p></p>
public struct ApplyPendingMaintenanceActionInput: Swift.Equatable {
    /// <p>The pending maintenance action to apply to this resource.</p>
    public let applyAction: Swift.String?
    /// <p>A value that specifies the type of opt-in request, or undoes an opt-in request. You can't undo an
    ///          opt-in request of type <code>immediate</code>.</p>
    ///          <p>Valid values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>immediate</code> - Apply the maintenance action immediately.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>next-maintenance</code> - Apply the maintenance action during the next
    ///                maintenance window for the resource.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>undo-opt-in</code> - Cancel any existing <code>next-maintenance</code> opt-in
    ///                requests.</p>
    ///             </li>
    ///          </ul>
    public let optInType: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the AWS DMS resource that the pending maintenance
    ///          action applies to.</p>
    public let replicationInstanceArn: Swift.String?

    public init (
        applyAction: Swift.String? = nil,
        optInType: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.applyAction = applyAction
        self.optInType = optInType
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct ApplyPendingMaintenanceActionInputBody: Swift.Equatable {
    public let replicationInstanceArn: Swift.String?
    public let applyAction: Swift.String?
    public let optInType: Swift.String?
}

extension ApplyPendingMaintenanceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyAction = "ApplyAction"
        case optInType = "OptInType"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let applyActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applyAction)
        applyAction = applyActionDecoded
        let optInTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optInType)
        optInType = optInTypeDecoded
    }
}

extension ApplyPendingMaintenanceActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ApplyPendingMaintenanceActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApplyPendingMaintenanceActionOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplyPendingMaintenanceActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplyPendingMaintenanceActionOutputResponse(resourcePendingMaintenanceActions: \(Swift.String(describing: resourcePendingMaintenanceActions)))"}
}

extension ApplyPendingMaintenanceActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ApplyPendingMaintenanceActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourcePendingMaintenanceActions = output.resourcePendingMaintenanceActions
        } else {
            self.resourcePendingMaintenanceActions = nil
        }
    }
}

/// <p></p>
public struct ApplyPendingMaintenanceActionOutputResponse: Swift.Equatable {
    /// <p>The AWS DMS resource that the pending maintenance action will be applied to.</p>
    public let resourcePendingMaintenanceActions: DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions?

    public init (
        resourcePendingMaintenanceActions: DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions? = nil
    )
    {
        self.resourcePendingMaintenanceActions = resourcePendingMaintenanceActions
    }
}

struct ApplyPendingMaintenanceActionOutputResponseBody: Swift.Equatable {
    public let resourcePendingMaintenanceActions: DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions?
}

extension ApplyPendingMaintenanceActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePendingMaintenanceActions = "ResourcePendingMaintenanceActions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcePendingMaintenanceActionsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions.self, forKey: .resourcePendingMaintenanceActions)
        resourcePendingMaintenanceActions = resourcePendingMaintenanceActionsDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum AuthMechanismValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case mongodbCr
        case scramSha1
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthMechanismValue] {
            return [
                .default,
                .mongodbCr,
                .scramSha1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "default"
            case .mongodbCr: return "mongodb_cr"
            case .scramSha1: return "scram_sha_1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthMechanismValue(rawValue: rawValue) ?? AuthMechanismValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum AuthTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case no
        case password
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthTypeValue] {
            return [
                .no,
                .password,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .no: return "no"
            case .password: return "password"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthTypeValue(rawValue: rawValue) ?? AuthTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.AvailabilityZone: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DatabaseMigrationClientTypes.AvailabilityZone: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AvailabilityZone(name: \(Swift.String(describing: name)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>The name of an Availability Zone for use during database migration.
    ///             <code>AvailabilityZone</code> is an optional parameter to the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationInstance.html">
    ///                <code>CreateReplicationInstance</code>
    ///             </a> operation, and itâ€™s value relates to
    ///          the AWS Region of an endpoint. For example, the availability zone of an endpoint in the
    ///          us-east-1 region might be us-east-1a, us-east-1b, us-east-1c, or us-east-1d.</p>
    public struct AvailabilityZone: Swift.Equatable {
        /// <p>The name of the Availability Zone.</p>
        public let name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

public struct CancelReplicationTaskAssessmentRunInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelReplicationTaskAssessmentRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelReplicationTaskAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelReplicationTaskAssessmentRunOutputError>
}

extension CancelReplicationTaskAssessmentRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelReplicationTaskAssessmentRunInput(replicationTaskAssessmentRunArn: \(Swift.String(describing: replicationTaskAssessmentRunArn)))"}
}

extension CancelReplicationTaskAssessmentRunInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
    }
}

public struct CancelReplicationTaskAssessmentRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelReplicationTaskAssessmentRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelReplicationTaskAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelReplicationTaskAssessmentRunOutputError>
}

public struct CancelReplicationTaskAssessmentRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelReplicationTaskAssessmentRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelReplicationTaskAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelReplicationTaskAssessmentRunOutputError>
}

/// <p></p>
public struct CancelReplicationTaskAssessmentRunInput: Swift.Equatable {
    /// <p>Amazon Resource Name (ARN) of the premigration assessment run to be canceled.</p>
    public let replicationTaskAssessmentRunArn: Swift.String?

    public init (
        replicationTaskAssessmentRunArn: Swift.String? = nil
    )
    {
        self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
    }
}

struct CancelReplicationTaskAssessmentRunInputBody: Swift.Equatable {
    public let replicationTaskAssessmentRunArn: Swift.String?
}

extension CancelReplicationTaskAssessmentRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
    }
}

extension CancelReplicationTaskAssessmentRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelReplicationTaskAssessmentRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelReplicationTaskAssessmentRunOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelReplicationTaskAssessmentRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelReplicationTaskAssessmentRunOutputResponse(replicationTaskAssessmentRun: \(Swift.String(describing: replicationTaskAssessmentRun)))"}
}

extension CancelReplicationTaskAssessmentRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelReplicationTaskAssessmentRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTaskAssessmentRun = output.replicationTaskAssessmentRun
        } else {
            self.replicationTaskAssessmentRun = nil
        }
    }
}

/// <p></p>
public struct CancelReplicationTaskAssessmentRunOutputResponse: Swift.Equatable {
    /// <p>The <code>ReplicationTaskAssessmentRun</code> object for the canceled assessment
    ///          run.</p>
    public let replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?

    public init (
        replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun? = nil
    )
    {
        self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
    }
}

struct CancelReplicationTaskAssessmentRunOutputResponseBody: Swift.Equatable {
    public let replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?
}

extension CancelReplicationTaskAssessmentRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun.self, forKey: .replicationTaskAssessmentRun)
        replicationTaskAssessmentRun = replicationTaskAssessmentRunDecoded
    }
}

extension DatabaseMigrationClientTypes.Certificate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case certificateCreationDate = "CertificateCreationDate"
        case certificateIdentifier = "CertificateIdentifier"
        case certificateOwner = "CertificateOwner"
        case certificatePem = "CertificatePem"
        case certificateWallet = "CertificateWallet"
        case keyLength = "KeyLength"
        case signingAlgorithm = "SigningAlgorithm"
        case validFromDate = "ValidFromDate"
        case validToDate = "ValidToDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateCreationDate = certificateCreationDate {
            try encodeContainer.encode(certificateCreationDate.timeIntervalSince1970, forKey: .certificateCreationDate)
        }
        if let certificateIdentifier = certificateIdentifier {
            try encodeContainer.encode(certificateIdentifier, forKey: .certificateIdentifier)
        }
        if let certificateOwner = certificateOwner {
            try encodeContainer.encode(certificateOwner, forKey: .certificateOwner)
        }
        if let certificatePem = certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let certificateWallet = certificateWallet {
            try encodeContainer.encode(certificateWallet.base64EncodedString(), forKey: .certificateWallet)
        }
        if let keyLength = keyLength {
            try encodeContainer.encode(keyLength, forKey: .keyLength)
        }
        if let signingAlgorithm = signingAlgorithm {
            try encodeContainer.encode(signingAlgorithm, forKey: .signingAlgorithm)
        }
        if let validFromDate = validFromDate {
            try encodeContainer.encode(validFromDate.timeIntervalSince1970, forKey: .validFromDate)
        }
        if let validToDate = validToDate {
            try encodeContainer.encode(validToDate.timeIntervalSince1970, forKey: .validToDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateIdentifier)
        certificateIdentifier = certificateIdentifierDecoded
        let certificateCreationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .certificateCreationDate)
        certificateCreationDate = certificateCreationDateDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let certificateWalletDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .certificateWallet)
        certificateWallet = certificateWalletDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateOwner)
        certificateOwner = certificateOwnerDecoded
        let validFromDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .validFromDate)
        validFromDate = validFromDateDecoded
        let validToDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .validToDate)
        validToDate = validToDateDecoded
        let signingAlgorithmDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingAlgorithm)
        signingAlgorithm = signingAlgorithmDecoded
        let keyLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .keyLength)
        keyLength = keyLengthDecoded
    }
}

extension DatabaseMigrationClientTypes.Certificate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Certificate(certificateArn: \(Swift.String(describing: certificateArn)), certificateCreationDate: \(Swift.String(describing: certificateCreationDate)), certificateIdentifier: \(Swift.String(describing: certificateIdentifier)), certificateOwner: \(Swift.String(describing: certificateOwner)), certificatePem: \(Swift.String(describing: certificatePem)), certificateWallet: \(Swift.String(describing: certificateWallet)), keyLength: \(Swift.String(describing: keyLength)), signingAlgorithm: \(Swift.String(describing: signingAlgorithm)), validFromDate: \(Swift.String(describing: validFromDate)), validToDate: \(Swift.String(describing: validToDate)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>The SSL certificate that can be used to encrypt connections between the endpoints and
    ///          the replication instance.</p>
    public struct Certificate: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) for the certificate.</p>
        public let certificateArn: Swift.String?
        /// <p>The date that the certificate was created.</p>
        public let certificateCreationDate: ClientRuntime.Date?
        /// <p>A customer-assigned name for the certificate. Identifiers must begin with a letter and
        ///          must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or
        ///          contain two consecutive hyphens.</p>
        public let certificateIdentifier: Swift.String?
        /// <p>The owner of the certificate.</p>
        public let certificateOwner: Swift.String?
        /// <p>The contents of a <code>.pem</code> file, which contains an X.509 certificate.</p>
        public let certificatePem: Swift.String?
        /// <p>The location of an imported Oracle Wallet certificate for use with SSL.</p>
        public let certificateWallet: ClientRuntime.Data?
        /// <p>The key length of the cryptographic algorithm being used.</p>
        public let keyLength: Swift.Int?
        /// <p>The signing algorithm for the certificate.</p>
        public let signingAlgorithm: Swift.String?
        /// <p>The beginning date that the certificate is valid.</p>
        public let validFromDate: ClientRuntime.Date?
        /// <p>The final date that the certificate is valid.</p>
        public let validToDate: ClientRuntime.Date?

        public init (
            certificateArn: Swift.String? = nil,
            certificateCreationDate: ClientRuntime.Date? = nil,
            certificateIdentifier: Swift.String? = nil,
            certificateOwner: Swift.String? = nil,
            certificatePem: Swift.String? = nil,
            certificateWallet: ClientRuntime.Data? = nil,
            keyLength: Swift.Int? = nil,
            signingAlgorithm: Swift.String? = nil,
            validFromDate: ClientRuntime.Date? = nil,
            validToDate: ClientRuntime.Date? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateCreationDate = certificateCreationDate
            self.certificateIdentifier = certificateIdentifier
            self.certificateOwner = certificateOwner
            self.certificatePem = certificatePem
            self.certificateWallet = certificateWallet
            self.keyLength = keyLength
            self.signingAlgorithm = signingAlgorithm
            self.validFromDate = validFromDate
            self.validToDate = validToDate
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum CharLengthSemantics: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case byte
        case char
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [CharLengthSemantics] {
            return [
                .byte,
                .char,
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .byte: return "byte"
            case .char: return "char"
            case .default: return "default"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CharLengthSemantics(rawValue: rawValue) ?? CharLengthSemantics.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum CompressionTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionTypeValue] {
            return [
                .gzip,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "gzip"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CompressionTypeValue(rawValue: rawValue) ?? CompressionTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.Connection: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case lastFailureMessage = "LastFailureMessage"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let endpointIdentifier = endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let lastFailureMessage = lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationInstanceIdentifier = replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
    }
}

extension DatabaseMigrationClientTypes.Connection: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Connection(endpointArn: \(Swift.String(describing: endpointArn)), endpointIdentifier: \(Swift.String(describing: endpointIdentifier)), lastFailureMessage: \(Swift.String(describing: lastFailureMessage)), replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)), replicationInstanceIdentifier: \(Swift.String(describing: replicationInstanceIdentifier)), status: \(Swift.String(describing: status)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Status of the connection between an endpoint and a replication instance, including
    ///          Amazon Resource Names (ARNs) and the last error message issued.</p>
    public struct Connection: Swift.Equatable {
        /// <p>The ARN string that uniquely identifies the endpoint.</p>
        public let endpointArn: Swift.String?
        /// <p>The identifier of the endpoint. Identifiers must begin with a letter and must contain only
        ///          ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two
        ///          consecutive hyphens.</p>
        public let endpointIdentifier: Swift.String?
        /// <p>The error message when the connection last failed.</p>
        public let lastFailureMessage: Swift.String?
        /// <p>The ARN of the replication instance.</p>
        public let replicationInstanceArn: Swift.String?
        /// <p>The replication instance identifier. This parameter is stored as a lowercase
        ///          string.</p>
        public let replicationInstanceIdentifier: Swift.String?
        /// <p>The connection status. This parameter can return one of the following values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>"successful"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"testing"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"failed"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"deleting"</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        public let status: Swift.String?

        public init (
            endpointArn: Swift.String? = nil,
            endpointIdentifier: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            replicationInstanceArn: Swift.String? = nil,
            replicationInstanceIdentifier: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.lastFailureMessage = lastFailureMessage
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.status = status
        }
    }

}

public struct CreateEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEndpointOutputError>
}

extension CreateEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEndpointInput(certificateArn: \(Swift.String(describing: certificateArn)), databaseName: \(Swift.String(describing: databaseName)), dmsTransferSettings: \(Swift.String(describing: dmsTransferSettings)), docDbSettings: \(Swift.String(describing: docDbSettings)), dynamoDbSettings: \(Swift.String(describing: dynamoDbSettings)), elasticsearchSettings: \(Swift.String(describing: elasticsearchSettings)), endpointIdentifier: \(Swift.String(describing: endpointIdentifier)), endpointType: \(Swift.String(describing: endpointType)), engineName: \(Swift.String(describing: engineName)), externalTableDefinition: \(Swift.String(describing: externalTableDefinition)), extraConnectionAttributes: \(Swift.String(describing: extraConnectionAttributes)), iBMDb2Settings: \(Swift.String(describing: iBMDb2Settings)), kafkaSettings: \(Swift.String(describing: kafkaSettings)), kinesisSettings: \(Swift.String(describing: kinesisSettings)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), microsoftSQLServerSettings: \(Swift.String(describing: microsoftSQLServerSettings)), mongoDbSettings: \(Swift.String(describing: mongoDbSettings)), mySQLSettings: \(Swift.String(describing: mySQLSettings)), neptuneSettings: \(Swift.String(describing: neptuneSettings)), oracleSettings: \(Swift.String(describing: oracleSettings)), password: \(Swift.String(describing: password)), port: \(Swift.String(describing: port)), postgreSQLSettings: \(Swift.String(describing: postgreSQLSettings)), redshiftSettings: \(Swift.String(describing: redshiftSettings)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)), s3Settings: \(Swift.String(describing: s3Settings)), serverName: \(Swift.String(describing: serverName)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), sslMode: \(Swift.String(describing: sslMode)), sybaseSettings: \(Swift.String(describing: sybaseSettings)), tags: \(Swift.String(describing: tags)), username: \(Swift.String(describing: username)))"}
}

extension CreateEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case iBMDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case kmsKeyId = "KmsKeyId"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redshiftSettings = "RedshiftSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case tags = "Tags"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dmsTransferSettings = dmsTransferSettings {
            try encodeContainer.encode(dmsTransferSettings, forKey: .dmsTransferSettings)
        }
        if let docDbSettings = docDbSettings {
            try encodeContainer.encode(docDbSettings, forKey: .docDbSettings)
        }
        if let dynamoDbSettings = dynamoDbSettings {
            try encodeContainer.encode(dynamoDbSettings, forKey: .dynamoDbSettings)
        }
        if let elasticsearchSettings = elasticsearchSettings {
            try encodeContainer.encode(elasticsearchSettings, forKey: .elasticsearchSettings)
        }
        if let endpointIdentifier = endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineName = engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let externalTableDefinition = externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let extraConnectionAttributes = extraConnectionAttributes {
            try encodeContainer.encode(extraConnectionAttributes, forKey: .extraConnectionAttributes)
        }
        if let iBMDb2Settings = iBMDb2Settings {
            try encodeContainer.encode(iBMDb2Settings, forKey: .iBMDb2Settings)
        }
        if let kafkaSettings = kafkaSettings {
            try encodeContainer.encode(kafkaSettings, forKey: .kafkaSettings)
        }
        if let kinesisSettings = kinesisSettings {
            try encodeContainer.encode(kinesisSettings, forKey: .kinesisSettings)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let microsoftSQLServerSettings = microsoftSQLServerSettings {
            try encodeContainer.encode(microsoftSQLServerSettings, forKey: .microsoftSQLServerSettings)
        }
        if let mongoDbSettings = mongoDbSettings {
            try encodeContainer.encode(mongoDbSettings, forKey: .mongoDbSettings)
        }
        if let mySQLSettings = mySQLSettings {
            try encodeContainer.encode(mySQLSettings, forKey: .mySQLSettings)
        }
        if let neptuneSettings = neptuneSettings {
            try encodeContainer.encode(neptuneSettings, forKey: .neptuneSettings)
        }
        if let oracleSettings = oracleSettings {
            try encodeContainer.encode(oracleSettings, forKey: .oracleSettings)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let postgreSQLSettings = postgreSQLSettings {
            try encodeContainer.encode(postgreSQLSettings, forKey: .postgreSQLSettings)
        }
        if let redshiftSettings = redshiftSettings {
            try encodeContainer.encode(redshiftSettings, forKey: .redshiftSettings)
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let s3Settings = s3Settings {
            try encodeContainer.encode(s3Settings, forKey: .s3Settings)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let sslMode = sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
        if let sybaseSettings = sybaseSettings {
            try encodeContainer.encode(sybaseSettings, forKey: .sybaseSettings)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct CreateEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEndpointOutputError>
}

public struct CreateEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEndpointOutputError>
}

/// <p></p>
public struct CreateEndpointInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) for the certificate.</p>
    public let certificateArn: Swift.String?
    /// <p>The name of the endpoint database.</p>
    public let databaseName: Swift.String?
    /// <p>The settings in JSON format for the DMS transfer type of source endpoint. </p>
    ///          <p>Possible settings include the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ServiceAccessRoleArn</code> - The IAM role that has permission to access the
    ///                Amazon S3 bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BucketName</code> - The name of the S3 bucket to use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CompressionType</code> - An optional parameter to use GZIP to compress the
    ///                target files. To use GZIP, set this value to <code>NONE</code> (the default). To keep
    ///                the files uncompressed, don't use this value.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Shorthand syntax for these settings is as follows:
    ///             <code>ServiceAccessRoleArn=string,BucketName=string,CompressionType=string</code>
    ///          </p>
    ///          <p>JSON syntax for these settings is as follows: <code>{ "ServiceAccessRoleArn":
    ///             "string", "BucketName": "string", "CompressionType": "none"|"gzip" } </code>
    ///          </p>
    public let dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
    /// <p>Provides information that defines a DocumentDB endpoint.</p>
    public let docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
    /// <p>Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other
    ///             available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.DynamoDB.html">Using Object Mapping to Migrate
    ///             Data to DynamoDB</a> in the <i>AWS Database Migration Service User
    ///             Guide.</i>
    ///          </p>
    public let dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
    /// <p>Settings in JSON format for the target Elasticsearch endpoint. For more information
    ///          about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Elasticsearch.html#CHAP_Target.Elasticsearch.Configuration">Extra Connection Attributes When Using Elasticsearch as a Target for AWS DMS</a> in
    ///          the <i>AWS Database Migration Service User Guide</i>.</p>
    public let elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
    /// <p>The database endpoint identifier. Identifiers must begin with a letter and must contain
    ///          only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two
    ///          consecutive hyphens.</p>
    public let endpointIdentifier: Swift.String?
    /// <p>The type of endpoint.  Valid values are <code>source</code> and <code>target</code>.</p>
    public let endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
    /// <p>The type of engine for the endpoint. Valid values, depending on the
    ///          <code>EndpointType</code> value, include <code>"mysql"</code>, <code>"oracle"</code>,
    ///          <code>"postgres"</code>, <code>"mariadb"</code>, <code>"aurora"</code>,
    ///          <code>"aurora-postgresql"</code>, <code>"redshift"</code>, <code>"s3"</code>,
    ///          <code>"db2"</code>, <code>"azuredb"</code>, <code>"sybase"</code>, <code>"dynamodb"</code>, <code>"mongodb"</code>,
    ///          <code>"kinesis"</code>, <code>"kafka"</code>, <code>"elasticsearch"</code>, <code>"docdb"</code>,
    ///          <code>"sqlserver"</code>, and <code>"neptune"</code>.</p>
    public let engineName: Swift.String?
    /// <p>The external table definition. </p>
    public let externalTableDefinition: Swift.String?
    /// <p>Additional attributes associated with the connection. Each attribute is specified as a
    ///          name-value pair associated by an equal sign (=). Multiple attributes are separated by a
    ///          semicolon (;) with no additional white space. For information on the attributes available
    ///          for connecting your source or target endpoint, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Endpoints.html">Working with
    ///             AWS DMS Endpoints</a> in the <i>AWS Database Migration Service User
    ///             Guide.</i>
    ///          </p>
    public let extraConnectionAttributes: Swift.String?
    /// <p>Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other
    ///          available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DB2.html">Extra connection attributes
    ///             when using Db2 LUW as a source for AWS DMS</a> in the <i>AWS Database
    ///             Migration Service User Guide.</i>
    ///          </p>
    public let iBMDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
    /// <p>Settings in JSON format for the target Apache Kafka endpoint. For more information about
    ///          the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html">Using Apache Kafka as a Target for
    ///             AWS Database Migration Service</a> in the <i>AWS Database Migration Service User
    ///             Guide.</i>
    ///          </p>
    public let kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
    /// <p>Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For
    ///          more information about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kinesis.html">Using Amazon Kinesis Data Streams
    ///             as a Target for AWS Database Migration Service</a> in the <i>AWS Database Migration Service User
    ///             Guide.</i>
    ///          </p>
    public let kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
    /// <p>An AWS KMS key identifier that is used to encrypt the connection parameters for the endpoint.</p>
    ///          <p>If you don't specify a value for the <code>KmsKeyId</code> parameter, then
    ///            AWS DMS uses your default encryption key.</p>
    ///          <p>AWS KMS creates the default encryption key for your AWS account. Your AWS account has a
    ///          different default encryption key for each AWS Region.</p>
    public let kmsKeyId: Swift.String?
    /// <p>Settings in JSON format for the source and target Microsoft SQL Server endpoint. For
    ///          information about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SQLServer.html">Extra connection
    ///             attributes when using SQL Server as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SQLServer.html">
    ///             Extra connection attributes when using SQL Server as a target for AWS DMS</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
    /// <p>Settings in JSON format for the source MongoDB endpoint. For more information about the
    ///          available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MongoDB.html#CHAP_Source.MongoDB.Configuration">Using MongoDB as a Target for AWS Database Migration Service</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
    /// <p>Settings in JSON format for the source and target MySQL endpoint. For information about
    ///          other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MySQL.html">Extra connection attributes
    ///             when using MySQL as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.MySQL.html">Extra connection attributes when using a MySQL-compatible database as a target for AWS DMS</a> in
    ///          the <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
    /// <p>Settings in JSON format for the target Amazon Neptune endpoint.
    ///          For more information
    ///          about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.EndpointSettings">Specifying Endpoint Settings for Amazon Neptune as a Target</a>
    ///             in the <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
    /// <p>Settings in JSON format for the source and target Oracle endpoint. For information about
    ///          other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html">Extra connection attributes
    ///             when using Oracle as a source for AWS DMS</a> and
    ///             <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Oracle.html">
    ///             Extra connection attributes when using Oracle as a target for AWS DMS</a>
    ///             in the <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
    /// <p>The password to be used to log in to the endpoint database.</p>
    public let password: Swift.String?
    /// <p>The port used by the endpoint database.</p>
    public let port: Swift.Int?
    /// <p>Settings in JSON format for the source and target PostgreSQL endpoint. For information
    ///          about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html">Extra connection
    ///             attributes when using PostgreSQL as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.PostgreSQL.html">
    ///                Extra connection attributes when using PostgreSQL as a target for AWS DMS</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
    /// <p>Provides information that defines an Amazon Redshift endpoint.</p>
    public let redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
    /// <p>A friendly name for the resource identifier at the end of the <code>EndpointArn</code>
    ///          response parameter that is returned in the created <code>Endpoint</code> object. The value
    ///          for this parameter can have up to 31 characters. It can contain only ASCII letters, digits,
    ///          and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens,
    ///          and can only begin with a letter, such as <code>Example-App-ARN1</code>. For example, this
    ///          value might result in the <code>EndpointArn</code> value
    ///             <code>arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1</code>. If you don't
    ///          specify a <code>ResourceIdentifier</code> value, AWS DMS generates a default identifier
    ///          value for the end of <code>EndpointArn</code>.</p>
    public let resourceIdentifier: Swift.String?
    /// <p>Settings in JSON format for the target Amazon S3 endpoint. For more information about
    ///          the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring">Extra
    ///             Connection Attributes When Using Amazon S3 as a Target for AWS DMS</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let s3Settings: DatabaseMigrationClientTypes.S3Settings?
    /// <p>The name of the server where the endpoint database resides.</p>
    public let serverName: Swift.String?
    /// <p> The Amazon Resource Name (ARN) for the service access role that you want to use to
    ///          create the endpoint. </p>
    public let serviceAccessRoleArn: Swift.String?
    /// <p>The Secure Sockets Layer (SSL) mode to use for the SSL connection. The default is <code>none</code>
    ///          </p>
    public let sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
    /// <p>Settings in JSON format for the source and target SAP ASE endpoint. For information
    ///          about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SAP.html">Extra connection attributes
    ///             when using SAP ASE as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SAP.html">Extra connection attributes
    ///             when using SAP ASE as a target for AWS DMS</a> in the <i>AWS Database
    ///             Migration Service User Guide.</i>
    ///          </p>
    public let sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
    /// <p>One or more tags to be assigned to the endpoint.</p>
    public let tags: [DatabaseMigrationClientTypes.Tag]?
    /// <p>The user name to be used to log in to the endpoint database.</p>
    public let username: Swift.String?

    public init (
        certificateArn: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings? = nil,
        docDbSettings: DatabaseMigrationClientTypes.DocDbSettings? = nil,
        dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings? = nil,
        elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings? = nil,
        endpointIdentifier: Swift.String? = nil,
        endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
        engineName: Swift.String? = nil,
        externalTableDefinition: Swift.String? = nil,
        extraConnectionAttributes: Swift.String? = nil,
        iBMDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings? = nil,
        kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings? = nil,
        kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings? = nil,
        kmsKeyId: Swift.String? = nil,
        microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings? = nil,
        mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings? = nil,
        mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings? = nil,
        neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings? = nil,
        oracleSettings: DatabaseMigrationClientTypes.OracleSettings? = nil,
        password: Swift.String? = nil,
        port: Swift.Int? = nil,
        postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings? = nil,
        redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings? = nil,
        resourceIdentifier: Swift.String? = nil,
        s3Settings: DatabaseMigrationClientTypes.S3Settings? = nil,
        serverName: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil,
        sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil,
        sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        username: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.databaseName = databaseName
        self.dmsTransferSettings = dmsTransferSettings
        self.docDbSettings = docDbSettings
        self.dynamoDbSettings = dynamoDbSettings
        self.elasticsearchSettings = elasticsearchSettings
        self.endpointIdentifier = endpointIdentifier
        self.endpointType = endpointType
        self.engineName = engineName
        self.externalTableDefinition = externalTableDefinition
        self.extraConnectionAttributes = extraConnectionAttributes
        self.iBMDb2Settings = iBMDb2Settings
        self.kafkaSettings = kafkaSettings
        self.kinesisSettings = kinesisSettings
        self.kmsKeyId = kmsKeyId
        self.microsoftSQLServerSettings = microsoftSQLServerSettings
        self.mongoDbSettings = mongoDbSettings
        self.mySQLSettings = mySQLSettings
        self.neptuneSettings = neptuneSettings
        self.oracleSettings = oracleSettings
        self.password = password
        self.port = port
        self.postgreSQLSettings = postgreSQLSettings
        self.redshiftSettings = redshiftSettings
        self.resourceIdentifier = resourceIdentifier
        self.s3Settings = s3Settings
        self.serverName = serverName
        self.serviceAccessRoleArn = serviceAccessRoleArn
        self.sslMode = sslMode
        self.sybaseSettings = sybaseSettings
        self.tags = tags
        self.username = username
    }
}

struct CreateEndpointInputBody: Swift.Equatable {
    public let endpointIdentifier: Swift.String?
    public let endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
    public let engineName: Swift.String?
    public let username: Swift.String?
    public let password: Swift.String?
    public let serverName: Swift.String?
    public let port: Swift.Int?
    public let databaseName: Swift.String?
    public let extraConnectionAttributes: Swift.String?
    public let kmsKeyId: Swift.String?
    public let tags: [DatabaseMigrationClientTypes.Tag]?
    public let certificateArn: Swift.String?
    public let sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
    public let serviceAccessRoleArn: Swift.String?
    public let externalTableDefinition: Swift.String?
    public let dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
    public let s3Settings: DatabaseMigrationClientTypes.S3Settings?
    public let dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
    public let mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
    public let kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
    public let kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
    public let elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
    public let neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
    public let redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
    public let postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
    public let mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
    public let oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
    public let sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
    public let microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
    public let iBMDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
    public let resourceIdentifier: Swift.String?
    public let docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
}

extension CreateEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case iBMDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case kmsKeyId = "KmsKeyId"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redshiftSettings = "RedshiftSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case tags = "Tags"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let extraConnectionAttributesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extraConnectionAttributes)
        extraConnectionAttributes = extraConnectionAttributesDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let dynamoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DynamoDbSettings.self, forKey: .dynamoDbSettings)
        dynamoDbSettings = dynamoDbSettingsDecoded
        let s3SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.S3Settings.self, forKey: .s3Settings)
        s3Settings = s3SettingsDecoded
        let dmsTransferSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsTransferSettings.self, forKey: .dmsTransferSettings)
        dmsTransferSettings = dmsTransferSettingsDecoded
        let mongoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MongoDbSettings.self, forKey: .mongoDbSettings)
        mongoDbSettings = mongoDbSettingsDecoded
        let kinesisSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KinesisSettings.self, forKey: .kinesisSettings)
        kinesisSettings = kinesisSettingsDecoded
        let kafkaSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KafkaSettings.self, forKey: .kafkaSettings)
        kafkaSettings = kafkaSettingsDecoded
        let elasticsearchSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ElasticsearchSettings.self, forKey: .elasticsearchSettings)
        elasticsearchSettings = elasticsearchSettingsDecoded
        let neptuneSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.NeptuneSettings.self, forKey: .neptuneSettings)
        neptuneSettings = neptuneSettingsDecoded
        let redshiftSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedshiftSettings.self, forKey: .redshiftSettings)
        redshiftSettings = redshiftSettingsDecoded
        let postgreSQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.PostgreSQLSettings.self, forKey: .postgreSQLSettings)
        postgreSQLSettings = postgreSQLSettingsDecoded
        let mySQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MySQLSettings.self, forKey: .mySQLSettings)
        mySQLSettings = mySQLSettingsDecoded
        let oracleSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.OracleSettings.self, forKey: .oracleSettings)
        oracleSettings = oracleSettingsDecoded
        let sybaseSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SybaseSettings.self, forKey: .sybaseSettings)
        sybaseSettings = sybaseSettingsDecoded
        let microsoftSQLServerSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MicrosoftSQLServerSettings.self, forKey: .microsoftSQLServerSettings)
        microsoftSQLServerSettings = microsoftSQLServerSettingsDecoded
        let iBMDb2SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.IBMDb2Settings.self, forKey: .iBMDb2Settings)
        iBMDb2Settings = iBMDb2SettingsDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let docDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DocDbSettings.self, forKey: .docDbSettings)
        docDbSettings = docDbSettingsDecoded
    }
}

extension CreateEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3AccessDeniedFault" : self = .s3AccessDeniedFault(try S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case s3AccessDeniedFault(S3AccessDeniedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEndpointOutputResponse(endpoint: \(Swift.String(describing: endpoint)))"}
}

extension CreateEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

/// <p></p>
public struct CreateEndpointOutputResponse: Swift.Equatable {
    /// <p>The endpoint that was created.</p>
    public let endpoint: DatabaseMigrationClientTypes.Endpoint?

    public init (
        endpoint: DatabaseMigrationClientTypes.Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct CreateEndpointOutputResponseBody: Swift.Equatable {
    public let endpoint: DatabaseMigrationClientTypes.Endpoint?
}

extension CreateEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

public struct CreateEventSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSubscriptionOutputError>
}

extension CreateEventSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventSubscriptionInput(enabled: \(Swift.String(describing: enabled)), eventCategories: \(Swift.String(describing: eventCategories)), snsTopicArn: \(Swift.String(describing: snsTopicArn)), sourceIds: \(Swift.String(describing: sourceIds)), sourceType: \(Swift.String(describing: sourceType)), subscriptionName: \(Swift.String(describing: subscriptionName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateEventSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceIds = "SourceIds"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for eventcategorieslist0 in eventCategories {
                try eventCategoriesContainer.encode(eventcategorieslist0)
            }
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sourceIds = sourceIds {
            var sourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceIds)
            for sourceidslist0 in sourceIds {
                try sourceIdsContainer.encode(sourceidslist0)
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let subscriptionName = subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateEventSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSubscriptionOutputError>
}

public struct CreateEventSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSubscriptionOutputError>
}

/// <p></p>
public struct CreateEventSubscriptionInput: Swift.Equatable {
    /// <p> A Boolean value; set to <code>true</code> to activate the subscription, or set to
    ///             <code>false</code> to create the subscription but not activate it. </p>
    public let enabled: Swift.Bool?
    /// <p>A list of event categories for a source type that you want to subscribe to. For more
    ///            information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Events.html">Working with Events and
    ///                Notifications</a> in the <i>AWS Database Migration Service User
    ///                    Guide.</i>
    ///          </p>
    public let eventCategories: [Swift.String]?
    /// <p> The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification.
    ///          The ARN is created by Amazon SNS when you create a topic and subscribe to it. </p>
    public let snsTopicArn: Swift.String?
    /// <p>A list of identifiers for which AWS DMS provides notification events.</p>
    ///          <p>If you don't specify a value, notifications are provided for all sources.</p>
    ///         <p>If you specify multiple values, they must be of the same type. For example, if you
    ///             specify a database instance ID, then all of the other values must be database instance
    ///             IDs.</p>
    public let sourceIds: [Swift.String]?
    /// <p> The type of AWS DMS resource that generates the events. For example, if you want to be
    ///          notified of events generated by a replication instance, you set this parameter to
    ///             <code>replication-instance</code>. If this value isn't specified, all events are
    ///          returned. </p>
    ///          <p>Valid values: <code>replication-instance</code> | <code>replication-task</code>
    ///          </p>
    public let sourceType: Swift.String?
    /// <p>The name of the AWS DMS event notification subscription. This name must be less than 255 characters.</p>
    public let subscriptionName: Swift.String?
    /// <p>One or more tags to be assigned to the event subscription.</p>
    public let tags: [DatabaseMigrationClientTypes.Tag]?

    public init (
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceIds: [Swift.String]? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceIds = sourceIds
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
        self.tags = tags
    }
}

struct CreateEventSubscriptionInputBody: Swift.Equatable {
    public let subscriptionName: Swift.String?
    public let snsTopicArn: Swift.String?
    public let sourceType: Swift.String?
    public let eventCategories: [Swift.String]?
    public let sourceIds: [Swift.String]?
    public let enabled: Swift.Bool?
    public let tags: [DatabaseMigrationClientTypes.Tag]?
}

extension CreateEventSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceIds = "SourceIds"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[Swift.String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [Swift.String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let sourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceIds)
        var sourceIdsDecoded0:[Swift.String]? = nil
        if let sourceIdsContainer = sourceIdsContainer {
            sourceIdsDecoded0 = [Swift.String]()
            for string0 in sourceIdsContainer {
                if let string0 = string0 {
                    sourceIdsDecoded0?.append(string0)
                }
            }
        }
        sourceIds = sourceIdsDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "KMSAccessDeniedFault" : self = .kMSAccessDeniedFault(try KMSAccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledFault" : self = .kMSDisabledFault(try KMSDisabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateFault" : self = .kMSInvalidStateFault(try KMSInvalidStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundFault" : self = .kMSNotFoundFault(try KMSNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingFault" : self = .kMSThrottlingFault(try KMSThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case kMSAccessDeniedFault(KMSAccessDeniedFault)
    case kMSDisabledFault(KMSDisabledFault)
    case kMSInvalidStateFault(KMSInvalidStateFault)
    case kMSNotFoundFault(KMSNotFoundFault)
    case kMSThrottlingFault(KMSThrottlingFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventSubscriptionOutputResponse(eventSubscription: \(Swift.String(describing: eventSubscription)))"}
}

extension CreateEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

/// <p></p>
public struct CreateEventSubscriptionOutputResponse: Swift.Equatable {
    /// <p>The event subscription that was created.</p>
    public let eventSubscription: DatabaseMigrationClientTypes.EventSubscription?

    public init (
        eventSubscription: DatabaseMigrationClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct CreateEventSubscriptionOutputResponseBody: Swift.Equatable {
    public let eventSubscription: DatabaseMigrationClientTypes.EventSubscription?
}

extension CreateEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct CreateReplicationInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReplicationInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReplicationInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReplicationInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReplicationInstanceOutputError>
}

extension CreateReplicationInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReplicationInstanceInput(allocatedStorage: \(Swift.String(describing: allocatedStorage)), autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), availabilityZone: \(Swift.String(describing: availabilityZone)), dnsNameServers: \(Swift.String(describing: dnsNameServers)), engineVersion: \(Swift.String(describing: engineVersion)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), multiAZ: \(Swift.String(describing: multiAZ)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), replicationInstanceClass: \(Swift.String(describing: replicationInstanceClass)), replicationInstanceIdentifier: \(Swift.String(describing: replicationInstanceIdentifier)), replicationSubnetGroupIdentifier: \(Swift.String(describing: replicationSubnetGroupIdentifier)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)), tags: \(Swift.String(describing: tags)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension CreateReplicationInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case dnsNameServers = "DnsNameServers"
        case engineVersion = "EngineVersion"
        case kmsKeyId = "KmsKeyId"
        case multiAZ = "MultiAZ"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case resourceIdentifier = "ResourceIdentifier"
        case tags = "Tags"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedStorage = allocatedStorage {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let dnsNameServers = dnsNameServers {
            try encodeContainer.encode(dnsNameServers, forKey: .dnsNameServers)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let multiAZ = multiAZ {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let publiclyAccessible = publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let replicationInstanceClass = replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let replicationInstanceIdentifier = replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for vpcsecuritygroupidlist0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(vpcsecuritygroupidlist0)
            }
        }
    }
}

public struct CreateReplicationInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReplicationInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReplicationInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReplicationInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReplicationInstanceOutputError>
}

public struct CreateReplicationInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReplicationInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReplicationInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReplicationInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReplicationInstanceOutputError>
}

/// <p></p>
public struct CreateReplicationInstanceInput: Swift.Equatable {
    /// <p>The amount of storage (in gigabytes) to be initially allocated for the replication
    ///          instance.</p>
    public let allocatedStorage: Swift.Int?
    /// <p>A value that indicates whether minor engine upgrades are applied automatically to the
    ///          replication instance during the maintenance window. This parameter defaults to
    ///             <code>true</code>.</p>
    ///          <p>Default: <code>true</code>
    ///          </p>
    public let autoMinorVersionUpgrade: Swift.Bool?
    /// <p>The Availability Zone where the replication instance will be created. The default
    ///          value is a random, system-chosen Availability Zone in the endpoint's AWS Region, for
    ///          example: <code>us-east-1d</code>
    ///          </p>
    public let availabilityZone: Swift.String?
    /// <p>A list of custom DNS name servers supported for the replication instance to access your
    ///          on-premise source or target database. This list overrides the default name servers
    ///          supported by the replication instance. You can specify a comma-separated list of internet
    ///          addresses for up to four on-premise DNS name servers. For example:
    ///             <code>"1.1.1.1,2.2.2.2,3.3.3.3,4.4.4.4"</code>
    ///          </p>
    public let dnsNameServers: Swift.String?
    /// <p>The engine version number of the replication instance.</p>
    ///          <p>If an engine version number is not specified when a replication
    ///          instance is created, the default is the latest engine version available.</p>
    public let engineVersion: Swift.String?
    /// <p>An AWS KMS key identifier that is used to encrypt the data on the replication
    ///            instance.</p>
    ///          <p>If you don't specify a value for the <code>KmsKeyId</code> parameter, then
    ///            AWS DMS uses your default encryption key.</p>
    ///          <p>AWS KMS creates the default encryption key for your AWS account. Your AWS account has a
    ///          different default encryption key for each AWS Region.</p>
    public let kmsKeyId: Swift.String?
    /// <p> Specifies whether the replication instance is a Multi-AZ deployment. You can't set the
    ///             <code>AvailabilityZone</code> parameter if the Multi-AZ parameter is set to
    ///             <code>true</code>. </p>
    public let multiAZ: Swift.Bool?
    /// <p>The weekly time range during which system maintenance can occur, in Universal
    ///          Coordinated Time (UTC).</p>
    ///          <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///          </p>
    ///          <p>Default: A 30-minute window selected at random from an 8-hour block of time per AWS
    ///          Region, occurring on a random day of the week.</p>
    ///          <p>Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun</p>
    ///          <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: Swift.String?
    /// <p> Specifies the accessibility options for the replication instance. A value of
    ///             <code>true</code> represents an instance with a public IP address. A value of
    ///             <code>false</code> represents an instance with a private IP address. The default value
    ///          is <code>true</code>. </p>
    public let publiclyAccessible: Swift.Bool?
    /// <p>The compute and memory capacity of the replication instance as defined for the specified
    ///          replication instance class. For example to specify the instance class dms.c4.large, set this parameter to <code>"dms.c4.large"</code>.</p>
    ///          <p>For more information on the settings and capacities for the available replication instance classes, see
    ///          <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth">
    ///             Selecting the right AWS DMS replication instance for your migration</a>.
    ///       </p>
    public let replicationInstanceClass: Swift.String?
    /// <p>The replication instance identifier. This parameter is stored as a lowercase
    ///          string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain 1-63 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>myrepinstance</code>
    ///          </p>
    public let replicationInstanceIdentifier: Swift.String?
    /// <p>A subnet group to associate with the replication instance.</p>
    public let replicationSubnetGroupIdentifier: Swift.String?
    /// <p>A friendly name for the resource identifier at the end of the <code>EndpointArn</code>
    ///          response parameter that is returned in the created <code>Endpoint</code> object. The value
    ///          for this parameter can have up to 31 characters. It can contain only ASCII letters, digits,
    ///          and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens,
    ///          and can only begin with a letter, such as <code>Example-App-ARN1</code>. For example, this
    ///          value might result in the <code>EndpointArn</code> value
    ///          <code>arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1</code>. If you don't
    ///          specify a <code>ResourceIdentifier</code> value, AWS DMS generates a default identifier
    ///          value for the end of <code>EndpointArn</code>.</p>
    public let resourceIdentifier: Swift.String?
    /// <p>One or more tags to be assigned to the replication instance.</p>
    public let tags: [DatabaseMigrationClientTypes.Tag]?
    /// <p> Specifies the VPC security group to be used with the replication instance. The VPC
    ///          security group must work with the VPC containing the replication instance. </p>
    public let vpcSecurityGroupIds: [Swift.String]?

    public init (
        allocatedStorage: Swift.Int? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZone: Swift.String? = nil,
        dnsNameServers: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        replicationInstanceClass: Swift.String? = nil,
        replicationInstanceIdentifier: Swift.String? = nil,
        replicationSubnetGroupIdentifier: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.dnsNameServers = dnsNameServers
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.multiAZ = multiAZ
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.replicationInstanceClass = replicationInstanceClass
        self.replicationInstanceIdentifier = replicationInstanceIdentifier
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.resourceIdentifier = resourceIdentifier
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct CreateReplicationInstanceInputBody: Swift.Equatable {
    public let replicationInstanceIdentifier: Swift.String?
    public let allocatedStorage: Swift.Int?
    public let replicationInstanceClass: Swift.String?
    public let vpcSecurityGroupIds: [Swift.String]?
    public let availabilityZone: Swift.String?
    public let replicationSubnetGroupIdentifier: Swift.String?
    public let preferredMaintenanceWindow: Swift.String?
    public let multiAZ: Swift.Bool?
    public let engineVersion: Swift.String?
    public let autoMinorVersionUpgrade: Swift.Bool?
    public let tags: [DatabaseMigrationClientTypes.Tag]?
    public let kmsKeyId: Swift.String?
    public let publiclyAccessible: Swift.Bool?
    public let dnsNameServers: Swift.String?
    public let resourceIdentifier: Swift.String?
}

extension CreateReplicationInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case dnsNameServers = "DnsNameServers"
        case engineVersion = "EngineVersion"
        case kmsKeyId = "KmsKeyId"
        case multiAZ = "MultiAZ"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case resourceIdentifier = "ResourceIdentifier"
        case tags = "Tags"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let dnsNameServersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsNameServers)
        dnsNameServers = dnsNameServersDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
    }
}

extension CreateReplicationInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientResourceCapacityFault" : self = .insufficientResourceCapacityFault(try InsufficientResourceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplicationSubnetGroupDoesNotCoverEnoughAZs" : self = .replicationSubnetGroupDoesNotCoverEnoughAZs(try ReplicationSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReplicationInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case insufficientResourceCapacityFault(InsufficientResourceCapacityFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case invalidSubnet(InvalidSubnet)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case replicationSubnetGroupDoesNotCoverEnoughAZs(ReplicationSubnetGroupDoesNotCoverEnoughAZs)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReplicationInstanceOutputResponse(replicationInstance: \(Swift.String(describing: replicationInstance)))"}
}

extension CreateReplicationInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateReplicationInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

/// <p></p>
public struct CreateReplicationInstanceOutputResponse: Swift.Equatable {
    /// <p>The replication instance that was created.</p>
    public let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init (
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct CreateReplicationInstanceOutputResponseBody: Swift.Equatable {
    public let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?
}

extension CreateReplicationInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

public struct CreateReplicationSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReplicationSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReplicationSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReplicationSubnetGroupOutputError>
}

extension CreateReplicationSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReplicationSubnetGroupInput(replicationSubnetGroupDescription: \(Swift.String(describing: replicationSubnetGroupDescription)), replicationSubnetGroupIdentifier: \(Swift.String(describing: replicationSubnetGroupIdentifier)), subnetIds: \(Swift.String(describing: subnetIds)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateReplicationSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupDescription = replicationSubnetGroupDescription {
            try encodeContainer.encode(replicationSubnetGroupDescription, forKey: .replicationSubnetGroupDescription)
        }
        if let replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidentifierlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidentifierlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateReplicationSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReplicationSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReplicationSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReplicationSubnetGroupOutputError>
}

public struct CreateReplicationSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReplicationSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReplicationSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReplicationSubnetGroupOutputError>
}

/// <p></p>
public struct CreateReplicationSubnetGroupInput: Swift.Equatable {
    /// <p>The description for the subnet group.</p>
    public let replicationSubnetGroupDescription: Swift.String?
    /// <p>The name for the replication subnet group. This value is stored as a lowercase
    ///          string.</p>
    ///          <p>Constraints: Must contain no more than 255 alphanumeric characters, periods, spaces,
    ///          underscores, or hyphens. Must not be "default".</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let replicationSubnetGroupIdentifier: Swift.String?
    /// <p>One or more subnet IDs to be assigned to the subnet group.</p>
    public let subnetIds: [Swift.String]?
    /// <p>One or more tags to be assigned to the subnet group.</p>
    public let tags: [DatabaseMigrationClientTypes.Tag]?

    public init (
        replicationSubnetGroupDescription: Swift.String? = nil,
        replicationSubnetGroupIdentifier: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

struct CreateReplicationSubnetGroupInputBody: Swift.Equatable {
    public let replicationSubnetGroupIdentifier: Swift.String?
    public let replicationSubnetGroupDescription: Swift.String?
    public let subnetIds: [Swift.String]?
    public let tags: [DatabaseMigrationClientTypes.Tag]?
}

extension CreateReplicationSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let replicationSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupDescription)
        replicationSubnetGroupDescription = replicationSubnetGroupDescriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReplicationSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplicationSubnetGroupDoesNotCoverEnoughAZs" : self = .replicationSubnetGroupDoesNotCoverEnoughAZs(try ReplicationSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReplicationSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidSubnet(InvalidSubnet)
    case replicationSubnetGroupDoesNotCoverEnoughAZs(ReplicationSubnetGroupDoesNotCoverEnoughAZs)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReplicationSubnetGroupOutputResponse(replicationSubnetGroup: \(Swift.String(describing: replicationSubnetGroup)))"}
}

extension CreateReplicationSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateReplicationSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationSubnetGroup = output.replicationSubnetGroup
        } else {
            self.replicationSubnetGroup = nil
        }
    }
}

/// <p></p>
public struct CreateReplicationSubnetGroupOutputResponse: Swift.Equatable {
    /// <p>The replication subnet group that was created.</p>
    public let replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?

    public init (
        replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup? = nil
    )
    {
        self.replicationSubnetGroup = replicationSubnetGroup
    }
}

struct CreateReplicationSubnetGroupOutputResponseBody: Swift.Equatable {
    public let replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?
}

extension CreateReplicationSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroup = "ReplicationSubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationSubnetGroup.self, forKey: .replicationSubnetGroup)
        replicationSubnetGroup = replicationSubnetGroupDecoded
    }
}

public struct CreateReplicationTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReplicationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReplicationTaskOutputError>
}

extension CreateReplicationTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReplicationTaskInput(cdcStartPosition: \(Swift.String(describing: cdcStartPosition)), cdcStartTime: \(Swift.String(describing: cdcStartTime)), cdcStopPosition: \(Swift.String(describing: cdcStopPosition)), migrationType: \(Swift.String(describing: migrationType)), replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)), replicationTaskIdentifier: \(Swift.String(describing: replicationTaskIdentifier)), replicationTaskSettings: \(Swift.String(describing: replicationTaskSettings)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)), sourceEndpointArn: \(Swift.String(describing: sourceEndpointArn)), tableMappings: \(Swift.String(describing: tableMappings)), tags: \(Swift.String(describing: tags)), targetEndpointArn: \(Swift.String(describing: targetEndpointArn)), taskData: \(Swift.String(describing: taskData)))"}
}

extension CreateReplicationTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case sourceEndpointArn = "SourceEndpointArn"
        case tableMappings = "TableMappings"
        case tags = "Tags"
        case targetEndpointArn = "TargetEndpointArn"
        case taskData = "TaskData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStartTime = cdcStartTime {
            try encodeContainer.encode(cdcStartTime.timeIntervalSince1970, forKey: .cdcStartTime)
        }
        if let cdcStopPosition = cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let migrationType = migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationTaskIdentifier = replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskSettings = replicationTaskSettings {
            try encodeContainer.encode(replicationTaskSettings, forKey: .replicationTaskSettings)
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let sourceEndpointArn = sourceEndpointArn {
            try encodeContainer.encode(sourceEndpointArn, forKey: .sourceEndpointArn)
        }
        if let tableMappings = tableMappings {
            try encodeContainer.encode(tableMappings, forKey: .tableMappings)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetEndpointArn = targetEndpointArn {
            try encodeContainer.encode(targetEndpointArn, forKey: .targetEndpointArn)
        }
        if let taskData = taskData {
            try encodeContainer.encode(taskData, forKey: .taskData)
        }
    }
}

public struct CreateReplicationTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReplicationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReplicationTaskOutputError>
}

public struct CreateReplicationTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReplicationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReplicationTaskOutputError>
}

/// <p></p>
public struct CreateReplicationTaskInput: Swift.Equatable {
    /// <p>Indicates when you want a change data capture (CDC) operation to start. Use either
    ///          CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start.
    ///          Specifying both values results in an error.</p>
    ///          <p> The value can be in date, checkpoint, or LSN/SCN format.</p>
    ///          <p>Date Example: --cdc-start-position â€œ2018-03-08T12:12:12â€</p>
    ///          <p>Checkpoint Example: --cdc-start-position
    ///          "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93"</p>
    ///          <p>LSN Example: --cdc-start-position â€œmysql-bin-changelog.000024:373â€</p>
    ///          <note>
    ///             <p>When you use this task setting with a source PostgreSQL database, a logical
    ///             replication slot should already be created and associated with the source endpoint. You
    ///             can verify this by setting the <code>slotName</code> extra connection attribute to the
    ///             name of this logical replication slot. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib">Extra Connection Attributes When Using PostgreSQL as a Source
    ///                for AWS DMS</a>.</p>
    ///          </note>
    public let cdcStartPosition: Swift.String?
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either
    ///          CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start.
    ///          Specifying both values results in an error.</p>
    ///          <p>Timestamp Example: --cdc-start-time â€œ2018-03-08T12:12:12â€</p>
    public let cdcStartTime: ClientRuntime.Date?
    /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be
    ///          either server time or commit time.</p>
    ///          <p>Server time example: --cdc-stop-position â€œserver_time:2018-02-09T12:12:12â€</p>
    ///          <p>Commit time example: --cdc-stop-position â€œcommit_time: 2018-02-09T12:12:12 â€œ</p>
    public let cdcStopPosition: Swift.String?
    /// <p>The migration type. Valid values: <code>full-load</code> | <code>cdc</code> | <code>full-load-and-cdc</code>
    ///          </p>
    public let migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// <p>The Amazon Resource Name (ARN) of a replication instance.</p>
    public let replicationInstanceArn: Swift.String?
    /// <p>An identifier for the replication task.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain 1-255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let replicationTaskIdentifier: Swift.String?
    /// <p>Overall settings for the task, in JSON format. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TaskSettings.html">Specifying Task
    ///             Settings for AWS Database Migration Service Tasks</a> in the <i>AWS Database
    ///             Migration User Guide.</i>
    ///          </p>
    public let replicationTaskSettings: Swift.String?
    /// <p>A friendly name for the resource identifier at the end of the <code>EndpointArn</code>
    ///          response parameter that is returned in the created <code>Endpoint</code> object. The value
    ///          for this parameter can have up to 31 characters. It can contain only ASCII letters, digits,
    ///          and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens,
    ///          and can only begin with a letter, such as <code>Example-App-ARN1</code>. For example, this
    ///          value might result in the <code>EndpointArn</code> value
    ///          <code>arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1</code>. If you don't
    ///          specify a <code>ResourceIdentifier</code> value, AWS DMS generates a default identifier
    ///          value for the end of <code>EndpointArn</code>.</p>
    public let resourceIdentifier: Swift.String?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies the source endpoint.</p>
    public let sourceEndpointArn: Swift.String?
    /// <p>The table mappings for the task, in JSON format. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TableMapping.html">Using Table
    ///             Mapping to Specify Task Settings</a> in the <i>AWS Database Migration Service User
    ///             Guide.</i>
    ///          </p>
    public let tableMappings: Swift.String?
    /// <p>One or more tags to be assigned to the replication task.</p>
    public let tags: [DatabaseMigrationClientTypes.Tag]?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies the target endpoint.</p>
    public let targetEndpointArn: Swift.String?
    /// <p>Supplemental information that the task requires to migrate the data for certain source and target endpoints.
    ///          For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html">Specifying Supplemental Data for Task Settings</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let taskData: Swift.String?

    public init (
        cdcStartPosition: Swift.String? = nil,
        cdcStartTime: ClientRuntime.Date? = nil,
        cdcStopPosition: Swift.String? = nil,
        migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationTaskIdentifier: Swift.String? = nil,
        replicationTaskSettings: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        sourceEndpointArn: Swift.String? = nil,
        tableMappings: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        targetEndpointArn: Swift.String? = nil,
        taskData: Swift.String? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.migrationType = migrationType
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationTaskIdentifier = replicationTaskIdentifier
        self.replicationTaskSettings = replicationTaskSettings
        self.resourceIdentifier = resourceIdentifier
        self.sourceEndpointArn = sourceEndpointArn
        self.tableMappings = tableMappings
        self.tags = tags
        self.targetEndpointArn = targetEndpointArn
        self.taskData = taskData
    }
}

struct CreateReplicationTaskInputBody: Swift.Equatable {
    public let replicationTaskIdentifier: Swift.String?
    public let sourceEndpointArn: Swift.String?
    public let targetEndpointArn: Swift.String?
    public let replicationInstanceArn: Swift.String?
    public let migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    public let tableMappings: Swift.String?
    public let replicationTaskSettings: Swift.String?
    public let cdcStartTime: ClientRuntime.Date?
    public let cdcStartPosition: Swift.String?
    public let cdcStopPosition: Swift.String?
    public let tags: [DatabaseMigrationClientTypes.Tag]?
    public let taskData: Swift.String?
    public let resourceIdentifier: Swift.String?
}

extension CreateReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case sourceEndpointArn = "SourceEndpointArn"
        case tableMappings = "TableMappings"
        case tags = "Tags"
        case targetEndpointArn = "TargetEndpointArn"
        case taskData = "TaskData"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let sourceEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEndpointArn)
        sourceEndpointArn = sourceEndpointArnDecoded
        let targetEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEndpointArn)
        targetEndpointArn = targetEndpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let tableMappingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableMappings)
        tableMappings = tableMappingsDecoded
        let replicationTaskSettingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskSettings)
        replicationTaskSettings = replicationTaskSettingsDecoded
        let cdcStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .cdcStartTime)
        cdcStartTime = cdcStartTimeDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let taskDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskData)
        taskData = taskDataDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
    }
}

extension CreateReplicationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReplicationTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReplicationTaskOutputResponse(replicationTask: \(Swift.String(describing: replicationTask)))"}
}

extension CreateReplicationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

/// <p></p>
public struct CreateReplicationTaskOutputResponse: Swift.Equatable {
    /// <p>The replication task that was created.</p>
    public let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init (
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct CreateReplicationTaskOutputResponseBody: Swift.Equatable {
    public let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension CreateReplicationTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum DataFormatValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [DataFormatValue] {
            return [
                .csv,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "csv"
            case .parquet: return "parquet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataFormatValue(rawValue: rawValue) ?? DataFormatValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum DatePartitionDelimiterValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dash
        case `none`
        case slash
        case underscore
        case sdkUnknown(Swift.String)

        public static var allCases: [DatePartitionDelimiterValue] {
            return [
                .dash,
                .none,
                .slash,
                .underscore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dash: return "DASH"
            case .none: return "NONE"
            case .slash: return "SLASH"
            case .underscore: return "UNDERSCORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatePartitionDelimiterValue(rawValue: rawValue) ?? DatePartitionDelimiterValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum DatePartitionSequenceValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ddmmyyyy
        case mmyyyydd
        case yyyymm
        case yyyymmdd
        case yyyymmddhh
        case sdkUnknown(Swift.String)

        public static var allCases: [DatePartitionSequenceValue] {
            return [
                .ddmmyyyy,
                .mmyyyydd,
                .yyyymm,
                .yyyymmdd,
                .yyyymmddhh,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ddmmyyyy: return "DDMMYYYY"
            case .mmyyyydd: return "MMYYYYDD"
            case .yyyymm: return "YYYYMM"
            case .yyyymmdd: return "YYYYMMDD"
            case .yyyymmddhh: return "YYYYMMDDHH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatePartitionSequenceValue(rawValue: rawValue) ?? DatePartitionSequenceValue.sdkUnknown(rawValue)
        }
    }
}

public struct DeleteCertificateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCertificateOutputError>
}

extension DeleteCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCertificateInput(certificateArn: \(Swift.String(describing: certificateArn)))"}
}

extension DeleteCertificateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
    }
}

public struct DeleteCertificateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCertificateOutputError>
}

public struct DeleteCertificateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCertificateOutputError>
}

public struct DeleteCertificateInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the deleted certificate.</p>
    public let certificateArn: Swift.String?

    public init (
        certificateArn: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
    }
}

struct DeleteCertificateInputBody: Swift.Equatable {
    public let certificateArn: Swift.String?
}

extension DeleteCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension DeleteCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCertificateOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCertificateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCertificateOutputResponse(certificate: \(Swift.String(describing: certificate)))"}
}

extension DeleteCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

public struct DeleteCertificateOutputResponse: Swift.Equatable {
    /// <p>The Secure Sockets Layer (SSL) certificate.</p>
    public let certificate: DatabaseMigrationClientTypes.Certificate?

    public init (
        certificate: DatabaseMigrationClientTypes.Certificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct DeleteCertificateOutputResponseBody: Swift.Equatable {
    public let certificate: DatabaseMigrationClientTypes.Certificate?
}

extension DeleteCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

public struct DeleteConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

extension DeleteConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectionInput(endpointArn: \(Swift.String(describing: endpointArn)), replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)))"}
}

extension DeleteConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct DeleteConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

/// <p></p>
public struct DeleteConnectionInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DeleteConnectionInputBody: Swift.Equatable {
    public let endpointArn: Swift.String?
    public let replicationInstanceArn: Swift.String?
}

extension DeleteConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
    }
}

extension DeleteConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectionOutputResponse(connection: \(Swift.String(describing: connection)))"}
}

extension DeleteConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

/// <p></p>
public struct DeleteConnectionOutputResponse: Swift.Equatable {
    /// <p>The connection that is being deleted.</p>
    public let connection: DatabaseMigrationClientTypes.Connection?

    public init (
        connection: DatabaseMigrationClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct DeleteConnectionOutputResponseBody: Swift.Equatable {
    public let connection: DatabaseMigrationClientTypes.Connection?
}

extension DeleteConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

public struct DeleteEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEndpointOutputError>
}

extension DeleteEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEndpointInput(endpointArn: \(Swift.String(describing: endpointArn)))"}
}

extension DeleteEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
    }
}

public struct DeleteEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEndpointOutputError>
}

public struct DeleteEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEndpointOutputError>
}

/// <p></p>
public struct DeleteEndpointInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct DeleteEndpointInputBody: Swift.Equatable {
    public let endpointArn: Swift.String?
}

extension DeleteEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension DeleteEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEndpointOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEndpointOutputResponse(endpoint: \(Swift.String(describing: endpoint)))"}
}

extension DeleteEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

/// <p></p>
public struct DeleteEndpointOutputResponse: Swift.Equatable {
    /// <p>The endpoint that was deleted.</p>
    public let endpoint: DatabaseMigrationClientTypes.Endpoint?

    public init (
        endpoint: DatabaseMigrationClientTypes.Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct DeleteEndpointOutputResponseBody: Swift.Equatable {
    public let endpoint: DatabaseMigrationClientTypes.Endpoint?
}

extension DeleteEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

public struct DeleteEventSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSubscriptionOutputError>
}

extension DeleteEventSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventSubscriptionInput(subscriptionName: \(Swift.String(describing: subscriptionName)))"}
}

extension DeleteEventSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionName = "SubscriptionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subscriptionName = subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
    }
}

public struct DeleteEventSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSubscriptionOutputError>
}

public struct DeleteEventSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSubscriptionOutputError>
}

/// <p></p>
public struct DeleteEventSubscriptionInput: Swift.Equatable {
    /// <p>The name of the DMS event notification subscription to be deleted.</p>
    public let subscriptionName: Swift.String?

    public init (
        subscriptionName: Swift.String? = nil
    )
    {
        self.subscriptionName = subscriptionName
    }
}

struct DeleteEventSubscriptionInputBody: Swift.Equatable {
    public let subscriptionName: Swift.String?
}

extension DeleteEventSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionName = "SubscriptionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
    }
}

extension DeleteEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventSubscriptionOutputResponse(eventSubscription: \(Swift.String(describing: eventSubscription)))"}
}

extension DeleteEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

/// <p></p>
public struct DeleteEventSubscriptionOutputResponse: Swift.Equatable {
    /// <p>The event subscription that was deleted.</p>
    public let eventSubscription: DatabaseMigrationClientTypes.EventSubscription?

    public init (
        eventSubscription: DatabaseMigrationClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct DeleteEventSubscriptionOutputResponseBody: Swift.Equatable {
    public let eventSubscription: DatabaseMigrationClientTypes.EventSubscription?
}

extension DeleteEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct DeleteReplicationInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReplicationInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReplicationInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReplicationInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReplicationInstanceOutputError>
}

extension DeleteReplicationInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteReplicationInstanceInput(replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)))"}
}

extension DeleteReplicationInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct DeleteReplicationInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReplicationInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReplicationInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReplicationInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReplicationInstanceOutputError>
}

public struct DeleteReplicationInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReplicationInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReplicationInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReplicationInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReplicationInstanceOutputError>
}

/// <p></p>
public struct DeleteReplicationInstanceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the replication instance to be deleted.</p>
    public let replicationInstanceArn: Swift.String?

    public init (
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DeleteReplicationInstanceInputBody: Swift.Equatable {
    public let replicationInstanceArn: Swift.String?
}

extension DeleteReplicationInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
    }
}

extension DeleteReplicationInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReplicationInstanceOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteReplicationInstanceOutputResponse(replicationInstance: \(Swift.String(describing: replicationInstance)))"}
}

extension DeleteReplicationInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteReplicationInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

/// <p></p>
public struct DeleteReplicationInstanceOutputResponse: Swift.Equatable {
    /// <p>The replication instance that was deleted.</p>
    public let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init (
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct DeleteReplicationInstanceOutputResponseBody: Swift.Equatable {
    public let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?
}

extension DeleteReplicationInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

public struct DeleteReplicationSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReplicationSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReplicationSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReplicationSubnetGroupOutputError>
}

extension DeleteReplicationSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteReplicationSubnetGroupInput(replicationSubnetGroupIdentifier: \(Swift.String(describing: replicationSubnetGroupIdentifier)))"}
}

extension DeleteReplicationSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
    }
}

public struct DeleteReplicationSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReplicationSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReplicationSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReplicationSubnetGroupOutputError>
}

public struct DeleteReplicationSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReplicationSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReplicationSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReplicationSubnetGroupOutputError>
}

/// <p></p>
public struct DeleteReplicationSubnetGroupInput: Swift.Equatable {
    /// <p>The subnet group name of the replication instance.</p>
    public let replicationSubnetGroupIdentifier: Swift.String?

    public init (
        replicationSubnetGroupIdentifier: Swift.String? = nil
    )
    {
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
    }
}

struct DeleteReplicationSubnetGroupInputBody: Swift.Equatable {
    public let replicationSubnetGroupIdentifier: Swift.String?
}

extension DeleteReplicationSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
    }
}

extension DeleteReplicationSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReplicationSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteReplicationSubnetGroupOutputResponse()"}
}

extension DeleteReplicationSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p></p>
public struct DeleteReplicationSubnetGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteReplicationSubnetGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteReplicationSubnetGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteReplicationTaskAssessmentRunInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReplicationTaskAssessmentRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReplicationTaskAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReplicationTaskAssessmentRunOutputError>
}

extension DeleteReplicationTaskAssessmentRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteReplicationTaskAssessmentRunInput(replicationTaskAssessmentRunArn: \(Swift.String(describing: replicationTaskAssessmentRunArn)))"}
}

extension DeleteReplicationTaskAssessmentRunInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
    }
}

public struct DeleteReplicationTaskAssessmentRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReplicationTaskAssessmentRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReplicationTaskAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReplicationTaskAssessmentRunOutputError>
}

public struct DeleteReplicationTaskAssessmentRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReplicationTaskAssessmentRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReplicationTaskAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReplicationTaskAssessmentRunOutputError>
}

/// <p></p>
public struct DeleteReplicationTaskAssessmentRunInput: Swift.Equatable {
    /// <p>Amazon Resource Name (ARN) of the premigration assessment run to be deleted.</p>
    public let replicationTaskAssessmentRunArn: Swift.String?

    public init (
        replicationTaskAssessmentRunArn: Swift.String? = nil
    )
    {
        self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
    }
}

struct DeleteReplicationTaskAssessmentRunInputBody: Swift.Equatable {
    public let replicationTaskAssessmentRunArn: Swift.String?
}

extension DeleteReplicationTaskAssessmentRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
    }
}

extension DeleteReplicationTaskAssessmentRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationTaskAssessmentRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReplicationTaskAssessmentRunOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationTaskAssessmentRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteReplicationTaskAssessmentRunOutputResponse(replicationTaskAssessmentRun: \(Swift.String(describing: replicationTaskAssessmentRun)))"}
}

extension DeleteReplicationTaskAssessmentRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteReplicationTaskAssessmentRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTaskAssessmentRun = output.replicationTaskAssessmentRun
        } else {
            self.replicationTaskAssessmentRun = nil
        }
    }
}

/// <p></p>
public struct DeleteReplicationTaskAssessmentRunOutputResponse: Swift.Equatable {
    /// <p>The <code>ReplicationTaskAssessmentRun</code> object for the deleted assessment
    ///          run.</p>
    public let replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?

    public init (
        replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun? = nil
    )
    {
        self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
    }
}

struct DeleteReplicationTaskAssessmentRunOutputResponseBody: Swift.Equatable {
    public let replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?
}

extension DeleteReplicationTaskAssessmentRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun.self, forKey: .replicationTaskAssessmentRun)
        replicationTaskAssessmentRun = replicationTaskAssessmentRunDecoded
    }
}

public struct DeleteReplicationTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReplicationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReplicationTaskOutputError>
}

extension DeleteReplicationTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteReplicationTaskInput(replicationTaskArn: \(Swift.String(describing: replicationTaskArn)))"}
}

extension DeleteReplicationTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

public struct DeleteReplicationTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReplicationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReplicationTaskOutputError>
}

public struct DeleteReplicationTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReplicationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReplicationTaskOutputError>
}

/// <p></p>
public struct DeleteReplicationTaskInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the replication task to be deleted.</p>
    public let replicationTaskArn: Swift.String?

    public init (
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct DeleteReplicationTaskInputBody: Swift.Equatable {
    public let replicationTaskArn: Swift.String?
}

extension DeleteReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

extension DeleteReplicationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReplicationTaskOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteReplicationTaskOutputResponse(replicationTask: \(Swift.String(describing: replicationTask)))"}
}

extension DeleteReplicationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

/// <p></p>
public struct DeleteReplicationTaskOutputResponse: Swift.Equatable {
    /// <p>The deleted replication task.</p>
    public let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init (
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct DeleteReplicationTaskOutputResponseBody: Swift.Equatable {
    public let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension DeleteReplicationTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension DescribeAccountAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccountAttributesInput()"}
}

extension DescribeAccountAttributesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAccountAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountAttributesOutputError>
}

public struct DescribeAccountAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountAttributesOutputError>
}

/// <p></p>
public struct DescribeAccountAttributesInput: Swift.Equatable {

    public init() {}
}

struct DescribeAccountAttributesInputBody: Swift.Equatable {
}

extension DescribeAccountAttributesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountAttributesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccountAttributesOutputResponse(accountQuotas: \(Swift.String(describing: accountQuotas)), uniqueAccountIdentifier: \(Swift.String(describing: uniqueAccountIdentifier)))"}
}

extension DescribeAccountAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccountAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountQuotas = output.accountQuotas
            self.uniqueAccountIdentifier = output.uniqueAccountIdentifier
        } else {
            self.accountQuotas = nil
            self.uniqueAccountIdentifier = nil
        }
    }
}

/// <p></p>
public struct DescribeAccountAttributesOutputResponse: Swift.Equatable {
    /// <p>Account quota information.</p>
    public let accountQuotas: [DatabaseMigrationClientTypes.AccountQuota]?
    /// <p>A unique AWS DMS identifier for an account in a particular AWS Region. The value of this
    ///          identifier has the following format: <code>c99999999999</code>. DMS uses this identifier to
    ///          name artifacts. For example, DMS uses this identifier to name the default Amazon S3 bucket
    ///          for storing task assessment reports in a given AWS Region. The format of this S3 bucket
    ///          name is the following:
    ///                <code>dms-<i>AccountNumber</i>-<i>UniqueAccountIdentifier</i>.</code>
    ///          Here is an example name for this default S3 bucket:
    ///             <code>dms-111122223333-c44445555666</code>.</p>
    ///          <note>
    ///             <p>AWS DMS supports the <code>UniqueAccountIdentifier</code> parameter in
    ///             versions 3.1.4 and later.</p>
    ///          </note>
    public let uniqueAccountIdentifier: Swift.String?

    public init (
        accountQuotas: [DatabaseMigrationClientTypes.AccountQuota]? = nil,
        uniqueAccountIdentifier: Swift.String? = nil
    )
    {
        self.accountQuotas = accountQuotas
        self.uniqueAccountIdentifier = uniqueAccountIdentifier
    }
}

struct DescribeAccountAttributesOutputResponseBody: Swift.Equatable {
    public let accountQuotas: [DatabaseMigrationClientTypes.AccountQuota]?
    public let uniqueAccountIdentifier: Swift.String?
}

extension DescribeAccountAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountQuotas = "AccountQuotas"
        case uniqueAccountIdentifier = "UniqueAccountIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountQuotasContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.AccountQuota?].self, forKey: .accountQuotas)
        var accountQuotasDecoded0:[DatabaseMigrationClientTypes.AccountQuota]? = nil
        if let accountQuotasContainer = accountQuotasContainer {
            accountQuotasDecoded0 = [DatabaseMigrationClientTypes.AccountQuota]()
            for structure0 in accountQuotasContainer {
                if let structure0 = structure0 {
                    accountQuotasDecoded0?.append(structure0)
                }
            }
        }
        accountQuotas = accountQuotasDecoded0
        let uniqueAccountIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uniqueAccountIdentifier)
        uniqueAccountIdentifier = uniqueAccountIdentifierDecoded
    }
}

public struct DescribeApplicableIndividualAssessmentsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeApplicableIndividualAssessmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeApplicableIndividualAssessmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeApplicableIndividualAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeApplicableIndividualAssessmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeApplicableIndividualAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeApplicableIndividualAssessmentsOutputError>
}

extension DescribeApplicableIndividualAssessmentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeApplicableIndividualAssessmentsInput(marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), migrationType: \(Swift.String(describing: migrationType)), replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)), replicationTaskArn: \(Swift.String(describing: replicationTaskArn)), sourceEngineName: \(Swift.String(describing: sourceEngineName)), targetEngineName: \(Swift.String(describing: targetEngineName)))"}
}

extension DescribeApplicableIndividualAssessmentsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskArn = "ReplicationTaskArn"
        case sourceEngineName = "SourceEngineName"
        case targetEngineName = "TargetEngineName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let migrationType = migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let sourceEngineName = sourceEngineName {
            try encodeContainer.encode(sourceEngineName, forKey: .sourceEngineName)
        }
        if let targetEngineName = targetEngineName {
            try encodeContainer.encode(targetEngineName, forKey: .targetEngineName)
        }
    }
}

public struct DescribeApplicableIndividualAssessmentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeApplicableIndividualAssessmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeApplicableIndividualAssessmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeApplicableIndividualAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeApplicableIndividualAssessmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeApplicableIndividualAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeApplicableIndividualAssessmentsOutputError>
}

public struct DescribeApplicableIndividualAssessmentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeApplicableIndividualAssessmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeApplicableIndividualAssessmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeApplicableIndividualAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeApplicableIndividualAssessmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeApplicableIndividualAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeApplicableIndividualAssessmentsOutputError>
}

/// <p></p>
public struct DescribeApplicableIndividualAssessmentsInput: Swift.Equatable {
    /// <p>Optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p>Maximum number of records to include in the response. If more records exist than the
    ///          specified <code>MaxRecords</code> value, a pagination token called a marker is included in
    ///          the response so that the remaining results can be retrieved.</p>
    public let maxRecords: Swift.Int?
    /// <p>Name of the migration type that each provided individual assessment must support.</p>
    public let migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// <p>ARN of a replication instance on which you want to base the default list of individual
    ///          assessments.</p>
    public let replicationInstanceArn: Swift.String?
    /// <p>Amazon Resource Name (ARN) of a migration task on which you want to base
    ///          the default list of individual assessments.</p>
    public let replicationTaskArn: Swift.String?
    /// <p>Name of a database engine that the specified replication instance supports as a source.</p>
    public let sourceEngineName: Swift.String?
    /// <p>Name of a database engine that the specified replication instance supports as a target.</p>
    public let targetEngineName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationTaskArn: Swift.String? = nil,
        sourceEngineName: Swift.String? = nil,
        targetEngineName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationType = migrationType
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationTaskArn = replicationTaskArn
        self.sourceEngineName = sourceEngineName
        self.targetEngineName = targetEngineName
    }
}

struct DescribeApplicableIndividualAssessmentsInputBody: Swift.Equatable {
    public let replicationTaskArn: Swift.String?
    public let replicationInstanceArn: Swift.String?
    public let sourceEngineName: Swift.String?
    public let targetEngineName: Swift.String?
    public let migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeApplicableIndividualAssessmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskArn = "ReplicationTaskArn"
        case sourceEngineName = "SourceEngineName"
        case targetEngineName = "TargetEngineName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let sourceEngineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEngineName)
        sourceEngineName = sourceEngineNameDecoded
        let targetEngineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEngineName)
        targetEngineName = targetEngineNameDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeApplicableIndividualAssessmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicableIndividualAssessmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApplicableIndividualAssessmentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicableIndividualAssessmentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeApplicableIndividualAssessmentsOutputResponse(individualAssessmentNames: \(Swift.String(describing: individualAssessmentNames)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeApplicableIndividualAssessmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeApplicableIndividualAssessmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.individualAssessmentNames = output.individualAssessmentNames
            self.marker = output.marker
        } else {
            self.individualAssessmentNames = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeApplicableIndividualAssessmentsOutputResponse: Swift.Equatable {
    /// <p>List of names for the individual assessments supported by the premigration assessment
    ///          run that you start based on the specified request parameters. For more information on the
    ///          available individual assessments, including compatibility with different migration task
    ///          configurations, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.AssessmentReport.html">Working with premigration assessment runs</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let individualAssessmentNames: [Swift.String]?
    /// <p>Pagination token returned for you to pass to a subsequent request. If you pass this
    ///          token as the <code>Marker</code> value in a subsequent request, the response includes only
    ///          records beyond the marker, up to the value specified in the request by
    ///             <code>MaxRecords</code>.</p>
    public let marker: Swift.String?

    public init (
        individualAssessmentNames: [Swift.String]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.individualAssessmentNames = individualAssessmentNames
        self.marker = marker
    }
}

struct DescribeApplicableIndividualAssessmentsOutputResponseBody: Swift.Equatable {
    public let individualAssessmentNames: [Swift.String]?
    public let marker: Swift.String?
}

extension DescribeApplicableIndividualAssessmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case individualAssessmentNames = "IndividualAssessmentNames"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let individualAssessmentNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .individualAssessmentNames)
        var individualAssessmentNamesDecoded0:[Swift.String]? = nil
        if let individualAssessmentNamesContainer = individualAssessmentNamesContainer {
            individualAssessmentNamesDecoded0 = [Swift.String]()
            for string0 in individualAssessmentNamesContainer {
                if let string0 = string0 {
                    individualAssessmentNamesDecoded0?.append(string0)
                }
            }
        }
        individualAssessmentNames = individualAssessmentNamesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeCertificatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificatesOutputError>
}

extension DescribeCertificatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCertificatesInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeCertificatesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeCertificatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificatesOutputError>
}

public struct DescribeCertificatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificatesOutputError>
}

public struct DescribeCertificatesInput: Swift.Equatable {
    /// <p>Filters applied to the certificates described in the form of key-value pairs.</p>
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 10</p>
    public let maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeCertificatesInputBody: Swift.Equatable {
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeCertificatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCertificatesOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCertificatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCertificatesOutputResponse(certificates: \(Swift.String(describing: certificates)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificates = output.certificates
            self.marker = output.marker
        } else {
            self.certificates = nil
            self.marker = nil
        }
    }
}

public struct DescribeCertificatesOutputResponse: Swift.Equatable {
    /// <p>The Secure Sockets Layer (SSL) certificates associated with the replication
    ///          instance.</p>
    public let certificates: [DatabaseMigrationClientTypes.Certificate]?
    /// <p>The pagination token.</p>
    public let marker: Swift.String?

    public init (
        certificates: [DatabaseMigrationClientTypes.Certificate]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.marker = marker
    }
}

struct DescribeCertificatesOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let certificates: [DatabaseMigrationClientTypes.Certificate]?
}

extension DescribeCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificates = "Certificates"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let certificatesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Certificate?].self, forKey: .certificates)
        var certificatesDecoded0:[DatabaseMigrationClientTypes.Certificate]? = nil
        if let certificatesContainer = certificatesContainer {
            certificatesDecoded0 = [DatabaseMigrationClientTypes.Certificate]()
            for structure0 in certificatesContainer {
                if let structure0 = structure0 {
                    certificatesDecoded0?.append(structure0)
                }
            }
        }
        certificates = certificatesDecoded0
    }
}

public struct DescribeConnectionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConnectionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConnectionsOutputError>
}

extension DescribeConnectionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConnectionsInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeConnectionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeConnectionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConnectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConnectionsOutputError>
}

public struct DescribeConnectionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConnectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConnectionsOutputError>
}

/// <p></p>
public struct DescribeConnectionsInput: Swift.Equatable {
    /// <p>The filters applied to the connection.</p>
    ///          <p>Valid filter names: endpoint-arn | replication-instance-arn</p>
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeConnectionsInputBody: Swift.Equatable {
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeConnectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConnectionsOutputResponse(connections: \(Swift.String(describing: connections)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
            self.marker = output.marker
        } else {
            self.connections = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeConnectionsOutputResponse: Swift.Equatable {
    /// <p>A description of the connections.</p>
    public let connections: [DatabaseMigrationClientTypes.Connection]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?

    public init (
        connections: [DatabaseMigrationClientTypes.Connection]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.connections = connections
        self.marker = marker
    }
}

struct DescribeConnectionsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let connections: [DatabaseMigrationClientTypes.Connection]?
}

extension DescribeConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connections = "Connections"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let connectionsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[DatabaseMigrationClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [DatabaseMigrationClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
    }
}

public struct DescribeEndpointSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointSettingsOutputError>
}

extension DescribeEndpointSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointSettingsInput(engineName: \(Swift.String(describing: engineName)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeEndpointSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineName = "EngineName"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineName = engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeEndpointSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointSettingsOutputError>
}

public struct DescribeEndpointSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointSettingsOutputError>
}

public struct DescribeEndpointSettingsInput: Swift.Equatable {
    /// <p>The databse engine used for your source or target endpoint.</p>
    public let engineName: Swift.String?
    /// <p>An optional pagination token provided by a previous request. If this parameter is specified,
    ///          the response includes only records beyond the marker, up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response
    ///          so that the remaining results can be retrieved.</p>
    public let maxRecords: Swift.Int?

    public init (
        engineName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.engineName = engineName
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeEndpointSettingsInputBody: Swift.Equatable {
    public let engineName: Swift.String?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeEndpointSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineName = "EngineName"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEndpointSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointSettingsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointSettingsOutputResponse(endpointSettings: \(Swift.String(describing: endpointSettings)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeEndpointSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEndpointSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointSettings = output.endpointSettings
            self.marker = output.marker
        } else {
            self.endpointSettings = nil
            self.marker = nil
        }
    }
}

public struct DescribeEndpointSettingsOutputResponse: Swift.Equatable {
    /// <p>Descriptions of the endpoint settings available for your source or target database engine.</p>
    public let endpointSettings: [DatabaseMigrationClientTypes.EndpointSetting]?
    /// <p>An optional pagination token provided by a previous request. If this parameter is specified,
    ///          the response includes only records beyond the marker, up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: Swift.String?

    public init (
        endpointSettings: [DatabaseMigrationClientTypes.EndpointSetting]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.endpointSettings = endpointSettings
        self.marker = marker
    }
}

struct DescribeEndpointSettingsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let endpointSettings: [DatabaseMigrationClientTypes.EndpointSetting]?
}

extension DescribeEndpointSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointSettings = "EndpointSettings"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let endpointSettingsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.EndpointSetting?].self, forKey: .endpointSettings)
        var endpointSettingsDecoded0:[DatabaseMigrationClientTypes.EndpointSetting]? = nil
        if let endpointSettingsContainer = endpointSettingsContainer {
            endpointSettingsDecoded0 = [DatabaseMigrationClientTypes.EndpointSetting]()
            for structure0 in endpointSettingsContainer {
                if let structure0 = structure0 {
                    endpointSettingsDecoded0?.append(structure0)
                }
            }
        }
        endpointSettings = endpointSettingsDecoded0
    }
}

public struct DescribeEndpointTypesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointTypesOutputError>
}

extension DescribeEndpointTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointTypesInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeEndpointTypesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeEndpointTypesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointTypesOutputError>
}

public struct DescribeEndpointTypesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointTypesOutputError>
}

/// <p></p>
public struct DescribeEndpointTypesInput: Swift.Equatable {
    /// <p>Filters applied to the endpoint types.</p>
    ///          <p>Valid filter names: engine-name | endpoint-type</p>
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeEndpointTypesInputBody: Swift.Equatable {
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeEndpointTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEndpointTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointTypesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointTypesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointTypesOutputResponse(marker: \(Swift.String(describing: marker)), supportedEndpointTypes: \(Swift.String(describing: supportedEndpointTypes)))"}
}

extension DescribeEndpointTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEndpointTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.supportedEndpointTypes = output.supportedEndpointTypes
        } else {
            self.marker = nil
            self.supportedEndpointTypes = nil
        }
    }
}

/// <p></p>
public struct DescribeEndpointTypesOutputResponse: Swift.Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p>The types of endpoints that are supported.</p>
    public let supportedEndpointTypes: [DatabaseMigrationClientTypes.SupportedEndpointType]?

    public init (
        marker: Swift.String? = nil,
        supportedEndpointTypes: [DatabaseMigrationClientTypes.SupportedEndpointType]? = nil
    )
    {
        self.marker = marker
        self.supportedEndpointTypes = supportedEndpointTypes
    }
}

struct DescribeEndpointTypesOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let supportedEndpointTypes: [DatabaseMigrationClientTypes.SupportedEndpointType]?
}

extension DescribeEndpointTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case supportedEndpointTypes = "SupportedEndpointTypes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let supportedEndpointTypesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.SupportedEndpointType?].self, forKey: .supportedEndpointTypes)
        var supportedEndpointTypesDecoded0:[DatabaseMigrationClientTypes.SupportedEndpointType]? = nil
        if let supportedEndpointTypesContainer = supportedEndpointTypesContainer {
            supportedEndpointTypesDecoded0 = [DatabaseMigrationClientTypes.SupportedEndpointType]()
            for structure0 in supportedEndpointTypesContainer {
                if let structure0 = structure0 {
                    supportedEndpointTypesDecoded0?.append(structure0)
                }
            }
        }
        supportedEndpointTypes = supportedEndpointTypesDecoded0
    }
}

public struct DescribeEndpointsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointsOutputError>
}

extension DescribeEndpointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointsInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeEndpointsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeEndpointsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointsOutputError>
}

public struct DescribeEndpointsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointsOutputError>
}

/// <p></p>
public struct DescribeEndpointsInput: Swift.Equatable {
    /// <p>Filters applied to the endpoints.</p>
    ///          <p>Valid filter names: endpoint-arn | endpoint-type | endpoint-id | engine-name</p>
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeEndpointsInputBody: Swift.Equatable {
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointsOutputResponse(endpoints: \(Swift.String(describing: endpoints)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
            self.marker = output.marker
        } else {
            self.endpoints = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeEndpointsOutputResponse: Swift.Equatable {
    /// <p>Endpoint description.</p>
    public let endpoints: [DatabaseMigrationClientTypes.Endpoint]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?

    public init (
        endpoints: [DatabaseMigrationClientTypes.Endpoint]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.marker = marker
    }
}

struct DescribeEndpointsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let endpoints: [DatabaseMigrationClientTypes.Endpoint]?
}

extension DescribeEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[DatabaseMigrationClientTypes.Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [DatabaseMigrationClientTypes.Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

public struct DescribeEventCategoriesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventCategoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventCategoriesOutputError>
}

extension DescribeEventCategoriesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventCategoriesInput(filters: \(Swift.String(describing: filters)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension DescribeEventCategoriesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
    }
}

public struct DescribeEventCategoriesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventCategoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventCategoriesOutputError>
}

public struct DescribeEventCategoriesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventCategoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventCategoriesOutputError>
}

/// <p></p>
public struct DescribeEventCategoriesInput: Swift.Equatable {
    /// <p>Filters applied to the event categories.</p>
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    /// <p> The type of AWS DMS resource that generates events. </p>
    ///          <p>Valid values: replication-instance | replication-task</p>
    public let sourceType: Swift.String?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        sourceType: Swift.String? = nil
    )
    {
        self.filters = filters
        self.sourceType = sourceType
    }
}

struct DescribeEventCategoriesInputBody: Swift.Equatable {
    public let sourceType: Swift.String?
    public let filters: [DatabaseMigrationClientTypes.Filter]?
}

extension DescribeEventCategoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case sourceType = "SourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension DescribeEventCategoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventCategoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventCategoriesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventCategoriesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventCategoriesOutputResponse(eventCategoryGroupList: \(Swift.String(describing: eventCategoryGroupList)))"}
}

extension DescribeEventCategoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventCategoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventCategoryGroupList = output.eventCategoryGroupList
        } else {
            self.eventCategoryGroupList = nil
        }
    }
}

/// <p></p>
public struct DescribeEventCategoriesOutputResponse: Swift.Equatable {
    /// <p>A list of event categories.</p>
    public let eventCategoryGroupList: [DatabaseMigrationClientTypes.EventCategoryGroup]?

    public init (
        eventCategoryGroupList: [DatabaseMigrationClientTypes.EventCategoryGroup]? = nil
    )
    {
        self.eventCategoryGroupList = eventCategoryGroupList
    }
}

struct DescribeEventCategoriesOutputResponseBody: Swift.Equatable {
    public let eventCategoryGroupList: [DatabaseMigrationClientTypes.EventCategoryGroup]?
}

extension DescribeEventCategoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventCategoryGroupList = "EventCategoryGroupList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventCategoryGroupListContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.EventCategoryGroup?].self, forKey: .eventCategoryGroupList)
        var eventCategoryGroupListDecoded0:[DatabaseMigrationClientTypes.EventCategoryGroup]? = nil
        if let eventCategoryGroupListContainer = eventCategoryGroupListContainer {
            eventCategoryGroupListDecoded0 = [DatabaseMigrationClientTypes.EventCategoryGroup]()
            for structure0 in eventCategoryGroupListContainer {
                if let structure0 = structure0 {
                    eventCategoryGroupListDecoded0?.append(structure0)
                }
            }
        }
        eventCategoryGroupList = eventCategoryGroupListDecoded0
    }
}

public struct DescribeEventSubscriptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSubscriptionsOutputError>
}

extension DescribeEventSubscriptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventSubscriptionsInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), subscriptionName: \(Swift.String(describing: subscriptionName)))"}
}

extension DescribeEventSubscriptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case subscriptionName = "SubscriptionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let subscriptionName = subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
    }
}

public struct DescribeEventSubscriptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSubscriptionsOutputError>
}

public struct DescribeEventSubscriptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSubscriptionsOutputError>
}

/// <p></p>
public struct DescribeEventSubscriptionsInput: Swift.Equatable {
    /// <p>Filters applied to event subscriptions.</p>
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The name of the AWS DMS event subscription to be described.</p>
    public let subscriptionName: Swift.String?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.subscriptionName = subscriptionName
    }
}

struct DescribeEventSubscriptionsInputBody: Swift.Equatable {
    public let subscriptionName: Swift.String?
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeEventSubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case subscriptionName = "SubscriptionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEventSubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventSubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventSubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventSubscriptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventSubscriptionsOutputResponse(eventSubscriptionsList: \(Swift.String(describing: eventSubscriptionsList)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeEventSubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscriptionsList = output.eventSubscriptionsList
            self.marker = output.marker
        } else {
            self.eventSubscriptionsList = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeEventSubscriptionsOutputResponse: Swift.Equatable {
    /// <p>A list of event subscriptions.</p>
    public let eventSubscriptionsList: [DatabaseMigrationClientTypes.EventSubscription]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?

    public init (
        eventSubscriptionsList: [DatabaseMigrationClientTypes.EventSubscription]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.eventSubscriptionsList = eventSubscriptionsList
        self.marker = marker
    }
}

struct DescribeEventSubscriptionsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let eventSubscriptionsList: [DatabaseMigrationClientTypes.EventSubscription]?
}

extension DescribeEventSubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscriptionsList = "EventSubscriptionsList"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let eventSubscriptionsListContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.EventSubscription?].self, forKey: .eventSubscriptionsList)
        var eventSubscriptionsListDecoded0:[DatabaseMigrationClientTypes.EventSubscription]? = nil
        if let eventSubscriptionsListContainer = eventSubscriptionsListContainer {
            eventSubscriptionsListDecoded0 = [DatabaseMigrationClientTypes.EventSubscription]()
            for structure0 in eventSubscriptionsListContainer {
                if let structure0 = structure0 {
                    eventSubscriptionsListDecoded0?.append(structure0)
                }
            }
        }
        eventSubscriptionsList = eventSubscriptionsListDecoded0
    }
}

public struct DescribeEventsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

extension DescribeEventsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventsInput(duration: \(Swift.String(describing: duration)), endTime: \(Swift.String(describing: endTime)), eventCategories: \(Swift.String(describing: eventCategories)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), sourceIdentifier: \(Swift.String(describing: sourceIdentifier)), sourceType: \(Swift.String(describing: sourceType)), startTime: \(Swift.String(describing: startTime)))"}
}

extension DescribeEventsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case eventCategories = "EventCategories"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for eventcategorieslist0 in eventCategories {
                try eventCategoriesContainer.encode(eventcategorieslist0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let sourceIdentifier = sourceIdentifier {
            try encodeContainer.encode(sourceIdentifier, forKey: .sourceIdentifier)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct DescribeEventsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

/// <p></p>
public struct DescribeEventsInput: Swift.Equatable {
    /// <p>The duration of the events to be listed.</p>
    public let duration: Swift.Int?
    /// <p>The end time for the events to be listed.</p>
    public let endTime: ClientRuntime.Date?
    /// <p>A list of event categories for the source type that you've chosen.</p>
    public let eventCategories: [Swift.String]?
    /// <p>Filters applied to events.</p>
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p> The identifier of an event source.</p>
    public let sourceIdentifier: Swift.String?
    /// <p>The type of AWS DMS resource that generates events.</p>
    ///          <p>Valid values: replication-instance | replication-task</p>
    public let sourceType: DatabaseMigrationClientTypes.SourceType?
    /// <p>The start time for the events to be listed.</p>
    public let startTime: ClientRuntime.Date?

    public init (
        duration: Swift.Int? = nil,
        endTime: ClientRuntime.Date? = nil,
        eventCategories: [Swift.String]? = nil,
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        sourceIdentifier: Swift.String? = nil,
        sourceType: DatabaseMigrationClientTypes.SourceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.eventCategories = eventCategories
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

struct DescribeEventsInputBody: Swift.Equatable {
    public let sourceIdentifier: Swift.String?
    public let sourceType: DatabaseMigrationClientTypes.SourceType?
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
    public let duration: Swift.Int?
    public let eventCategories: [Swift.String]?
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case eventCategories = "EventCategories"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[Swift.String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [Swift.String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventsOutputResponse(events: \(Swift.String(describing: events)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.marker = output.marker
        } else {
            self.events = nil
            self.marker = nil
        }
    }
}

/// <p></p>
public struct DescribeEventsOutputResponse: Swift.Equatable {
    /// <p>The events described.</p>
    public let events: [DatabaseMigrationClientTypes.Event]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?

    public init (
        events: [DatabaseMigrationClientTypes.Event]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.events = events
        self.marker = marker
    }
}

struct DescribeEventsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let events: [DatabaseMigrationClientTypes.Event]?
}

extension DescribeEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let eventsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[DatabaseMigrationClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [DatabaseMigrationClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

public struct DescribeOrderableReplicationInstancesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrderableReplicationInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOrderableReplicationInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrderableReplicationInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOrderableReplicationInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrderableReplicationInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrderableReplicationInstancesOutputError>
}

extension DescribeOrderableReplicationInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOrderableReplicationInstancesInput(marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeOrderableReplicationInstancesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeOrderableReplicationInstancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrderableReplicationInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOrderableReplicationInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrderableReplicationInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOrderableReplicationInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrderableReplicationInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrderableReplicationInstancesOutputError>
}

public struct DescribeOrderableReplicationInstancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrderableReplicationInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOrderableReplicationInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrderableReplicationInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOrderableReplicationInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrderableReplicationInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrderableReplicationInstancesOutputError>
}

/// <p></p>
public struct DescribeOrderableReplicationInstancesInput: Swift.Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeOrderableReplicationInstancesInputBody: Swift.Equatable {
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeOrderableReplicationInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeOrderableReplicationInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrderableReplicationInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrderableReplicationInstancesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrderableReplicationInstancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOrderableReplicationInstancesOutputResponse(marker: \(Swift.String(describing: marker)), orderableReplicationInstances: \(Swift.String(describing: orderableReplicationInstances)))"}
}

extension DescribeOrderableReplicationInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOrderableReplicationInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.orderableReplicationInstances = output.orderableReplicationInstances
        } else {
            self.marker = nil
            self.orderableReplicationInstances = nil
        }
    }
}

/// <p></p>
public struct DescribeOrderableReplicationInstancesOutputResponse: Swift.Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p>The order-able replication instances available.</p>
    public let orderableReplicationInstances: [DatabaseMigrationClientTypes.OrderableReplicationInstance]?

    public init (
        marker: Swift.String? = nil,
        orderableReplicationInstances: [DatabaseMigrationClientTypes.OrderableReplicationInstance]? = nil
    )
    {
        self.marker = marker
        self.orderableReplicationInstances = orderableReplicationInstances
    }
}

struct DescribeOrderableReplicationInstancesOutputResponseBody: Swift.Equatable {
    public let orderableReplicationInstances: [DatabaseMigrationClientTypes.OrderableReplicationInstance]?
    public let marker: Swift.String?
}

extension DescribeOrderableReplicationInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case orderableReplicationInstances = "OrderableReplicationInstances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderableReplicationInstancesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.OrderableReplicationInstance?].self, forKey: .orderableReplicationInstances)
        var orderableReplicationInstancesDecoded0:[DatabaseMigrationClientTypes.OrderableReplicationInstance]? = nil
        if let orderableReplicationInstancesContainer = orderableReplicationInstancesContainer {
            orderableReplicationInstancesDecoded0 = [DatabaseMigrationClientTypes.OrderableReplicationInstance]()
            for structure0 in orderableReplicationInstancesContainer {
                if let structure0 = structure0 {
                    orderableReplicationInstancesDecoded0?.append(structure0)
                }
            }
        }
        orderableReplicationInstances = orderableReplicationInstancesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribePendingMaintenanceActionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePendingMaintenanceActionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePendingMaintenanceActionsOutputError>
}

extension DescribePendingMaintenanceActionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePendingMaintenanceActionsInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)))"}
}

extension DescribePendingMaintenanceActionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct DescribePendingMaintenanceActionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePendingMaintenanceActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePendingMaintenanceActionsOutputError>
}

public struct DescribePendingMaintenanceActionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePendingMaintenanceActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePendingMaintenanceActionsOutputError>
}

/// <p></p>
public struct DescribePendingMaintenanceActionsInput: Swift.Equatable {
    /// <p></p>
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: Swift.String?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DescribePendingMaintenanceActionsInputBody: Swift.Equatable {
    public let replicationInstanceArn: Swift.String?
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    public let marker: Swift.String?
    public let maxRecords: Swift.Int?
}

extension DescribePendingMaintenanceActionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribePendingMaintenanceActionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePendingMaintenanceActionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePendingMaintenanceActionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePendingMaintenanceActionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePendingMaintenanceActionsOutputResponse(marker: \(Swift.String(describing: marker)), pendingMaintenanceActions: \(Swift.String(describing: pendingMaintenanceActions)))"}
}

extension DescribePendingMaintenanceActionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePendingMaintenanceActionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.pendingMaintenanceActions = output.pendingMaintenanceActions
        } else {
            self.marker = nil
            self.pendingMaintenanceActions = nil
        }
    }
}

/// <p></p>
public struct DescribePendingMaintenanceActionsOutputResponse: Swift.Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p>The pending maintenance action.</p>
    public let pendingMaintenanceActions: [DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]?

    public init (
        marker: Swift.String? = nil,
        pendingMaintenanceActions: [DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]? = nil
    )
    {
        self.marker = marker
        self.pendingMaintenanceActions = pendingMaintenanceActions
    }
}

struct DescribePendingMaintenanceActionsOutputResponseBody: Swift.Equatable {
    public let pendingMaintenanceActions: [DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]?
    public let marker: Swift.String?
}

extension DescribePendingMaintenanceActionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case pendingMaintenanceActions = "PendingMaintenanceActions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pendingMaintenanceActionsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions?].self, forKey: .pendingMaintenanceActions)
        var pendingMaintenanceActionsDecoded0:[DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]? = nil
        if let pendingMaintenanceActionsContainer = pendingMaintenanceActionsContainer {
            pendingMaintenanceActionsDecoded0 = [DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]()
            for structure0 in pendingMaintenanceActionsContainer {
                if let structure0 = structure0 {
                    pendingMaintenanceActionsDecoded0?.append(structure0)
                }
            }
        }
        pendingMaintenanceActions = pendingMaintenanceActionsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeRefreshSchemasStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRefreshSchemasStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRefreshSchemasStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRefreshSchemasStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRefreshSchemasStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRefreshSchemasStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRefreshSchemasStatusOutputError>
}

extension DescribeRefreshSchemasStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRefreshSchemasStatusInput(endpointArn: \(Swift.String(describing: endpointArn)))"}
}

extension DescribeRefreshSchemasStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
    }
}

public struct DescribeRefreshSchemasStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRefreshSchemasStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRefreshSchemasStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRefreshSchemasStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRefreshSchemasStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRefreshSchemasStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRefreshSchemasStatusOutputError>
}

public struct DescribeRefreshSchemasStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRefreshSchemasStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRefreshSchemasStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRefreshSchemasStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRefreshSchemasStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRefreshSchemasStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRefreshSchemasStatusOutputError>
}

/// <p></p>
public struct DescribeRefreshSchemasStatusInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct DescribeRefreshSchemasStatusInputBody: Swift.Equatable {
    public let endpointArn: Swift.String?
}

extension DescribeRefreshSchemasStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension DescribeRefreshSchemasStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRefreshSchemasStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRefreshSchemasStatusOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRefreshSchemasStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRefreshSchemasStatusOutputResponse(refreshSchemasStatus: \(Swift.String(describing: refreshSchemasStatus)))"}
}

extension DescribeRefreshSchemasStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRefreshSchemasStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.refreshSchemasStatus = output.refreshSchemasStatus
        } else {
            self.refreshSchemasStatus = nil
        }
    }
}

/// <p></p>
public struct DescribeRefreshSchemasStatusOutputResponse: Swift.Equatable {
    /// <p>The status of the schema.</p>
    public let refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus?

    public init (
        refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus? = nil
    )
    {
        self.refreshSchemasStatus = refreshSchemasStatus
    }
}

struct DescribeRefreshSchemasStatusOutputResponseBody: Swift.Equatable {
    public let refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus?
}

extension DescribeRefreshSchemasStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case refreshSchemasStatus = "RefreshSchemasStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refreshSchemasStatusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RefreshSchemasStatus.self, forKey: .refreshSchemasStatus)
        refreshSchemasStatus = refreshSchemasStatusDecoded
    }
}

public struct DescribeReplicationInstanceTaskLogsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationInstanceTaskLogsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationInstanceTaskLogsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationInstanceTaskLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationInstanceTaskLogsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationInstanceTaskLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationInstanceTaskLogsOutputError>
}

extension DescribeReplicationInstanceTaskLogsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplicationInstanceTaskLogsInput(marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)))"}
}

extension DescribeReplicationInstanceTaskLogsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct DescribeReplicationInstanceTaskLogsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationInstanceTaskLogsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationInstanceTaskLogsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationInstanceTaskLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationInstanceTaskLogsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationInstanceTaskLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationInstanceTaskLogsOutputError>
}

public struct DescribeReplicationInstanceTaskLogsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationInstanceTaskLogsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationInstanceTaskLogsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationInstanceTaskLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationInstanceTaskLogsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationInstanceTaskLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationInstanceTaskLogsOutputError>
}

public struct DescribeReplicationInstanceTaskLogsInput: Swift.Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DescribeReplicationInstanceTaskLogsInputBody: Swift.Equatable {
    public let replicationInstanceArn: Swift.String?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeReplicationInstanceTaskLogsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationInstanceTaskLogsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationInstanceTaskLogsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationInstanceTaskLogsOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationInstanceTaskLogsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplicationInstanceTaskLogsOutputResponse(marker: \(Swift.String(describing: marker)), replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)), replicationInstanceTaskLogs: \(Swift.String(describing: replicationInstanceTaskLogs)))"}
}

extension DescribeReplicationInstanceTaskLogsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReplicationInstanceTaskLogsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationInstanceArn = output.replicationInstanceArn
            self.replicationInstanceTaskLogs = output.replicationInstanceTaskLogs
        } else {
            self.marker = nil
            self.replicationInstanceArn = nil
            self.replicationInstanceTaskLogs = nil
        }
    }
}

public struct DescribeReplicationInstanceTaskLogsOutputResponse: Swift.Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: Swift.String?
    /// <p>An array of replication task log metadata. Each member of the array contains the
    ///          replication task name, ARN, and task log size (in bytes). </p>
    public let replicationInstanceTaskLogs: [DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]?

    public init (
        marker: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationInstanceTaskLogs: [DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]? = nil
    )
    {
        self.marker = marker
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationInstanceTaskLogs = replicationInstanceTaskLogs
    }
}

struct DescribeReplicationInstanceTaskLogsOutputResponseBody: Swift.Equatable {
    public let replicationInstanceArn: Swift.String?
    public let replicationInstanceTaskLogs: [DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]?
    public let marker: Swift.String?
}

extension DescribeReplicationInstanceTaskLogsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceTaskLogs = "ReplicationInstanceTaskLogs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let replicationInstanceTaskLogsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationInstanceTaskLog?].self, forKey: .replicationInstanceTaskLogs)
        var replicationInstanceTaskLogsDecoded0:[DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]? = nil
        if let replicationInstanceTaskLogsContainer = replicationInstanceTaskLogsContainer {
            replicationInstanceTaskLogsDecoded0 = [DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]()
            for structure0 in replicationInstanceTaskLogsContainer {
                if let structure0 = structure0 {
                    replicationInstanceTaskLogsDecoded0?.append(structure0)
                }
            }
        }
        replicationInstanceTaskLogs = replicationInstanceTaskLogsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeReplicationInstancesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationInstancesOutputError>
}

extension DescribeReplicationInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplicationInstancesInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeReplicationInstancesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeReplicationInstancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationInstancesOutputError>
}

public struct DescribeReplicationInstancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationInstancesOutputError>
}

/// <p></p>
public struct DescribeReplicationInstancesInput: Swift.Equatable {
    /// <p>Filters applied to replication instances.</p>
    ///          <p>Valid filter names: replication-instance-arn | replication-instance-id |
    ///          replication-instance-class | engine-version</p>
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationInstancesInputBody: Swift.Equatable {
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeReplicationInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationInstancesOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationInstancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplicationInstancesOutputResponse(marker: \(Swift.String(describing: marker)), replicationInstances: \(Swift.String(describing: replicationInstances)))"}
}

extension DescribeReplicationInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReplicationInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationInstances = output.replicationInstances
        } else {
            self.marker = nil
            self.replicationInstances = nil
        }
    }
}

/// <p></p>
public struct DescribeReplicationInstancesOutputResponse: Swift.Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p>The replication instances described.</p>
    public let replicationInstances: [DatabaseMigrationClientTypes.ReplicationInstance]?

    public init (
        marker: Swift.String? = nil,
        replicationInstances: [DatabaseMigrationClientTypes.ReplicationInstance]? = nil
    )
    {
        self.marker = marker
        self.replicationInstances = replicationInstances
    }
}

struct DescribeReplicationInstancesOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let replicationInstances: [DatabaseMigrationClientTypes.ReplicationInstance]?
}

extension DescribeReplicationInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationInstances = "ReplicationInstances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationInstancesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationInstance?].self, forKey: .replicationInstances)
        var replicationInstancesDecoded0:[DatabaseMigrationClientTypes.ReplicationInstance]? = nil
        if let replicationInstancesContainer = replicationInstancesContainer {
            replicationInstancesDecoded0 = [DatabaseMigrationClientTypes.ReplicationInstance]()
            for structure0 in replicationInstancesContainer {
                if let structure0 = structure0 {
                    replicationInstancesDecoded0?.append(structure0)
                }
            }
        }
        replicationInstances = replicationInstancesDecoded0
    }
}

public struct DescribeReplicationSubnetGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationSubnetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationSubnetGroupsOutputError>
}

extension DescribeReplicationSubnetGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplicationSubnetGroupsInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeReplicationSubnetGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeReplicationSubnetGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationSubnetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationSubnetGroupsOutputError>
}

public struct DescribeReplicationSubnetGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationSubnetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationSubnetGroupsOutputError>
}

/// <p></p>
public struct DescribeReplicationSubnetGroupsInput: Swift.Equatable {
    /// <p>Filters applied to replication subnet groups.</p>
    ///          <p>Valid filter names: replication-subnet-group-id</p>
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationSubnetGroupsInputBody: Swift.Equatable {
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeReplicationSubnetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationSubnetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationSubnetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationSubnetGroupsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationSubnetGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplicationSubnetGroupsOutputResponse(marker: \(Swift.String(describing: marker)), replicationSubnetGroups: \(Swift.String(describing: replicationSubnetGroups)))"}
}

extension DescribeReplicationSubnetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReplicationSubnetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationSubnetGroups = output.replicationSubnetGroups
        } else {
            self.marker = nil
            self.replicationSubnetGroups = nil
        }
    }
}

/// <p></p>
public struct DescribeReplicationSubnetGroupsOutputResponse: Swift.Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p>A description of the replication subnet groups.</p>
    public let replicationSubnetGroups: [DatabaseMigrationClientTypes.ReplicationSubnetGroup]?

    public init (
        marker: Swift.String? = nil,
        replicationSubnetGroups: [DatabaseMigrationClientTypes.ReplicationSubnetGroup]? = nil
    )
    {
        self.marker = marker
        self.replicationSubnetGroups = replicationSubnetGroups
    }
}

struct DescribeReplicationSubnetGroupsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let replicationSubnetGroups: [DatabaseMigrationClientTypes.ReplicationSubnetGroup]?
}

extension DescribeReplicationSubnetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationSubnetGroups = "ReplicationSubnetGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationSubnetGroupsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationSubnetGroup?].self, forKey: .replicationSubnetGroups)
        var replicationSubnetGroupsDecoded0:[DatabaseMigrationClientTypes.ReplicationSubnetGroup]? = nil
        if let replicationSubnetGroupsContainer = replicationSubnetGroupsContainer {
            replicationSubnetGroupsDecoded0 = [DatabaseMigrationClientTypes.ReplicationSubnetGroup]()
            for structure0 in replicationSubnetGroupsContainer {
                if let structure0 = structure0 {
                    replicationSubnetGroupsDecoded0?.append(structure0)
                }
            }
        }
        replicationSubnetGroups = replicationSubnetGroupsDecoded0
    }
}

public struct DescribeReplicationTaskAssessmentResultsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationTaskAssessmentResultsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationTaskAssessmentResultsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationTaskAssessmentResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationTaskAssessmentResultsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationTaskAssessmentResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationTaskAssessmentResultsOutputError>
}

extension DescribeReplicationTaskAssessmentResultsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplicationTaskAssessmentResultsInput(marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), replicationTaskArn: \(Swift.String(describing: replicationTaskArn)))"}
}

extension DescribeReplicationTaskAssessmentResultsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

public struct DescribeReplicationTaskAssessmentResultsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationTaskAssessmentResultsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationTaskAssessmentResultsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationTaskAssessmentResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationTaskAssessmentResultsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationTaskAssessmentResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationTaskAssessmentResultsOutputError>
}

public struct DescribeReplicationTaskAssessmentResultsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationTaskAssessmentResultsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationTaskAssessmentResultsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationTaskAssessmentResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationTaskAssessmentResultsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationTaskAssessmentResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationTaskAssessmentResultsOutputError>
}

/// <p></p>
public struct DescribeReplicationTaskAssessmentResultsInput: Swift.Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the task. When this input
    ///          parameter is specified, the API returns only one result and ignore the values of the
    ///             <code>MaxRecords</code> and <code>Marker</code> parameters. </p>
    public let replicationTaskArn: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationTaskArn = replicationTaskArn
    }
}

struct DescribeReplicationTaskAssessmentResultsInputBody: Swift.Equatable {
    public let replicationTaskArn: Swift.String?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeReplicationTaskAssessmentResultsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationTaskAssessmentResultsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationTaskAssessmentResultsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationTaskAssessmentResultsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationTaskAssessmentResultsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplicationTaskAssessmentResultsOutputResponse(bucketName: \(Swift.String(describing: bucketName)), marker: \(Swift.String(describing: marker)), replicationTaskAssessmentResults: \(Swift.String(describing: replicationTaskAssessmentResults)))"}
}

extension DescribeReplicationTaskAssessmentResultsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReplicationTaskAssessmentResultsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bucketName = output.bucketName
            self.marker = output.marker
            self.replicationTaskAssessmentResults = output.replicationTaskAssessmentResults
        } else {
            self.bucketName = nil
            self.marker = nil
            self.replicationTaskAssessmentResults = nil
        }
    }
}

/// <p></p>
public struct DescribeReplicationTaskAssessmentResultsOutputResponse: Swift.Equatable {
    /// <p>- The Amazon S3 bucket where the task assessment report is located. </p>
    public let bucketName: Swift.String?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p> The task assessment report. </p>
    public let replicationTaskAssessmentResults: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]?

    public init (
        bucketName: Swift.String? = nil,
        marker: Swift.String? = nil,
        replicationTaskAssessmentResults: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]? = nil
    )
    {
        self.bucketName = bucketName
        self.marker = marker
        self.replicationTaskAssessmentResults = replicationTaskAssessmentResults
    }
}

struct DescribeReplicationTaskAssessmentResultsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let bucketName: Swift.String?
    public let replicationTaskAssessmentResults: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]?
}

extension DescribeReplicationTaskAssessmentResultsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case marker = "Marker"
        case replicationTaskAssessmentResults = "ReplicationTaskAssessmentResults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let replicationTaskAssessmentResultsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult?].self, forKey: .replicationTaskAssessmentResults)
        var replicationTaskAssessmentResultsDecoded0:[DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]? = nil
        if let replicationTaskAssessmentResultsContainer = replicationTaskAssessmentResultsContainer {
            replicationTaskAssessmentResultsDecoded0 = [DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]()
            for structure0 in replicationTaskAssessmentResultsContainer {
                if let structure0 = structure0 {
                    replicationTaskAssessmentResultsDecoded0?.append(structure0)
                }
            }
        }
        replicationTaskAssessmentResults = replicationTaskAssessmentResultsDecoded0
    }
}

public struct DescribeReplicationTaskAssessmentRunsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationTaskAssessmentRunsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationTaskAssessmentRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationTaskAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationTaskAssessmentRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationTaskAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationTaskAssessmentRunsOutputError>
}

extension DescribeReplicationTaskAssessmentRunsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplicationTaskAssessmentRunsInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeReplicationTaskAssessmentRunsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeReplicationTaskAssessmentRunsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationTaskAssessmentRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationTaskAssessmentRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationTaskAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationTaskAssessmentRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationTaskAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationTaskAssessmentRunsOutputError>
}

public struct DescribeReplicationTaskAssessmentRunsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationTaskAssessmentRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationTaskAssessmentRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationTaskAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationTaskAssessmentRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationTaskAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationTaskAssessmentRunsOutputError>
}

/// <p></p>
public struct DescribeReplicationTaskAssessmentRunsInput: Swift.Equatable {
    /// <p>Filters applied to the premigration assessment runs described in the form of key-value pairs.</p>
    ///          <p>Valid filter names: <code>replication-task-assessment-run-arn</code>, <code>replication-task-arn</code>,
    ///          <code>replication-instance-arn</code>, <code>status</code>
    ///          </p>
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    /// <p>An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of records to include in the response. If more records exist than the
    ///          specified <code>MaxRecords</code> value, a pagination token called a marker is included in
    ///          the response so that the remaining results can be retrieved.</p>
    public let maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationTaskAssessmentRunsInputBody: Swift.Equatable {
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeReplicationTaskAssessmentRunsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationTaskAssessmentRunsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationTaskAssessmentRunsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationTaskAssessmentRunsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationTaskAssessmentRunsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplicationTaskAssessmentRunsOutputResponse(marker: \(Swift.String(describing: marker)), replicationTaskAssessmentRuns: \(Swift.String(describing: replicationTaskAssessmentRuns)))"}
}

extension DescribeReplicationTaskAssessmentRunsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReplicationTaskAssessmentRunsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationTaskAssessmentRuns = output.replicationTaskAssessmentRuns
        } else {
            self.marker = nil
            self.replicationTaskAssessmentRuns = nil
        }
    }
}

/// <p></p>
public struct DescribeReplicationTaskAssessmentRunsOutputResponse: Swift.Equatable {
    /// <p>A pagination token returned for you to pass to a subsequent request. If you pass this
    ///          token as the <code>Marker</code> value in a subsequent request, the response includes only
    ///          records beyond the marker, up to the value specified in the request by
    ///             <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p>One or more premigration assessment runs as specified by <code>Filters</code>.</p>
    public let replicationTaskAssessmentRuns: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]?

    public init (
        marker: Swift.String? = nil,
        replicationTaskAssessmentRuns: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]? = nil
    )
    {
        self.marker = marker
        self.replicationTaskAssessmentRuns = replicationTaskAssessmentRuns
    }
}

struct DescribeReplicationTaskAssessmentRunsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let replicationTaskAssessmentRuns: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]?
}

extension DescribeReplicationTaskAssessmentRunsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationTaskAssessmentRuns = "ReplicationTaskAssessmentRuns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationTaskAssessmentRunsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?].self, forKey: .replicationTaskAssessmentRuns)
        var replicationTaskAssessmentRunsDecoded0:[DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]? = nil
        if let replicationTaskAssessmentRunsContainer = replicationTaskAssessmentRunsContainer {
            replicationTaskAssessmentRunsDecoded0 = [DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]()
            for structure0 in replicationTaskAssessmentRunsContainer {
                if let structure0 = structure0 {
                    replicationTaskAssessmentRunsDecoded0?.append(structure0)
                }
            }
        }
        replicationTaskAssessmentRuns = replicationTaskAssessmentRunsDecoded0
    }
}

public struct DescribeReplicationTaskIndividualAssessmentsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationTaskIndividualAssessmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationTaskIndividualAssessmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationTaskIndividualAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationTaskIndividualAssessmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationTaskIndividualAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationTaskIndividualAssessmentsOutputError>
}

extension DescribeReplicationTaskIndividualAssessmentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplicationTaskIndividualAssessmentsInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeReplicationTaskIndividualAssessmentsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeReplicationTaskIndividualAssessmentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationTaskIndividualAssessmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationTaskIndividualAssessmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationTaskIndividualAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationTaskIndividualAssessmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationTaskIndividualAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationTaskIndividualAssessmentsOutputError>
}

public struct DescribeReplicationTaskIndividualAssessmentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationTaskIndividualAssessmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationTaskIndividualAssessmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationTaskIndividualAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationTaskIndividualAssessmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationTaskIndividualAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationTaskIndividualAssessmentsOutputError>
}

/// <p></p>
public struct DescribeReplicationTaskIndividualAssessmentsInput: Swift.Equatable {
    /// <p>Filters applied to the individual assessments described in the form of key-value
    ///          pairs.</p>
    ///          <p>Valid filter names: <code>replication-task-assessment-run-arn</code>,
    ///             <code>replication-task-arn</code>, <code>status</code>
    ///          </p>
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    /// <p>An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of records to include in the response. If more records exist than the
    ///          specified <code>MaxRecords</code> value, a pagination token called a marker is included in
    ///          the response so that the remaining results can be retrieved.</p>
    public let maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationTaskIndividualAssessmentsInputBody: Swift.Equatable {
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeReplicationTaskIndividualAssessmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationTaskIndividualAssessmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationTaskIndividualAssessmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationTaskIndividualAssessmentsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationTaskIndividualAssessmentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplicationTaskIndividualAssessmentsOutputResponse(marker: \(Swift.String(describing: marker)), replicationTaskIndividualAssessments: \(Swift.String(describing: replicationTaskIndividualAssessments)))"}
}

extension DescribeReplicationTaskIndividualAssessmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReplicationTaskIndividualAssessmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationTaskIndividualAssessments = output.replicationTaskIndividualAssessments
        } else {
            self.marker = nil
            self.replicationTaskIndividualAssessments = nil
        }
    }
}

/// <p></p>
public struct DescribeReplicationTaskIndividualAssessmentsOutputResponse: Swift.Equatable {
    /// <p>A pagination token returned for you to pass to a subsequent request. If you pass this
    ///          token as the <code>Marker</code> value in a subsequent request, the response includes only
    ///          records beyond the marker, up to the value specified in the request by
    ///             <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p>One or more individual assessments as specified by <code>Filters</code>.</p>
    public let replicationTaskIndividualAssessments: [DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]?

    public init (
        marker: Swift.String? = nil,
        replicationTaskIndividualAssessments: [DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]? = nil
    )
    {
        self.marker = marker
        self.replicationTaskIndividualAssessments = replicationTaskIndividualAssessments
    }
}

struct DescribeReplicationTaskIndividualAssessmentsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let replicationTaskIndividualAssessments: [DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]?
}

extension DescribeReplicationTaskIndividualAssessmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationTaskIndividualAssessments = "ReplicationTaskIndividualAssessments"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationTaskIndividualAssessmentsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment?].self, forKey: .replicationTaskIndividualAssessments)
        var replicationTaskIndividualAssessmentsDecoded0:[DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]? = nil
        if let replicationTaskIndividualAssessmentsContainer = replicationTaskIndividualAssessmentsContainer {
            replicationTaskIndividualAssessmentsDecoded0 = [DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]()
            for structure0 in replicationTaskIndividualAssessmentsContainer {
                if let structure0 = structure0 {
                    replicationTaskIndividualAssessmentsDecoded0?.append(structure0)
                }
            }
        }
        replicationTaskIndividualAssessments = replicationTaskIndividualAssessmentsDecoded0
    }
}

public struct DescribeReplicationTasksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationTasksOutputError>
}

extension DescribeReplicationTasksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplicationTasksInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), withoutSettings: \(Swift.String(describing: withoutSettings)))"}
}

extension DescribeReplicationTasksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case withoutSettings = "WithoutSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let withoutSettings = withoutSettings {
            try encodeContainer.encode(withoutSettings, forKey: .withoutSettings)
        }
    }
}

public struct DescribeReplicationTasksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationTasksOutputError>
}

public struct DescribeReplicationTasksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplicationTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplicationTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplicationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplicationTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplicationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplicationTasksOutputError>
}

/// <p></p>
public struct DescribeReplicationTasksInput: Swift.Equatable {
    /// <p>Filters applied to replication tasks.</p>
    ///          <p>Valid filter names: replication-task-arn | replication-task-id | migration-type |
    ///          endpoint-arn | replication-instance-arn</p>
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>An option to set to avoid returning information about settings. Use this to reduce
    ///          overhead when setting information is too large. To use this option, choose
    ///             <code>true</code>; otherwise, choose <code>false</code> (the default).</p>
    public let withoutSettings: Swift.Bool?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        withoutSettings: Swift.Bool? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.withoutSettings = withoutSettings
    }
}

struct DescribeReplicationTasksInputBody: Swift.Equatable {
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
    public let withoutSettings: Swift.Bool?
}

extension DescribeReplicationTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case withoutSettings = "WithoutSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let withoutSettingsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .withoutSettings)
        withoutSettings = withoutSettingsDecoded
    }
}

extension DescribeReplicationTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationTasksOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationTasksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplicationTasksOutputResponse(marker: \(Swift.String(describing: marker)), replicationTasks: \(Swift.String(describing: replicationTasks)))"}
}

extension DescribeReplicationTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReplicationTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationTasks = output.replicationTasks
        } else {
            self.marker = nil
            self.replicationTasks = nil
        }
    }
}

/// <p></p>
public struct DescribeReplicationTasksOutputResponse: Swift.Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p>A description of the replication tasks.</p>
    public let replicationTasks: [DatabaseMigrationClientTypes.ReplicationTask]?

    public init (
        marker: Swift.String? = nil,
        replicationTasks: [DatabaseMigrationClientTypes.ReplicationTask]? = nil
    )
    {
        self.marker = marker
        self.replicationTasks = replicationTasks
    }
}

struct DescribeReplicationTasksOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let replicationTasks: [DatabaseMigrationClientTypes.ReplicationTask]?
}

extension DescribeReplicationTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationTasks = "ReplicationTasks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationTasksContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationTask?].self, forKey: .replicationTasks)
        var replicationTasksDecoded0:[DatabaseMigrationClientTypes.ReplicationTask]? = nil
        if let replicationTasksContainer = replicationTasksContainer {
            replicationTasksDecoded0 = [DatabaseMigrationClientTypes.ReplicationTask]()
            for structure0 in replicationTasksContainer {
                if let structure0 = structure0 {
                    replicationTasksDecoded0?.append(structure0)
                }
            }
        }
        replicationTasks = replicationTasksDecoded0
    }
}

public struct DescribeSchemasInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSchemasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSchemasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSchemasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSchemasOutputError>
}

extension DescribeSchemasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSchemasInput(endpointArn: \(Swift.String(describing: endpointArn)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeSchemasInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

public struct DescribeSchemasInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSchemasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSchemasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSchemasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSchemasOutputError>
}

public struct DescribeSchemasInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSchemasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSchemasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSchemasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSchemasOutputError>
}

/// <p></p>
public struct DescribeSchemasInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: Swift.String?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        endpointArn: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.endpointArn = endpointArn
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeSchemasInputBody: Swift.Equatable {
    public let endpointArn: Swift.String?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
}

extension DescribeSchemasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeSchemasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSchemasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSchemasOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSchemasOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSchemasOutputResponse(marker: \(Swift.String(describing: marker)), schemas: \(Swift.String(describing: schemas)))"}
}

extension DescribeSchemasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSchemasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.schemas = output.schemas
        } else {
            self.marker = nil
            self.schemas = nil
        }
    }
}

/// <p></p>
public struct DescribeSchemasOutputResponse: Swift.Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p>The described schema.</p>
    public let schemas: [Swift.String]?

    public init (
        marker: Swift.String? = nil,
        schemas: [Swift.String]? = nil
    )
    {
        self.marker = marker
        self.schemas = schemas
    }
}

struct DescribeSchemasOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let schemas: [Swift.String]?
}

extension DescribeSchemasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case schemas = "Schemas"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let schemasContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .schemas)
        var schemasDecoded0:[Swift.String]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [Swift.String]()
            for string0 in schemasContainer {
                if let string0 = string0 {
                    schemasDecoded0?.append(string0)
                }
            }
        }
        schemas = schemasDecoded0
    }
}

public struct DescribeTableStatisticsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTableStatisticsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTableStatisticsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTableStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTableStatisticsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTableStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTableStatisticsOutputError>
}

extension DescribeTableStatisticsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTableStatisticsInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), replicationTaskArn: \(Swift.String(describing: replicationTaskArn)))"}
}

extension DescribeTableStatisticsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

public struct DescribeTableStatisticsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTableStatisticsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTableStatisticsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTableStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTableStatisticsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTableStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTableStatisticsOutputError>
}

public struct DescribeTableStatisticsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTableStatisticsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTableStatisticsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTableStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTableStatisticsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTableStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTableStatisticsOutputError>
}

/// <p></p>
public struct DescribeTableStatisticsInput: Swift.Equatable {
    /// <p>Filters applied to table statistics.</p>
    ///          <p>Valid filter names: schema-name | table-name | table-state</p>
    ///          <p>A combination of filters creates an AND condition where each record matches all
    ///          specified filters.</p>
    public let filters: [DatabaseMigrationClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than
    ///          the specified <code>MaxRecords</code> value, a pagination token called a marker is included
    ///          in the response so that the remaining results can be retrieved. </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 500.</p>
    public let maxRecords: Swift.Int?
    /// <p>The Amazon Resource Name (ARN) of the replication task.</p>
    public let replicationTaskArn: Swift.String?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationTaskArn = replicationTaskArn
    }
}

struct DescribeTableStatisticsInputBody: Swift.Equatable {
    public let replicationTaskArn: Swift.String?
    public let maxRecords: Swift.Int?
    public let marker: Swift.String?
    public let filters: [DatabaseMigrationClientTypes.Filter]?
}

extension DescribeTableStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension DescribeTableStatisticsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTableStatisticsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTableStatisticsOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTableStatisticsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTableStatisticsOutputResponse(marker: \(Swift.String(describing: marker)), replicationTaskArn: \(Swift.String(describing: replicationTaskArn)), tableStatistics: \(Swift.String(describing: tableStatistics)))"}
}

extension DescribeTableStatisticsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTableStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationTaskArn = output.replicationTaskArn
            self.tableStatistics = output.tableStatistics
        } else {
            self.marker = nil
            self.replicationTaskArn = nil
            self.tableStatistics = nil
        }
    }
}

/// <p></p>
public struct DescribeTableStatisticsOutputResponse: Swift.Equatable {
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///          specified, the response includes only records beyond the marker, up to the value specified
    ///          by <code>MaxRecords</code>. </p>
    public let marker: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the replication task.</p>
    public let replicationTaskArn: Swift.String?
    /// <p>The table statistics.</p>
    public let tableStatistics: [DatabaseMigrationClientTypes.TableStatistics]?

    public init (
        marker: Swift.String? = nil,
        replicationTaskArn: Swift.String? = nil,
        tableStatistics: [DatabaseMigrationClientTypes.TableStatistics]? = nil
    )
    {
        self.marker = marker
        self.replicationTaskArn = replicationTaskArn
        self.tableStatistics = tableStatistics
    }
}

struct DescribeTableStatisticsOutputResponseBody: Swift.Equatable {
    public let replicationTaskArn: Swift.String?
    public let tableStatistics: [DatabaseMigrationClientTypes.TableStatistics]?
    public let marker: Swift.String?
}

extension DescribeTableStatisticsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationTaskArn = "ReplicationTaskArn"
        case tableStatistics = "TableStatistics"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let tableStatisticsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.TableStatistics?].self, forKey: .tableStatistics)
        var tableStatisticsDecoded0:[DatabaseMigrationClientTypes.TableStatistics]? = nil
        if let tableStatisticsContainer = tableStatisticsContainer {
            tableStatisticsDecoded0 = [DatabaseMigrationClientTypes.TableStatistics]()
            for structure0 in tableStatisticsContainer {
                if let structure0 = structure0 {
                    tableStatisticsDecoded0?.append(structure0)
                }
            }
        }
        tableStatistics = tableStatisticsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum DmsSslModeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case require
        case verifyCa
        case verifyFull
        case sdkUnknown(Swift.String)

        public static var allCases: [DmsSslModeValue] {
            return [
                .none,
                .require,
                .verifyCa,
                .verifyFull,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .require: return "require"
            case .verifyCa: return "verify-ca"
            case .verifyFull: return "verify-full"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DmsSslModeValue(rawValue: rawValue) ?? DmsSslModeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.DmsTransferSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension DatabaseMigrationClientTypes.DmsTransferSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DmsTransferSettings(bucketName: \(Swift.String(describing: bucketName)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p> The settings in JSON format for the DMS Transfer type source endpoint. </p>
    public struct DmsTransferSettings: Swift.Equatable {
        /// <p> The name of the S3 bucket to use. </p>
        public let bucketName: Swift.String?
        /// <p> The IAM role that has permission to access the Amazon S3 bucket. </p>
        public let serviceAccessRoleArn: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }
    }

}

extension DatabaseMigrationClientTypes.DocDbSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case docsToInvestigate = "DocsToInvestigate"
        case extractDocId = "ExtractDocId"
        case kmsKeyId = "KmsKeyId"
        case nestingLevel = "NestingLevel"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let docsToInvestigate = docsToInvestigate {
            try encodeContainer.encode(docsToInvestigate, forKey: .docsToInvestigate)
        }
        if let extractDocId = extractDocId {
            try encodeContainer.encode(extractDocId, forKey: .extractDocId)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let nestingLevel = nestingLevel {
            try encodeContainer.encode(nestingLevel.rawValue, forKey: .nestingLevel)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let nestingLevelDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.NestingLevelValue.self, forKey: .nestingLevel)
        nestingLevel = nestingLevelDecoded
        let extractDocIdDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .extractDocId)
        extractDocId = extractDocIdDecoded
        let docsToInvestigateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .docsToInvestigate)
        docsToInvestigate = docsToInvestigateDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.DocDbSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocDbSettings(databaseName: \(Swift.String(describing: databaseName)), docsToInvestigate: \(Swift.String(describing: docsToInvestigate)), extractDocId: \(Swift.String(describing: extractDocId)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), nestingLevel: \(Swift.String(describing: nestingLevel)), password: \(Swift.String(describing: password)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), username: \(Swift.String(describing: username)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that defines a DocumentDB endpoint.</p>
    public struct DocDbSettings: Swift.Equatable {
        /// <p> The database name on the DocumentDB source endpoint. </p>
        public let databaseName: Swift.String?
        /// <p> Indicates the number of documents to preview to determine the document organization.
        ///          Use this setting when <code>NestingLevel</code> is set to <code>"one"</code>. </p>
        ///          <p>Must be a positive value greater than <code>0</code>. Default value is
        ///          <code>1000</code>.</p>
        public let docsToInvestigate: Swift.Int?
        /// <p> Specifies the document ID. Use this setting when <code>NestingLevel</code> is set to
        ///          <code>"none"</code>. </p>
        ///          <p>Default value is <code>"false"</code>. </p>
        public let extractDocId: Swift.Bool?
        /// <p>The AWS KMS key identifier that is used to encrypt the content on the replication
        ///          instance. If you don't specify a value for the <code>KmsKeyId</code> parameter, then
        ///          AWS DMS uses your default encryption key. AWS KMS creates the default encryption key for
        ///          your AWS account. Your AWS account has a different default encryption key for each AWS
        ///          Region.</p>
        public let kmsKeyId: Swift.String?
        /// <p> Specifies either document or table mode. </p>
        ///          <p>Default value is <code>"none"</code>. Specify <code>"none"</code> to use document mode.
        ///          Specify <code>"one"</code> to use table mode.</p>
        public let nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue?
        /// <p> The password for the user account you use to access the DocumentDB source endpoint.
        ///       </p>
        public let password: Swift.String?
        /// <p> The port value for the DocumentDB source endpoint. </p>
        public let port: Swift.Int?
        /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
        ///          trusted entity and grants the required permissions to access the value in
        ///          <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
        ///          Manager secret that allows access to the DocumentDB endpoint.</p>
        ///          <note>
        ///             <p>You can specify one of two sets of values for these permissions. You can specify the
        ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
        ///             clear-text values for <code>UserName</code>, <code>Password</code>,
        ///             <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
        ///             information on creating this <code>SecretsManagerSecret</code> and the
        ///             <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
        ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
        ///                resources</a> in the <i>AWS Database Migration Service User
        ///                   Guide</i>.</p>
        ///          </note>
        public let secretsManagerAccessRoleArn: Swift.String?
        /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code>
        ///          that contains the DocumentDB endpoint connection details.</p>
        public let secretsManagerSecretId: Swift.String?
        /// <p> The name of the server on the DocumentDB source endpoint. </p>
        public let serverName: Swift.String?
        /// <p>The user name you use to access the DocumentDB source endpoint. </p>
        public let username: Swift.String?

        public init (
            databaseName: Swift.String? = nil,
            docsToInvestigate: Swift.Int? = nil,
            extractDocId: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.docsToInvestigate = docsToInvestigate
            self.extractDocId = extractDocId
            self.kmsKeyId = kmsKeyId
            self.nestingLevel = nestingLevel
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.DynamoDbSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
    }
}

extension DatabaseMigrationClientTypes.DynamoDbSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DynamoDbSettings(serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides the Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM)
    ///          role used to define an Amazon DynamoDB target endpoint.</p>
    public struct DynamoDbSettings: Swift.Equatable {
        /// <p> The Amazon Resource Name (ARN) used by the service access IAM role. </p>
        public let serviceAccessRoleArn: Swift.String?

        public init (
            serviceAccessRoleArn: Swift.String? = nil
        )
        {
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }
    }

}

extension DatabaseMigrationClientTypes.ElasticsearchSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointUri = "EndpointUri"
        case errorRetryDuration = "ErrorRetryDuration"
        case fullLoadErrorPercentage = "FullLoadErrorPercentage"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointUri = endpointUri {
            try encodeContainer.encode(endpointUri, forKey: .endpointUri)
        }
        if let errorRetryDuration = errorRetryDuration {
            try encodeContainer.encode(errorRetryDuration, forKey: .errorRetryDuration)
        }
        if let fullLoadErrorPercentage = fullLoadErrorPercentage {
            try encodeContainer.encode(fullLoadErrorPercentage, forKey: .fullLoadErrorPercentage)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let endpointUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointUri)
        endpointUri = endpointUriDecoded
        let fullLoadErrorPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fullLoadErrorPercentage)
        fullLoadErrorPercentage = fullLoadErrorPercentageDecoded
        let errorRetryDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorRetryDuration)
        errorRetryDuration = errorRetryDurationDecoded
    }
}

extension DatabaseMigrationClientTypes.ElasticsearchSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ElasticsearchSettings(endpointUri: \(Swift.String(describing: endpointUri)), errorRetryDuration: \(Swift.String(describing: errorRetryDuration)), fullLoadErrorPercentage: \(Swift.String(describing: fullLoadErrorPercentage)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that defines an Elasticsearch endpoint.</p>
    public struct ElasticsearchSettings: Swift.Equatable {
        /// <p>The endpoint for the Elasticsearch cluster. AWS DMS uses HTTPS if a transport
        ///          protocol (http/https) is not specified.</p>
        public let endpointUri: Swift.String?
        /// <p>The maximum number of seconds for which DMS retries failed API requests to the
        ///          Elasticsearch cluster.</p>
        public let errorRetryDuration: Swift.Int?
        /// <p>The maximum percentage of records that can fail to be written before a full load
        ///             operation stops.</p>
        ///          <p>To avoid early failure, this counter is only effective after 1000 records
        ///          are transferred. Elasticsearch also has the concept of error monitoring during the
        ///          last 10 minutes of an Observation Window. If transfer of all records fail in the
        ///          last 10 minutes, the full load operation stops. </p>
        public let fullLoadErrorPercentage: Swift.Int?
        /// <p>The Amazon Resource Name (ARN) used by service to access the IAM role.</p>
        public let serviceAccessRoleArn: Swift.String?

        public init (
            endpointUri: Swift.String? = nil,
            errorRetryDuration: Swift.Int? = nil,
            fullLoadErrorPercentage: Swift.Int? = nil,
            serviceAccessRoleArn: Swift.String? = nil
        )
        {
            self.endpointUri = endpointUri
            self.errorRetryDuration = errorRetryDuration
            self.fullLoadErrorPercentage = fullLoadErrorPercentage
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum EncodingTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plain
        case plainDictionary
        case rleDictionary
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingTypeValue] {
            return [
                .plain,
                .plainDictionary,
                .rleDictionary,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plain: return "plain"
            case .plainDictionary: return "plain-dictionary"
            case .rleDictionary: return "rle-dictionary"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncodingTypeValue(rawValue: rawValue) ?? EncodingTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum EncryptionModeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sseKms
        case sseS3
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionModeValue] {
            return [
                .sseKms,
                .sseS3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sseKms: return "sse-kms"
            case .sseS3: return "sse-s3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionModeValue(rawValue: rawValue) ?? EncryptionModeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.Endpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineDisplayName = "EngineDisplayName"
        case engineName = "EngineName"
        case externalId = "ExternalId"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case iBMDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case kmsKeyId = "KmsKeyId"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redshiftSettings = "RedshiftSettings"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case status = "Status"
        case sybaseSettings = "SybaseSettings"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dmsTransferSettings = dmsTransferSettings {
            try encodeContainer.encode(dmsTransferSettings, forKey: .dmsTransferSettings)
        }
        if let docDbSettings = docDbSettings {
            try encodeContainer.encode(docDbSettings, forKey: .docDbSettings)
        }
        if let dynamoDbSettings = dynamoDbSettings {
            try encodeContainer.encode(dynamoDbSettings, forKey: .dynamoDbSettings)
        }
        if let elasticsearchSettings = elasticsearchSettings {
            try encodeContainer.encode(elasticsearchSettings, forKey: .elasticsearchSettings)
        }
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let endpointIdentifier = endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineDisplayName = engineDisplayName {
            try encodeContainer.encode(engineDisplayName, forKey: .engineDisplayName)
        }
        if let engineName = engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let externalTableDefinition = externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let extraConnectionAttributes = extraConnectionAttributes {
            try encodeContainer.encode(extraConnectionAttributes, forKey: .extraConnectionAttributes)
        }
        if let iBMDb2Settings = iBMDb2Settings {
            try encodeContainer.encode(iBMDb2Settings, forKey: .iBMDb2Settings)
        }
        if let kafkaSettings = kafkaSettings {
            try encodeContainer.encode(kafkaSettings, forKey: .kafkaSettings)
        }
        if let kinesisSettings = kinesisSettings {
            try encodeContainer.encode(kinesisSettings, forKey: .kinesisSettings)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let microsoftSQLServerSettings = microsoftSQLServerSettings {
            try encodeContainer.encode(microsoftSQLServerSettings, forKey: .microsoftSQLServerSettings)
        }
        if let mongoDbSettings = mongoDbSettings {
            try encodeContainer.encode(mongoDbSettings, forKey: .mongoDbSettings)
        }
        if let mySQLSettings = mySQLSettings {
            try encodeContainer.encode(mySQLSettings, forKey: .mySQLSettings)
        }
        if let neptuneSettings = neptuneSettings {
            try encodeContainer.encode(neptuneSettings, forKey: .neptuneSettings)
        }
        if let oracleSettings = oracleSettings {
            try encodeContainer.encode(oracleSettings, forKey: .oracleSettings)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let postgreSQLSettings = postgreSQLSettings {
            try encodeContainer.encode(postgreSQLSettings, forKey: .postgreSQLSettings)
        }
        if let redshiftSettings = redshiftSettings {
            try encodeContainer.encode(redshiftSettings, forKey: .redshiftSettings)
        }
        if let s3Settings = s3Settings {
            try encodeContainer.encode(s3Settings, forKey: .s3Settings)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let sslMode = sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let sybaseSettings = sybaseSettings {
            try encodeContainer.encode(sybaseSettings, forKey: .sybaseSettings)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let engineDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineDisplayName)
        engineDisplayName = engineDisplayNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let extraConnectionAttributesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extraConnectionAttributes)
        extraConnectionAttributes = extraConnectionAttributesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let dynamoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DynamoDbSettings.self, forKey: .dynamoDbSettings)
        dynamoDbSettings = dynamoDbSettingsDecoded
        let s3SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.S3Settings.self, forKey: .s3Settings)
        s3Settings = s3SettingsDecoded
        let dmsTransferSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsTransferSettings.self, forKey: .dmsTransferSettings)
        dmsTransferSettings = dmsTransferSettingsDecoded
        let mongoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MongoDbSettings.self, forKey: .mongoDbSettings)
        mongoDbSettings = mongoDbSettingsDecoded
        let kinesisSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KinesisSettings.self, forKey: .kinesisSettings)
        kinesisSettings = kinesisSettingsDecoded
        let kafkaSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KafkaSettings.self, forKey: .kafkaSettings)
        kafkaSettings = kafkaSettingsDecoded
        let elasticsearchSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ElasticsearchSettings.self, forKey: .elasticsearchSettings)
        elasticsearchSettings = elasticsearchSettingsDecoded
        let neptuneSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.NeptuneSettings.self, forKey: .neptuneSettings)
        neptuneSettings = neptuneSettingsDecoded
        let redshiftSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedshiftSettings.self, forKey: .redshiftSettings)
        redshiftSettings = redshiftSettingsDecoded
        let postgreSQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.PostgreSQLSettings.self, forKey: .postgreSQLSettings)
        postgreSQLSettings = postgreSQLSettingsDecoded
        let mySQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MySQLSettings.self, forKey: .mySQLSettings)
        mySQLSettings = mySQLSettingsDecoded
        let oracleSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.OracleSettings.self, forKey: .oracleSettings)
        oracleSettings = oracleSettingsDecoded
        let sybaseSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SybaseSettings.self, forKey: .sybaseSettings)
        sybaseSettings = sybaseSettingsDecoded
        let microsoftSQLServerSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MicrosoftSQLServerSettings.self, forKey: .microsoftSQLServerSettings)
        microsoftSQLServerSettings = microsoftSQLServerSettingsDecoded
        let iBMDb2SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.IBMDb2Settings.self, forKey: .iBMDb2Settings)
        iBMDb2Settings = iBMDb2SettingsDecoded
        let docDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DocDbSettings.self, forKey: .docDbSettings)
        docDbSettings = docDbSettingsDecoded
    }
}

extension DatabaseMigrationClientTypes.Endpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Endpoint(certificateArn: \(Swift.String(describing: certificateArn)), databaseName: \(Swift.String(describing: databaseName)), dmsTransferSettings: \(Swift.String(describing: dmsTransferSettings)), docDbSettings: \(Swift.String(describing: docDbSettings)), dynamoDbSettings: \(Swift.String(describing: dynamoDbSettings)), elasticsearchSettings: \(Swift.String(describing: elasticsearchSettings)), endpointArn: \(Swift.String(describing: endpointArn)), endpointIdentifier: \(Swift.String(describing: endpointIdentifier)), endpointType: \(Swift.String(describing: endpointType)), engineDisplayName: \(Swift.String(describing: engineDisplayName)), engineName: \(Swift.String(describing: engineName)), externalId: \(Swift.String(describing: externalId)), externalTableDefinition: \(Swift.String(describing: externalTableDefinition)), extraConnectionAttributes: \(Swift.String(describing: extraConnectionAttributes)), iBMDb2Settings: \(Swift.String(describing: iBMDb2Settings)), kafkaSettings: \(Swift.String(describing: kafkaSettings)), kinesisSettings: \(Swift.String(describing: kinesisSettings)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), microsoftSQLServerSettings: \(Swift.String(describing: microsoftSQLServerSettings)), mongoDbSettings: \(Swift.String(describing: mongoDbSettings)), mySQLSettings: \(Swift.String(describing: mySQLSettings)), neptuneSettings: \(Swift.String(describing: neptuneSettings)), oracleSettings: \(Swift.String(describing: oracleSettings)), port: \(Swift.String(describing: port)), postgreSQLSettings: \(Swift.String(describing: postgreSQLSettings)), redshiftSettings: \(Swift.String(describing: redshiftSettings)), s3Settings: \(Swift.String(describing: s3Settings)), serverName: \(Swift.String(describing: serverName)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), sslMode: \(Swift.String(describing: sslMode)), status: \(Swift.String(describing: status)), sybaseSettings: \(Swift.String(describing: sybaseSettings)), username: \(Swift.String(describing: username)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Describes an endpoint of a database instance in response to operations such as the
    ///          following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CreateEndpoint</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DescribeEndpoint</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DescribeEndpointTypes</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ModifyEndpoint</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public struct Endpoint: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) used for SSL connection to the endpoint.</p>
        public let certificateArn: Swift.String?
        /// <p>The name of the database at the endpoint.</p>
        public let databaseName: Swift.String?
        /// <p>The settings in JSON format for the DMS transfer type of source endpoint. </p>
        ///          <p>Possible settings include the following:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>ServiceAccessRoleArn</code> - The IAM role that has permission to access the
        ///                Amazon S3 bucket.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>BucketName</code> - The name of the S3 bucket to use.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>CompressionType</code> - An optional parameter to use GZIP to compress the
        ///                target files. To use GZIP, set this value to <code>NONE</code> (the default). To keep
        ///                the files uncompressed, don't use this value.</p>
        ///             </li>
        ///          </ul>
        ///          <p>Shorthand syntax for these settings is as follows:
        ///             <code>ServiceAccessRoleArn=string,BucketName=string,CompressionType=string</code>
        ///          </p>
        ///          <p>JSON syntax for these settings is as follows: <code>{ "ServiceAccessRoleArn":
        ///             "string", "BucketName": "string", "CompressionType": "none"|"gzip" } </code>
        ///          </p>
        public let dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
        /// <p>Provides information that defines a DocumentDB endpoint.</p>
        public let docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
        /// <p>The settings for the DynamoDB target endpoint. For more information, see the
        ///             <code>DynamoDBSettings</code> structure.</p>
        public let dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
        /// <p>The settings for the Elasticsearch source endpoint. For more information, see the
        ///             <code>ElasticsearchSettings</code> structure.</p>
        public let elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
        /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
        public let endpointArn: Swift.String?
        /// <p>The database endpoint identifier. Identifiers must begin with a letter and must contain
        ///          only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two
        ///          consecutive hyphens.</p>
        public let endpointIdentifier: Swift.String?
        /// <p>The type of endpoint.  Valid values are <code>source</code> and <code>target</code>.</p>
        public let endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
        /// <p>The expanded name for the engine name. For example, if the <code>EngineName</code>
        ///          parameter is "aurora," this value would be "Amazon Aurora MySQL."</p>
        public let engineDisplayName: Swift.String?
        /// <p>The database engine name. Valid values, depending on the EndpointType, include
        ///             <code>"mysql"</code>, <code>"oracle"</code>, <code>"postgres"</code>,
        ///             <code>"mariadb"</code>, <code>"aurora"</code>, <code>"aurora-postgresql"</code>,
        ///             <code>"redshift"</code>, <code>"s3"</code>, <code>"db2"</code>, <code>"azuredb"</code>,
        ///             <code>"sybase"</code>, <code>"dynamodb"</code>, <code>"mongodb"</code>,
        ///             <code>"kinesis"</code>, <code>"kafka"</code>, <code>"elasticsearch"</code>,
        ///             <code>"documentdb"</code>, <code>"sqlserver"</code>, and <code>"neptune"</code>.</p>
        public let engineName: Swift.String?
        /// <p> Value returned by a call to CreateEndpoint that can be used for cross-account
        ///          validation. Use it on a subsequent call to CreateEndpoint to create the endpoint with a
        ///          cross-account. </p>
        public let externalId: Swift.String?
        /// <p>The external table definition.</p>
        public let externalTableDefinition: Swift.String?
        /// <p>Additional connection attributes used to connect to the endpoint.</p>
        public let extraConnectionAttributes: Swift.String?
        /// <p>The settings for the IBM Db2 LUW source endpoint. For more information, see the
        ///             <code>IBMDb2Settings</code> structure.
        ///       </p>
        public let iBMDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
        /// <p>The settings for the Apache Kafka target endpoint. For more information, see the
        ///          <code>KafkaSettings</code> structure.</p>
        public let kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
        /// <p>The settings for the Amazon Kinesis target endpoint. For more information, see the
        ///             <code>KinesisSettings</code> structure.</p>
        public let kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
        /// <p>An AWS KMS key identifier that is used to encrypt the connection parameters for the endpoint.</p>
        ///          <p>If you don't specify a value for the <code>KmsKeyId</code> parameter, then
        ///            AWS DMS uses your default encryption key.</p>
        ///          <p>AWS KMS creates the default encryption key for your AWS account. Your AWS account has a
        ///          different default encryption key for each AWS Region.</p>
        public let kmsKeyId: Swift.String?
        /// <p>The settings for the Microsoft SQL Server source and target endpoint. For more
        ///          information, see the <code>MicrosoftSQLServerSettings</code> structure.</p>
        public let microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
        /// <p>The settings for the MongoDB source endpoint. For more information, see the
        ///             <code>MongoDbSettings</code> structure.</p>
        public let mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
        /// <p>The settings for the MySQL source and target endpoint. For more information, see the
        ///             <code>MySQLSettings</code> structure.</p>
        public let mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
        /// <p>The settings for the Amazon Neptune target endpoint. For more information, see the
        ///          <code>NeptuneSettings</code> structure.</p>
        public let neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
        /// <p>The settings for the Oracle source and target endpoint. For more information, see the
        ///             <code>OracleSettings</code> structure.</p>
        public let oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
        /// <p>The port value used to access the endpoint.</p>
        public let port: Swift.Int?
        /// <p>The settings for the PostgreSQL source and target endpoint. For more information, see
        ///          the <code>PostgreSQLSettings</code> structure.</p>
        public let postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
        /// <p>Settings for the Amazon Redshift endpoint.</p>
        public let redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
        /// <p>The settings for the S3 target endpoint. For more information, see the
        ///             <code>S3Settings</code> structure.</p>
        public let s3Settings: DatabaseMigrationClientTypes.S3Settings?
        /// <p>The name of the server at the endpoint.</p>
        public let serverName: Swift.String?
        /// <p>The Amazon Resource Name (ARN) used by the service access IAM role.</p>
        public let serviceAccessRoleArn: Swift.String?
        /// <p>The SSL mode used to connect to the endpoint. The default value is <code>none</code>.</p>
        public let sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
        /// <p>The status of the endpoint.</p>
        public let status: Swift.String?
        /// <p>The settings for the SAP ASE source and target endpoint. For more information, see the
        ///             <code>SybaseSettings</code> structure.</p>
        public let sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
        /// <p>The user name used to connect to the endpoint.</p>
        public let username: Swift.String?

        public init (
            certificateArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings? = nil,
            docDbSettings: DatabaseMigrationClientTypes.DocDbSettings? = nil,
            dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings? = nil,
            elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings? = nil,
            endpointArn: Swift.String? = nil,
            endpointIdentifier: Swift.String? = nil,
            endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
            engineDisplayName: Swift.String? = nil,
            engineName: Swift.String? = nil,
            externalId: Swift.String? = nil,
            externalTableDefinition: Swift.String? = nil,
            extraConnectionAttributes: Swift.String? = nil,
            iBMDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings? = nil,
            kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings? = nil,
            kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings? = nil,
            kmsKeyId: Swift.String? = nil,
            microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings? = nil,
            mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings? = nil,
            mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings? = nil,
            neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings? = nil,
            oracleSettings: DatabaseMigrationClientTypes.OracleSettings? = nil,
            port: Swift.Int? = nil,
            postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings? = nil,
            redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings? = nil,
            s3Settings: DatabaseMigrationClientTypes.S3Settings? = nil,
            serverName: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil,
            status: Swift.String? = nil,
            sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings? = nil,
            username: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.dmsTransferSettings = dmsTransferSettings
            self.docDbSettings = docDbSettings
            self.dynamoDbSettings = dynamoDbSettings
            self.elasticsearchSettings = elasticsearchSettings
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.endpointType = endpointType
            self.engineDisplayName = engineDisplayName
            self.engineName = engineName
            self.externalId = externalId
            self.externalTableDefinition = externalTableDefinition
            self.extraConnectionAttributes = extraConnectionAttributes
            self.iBMDb2Settings = iBMDb2Settings
            self.kafkaSettings = kafkaSettings
            self.kinesisSettings = kinesisSettings
            self.kmsKeyId = kmsKeyId
            self.microsoftSQLServerSettings = microsoftSQLServerSettings
            self.mongoDbSettings = mongoDbSettings
            self.mySQLSettings = mySQLSettings
            self.neptuneSettings = neptuneSettings
            self.oracleSettings = oracleSettings
            self.port = port
            self.postgreSQLSettings = postgreSQLSettings
            self.redshiftSettings = redshiftSettings
            self.s3Settings = s3Settings
            self.serverName = serverName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sslMode = sslMode
            self.status = status
            self.sybaseSettings = sybaseSettings
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.EndpointSetting: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicability = "Applicability"
        case enumValues = "EnumValues"
        case intValueMax = "IntValueMax"
        case intValueMin = "IntValueMin"
        case name = "Name"
        case sensitive = "Sensitive"
        case type = "Type"
        case units = "Units"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicability = applicability {
            try encodeContainer.encode(applicability, forKey: .applicability)
        }
        if let enumValues = enumValues {
            var enumValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enumValues)
            for endpointsettingenumvalues0 in enumValues {
                try enumValuesContainer.encode(endpointsettingenumvalues0)
            }
        }
        if let intValueMax = intValueMax {
            try encodeContainer.encode(intValueMax, forKey: .intValueMax)
        }
        if let intValueMin = intValueMin {
            try encodeContainer.encode(intValueMin, forKey: .intValueMin)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sensitive = sensitive {
            try encodeContainer.encode(sensitive, forKey: .sensitive)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let units = units {
            try encodeContainer.encode(units, forKey: .units)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EndpointSettingTypeValue.self, forKey: .type)
        type = typeDecoded
        let enumValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .enumValues)
        var enumValuesDecoded0:[Swift.String]? = nil
        if let enumValuesContainer = enumValuesContainer {
            enumValuesDecoded0 = [Swift.String]()
            for string0 in enumValuesContainer {
                if let string0 = string0 {
                    enumValuesDecoded0?.append(string0)
                }
            }
        }
        enumValues = enumValuesDecoded0
        let sensitiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sensitive)
        sensitive = sensitiveDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .units)
        units = unitsDecoded
        let applicabilityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicability)
        applicability = applicabilityDecoded
        let intValueMinDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .intValueMin)
        intValueMin = intValueMinDecoded
        let intValueMaxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .intValueMax)
        intValueMax = intValueMaxDecoded
    }
}

extension DatabaseMigrationClientTypes.EndpointSetting: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointSetting(applicability: \(Swift.String(describing: applicability)), enumValues: \(Swift.String(describing: enumValues)), intValueMax: \(Swift.String(describing: intValueMax)), intValueMin: \(Swift.String(describing: intValueMin)), name: \(Swift.String(describing: name)), sensitive: \(Swift.String(describing: sensitive)), type: \(Swift.String(describing: type)), units: \(Swift.String(describing: units)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Endpoint settings.</p>
    public struct EndpointSetting: Swift.Equatable {
        /// <p>The relevance or validity of an endpoint setting for an engine name and its endpoint type.</p>
        public let applicability: Swift.String?
        /// <p>Enumerated values to use for this endpoint.</p>
        public let enumValues: [Swift.String]?
        /// <p>The maximum value of an endpoint setting that is of type <code>int</code>.</p>
        public let intValueMax: Swift.Int?
        /// <p>The minimum value of an endpoint setting that is of type <code>int</code>.</p>
        public let intValueMin: Swift.Int?
        /// <p>The name that you want to give the endpoint settings.</p>
        public let name: Swift.String?
        /// <p>A value that marks this endpoint setting as sensitive.</p>
        public let sensitive: Swift.Bool?
        /// <p>The type of endpoint.  Valid values are <code>source</code> and <code>target</code>.</p>
        public let type: DatabaseMigrationClientTypes.EndpointSettingTypeValue?
        /// <p>The unit of measure for this endpoint setting.</p>
        public let units: Swift.String?

        public init (
            applicability: Swift.String? = nil,
            enumValues: [Swift.String]? = nil,
            intValueMax: Swift.Int? = nil,
            intValueMin: Swift.Int? = nil,
            name: Swift.String? = nil,
            sensitive: Swift.Bool? = nil,
            type: DatabaseMigrationClientTypes.EndpointSettingTypeValue? = nil,
            units: Swift.String? = nil
        )
        {
            self.applicability = applicability
            self.enumValues = enumValues
            self.intValueMax = intValueMax
            self.intValueMin = intValueMin
            self.name = name
            self.sensitive = sensitive
            self.type = type
            self.units = units
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum EndpointSettingTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case `enum`
        case integer
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointSettingTypeValue] {
            return [
                .boolean,
                .enum,
                .integer,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "boolean"
            case .enum: return "enum"
            case .integer: return "integer"
            case .string: return "string"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointSettingTypeValue(rawValue: rawValue) ?? EndpointSettingTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.Event: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case eventCategories = "EventCategories"
        case message = "Message"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = date {
            try encodeContainer.encode(date.timeIntervalSince1970, forKey: .date)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for eventcategorieslist0 in eventCategories {
                try eventCategoriesContainer.encode(eventcategorieslist0)
            }
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let sourceIdentifier = sourceIdentifier {
            try encodeContainer.encode(sourceIdentifier, forKey: .sourceIdentifier)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[Swift.String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [Swift.String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let dateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .date)
        date = dateDecoded
    }
}

extension DatabaseMigrationClientTypes.Event: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Event(date: \(Swift.String(describing: date)), eventCategories: \(Swift.String(describing: eventCategories)), message: \(Swift.String(describing: message)), sourceIdentifier: \(Swift.String(describing: sourceIdentifier)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Describes an identifiable significant activity that affects a replication instance or
    ///          task. This object can provide the message, the available event categories, the date and
    ///          source of the event, and the AWS DMS resource type.</p>
    public struct Event: Swift.Equatable {
        /// <p>The date of the event.</p>
        public let date: ClientRuntime.Date?
        /// <p>The event categories available for the specified source type.</p>
        public let eventCategories: [Swift.String]?
        /// <p>The event message.</p>
        public let message: Swift.String?
        /// <p> The identifier of an event source.</p>
        public let sourceIdentifier: Swift.String?
        /// <p> The type of AWS DMS resource that generates events. </p>
        ///          <p>Valid values: replication-instance | endpoint | replication-task</p>
        public let sourceType: DatabaseMigrationClientTypes.SourceType?

        public init (
            date: ClientRuntime.Date? = nil,
            eventCategories: [Swift.String]? = nil,
            message: Swift.String? = nil,
            sourceIdentifier: Swift.String? = nil,
            sourceType: DatabaseMigrationClientTypes.SourceType? = nil
        )
        {
            self.date = date
            self.eventCategories = eventCategories
            self.message = message
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
        }
    }

}

extension DatabaseMigrationClientTypes.EventCategoryGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventCategories = "EventCategories"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for eventcategorieslist0 in eventCategories {
                try eventCategoriesContainer.encode(eventcategorieslist0)
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[Swift.String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [Swift.String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
    }
}

extension DatabaseMigrationClientTypes.EventCategoryGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventCategoryGroup(eventCategories: \(Swift.String(describing: eventCategories)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Lists categories of events subscribed to, and generated by, the applicable AWS DMS
    ///          resource type. This data type appears in response to the
    ///          <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_EventCategoryGroup.html">
    ///                <code>DescribeEventCategories</code>
    ///             </a>
    ///          action.</p>
    public struct EventCategoryGroup: Swift.Equatable {
        /// <p> A list of event categories from a source type that you've chosen.</p>
        public let eventCategories: [Swift.String]?
        /// <p> The type of AWS DMS resource that generates events. </p>
        ///          <p>Valid values: replication-instance | replication-server | security-group |
        ///          replication-task</p>
        public let sourceType: Swift.String?

        public init (
            eventCategories: [Swift.String]? = nil,
            sourceType: Swift.String? = nil
        )
        {
            self.eventCategories = eventCategories
            self.sourceType = sourceType
        }
    }

}

extension DatabaseMigrationClientTypes.EventSubscription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case custSubscriptionId = "CustSubscriptionId"
        case customerAwsId = "CustomerAwsId"
        case enabled = "Enabled"
        case eventCategoriesList = "EventCategoriesList"
        case snsTopicArn = "SnsTopicArn"
        case sourceIdsList = "SourceIdsList"
        case sourceType = "SourceType"
        case status = "Status"
        case subscriptionCreationTime = "SubscriptionCreationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let custSubscriptionId = custSubscriptionId {
            try encodeContainer.encode(custSubscriptionId, forKey: .custSubscriptionId)
        }
        if let customerAwsId = customerAwsId {
            try encodeContainer.encode(customerAwsId, forKey: .customerAwsId)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventCategoriesList = eventCategoriesList {
            var eventCategoriesListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategoriesList)
            for eventcategorieslist0 in eventCategoriesList {
                try eventCategoriesListContainer.encode(eventcategorieslist0)
            }
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sourceIdsList = sourceIdsList {
            var sourceIdsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceIdsList)
            for sourceidslist0 in sourceIdsList {
                try sourceIdsListContainer.encode(sourceidslist0)
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subscriptionCreationTime = subscriptionCreationTime {
            try encodeContainer.encode(subscriptionCreationTime, forKey: .subscriptionCreationTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerAwsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAwsId)
        customerAwsId = customerAwsIdDecoded
        let custSubscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .custSubscriptionId)
        custSubscriptionId = custSubscriptionIdDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let subscriptionCreationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionCreationTime)
        subscriptionCreationTime = subscriptionCreationTimeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceIdsListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceIdsList)
        var sourceIdsListDecoded0:[Swift.String]? = nil
        if let sourceIdsListContainer = sourceIdsListContainer {
            sourceIdsListDecoded0 = [Swift.String]()
            for string0 in sourceIdsListContainer {
                if let string0 = string0 {
                    sourceIdsListDecoded0?.append(string0)
                }
            }
        }
        sourceIdsList = sourceIdsListDecoded0
        let eventCategoriesListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategoriesList)
        var eventCategoriesListDecoded0:[Swift.String]? = nil
        if let eventCategoriesListContainer = eventCategoriesListContainer {
            eventCategoriesListDecoded0 = [Swift.String]()
            for string0 in eventCategoriesListContainer {
                if let string0 = string0 {
                    eventCategoriesListDecoded0?.append(string0)
                }
            }
        }
        eventCategoriesList = eventCategoriesListDecoded0
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension DatabaseMigrationClientTypes.EventSubscription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventSubscription(custSubscriptionId: \(Swift.String(describing: custSubscriptionId)), customerAwsId: \(Swift.String(describing: customerAwsId)), enabled: \(Swift.String(describing: enabled)), eventCategoriesList: \(Swift.String(describing: eventCategoriesList)), snsTopicArn: \(Swift.String(describing: snsTopicArn)), sourceIdsList: \(Swift.String(describing: sourceIdsList)), sourceType: \(Swift.String(describing: sourceType)), status: \(Swift.String(describing: status)), subscriptionCreationTime: \(Swift.String(describing: subscriptionCreationTime)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Describes an event notification subscription created by the <code>CreateEventSubscription</code>
    ///          operation.</p>
    public struct EventSubscription: Swift.Equatable {
        /// <p>The AWS DMS event notification subscription Id.</p>
        public let custSubscriptionId: Swift.String?
        /// <p>The AWS customer account associated with the AWS DMS event notification
        ///          subscription.</p>
        public let customerAwsId: Swift.String?
        /// <p>Boolean value that indicates if the event subscription is enabled.</p>
        public let enabled: Swift.Bool
        /// <p>A lists of event categories.</p>
        public let eventCategoriesList: [Swift.String]?
        /// <p>The topic ARN of the AWS DMS event notification subscription.</p>
        public let snsTopicArn: Swift.String?
        /// <p>A list of source Ids for the event subscription.</p>
        public let sourceIdsList: [Swift.String]?
        /// <p> The type of AWS DMS resource that generates events. </p>
        ///          <p>Valid values: replication-instance | replication-server | security-group |
        ///          replication-task</p>
        public let sourceType: Swift.String?
        /// <p>The status of the AWS DMS event notification subscription.</p>
        ///          <p>Constraints:</p>
        ///          <p>Can be one of the following: creating | modifying | deleting | active | no-permission |
        ///          topic-not-exist</p>
        ///          <p>The status "no-permission" indicates that AWS DMS no longer has permission to post to
        ///          the SNS topic. The status "topic-not-exist" indicates that the topic was deleted after the
        ///          subscription was created.</p>
        public let status: Swift.String?
        /// <p>The time the AWS DMS event notification subscription was created.</p>
        public let subscriptionCreationTime: Swift.String?

        public init (
            custSubscriptionId: Swift.String? = nil,
            customerAwsId: Swift.String? = nil,
            enabled: Swift.Bool = false,
            eventCategoriesList: [Swift.String]? = nil,
            snsTopicArn: Swift.String? = nil,
            sourceIdsList: [Swift.String]? = nil,
            sourceType: Swift.String? = nil,
            status: Swift.String? = nil,
            subscriptionCreationTime: Swift.String? = nil
        )
        {
            self.custSubscriptionId = custSubscriptionId
            self.customerAwsId = customerAwsId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
        }
    }

}

extension DatabaseMigrationClientTypes.Filter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervaluelist0 in values {
                try valuesContainer.encode(filtervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DatabaseMigrationClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Identifies the name and value of a filter object. This filter is used to limit the
    ///          number and type of AWS DMS objects that are returned for a particular
    ///             <code>Describe*</code> call or similar operation. Filters are used as an optional
    ///          parameter for certain API operations. </p>
    public struct Filter: Swift.Equatable {
        /// <p>The name of the filter as specified for a <code>Describe*</code> or similar
        ///          operation.</p>
        public let name: Swift.String?
        /// <p>The filter value, which can specify one or more values used to narrow the returned results.</p>
        public let values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension DatabaseMigrationClientTypes.IBMDb2Settings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentLsn = "CurrentLsn"
        case databaseName = "DatabaseName"
        case maxKBytesPerRead = "MaxKBytesPerRead"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case setDataCaptureChanges = "SetDataCaptureChanges"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentLsn = currentLsn {
            try encodeContainer.encode(currentLsn, forKey: .currentLsn)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let maxKBytesPerRead = maxKBytesPerRead {
            try encodeContainer.encode(maxKBytesPerRead, forKey: .maxKBytesPerRead)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let setDataCaptureChanges = setDataCaptureChanges {
            try encodeContainer.encode(setDataCaptureChanges, forKey: .setDataCaptureChanges)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let setDataCaptureChangesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .setDataCaptureChanges)
        setDataCaptureChanges = setDataCaptureChangesDecoded
        let currentLsnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentLsn)
        currentLsn = currentLsnDecoded
        let maxKBytesPerReadDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxKBytesPerRead)
        maxKBytesPerRead = maxKBytesPerReadDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.IBMDb2Settings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IBMDb2Settings(currentLsn: \(Swift.String(describing: currentLsn)), databaseName: \(Swift.String(describing: databaseName)), maxKBytesPerRead: \(Swift.String(describing: maxKBytesPerRead)), password: \(Swift.String(describing: password)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), setDataCaptureChanges: \(Swift.String(describing: setDataCaptureChanges)), username: \(Swift.String(describing: username)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that defines an IBM Db2 LUW endpoint.</p>
    public struct IBMDb2Settings: Swift.Equatable {
        /// <p>For ongoing replication (CDC), use CurrentLSN to specify a
        ///          log sequence number (LSN) where you want the replication
        ///          to start.</p>
        public let currentLsn: Swift.String?
        /// <p>Database name for the endpoint.</p>
        public let databaseName: Swift.String?
        /// <p>Maximum number of bytes per read, as a NUMBER value.
        ///          The default is 64 KB.</p>
        public let maxKBytesPerRead: Swift.Int?
        /// <p>Endpoint connection password.</p>
        public let password: Swift.String?
        /// <p>Endpoint TCP port.</p>
        public let port: Swift.Int?
        /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
        ///          trusted entity and grants the required permissions to access the value in
        ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of
        ///          the AWS Secrets Manager secret that allows access to the Db2 LUW endpoint. </p>
        ///          <note>
        ///             <p>You can specify one of two sets of values for these permissions. You can specify the
        ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
        ///             clear-text values for <code>UserName</code>, <code>Password</code>,
        ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
        ///             information on creating this <code>SecretsManagerSecret</code> and the
        ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
        ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
        ///                resources</a> in the <i>AWS Database Migration Service User
        ///                Guide</i>.</p>
        ///          </note>
        public let secretsManagerAccessRoleArn: Swift.String?
        /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the Db2 LUW endpoint connection details.</p>
        public let secretsManagerSecretId: Swift.String?
        /// <p>Fully qualified domain name of the endpoint.</p>
        public let serverName: Swift.String?
        /// <p>Enables ongoing replication (CDC) as a BOOLEAN value. The
        ///          default is true.</p>
        public let setDataCaptureChanges: Swift.Bool?
        /// <p>Endpoint connection user name.</p>
        public let username: Swift.String?

        public init (
            currentLsn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            maxKBytesPerRead: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            setDataCaptureChanges: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.currentLsn = currentLsn
            self.databaseName = databaseName
            self.maxKBytesPerRead = maxKBytesPerRead
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.setDataCaptureChanges = setDataCaptureChanges
            self.username = username
        }
    }

}

public struct ImportCertificateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportCertificateOutputError>
}

extension ImportCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportCertificateInput(certificateIdentifier: \(Swift.String(describing: certificateIdentifier)), certificatePem: \(Swift.String(describing: certificatePem)), certificateWallet: \(Swift.String(describing: certificateWallet)), tags: \(Swift.String(describing: tags)))"}
}

extension ImportCertificateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateIdentifier = "CertificateIdentifier"
        case certificatePem = "CertificatePem"
        case certificateWallet = "CertificateWallet"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateIdentifier = certificateIdentifier {
            try encodeContainer.encode(certificateIdentifier, forKey: .certificateIdentifier)
        }
        if let certificatePem = certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let certificateWallet = certificateWallet {
            try encodeContainer.encode(certificateWallet.base64EncodedString(), forKey: .certificateWallet)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct ImportCertificateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportCertificateOutputError>
}

public struct ImportCertificateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportCertificateOutputError>
}

public struct ImportCertificateInput: Swift.Equatable {
    /// <p>A customer-assigned name for the certificate. Identifiers must begin with a letter and
    ///          must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or
    ///          contain two consecutive hyphens.</p>
    public let certificateIdentifier: Swift.String?
    /// <p>The contents of a <code>.pem</code> file, which contains an X.509 certificate.</p>
    public let certificatePem: Swift.String?
    /// <p>The location of an imported Oracle Wallet certificate for use with SSL.</p>
    public let certificateWallet: ClientRuntime.Data?
    /// <p>The tags associated with the certificate.</p>
    public let tags: [DatabaseMigrationClientTypes.Tag]?

    public init (
        certificateIdentifier: Swift.String? = nil,
        certificatePem: Swift.String? = nil,
        certificateWallet: ClientRuntime.Data? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.certificateIdentifier = certificateIdentifier
        self.certificatePem = certificatePem
        self.certificateWallet = certificateWallet
        self.tags = tags
    }
}

struct ImportCertificateInputBody: Swift.Equatable {
    public let certificateIdentifier: Swift.String?
    public let certificatePem: Swift.String?
    public let certificateWallet: ClientRuntime.Data?
    public let tags: [DatabaseMigrationClientTypes.Tag]?
}

extension ImportCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateIdentifier = "CertificateIdentifier"
        case certificatePem = "CertificatePem"
        case certificateWallet = "CertificateWallet"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateIdentifier)
        certificateIdentifier = certificateIdentifierDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let certificateWalletDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .certificateWallet)
        certificateWallet = certificateWalletDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidCertificateFault" : self = .invalidCertificateFault(try InvalidCertificateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportCertificateOutputError: Swift.Error, Swift.Equatable {
    case invalidCertificateFault(InvalidCertificateFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportCertificateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportCertificateOutputResponse(certificate: \(Swift.String(describing: certificate)))"}
}

extension ImportCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

public struct ImportCertificateOutputResponse: Swift.Equatable {
    /// <p>The certificate to be uploaded.</p>
    public let certificate: DatabaseMigrationClientTypes.Certificate?

    public init (
        certificate: DatabaseMigrationClientTypes.Certificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct ImportCertificateOutputResponseBody: Swift.Equatable {
    public let certificate: DatabaseMigrationClientTypes.Certificate?
}

extension ImportCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension InsufficientResourceCapacityFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InsufficientResourceCapacityFault(message: \(Swift.String(describing: message)))"}
}

extension InsufficientResourceCapacityFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InsufficientResourceCapacityFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There are not enough resources allocated to the database migration.</p>
public struct InsufficientResourceCapacityFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p></p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientResourceCapacityFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InsufficientResourceCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCertificateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidCertificateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidCertificateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidCertificateFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The certificate was not valid.</p>
public struct InvalidCertificateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCertificateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidCertificateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidResourceStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidResourceStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidResourceStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is in a state that prevents it from being used for database migration.</p>
public struct InvalidResourceStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p></p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidResourceStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSubnet(message: \(Swift.String(describing: message)))"}
}

extension InvalidSubnet: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidSubnetBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The subnet provided is invalid.</p>
public struct InvalidSubnet: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p></p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidSubnetBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSAccessDeniedFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSAccessDeniedFault(message: \(Swift.String(describing: message)))"}
}

extension KMSAccessDeniedFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSAccessDeniedFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The ciphertext references a key that doesn't exist or that the DMS account doesn't have access to.</p>
public struct KMSAccessDeniedFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSAccessDeniedFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSAccessDeniedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSDisabledFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSDisabledFault(message: \(Swift.String(describing: message)))"}
}

extension KMSDisabledFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSDisabledFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified master key (CMK) isn't enabled.</p>
public struct KMSDisabledFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSDisabledFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSDisabledFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSFault(message: \(Swift.String(describing: message)))"}
}

extension KMSFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An AWS Key Management Service (AWS KMS) error is preventing access to AWS KMS.</p>
public struct KMSFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSInvalidStateFault(message: \(Swift.String(describing: message)))"}
}

extension KMSInvalidStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSInvalidStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state of the specified AWS KMS resource isn't valid for this request.</p>
public struct KMSInvalidStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSInvalidStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSInvalidStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSKeyNotAccessibleFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSKeyNotAccessibleFault(message: \(Swift.String(describing: message)))"}
}

extension KMSKeyNotAccessibleFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSKeyNotAccessibleFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS DMS cannot access the AWS KMS key.</p>
public struct KMSKeyNotAccessibleFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p></p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSKeyNotAccessibleFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSKeyNotAccessibleFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension KMSNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified AWS KMS entity or resource can't be found.</p>
public struct KMSNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSThrottlingFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSThrottlingFault(message: \(Swift.String(describing: message)))"}
}

extension KMSThrottlingFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSThrottlingFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This request triggered AWS KMS request throttling.</p>
public struct KMSThrottlingFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSThrottlingFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSThrottlingFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum KafkaSecurityProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plaintext
        case saslSsl
        case sslAuthentication
        case sslEncryption
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaSecurityProtocol] {
            return [
                .plaintext,
                .saslSsl,
                .sslAuthentication,
                .sslEncryption,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "plaintext"
            case .saslSsl: return "sasl-ssl"
            case .sslAuthentication: return "ssl-authentication"
            case .sslEncryption: return "ssl-encryption"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KafkaSecurityProtocol(rawValue: rawValue) ?? KafkaSecurityProtocol.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.KafkaSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case broker = "Broker"
        case includeControlDetails = "IncludeControlDetails"
        case includeNullAndEmpty = "IncludeNullAndEmpty"
        case includePartitionValue = "IncludePartitionValue"
        case includeTableAlterOperations = "IncludeTableAlterOperations"
        case includeTransactionDetails = "IncludeTransactionDetails"
        case messageFormat = "MessageFormat"
        case messageMaxBytes = "MessageMaxBytes"
        case partitionIncludeSchemaTable = "PartitionIncludeSchemaTable"
        case saslPassword = "SaslPassword"
        case saslUsername = "SaslUsername"
        case securityProtocol = "SecurityProtocol"
        case sslCaCertificateArn = "SslCaCertificateArn"
        case sslClientCertificateArn = "SslClientCertificateArn"
        case sslClientKeyArn = "SslClientKeyArn"
        case sslClientKeyPassword = "SslClientKeyPassword"
        case topic = "Topic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let broker = broker {
            try encodeContainer.encode(broker, forKey: .broker)
        }
        if let includeControlDetails = includeControlDetails {
            try encodeContainer.encode(includeControlDetails, forKey: .includeControlDetails)
        }
        if let includeNullAndEmpty = includeNullAndEmpty {
            try encodeContainer.encode(includeNullAndEmpty, forKey: .includeNullAndEmpty)
        }
        if let includePartitionValue = includePartitionValue {
            try encodeContainer.encode(includePartitionValue, forKey: .includePartitionValue)
        }
        if let includeTableAlterOperations = includeTableAlterOperations {
            try encodeContainer.encode(includeTableAlterOperations, forKey: .includeTableAlterOperations)
        }
        if let includeTransactionDetails = includeTransactionDetails {
            try encodeContainer.encode(includeTransactionDetails, forKey: .includeTransactionDetails)
        }
        if let messageFormat = messageFormat {
            try encodeContainer.encode(messageFormat.rawValue, forKey: .messageFormat)
        }
        if let messageMaxBytes = messageMaxBytes {
            try encodeContainer.encode(messageMaxBytes, forKey: .messageMaxBytes)
        }
        if let partitionIncludeSchemaTable = partitionIncludeSchemaTable {
            try encodeContainer.encode(partitionIncludeSchemaTable, forKey: .partitionIncludeSchemaTable)
        }
        if let saslPassword = saslPassword {
            try encodeContainer.encode(saslPassword, forKey: .saslPassword)
        }
        if let saslUsername = saslUsername {
            try encodeContainer.encode(saslUsername, forKey: .saslUsername)
        }
        if let securityProtocol = securityProtocol {
            try encodeContainer.encode(securityProtocol.rawValue, forKey: .securityProtocol)
        }
        if let sslCaCertificateArn = sslCaCertificateArn {
            try encodeContainer.encode(sslCaCertificateArn, forKey: .sslCaCertificateArn)
        }
        if let sslClientCertificateArn = sslClientCertificateArn {
            try encodeContainer.encode(sslClientCertificateArn, forKey: .sslClientCertificateArn)
        }
        if let sslClientKeyArn = sslClientKeyArn {
            try encodeContainer.encode(sslClientKeyArn, forKey: .sslClientKeyArn)
        }
        if let sslClientKeyPassword = sslClientKeyPassword {
            try encodeContainer.encode(sslClientKeyPassword, forKey: .sslClientKeyPassword)
        }
        if let topic = topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .broker)
        broker = brokerDecoded
        let topicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topic)
        topic = topicDecoded
        let messageFormatDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MessageFormatValue.self, forKey: .messageFormat)
        messageFormat = messageFormatDecoded
        let includeTransactionDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTransactionDetails)
        includeTransactionDetails = includeTransactionDetailsDecoded
        let includePartitionValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includePartitionValue)
        includePartitionValue = includePartitionValueDecoded
        let partitionIncludeSchemaTableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .partitionIncludeSchemaTable)
        partitionIncludeSchemaTable = partitionIncludeSchemaTableDecoded
        let includeTableAlterOperationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTableAlterOperations)
        includeTableAlterOperations = includeTableAlterOperationsDecoded
        let includeControlDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeControlDetails)
        includeControlDetails = includeControlDetailsDecoded
        let messageMaxBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .messageMaxBytes)
        messageMaxBytes = messageMaxBytesDecoded
        let includeNullAndEmptyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeNullAndEmpty)
        includeNullAndEmpty = includeNullAndEmptyDecoded
        let securityProtocolDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KafkaSecurityProtocol.self, forKey: .securityProtocol)
        securityProtocol = securityProtocolDecoded
        let sslClientCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslClientCertificateArn)
        sslClientCertificateArn = sslClientCertificateArnDecoded
        let sslClientKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslClientKeyArn)
        sslClientKeyArn = sslClientKeyArnDecoded
        let sslClientKeyPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslClientKeyPassword)
        sslClientKeyPassword = sslClientKeyPasswordDecoded
        let sslCaCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslCaCertificateArn)
        sslCaCertificateArn = sslCaCertificateArnDecoded
        let saslUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .saslUsername)
        saslUsername = saslUsernameDecoded
        let saslPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .saslPassword)
        saslPassword = saslPasswordDecoded
    }
}

extension DatabaseMigrationClientTypes.KafkaSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KafkaSettings(broker: \(Swift.String(describing: broker)), includeControlDetails: \(Swift.String(describing: includeControlDetails)), includeNullAndEmpty: \(Swift.String(describing: includeNullAndEmpty)), includePartitionValue: \(Swift.String(describing: includePartitionValue)), includeTableAlterOperations: \(Swift.String(describing: includeTableAlterOperations)), includeTransactionDetails: \(Swift.String(describing: includeTransactionDetails)), messageFormat: \(Swift.String(describing: messageFormat)), messageMaxBytes: \(Swift.String(describing: messageMaxBytes)), partitionIncludeSchemaTable: \(Swift.String(describing: partitionIncludeSchemaTable)), saslPassword: \(Swift.String(describing: saslPassword)), saslUsername: \(Swift.String(describing: saslUsername)), securityProtocol: \(Swift.String(describing: securityProtocol)), sslCaCertificateArn: \(Swift.String(describing: sslCaCertificateArn)), sslClientCertificateArn: \(Swift.String(describing: sslClientCertificateArn)), sslClientKeyArn: \(Swift.String(describing: sslClientKeyArn)), sslClientKeyPassword: \(Swift.String(describing: sslClientKeyPassword)), topic: \(Swift.String(describing: topic)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that describes an Apache Kafka endpoint. This
    ///          information includes the output format of records applied to the endpoint and details of
    ///          transaction and control table data information.</p>
    public struct KafkaSettings: Swift.Equatable {
        /// <p>A comma-separated list of one or more broker locations in your Kafka cluster that host your Kafka instance. Specify each broker location
        ///          in the form <code>
        ///                <i>broker-hostname-or-ip</i>:<i>port</i>
        ///             </code>. For example, <code>"ec2-12-345-678-901.compute-1.amazonaws.com:2345"</code>.
        ///          For more information and examples of specifying a list of broker locations,
        ///          see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html">Using Apache Kafka as a target for AWS Database Migration Service</a>
        ///          in the <i>AWS Data Migration Service User Guide</i>.
        ///       </p>
        public let broker: Swift.String?
        /// <p>Shows detailed control information for table definition, column definition, and table
        ///          and column changes in the Kafka message output. The default is <code>false</code>.</p>
        public let includeControlDetails: Swift.Bool?
        /// <p>Include NULL and empty columns for records migrated to the endpoint. The default is <code>false</code>.</p>
        public let includeNullAndEmpty: Swift.Bool?
        /// <p>Shows the partition value within the Kafka message output, unless the partition type is
        ///             <code>schema-table-type</code>. The default is <code>false</code>.</p>
        public let includePartitionValue: Swift.Bool?
        /// <p>Includes any data definition language (DDL) operations that change the table in the
        ///          control data, such as <code>rename-table</code>, <code>drop-table</code>,
        ///             <code>add-column</code>, <code>drop-column</code>, and <code>rename-column</code>. The
        ///          default is <code>false</code>.</p>
        public let includeTableAlterOperations: Swift.Bool?
        /// <p>Provides detailed transaction information from the source database. This information
        ///          includes a commit timestamp, a log position, and values for <code>transaction_id</code>,
        ///          previous <code>transaction_id</code>, and <code>transaction_record_id</code> (the record
        ///          offset within a transaction). The default is <code>false</code>.</p>
        public let includeTransactionDetails: Swift.Bool?
        /// <p>The output format for the records created on the endpoint. The message format is
        ///             <code>JSON</code> (default) or <code>JSON_UNFORMATTED</code> (a single line with no
        ///          tab).</p>
        public let messageFormat: DatabaseMigrationClientTypes.MessageFormatValue?
        /// <p>The maximum size in bytes for records created on the endpoint The default is 1,000,000.</p>
        public let messageMaxBytes: Swift.Int?
        /// <p>Prefixes schema and table names to partition values, when the partition type is
        ///             <code>primary-key-type</code>. Doing this increases data distribution among Kafka
        ///          partitions. For example, suppose that a SysBench schema has thousands of tables and each
        ///          table has only limited range for a primary key. In this case, the same primary key is sent
        ///          from thousands of tables to the same partition, which causes throttling. The default is
        ///             <code>false</code>.</p>
        public let partitionIncludeSchemaTable: Swift.Bool?
        /// <p>The secure password you created when you first set up your MSK cluster to validate a client identity and
        ///          make an encrypted connection between server and client using SASL-SSL authentication.</p>
        public let saslPassword: Swift.String?
        /// <p> The secure username you created when you first set up your MSK cluster to validate a client identity and
        ///          make an encrypted connection between server and client using SASL-SSL authentication.</p>
        public let saslUsername: Swift.String?
        /// <p>Set secure connection to a Kafka target endpoint using Transport Layer Security (TLS). Options include
        ///          <code>ssl-encryption</code>, <code>ssl-authentication</code>, and <code>sasl-ssl</code>.
        ///          <code>sasl-ssl</code> requires <code>SaslUsername</code> and <code>SaslPassword</code>.</p>
        public let securityProtocol: DatabaseMigrationClientTypes.KafkaSecurityProtocol?
        /// <p> The Amazon Resource Name (ARN) for the private Certification Authority (CA) cert that AWS DMS uses
        ///          to securely connect to your Kafka target endpoint.</p>
        public let sslCaCertificateArn: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the client certificate used to securely connect to a Kafka target endpoint.</p>
        public let sslClientCertificateArn: Swift.String?
        /// <p>The Amazon Resource Name (ARN) for the client private key used to securely connect to a Kafka target endpoint.</p>
        public let sslClientKeyArn: Swift.String?
        /// <p> The password for the client private key used to securely connect to a Kafka target endpoint.</p>
        public let sslClientKeyPassword: Swift.String?
        /// <p>The topic to which you migrate the data. If you don't specify a topic, AWS DMS
        ///          specifies <code>"kafka-default-topic"</code> as the migration topic.</p>
        public let topic: Swift.String?

        public init (
            broker: Swift.String? = nil,
            includeControlDetails: Swift.Bool? = nil,
            includeNullAndEmpty: Swift.Bool? = nil,
            includePartitionValue: Swift.Bool? = nil,
            includeTableAlterOperations: Swift.Bool? = nil,
            includeTransactionDetails: Swift.Bool? = nil,
            messageFormat: DatabaseMigrationClientTypes.MessageFormatValue? = nil,
            messageMaxBytes: Swift.Int? = nil,
            partitionIncludeSchemaTable: Swift.Bool? = nil,
            saslPassword: Swift.String? = nil,
            saslUsername: Swift.String? = nil,
            securityProtocol: DatabaseMigrationClientTypes.KafkaSecurityProtocol? = nil,
            sslCaCertificateArn: Swift.String? = nil,
            sslClientCertificateArn: Swift.String? = nil,
            sslClientKeyArn: Swift.String? = nil,
            sslClientKeyPassword: Swift.String? = nil,
            topic: Swift.String? = nil
        )
        {
            self.broker = broker
            self.includeControlDetails = includeControlDetails
            self.includeNullAndEmpty = includeNullAndEmpty
            self.includePartitionValue = includePartitionValue
            self.includeTableAlterOperations = includeTableAlterOperations
            self.includeTransactionDetails = includeTransactionDetails
            self.messageFormat = messageFormat
            self.messageMaxBytes = messageMaxBytes
            self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
            self.saslPassword = saslPassword
            self.saslUsername = saslUsername
            self.securityProtocol = securityProtocol
            self.sslCaCertificateArn = sslCaCertificateArn
            self.sslClientCertificateArn = sslClientCertificateArn
            self.sslClientKeyArn = sslClientKeyArn
            self.sslClientKeyPassword = sslClientKeyPassword
            self.topic = topic
        }
    }

}

extension DatabaseMigrationClientTypes.KinesisSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeControlDetails = "IncludeControlDetails"
        case includeNullAndEmpty = "IncludeNullAndEmpty"
        case includePartitionValue = "IncludePartitionValue"
        case includeTableAlterOperations = "IncludeTableAlterOperations"
        case includeTransactionDetails = "IncludeTransactionDetails"
        case messageFormat = "MessageFormat"
        case partitionIncludeSchemaTable = "PartitionIncludeSchemaTable"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case streamArn = "StreamArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeControlDetails = includeControlDetails {
            try encodeContainer.encode(includeControlDetails, forKey: .includeControlDetails)
        }
        if let includeNullAndEmpty = includeNullAndEmpty {
            try encodeContainer.encode(includeNullAndEmpty, forKey: .includeNullAndEmpty)
        }
        if let includePartitionValue = includePartitionValue {
            try encodeContainer.encode(includePartitionValue, forKey: .includePartitionValue)
        }
        if let includeTableAlterOperations = includeTableAlterOperations {
            try encodeContainer.encode(includeTableAlterOperations, forKey: .includeTableAlterOperations)
        }
        if let includeTransactionDetails = includeTransactionDetails {
            try encodeContainer.encode(includeTransactionDetails, forKey: .includeTransactionDetails)
        }
        if let messageFormat = messageFormat {
            try encodeContainer.encode(messageFormat.rawValue, forKey: .messageFormat)
        }
        if let partitionIncludeSchemaTable = partitionIncludeSchemaTable {
            try encodeContainer.encode(partitionIncludeSchemaTable, forKey: .partitionIncludeSchemaTable)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let streamArn = streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let messageFormatDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MessageFormatValue.self, forKey: .messageFormat)
        messageFormat = messageFormatDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let includeTransactionDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTransactionDetails)
        includeTransactionDetails = includeTransactionDetailsDecoded
        let includePartitionValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includePartitionValue)
        includePartitionValue = includePartitionValueDecoded
        let partitionIncludeSchemaTableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .partitionIncludeSchemaTable)
        partitionIncludeSchemaTable = partitionIncludeSchemaTableDecoded
        let includeTableAlterOperationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTableAlterOperations)
        includeTableAlterOperations = includeTableAlterOperationsDecoded
        let includeControlDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeControlDetails)
        includeControlDetails = includeControlDetailsDecoded
        let includeNullAndEmptyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeNullAndEmpty)
        includeNullAndEmpty = includeNullAndEmptyDecoded
    }
}

extension DatabaseMigrationClientTypes.KinesisSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KinesisSettings(includeControlDetails: \(Swift.String(describing: includeControlDetails)), includeNullAndEmpty: \(Swift.String(describing: includeNullAndEmpty)), includePartitionValue: \(Swift.String(describing: includePartitionValue)), includeTableAlterOperations: \(Swift.String(describing: includeTableAlterOperations)), includeTransactionDetails: \(Swift.String(describing: includeTransactionDetails)), messageFormat: \(Swift.String(describing: messageFormat)), partitionIncludeSchemaTable: \(Swift.String(describing: partitionIncludeSchemaTable)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), streamArn: \(Swift.String(describing: streamArn)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that describes an Amazon Kinesis Data Stream endpoint. This
    ///          information includes the output format of records applied to the endpoint and details of
    ///          transaction and control table data information.</p>
    public struct KinesisSettings: Swift.Equatable {
        /// <p>Shows detailed control information for table definition, column definition, and table
        ///          and column changes in the Kinesis message output. The default is <code>false</code>.</p>
        public let includeControlDetails: Swift.Bool?
        /// <p>Include NULL and empty columns for records migrated to the endpoint. The default is <code>false</code>.</p>
        public let includeNullAndEmpty: Swift.Bool?
        /// <p>Shows the partition value within the Kinesis message output, unless the partition type
        ///          is <code>schema-table-type</code>. The default is <code>false</code>.</p>
        public let includePartitionValue: Swift.Bool?
        /// <p>Includes any data definition language (DDL) operations that change the table in the
        ///          control data, such as <code>rename-table</code>, <code>drop-table</code>,
        ///             <code>add-column</code>, <code>drop-column</code>, and <code>rename-column</code>. The
        ///          default is <code>false</code>.</p>
        public let includeTableAlterOperations: Swift.Bool?
        /// <p>Provides detailed transaction information from the source database. This information
        ///          includes a commit timestamp, a log position, and values for <code>transaction_id</code>,
        ///          previous <code>transaction_id</code>, and <code>transaction_record_id</code> (the record
        ///          offset within a transaction). The default is <code>false</code>.</p>
        public let includeTransactionDetails: Swift.Bool?
        /// <p>The output format for the records created on the endpoint. The message format is
        ///          <code>JSON</code> (default) or <code>JSON_UNFORMATTED</code> (a single line with no tab).</p>
        public let messageFormat: DatabaseMigrationClientTypes.MessageFormatValue?
        /// <p>Prefixes schema and table names to partition values, when the partition type is
        ///             <code>primary-key-type</code>. Doing this increases data distribution among Kinesis
        ///          shards. For example, suppose that a SysBench schema has thousands of tables and each table
        ///          has only limited range for a primary key. In this case, the same primary key is sent from
        ///          thousands of tables to the same shard, which causes throttling. The default is <code>false</code>.</p>
        public let partitionIncludeSchemaTable: Swift.Bool?
        /// <p>The Amazon Resource Name (ARN) for the AWS Identity and Access Management (IAM) role
        ///          that AWS DMS uses to write to the Kinesis data stream.</p>
        public let serviceAccessRoleArn: Swift.String?
        /// <p>The Amazon Resource Name (ARN) for the Amazon Kinesis Data Streams endpoint.</p>
        public let streamArn: Swift.String?

        public init (
            includeControlDetails: Swift.Bool? = nil,
            includeNullAndEmpty: Swift.Bool? = nil,
            includePartitionValue: Swift.Bool? = nil,
            includeTableAlterOperations: Swift.Bool? = nil,
            includeTransactionDetails: Swift.Bool? = nil,
            messageFormat: DatabaseMigrationClientTypes.MessageFormatValue? = nil,
            partitionIncludeSchemaTable: Swift.Bool? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            streamArn: Swift.String? = nil
        )
        {
            self.includeControlDetails = includeControlDetails
            self.includeNullAndEmpty = includeNullAndEmpty
            self.includePartitionValue = includePartitionValue
            self.includeTableAlterOperations = includeTableAlterOperations
            self.includeTransactionDetails = includeTransactionDetails
            self.messageFormat = messageFormat
            self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.streamArn = streamArn
        }
    }

}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

/// <p></p>
public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the AWS DMS
    ///          resource.</p>
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tagList: \(Swift.String(describing: tagList)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

/// <p></p>
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>A list of tags for the resource.</p>
    public let tagList: [DatabaseMigrationClientTypes.Tag]?

    public init (
        tagList: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tagList: [DatabaseMigrationClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension DatabaseMigrationClientTypes {
    public enum MessageFormatValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case jsonUnformatted
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageFormatValue] {
            return [
                .json,
                .jsonUnformatted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "json"
            case .jsonUnformatted: return "json-unformatted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageFormatValue(rawValue: rawValue) ?? MessageFormatValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.MicrosoftSQLServerSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bcpPacketSize = "BcpPacketSize"
        case controlTablesFileGroup = "ControlTablesFileGroup"
        case databaseName = "DatabaseName"
        case password = "Password"
        case port = "Port"
        case querySingleAlwaysOnNode = "QuerySingleAlwaysOnNode"
        case readBackupOnly = "ReadBackupOnly"
        case safeguardPolicy = "SafeguardPolicy"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case useBcpFullLoad = "UseBcpFullLoad"
        case useThirdPartyBackupDevice = "UseThirdPartyBackupDevice"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bcpPacketSize = bcpPacketSize {
            try encodeContainer.encode(bcpPacketSize, forKey: .bcpPacketSize)
        }
        if let controlTablesFileGroup = controlTablesFileGroup {
            try encodeContainer.encode(controlTablesFileGroup, forKey: .controlTablesFileGroup)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let querySingleAlwaysOnNode = querySingleAlwaysOnNode {
            try encodeContainer.encode(querySingleAlwaysOnNode, forKey: .querySingleAlwaysOnNode)
        }
        if let readBackupOnly = readBackupOnly {
            try encodeContainer.encode(readBackupOnly, forKey: .readBackupOnly)
        }
        if let safeguardPolicy = safeguardPolicy {
            try encodeContainer.encode(safeguardPolicy.rawValue, forKey: .safeguardPolicy)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let useBcpFullLoad = useBcpFullLoad {
            try encodeContainer.encode(useBcpFullLoad, forKey: .useBcpFullLoad)
        }
        if let useThirdPartyBackupDevice = useThirdPartyBackupDevice {
            try encodeContainer.encode(useThirdPartyBackupDevice, forKey: .useThirdPartyBackupDevice)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let bcpPacketSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bcpPacketSize)
        bcpPacketSize = bcpPacketSizeDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let controlTablesFileGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlTablesFileGroup)
        controlTablesFileGroup = controlTablesFileGroupDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let querySingleAlwaysOnNodeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .querySingleAlwaysOnNode)
        querySingleAlwaysOnNode = querySingleAlwaysOnNodeDecoded
        let readBackupOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readBackupOnly)
        readBackupOnly = readBackupOnlyDecoded
        let safeguardPolicyDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SafeguardPolicy.self, forKey: .safeguardPolicy)
        safeguardPolicy = safeguardPolicyDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let useBcpFullLoadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useBcpFullLoad)
        useBcpFullLoad = useBcpFullLoadDecoded
        let useThirdPartyBackupDeviceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useThirdPartyBackupDevice)
        useThirdPartyBackupDevice = useThirdPartyBackupDeviceDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.MicrosoftSQLServerSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MicrosoftSQLServerSettings(bcpPacketSize: \(Swift.String(describing: bcpPacketSize)), controlTablesFileGroup: \(Swift.String(describing: controlTablesFileGroup)), databaseName: \(Swift.String(describing: databaseName)), password: \(Swift.String(describing: password)), port: \(Swift.String(describing: port)), querySingleAlwaysOnNode: \(Swift.String(describing: querySingleAlwaysOnNode)), readBackupOnly: \(Swift.String(describing: readBackupOnly)), safeguardPolicy: \(Swift.String(describing: safeguardPolicy)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), useBcpFullLoad: \(Swift.String(describing: useBcpFullLoad)), useThirdPartyBackupDevice: \(Swift.String(describing: useThirdPartyBackupDevice)), username: \(Swift.String(describing: username)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that defines a Microsoft SQL Server endpoint.</p>
    public struct MicrosoftSQLServerSettings: Swift.Equatable {
        /// <p>The maximum size of the packets (in bytes) used to transfer
        ///          data using BCP.</p>
        public let bcpPacketSize: Swift.Int?
        /// <p>Specifies a file group for the AWS DMS internal tables. When the replication task
        ///          starts, all the internal AWS DMS control tables (awsdms_ apply_exception, awsdms_apply,
        ///          awsdms_changes) are created for the specified file group.</p>
        public let controlTablesFileGroup: Swift.String?
        /// <p>Database name for the endpoint.</p>
        public let databaseName: Swift.String?
        /// <p>Endpoint connection password.</p>
        public let password: Swift.String?
        /// <p>Endpoint TCP port.</p>
        public let port: Swift.Int?
        /// <p>Cleans and recreates table metadata information on the replication instance when
        ///          a mismatch occurs. An example is a situation where running an alter DDL statement on
        ///          a table might result in different information about the table cached in the replication
        ///          instance.</p>
        public let querySingleAlwaysOnNode: Swift.Bool?
        /// <p>When this attribute is set to <code>Y</code>, AWS DMS only reads changes
        ///          from transaction log backups and doesn't read from the
        ///          active transaction log file during ongoing replication. Setting
        ///          this parameter to <code>Y</code> enables you to control active transaction
        ///          log file growth during full load and ongoing replication
        ///          tasks. However, it can add some source latency to ongoing
        ///          replication.</p>
        public let readBackupOnly: Swift.Bool?
        /// <p>Use this attribute to minimize the need to access the
        ///          backup log and enable AWS DMS to prevent truncation using one of the
        ///          following two methods.</p>
        ///          <p>
        ///             <i>Start transactions in the database:</i> This is the default
        ///          method. When this method is used, AWS DMS prevents
        ///          TLOG truncation by mimicking a transaction in the database.
        ///          As long as such a transaction is open, changes that appear
        ///          after the transaction started aren't truncated. If you need
        ///          Microsoft Replication to be enabled in your database, then
        ///          you must choose this method.</p>
        ///          <p>
        ///             <i>Exclusively use sp_repldone within a single task</i>: When
        ///          this method is used, AWS DMS reads the changes and then
        ///          uses sp_repldone to mark the TLOG transactions as ready
        ///          for truncation. Although this method doesn't involve any
        ///          transactional activities, it can only be used when Microsoft
        ///          Replication isn't running. Also, when using this method, only
        ///          one AWS DMS task can access the database at any given
        ///          time. Therefore, if you need to run parallel AWS DMS tasks
        ///          against the same database, use the default method.</p>
        public let safeguardPolicy: DatabaseMigrationClientTypes.SafeguardPolicy?
        /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
        ///          trusted entity and grants the required permissions to access the value in
        ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
        ///          Manager secret that allows access to the SQL Server endpoint.</p>
        ///          <note>
        ///             <p>You can specify one of two sets of values for these permissions. You can specify the
        ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
        ///             clear-text values for <code>UserName</code>, <code>Password</code>,
        ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
        ///             information on creating this <code>SecretsManagerSecret</code> and the
        ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
        ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
        ///                resources</a> in the <i>AWS Database Migration Service User
        ///                Guide</i>.</p>
        ///          </note>
        public let secretsManagerAccessRoleArn: Swift.String?
        /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the SQL Server endpoint connection details.</p>
        public let secretsManagerSecretId: Swift.String?
        /// <p>Fully qualified domain name of the endpoint.</p>
        public let serverName: Swift.String?
        /// <p>Use this to attribute to transfer data for full-load operations
        ///          using BCP. When the target table contains an identity
        ///          column that does not exist in the source table, you must
        ///          disable the use BCP for loading table option.</p>
        public let useBcpFullLoad: Swift.Bool?
        /// <p>When this attribute is set to <code>Y</code>, DMS processes third-party
        ///          transaction log backups if they are created in native format.</p>
        public let useThirdPartyBackupDevice: Swift.Bool?
        /// <p>Endpoint connection user name.</p>
        public let username: Swift.String?

        public init (
            bcpPacketSize: Swift.Int? = nil,
            controlTablesFileGroup: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            querySingleAlwaysOnNode: Swift.Bool? = nil,
            readBackupOnly: Swift.Bool? = nil,
            safeguardPolicy: DatabaseMigrationClientTypes.SafeguardPolicy? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            useBcpFullLoad: Swift.Bool? = nil,
            useThirdPartyBackupDevice: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.bcpPacketSize = bcpPacketSize
            self.controlTablesFileGroup = controlTablesFileGroup
            self.databaseName = databaseName
            self.password = password
            self.port = port
            self.querySingleAlwaysOnNode = querySingleAlwaysOnNode
            self.readBackupOnly = readBackupOnly
            self.safeguardPolicy = safeguardPolicy
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.useBcpFullLoad = useBcpFullLoad
            self.useThirdPartyBackupDevice = useThirdPartyBackupDevice
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum MigrationTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cdc
        case fullLoad
        case fullLoadAndCdc
        case sdkUnknown(Swift.String)

        public static var allCases: [MigrationTypeValue] {
            return [
                .cdc,
                .fullLoad,
                .fullLoadAndCdc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cdc: return "cdc"
            case .fullLoad: return "full-load"
            case .fullLoadAndCdc: return "full-load-and-cdc"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MigrationTypeValue(rawValue: rawValue) ?? MigrationTypeValue.sdkUnknown(rawValue)
        }
    }
}

public struct ModifyEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEndpointOutputError>
}

extension ModifyEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyEndpointInput(certificateArn: \(Swift.String(describing: certificateArn)), databaseName: \(Swift.String(describing: databaseName)), dmsTransferSettings: \(Swift.String(describing: dmsTransferSettings)), docDbSettings: \(Swift.String(describing: docDbSettings)), dynamoDbSettings: \(Swift.String(describing: dynamoDbSettings)), elasticsearchSettings: \(Swift.String(describing: elasticsearchSettings)), endpointArn: \(Swift.String(describing: endpointArn)), endpointIdentifier: \(Swift.String(describing: endpointIdentifier)), endpointType: \(Swift.String(describing: endpointType)), engineName: \(Swift.String(describing: engineName)), externalTableDefinition: \(Swift.String(describing: externalTableDefinition)), extraConnectionAttributes: \(Swift.String(describing: extraConnectionAttributes)), iBMDb2Settings: \(Swift.String(describing: iBMDb2Settings)), kafkaSettings: \(Swift.String(describing: kafkaSettings)), kinesisSettings: \(Swift.String(describing: kinesisSettings)), microsoftSQLServerSettings: \(Swift.String(describing: microsoftSQLServerSettings)), mongoDbSettings: \(Swift.String(describing: mongoDbSettings)), mySQLSettings: \(Swift.String(describing: mySQLSettings)), neptuneSettings: \(Swift.String(describing: neptuneSettings)), oracleSettings: \(Swift.String(describing: oracleSettings)), password: \(Swift.String(describing: password)), port: \(Swift.String(describing: port)), postgreSQLSettings: \(Swift.String(describing: postgreSQLSettings)), redshiftSettings: \(Swift.String(describing: redshiftSettings)), s3Settings: \(Swift.String(describing: s3Settings)), serverName: \(Swift.String(describing: serverName)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), sslMode: \(Swift.String(describing: sslMode)), sybaseSettings: \(Swift.String(describing: sybaseSettings)), username: \(Swift.String(describing: username)))"}
}

extension ModifyEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case iBMDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redshiftSettings = "RedshiftSettings"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dmsTransferSettings = dmsTransferSettings {
            try encodeContainer.encode(dmsTransferSettings, forKey: .dmsTransferSettings)
        }
        if let docDbSettings = docDbSettings {
            try encodeContainer.encode(docDbSettings, forKey: .docDbSettings)
        }
        if let dynamoDbSettings = dynamoDbSettings {
            try encodeContainer.encode(dynamoDbSettings, forKey: .dynamoDbSettings)
        }
        if let elasticsearchSettings = elasticsearchSettings {
            try encodeContainer.encode(elasticsearchSettings, forKey: .elasticsearchSettings)
        }
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let endpointIdentifier = endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineName = engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let externalTableDefinition = externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let extraConnectionAttributes = extraConnectionAttributes {
            try encodeContainer.encode(extraConnectionAttributes, forKey: .extraConnectionAttributes)
        }
        if let iBMDb2Settings = iBMDb2Settings {
            try encodeContainer.encode(iBMDb2Settings, forKey: .iBMDb2Settings)
        }
        if let kafkaSettings = kafkaSettings {
            try encodeContainer.encode(kafkaSettings, forKey: .kafkaSettings)
        }
        if let kinesisSettings = kinesisSettings {
            try encodeContainer.encode(kinesisSettings, forKey: .kinesisSettings)
        }
        if let microsoftSQLServerSettings = microsoftSQLServerSettings {
            try encodeContainer.encode(microsoftSQLServerSettings, forKey: .microsoftSQLServerSettings)
        }
        if let mongoDbSettings = mongoDbSettings {
            try encodeContainer.encode(mongoDbSettings, forKey: .mongoDbSettings)
        }
        if let mySQLSettings = mySQLSettings {
            try encodeContainer.encode(mySQLSettings, forKey: .mySQLSettings)
        }
        if let neptuneSettings = neptuneSettings {
            try encodeContainer.encode(neptuneSettings, forKey: .neptuneSettings)
        }
        if let oracleSettings = oracleSettings {
            try encodeContainer.encode(oracleSettings, forKey: .oracleSettings)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let postgreSQLSettings = postgreSQLSettings {
            try encodeContainer.encode(postgreSQLSettings, forKey: .postgreSQLSettings)
        }
        if let redshiftSettings = redshiftSettings {
            try encodeContainer.encode(redshiftSettings, forKey: .redshiftSettings)
        }
        if let s3Settings = s3Settings {
            try encodeContainer.encode(s3Settings, forKey: .s3Settings)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let sslMode = sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
        if let sybaseSettings = sybaseSettings {
            try encodeContainer.encode(sybaseSettings, forKey: .sybaseSettings)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct ModifyEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEndpointOutputError>
}

public struct ModifyEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEndpointOutputError>
}

/// <p></p>
public struct ModifyEndpointInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the certificate used for SSL connection.</p>
    public let certificateArn: Swift.String?
    /// <p>The name of the endpoint database.</p>
    public let databaseName: Swift.String?
    /// <p>The settings in JSON format for the DMS transfer type of source endpoint. </p>
    ///          <p>Attributes include the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>serviceAccessRoleArn - The AWS Identity and Access Management (IAM) role that has
    ///                permission to access the Amazon S3 bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>BucketName - The name of the S3 bucket to use.</p>
    ///             </li>
    ///             <li>
    ///                <p>compressionType - An optional parameter to use GZIP to compress the target files.
    ///                Either set this parameter to NONE (the default) or don't use it to leave the
    ///                files uncompressed.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Shorthand syntax for these settings is as follows: <code>ServiceAccessRoleArn=string
    ///             ,BucketName=string,CompressionType=string</code>
    ///          </p>
    ///          <p>JSON syntax for these settings is as follows: <code>{ "ServiceAccessRoleArn": "string",
    ///             "BucketName": "string", "CompressionType": "none"|"gzip" } </code>
    ///          </p>
    public let dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
    /// <p>Settings in JSON format for the source DocumentDB endpoint. For more information about the
    ///          available settings, see the configuration properties section in <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DocumentDB.html"> Using DocumentDB as a Target for AWS
    ///             Database Migration Service</a> in the <i>AWS Database Migration Service User
    ///                Guide.</i>
    ///          </p>
    public let docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
    /// <p>Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other
    ///             available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.DynamoDB.html">Using Object Mapping to Migrate
    ///             Data to DynamoDB</a> in the <i>AWS Database Migration Service User
    ///             Guide.</i>
    ///          </p>
    public let dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
    /// <p>Settings in JSON format for the target Elasticsearch endpoint. For more information
    ///          about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Elasticsearch.html#CHAP_Target.Elasticsearch.Configuration">Extra Connection Attributes When Using Elasticsearch as a Target for AWS DMS</a> in
    ///          the <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: Swift.String?
    /// <p>The database endpoint identifier. Identifiers must begin with a letter and must contain
    ///          only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two
    ///          consecutive hyphens.</p>
    public let endpointIdentifier: Swift.String?
    /// <p>The type of endpoint.  Valid values are <code>source</code> and <code>target</code>.</p>
    public let endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
    /// <p>The type of engine for the endpoint. Valid values, depending on the EndpointType,
    ///          include
    ///          <code>"mysql"</code>, <code>"oracle"</code>, <code>"postgres"</code>,
    ///          <code>"mariadb"</code>, <code>"aurora"</code>, <code>"aurora-postgresql"</code>,
    ///          <code>"redshift"</code>, <code>"s3"</code>, <code>"db2"</code>, <code>"azuredb"</code>,
    ///          <code>"sybase"</code>, <code>"dynamodb"</code>, <code>"mongodb"</code>,
    ///          <code>"kinesis"</code>, <code>"kafka"</code>, <code>"elasticsearch"</code>,
    ///          <code>"documentdb"</code>, <code>"sqlserver"</code>, and <code>"neptune"</code>.</p>
    public let engineName: Swift.String?
    /// <p>The external table definition.</p>
    public let externalTableDefinition: Swift.String?
    /// <p>Additional attributes associated with the connection. To reset this parameter, pass the
    ///          empty string ("") as an argument.</p>
    public let extraConnectionAttributes: Swift.String?
    /// <p>Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other
    ///          available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DB2.ConnectionAttrib">Extra connection attributes
    ///             when using Db2 LUW as a source for AWS DMS</a> in the <i>AWS Database
    ///             Migration Service User Guide.</i>
    ///          </p>
    public let iBMDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
    /// <p>Settings in JSON format for the target Apache Kafka endpoint. For more information about
    ///          the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html">Using Apache Kafka as a Target for AWS
    ///             Database Migration Service</a> in the <i>AWS Database Migration Service User
    ///                Guide.</i>
    ///          </p>
    public let kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
    /// <p>Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For
    ///          more information about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kinesis.html">Using Amazon Kinesis Data Streams
    ///             as a Target for AWS Database Migration Service</a> in the <i>AWS Database Migration Service User
    ///                Guide.</i>
    ///          </p>
    public let kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
    /// <p>Settings in JSON format for the source and target Microsoft SQL Server endpoint. For
    ///          information about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SQLServer.ConnectionAttrib">Extra connection
    ///             attributes when using SQL Server as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SQLServer.ConnectionAttrib">
    ///             Extra connection attributes when using SQL Server as a target for AWS DMS</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
    /// <p>Settings in JSON format for the source MongoDB endpoint. For more information about the
    ///          available settings, see the configuration properties section in <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MongoDB.html"> Using MongoDB as a Target for AWS
    ///             Database Migration Service</a> in the <i>AWS Database Migration Service User
    ///             Guide.</i>
    ///          </p>
    public let mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
    /// <p>Settings in JSON format for the source and target MySQL endpoint. For information about
    ///          other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MySQL.ConnectionAttrib">Extra connection
    ///             attributes when using MySQL as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.MySQL.ConnectionAttrib">Extra
    ///             connection attributes when using a MySQL-compatible database as a target for AWS
    ///             DMS</a> in the <i>AWS Database Migration Service User
    ///          Guide.</i>
    ///          </p>
    public let mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
    /// <p>Settings in JSON format for the target Amazon Neptune endpoint. For more information
    ///          about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.EndpointSettings">Specifying Endpoint Settings for Amazon Neptune as a Target</a>
    ///          in the <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
    /// <p>Settings in JSON format for the source and target Oracle endpoint. For information about
    ///          other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.ConnectionAttrib">Extra connection
    ///             attributes when using Oracle as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Oracle.ConnectionAttrib">
    ///             Extra connection attributes when using Oracle as a target for AWS DMS</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
    /// <p>The password to be used to login to the endpoint database.</p>
    public let password: Swift.String?
    /// <p>The port used by the endpoint database.</p>
    public let port: Swift.Int?
    /// <p>Settings in JSON format for the source and target PostgreSQL endpoint. For information
    ///          about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.ConnectionAttrib">Extra connection
    ///             attributes when using PostgreSQL as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.PostgreSQL.ConnectionAttrib">
    ///             Extra connection attributes when using PostgreSQL as a target for AWS DMS</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
    /// <p>Provides information that defines an Amazon Redshift endpoint.</p>
    public let redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
    /// <p>Settings in JSON format for the target Amazon S3 endpoint. For more information about
    ///             the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring">Extra
    ///             Connection Attributes When Using Amazon S3 as a Target for AWS DMS</a> in the
    ///             <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let s3Settings: DatabaseMigrationClientTypes.S3Settings?
    /// <p>The name of the server where the endpoint database resides.</p>
    public let serverName: Swift.String?
    /// <p> The Amazon Resource Name (ARN) for the service access role you want to use to modify
    ///          the endpoint. </p>
    public let serviceAccessRoleArn: Swift.String?
    /// <p>The SSL mode used to connect to the endpoint.  The default value is <code>none</code>.</p>
    public let sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
    /// <p>Settings in JSON format for the source and target SAP ASE endpoint. For information
    ///          about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SAP.ConnectionAttrib">Extra connection attributes
    ///             when using SAP ASE as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SAP.ConnectionAttrib">Extra connection attributes
    ///             when using SAP ASE as a target for AWS DMS</a> in the <i>AWS Database
    ///             Migration Service User Guide.</i>
    ///          </p>
    public let sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
    /// <p>The user name to be used to login to the endpoint database.</p>
    public let username: Swift.String?

    public init (
        certificateArn: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings? = nil,
        docDbSettings: DatabaseMigrationClientTypes.DocDbSettings? = nil,
        dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings? = nil,
        elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings? = nil,
        endpointArn: Swift.String? = nil,
        endpointIdentifier: Swift.String? = nil,
        endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
        engineName: Swift.String? = nil,
        externalTableDefinition: Swift.String? = nil,
        extraConnectionAttributes: Swift.String? = nil,
        iBMDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings? = nil,
        kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings? = nil,
        kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings? = nil,
        microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings? = nil,
        mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings? = nil,
        mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings? = nil,
        neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings? = nil,
        oracleSettings: DatabaseMigrationClientTypes.OracleSettings? = nil,
        password: Swift.String? = nil,
        port: Swift.Int? = nil,
        postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings? = nil,
        redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings? = nil,
        s3Settings: DatabaseMigrationClientTypes.S3Settings? = nil,
        serverName: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil,
        sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil,
        sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings? = nil,
        username: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.databaseName = databaseName
        self.dmsTransferSettings = dmsTransferSettings
        self.docDbSettings = docDbSettings
        self.dynamoDbSettings = dynamoDbSettings
        self.elasticsearchSettings = elasticsearchSettings
        self.endpointArn = endpointArn
        self.endpointIdentifier = endpointIdentifier
        self.endpointType = endpointType
        self.engineName = engineName
        self.externalTableDefinition = externalTableDefinition
        self.extraConnectionAttributes = extraConnectionAttributes
        self.iBMDb2Settings = iBMDb2Settings
        self.kafkaSettings = kafkaSettings
        self.kinesisSettings = kinesisSettings
        self.microsoftSQLServerSettings = microsoftSQLServerSettings
        self.mongoDbSettings = mongoDbSettings
        self.mySQLSettings = mySQLSettings
        self.neptuneSettings = neptuneSettings
        self.oracleSettings = oracleSettings
        self.password = password
        self.port = port
        self.postgreSQLSettings = postgreSQLSettings
        self.redshiftSettings = redshiftSettings
        self.s3Settings = s3Settings
        self.serverName = serverName
        self.serviceAccessRoleArn = serviceAccessRoleArn
        self.sslMode = sslMode
        self.sybaseSettings = sybaseSettings
        self.username = username
    }
}

struct ModifyEndpointInputBody: Swift.Equatable {
    public let endpointArn: Swift.String?
    public let endpointIdentifier: Swift.String?
    public let endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
    public let engineName: Swift.String?
    public let username: Swift.String?
    public let password: Swift.String?
    public let serverName: Swift.String?
    public let port: Swift.Int?
    public let databaseName: Swift.String?
    public let extraConnectionAttributes: Swift.String?
    public let certificateArn: Swift.String?
    public let sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
    public let serviceAccessRoleArn: Swift.String?
    public let externalTableDefinition: Swift.String?
    public let dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
    public let s3Settings: DatabaseMigrationClientTypes.S3Settings?
    public let dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
    public let mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
    public let kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
    public let kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
    public let elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
    public let neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
    public let redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
    public let postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
    public let mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
    public let oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
    public let sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
    public let microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
    public let iBMDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
    public let docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
}

extension ModifyEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case iBMDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redshiftSettings = "RedshiftSettings"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let extraConnectionAttributesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extraConnectionAttributes)
        extraConnectionAttributes = extraConnectionAttributesDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let dynamoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DynamoDbSettings.self, forKey: .dynamoDbSettings)
        dynamoDbSettings = dynamoDbSettingsDecoded
        let s3SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.S3Settings.self, forKey: .s3Settings)
        s3Settings = s3SettingsDecoded
        let dmsTransferSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsTransferSettings.self, forKey: .dmsTransferSettings)
        dmsTransferSettings = dmsTransferSettingsDecoded
        let mongoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MongoDbSettings.self, forKey: .mongoDbSettings)
        mongoDbSettings = mongoDbSettingsDecoded
        let kinesisSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KinesisSettings.self, forKey: .kinesisSettings)
        kinesisSettings = kinesisSettingsDecoded
        let kafkaSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KafkaSettings.self, forKey: .kafkaSettings)
        kafkaSettings = kafkaSettingsDecoded
        let elasticsearchSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ElasticsearchSettings.self, forKey: .elasticsearchSettings)
        elasticsearchSettings = elasticsearchSettingsDecoded
        let neptuneSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.NeptuneSettings.self, forKey: .neptuneSettings)
        neptuneSettings = neptuneSettingsDecoded
        let redshiftSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedshiftSettings.self, forKey: .redshiftSettings)
        redshiftSettings = redshiftSettingsDecoded
        let postgreSQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.PostgreSQLSettings.self, forKey: .postgreSQLSettings)
        postgreSQLSettings = postgreSQLSettingsDecoded
        let mySQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MySQLSettings.self, forKey: .mySQLSettings)
        mySQLSettings = mySQLSettingsDecoded
        let oracleSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.OracleSettings.self, forKey: .oracleSettings)
        oracleSettings = oracleSettingsDecoded
        let sybaseSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SybaseSettings.self, forKey: .sybaseSettings)
        sybaseSettings = sybaseSettingsDecoded
        let microsoftSQLServerSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MicrosoftSQLServerSettings.self, forKey: .microsoftSQLServerSettings)
        microsoftSQLServerSettings = microsoftSQLServerSettingsDecoded
        let iBMDb2SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.IBMDb2Settings.self, forKey: .iBMDb2Settings)
        iBMDb2Settings = iBMDb2SettingsDecoded
        let docDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DocDbSettings.self, forKey: .docDbSettings)
        docDbSettings = docDbSettingsDecoded
    }
}

extension ModifyEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyEndpointOutputResponse(endpoint: \(Swift.String(describing: endpoint)))"}
}

extension ModifyEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

/// <p></p>
public struct ModifyEndpointOutputResponse: Swift.Equatable {
    /// <p>The modified endpoint.</p>
    public let endpoint: DatabaseMigrationClientTypes.Endpoint?

    public init (
        endpoint: DatabaseMigrationClientTypes.Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct ModifyEndpointOutputResponseBody: Swift.Equatable {
    public let endpoint: DatabaseMigrationClientTypes.Endpoint?
}

extension ModifyEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

public struct ModifyEventSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEventSubscriptionOutputError>
}

extension ModifyEventSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyEventSubscriptionInput(enabled: \(Swift.String(describing: enabled)), eventCategories: \(Swift.String(describing: eventCategories)), snsTopicArn: \(Swift.String(describing: snsTopicArn)), sourceType: \(Swift.String(describing: sourceType)), subscriptionName: \(Swift.String(describing: subscriptionName)))"}
}

extension ModifyEventSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for eventcategorieslist0 in eventCategories {
                try eventCategoriesContainer.encode(eventcategorieslist0)
            }
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let subscriptionName = subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
    }
}

public struct ModifyEventSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEventSubscriptionOutputError>
}

public struct ModifyEventSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEventSubscriptionOutputError>
}

/// <p></p>
public struct ModifyEventSubscriptionInput: Swift.Equatable {
    /// <p> A Boolean value; set to <b>true</b> to activate the
    ///          subscription. </p>
    public let enabled: Swift.Bool?
    /// <p> A list of event categories for a source type that you want to subscribe to. Use the
    ///             <code>DescribeEventCategories</code> action to see a list of event categories. </p>
    public let eventCategories: [Swift.String]?
    /// <p> The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification.
    ///          The ARN is created by Amazon SNS when you create a topic and subscribe to it.</p>
    public let snsTopicArn: Swift.String?
    /// <p> The type of AWS DMS resource that generates the events you want to subscribe to. </p>
    ///          <p>Valid values: replication-instance | replication-task</p>
    public let sourceType: Swift.String?
    /// <p>The name of the AWS DMS event notification subscription to be modified.</p>
    public let subscriptionName: Swift.String?

    public init (
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
    }
}

struct ModifyEventSubscriptionInputBody: Swift.Equatable {
    public let subscriptionName: Swift.String?
    public let snsTopicArn: Swift.String?
    public let sourceType: Swift.String?
    public let eventCategories: [Swift.String]?
    public let enabled: Swift.Bool?
}

extension ModifyEventSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[Swift.String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [Swift.String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension ModifyEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "KMSAccessDeniedFault" : self = .kMSAccessDeniedFault(try KMSAccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledFault" : self = .kMSDisabledFault(try KMSDisabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateFault" : self = .kMSInvalidStateFault(try KMSInvalidStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundFault" : self = .kMSNotFoundFault(try KMSNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingFault" : self = .kMSThrottlingFault(try KMSThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case kMSAccessDeniedFault(KMSAccessDeniedFault)
    case kMSDisabledFault(KMSDisabledFault)
    case kMSInvalidStateFault(KMSInvalidStateFault)
    case kMSNotFoundFault(KMSNotFoundFault)
    case kMSThrottlingFault(KMSThrottlingFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyEventSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyEventSubscriptionOutputResponse(eventSubscription: \(Swift.String(describing: eventSubscription)))"}
}

extension ModifyEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

/// <p></p>
public struct ModifyEventSubscriptionOutputResponse: Swift.Equatable {
    /// <p>The modified event subscription.</p>
    public let eventSubscription: DatabaseMigrationClientTypes.EventSubscription?

    public init (
        eventSubscription: DatabaseMigrationClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct ModifyEventSubscriptionOutputResponseBody: Swift.Equatable {
    public let eventSubscription: DatabaseMigrationClientTypes.EventSubscription?
}

extension ModifyEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct ModifyReplicationInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyReplicationInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyReplicationInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyReplicationInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyReplicationInstanceOutputError>
}

extension ModifyReplicationInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyReplicationInstanceInput(allocatedStorage: \(Swift.String(describing: allocatedStorage)), allowMajorVersionUpgrade: \(Swift.String(describing: allowMajorVersionUpgrade)), applyImmediately: \(Swift.String(describing: applyImmediately)), autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), engineVersion: \(Swift.String(describing: engineVersion)), multiAZ: \(Swift.String(describing: multiAZ)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)), replicationInstanceClass: \(Swift.String(describing: replicationInstanceClass)), replicationInstanceIdentifier: \(Swift.String(describing: replicationInstanceIdentifier)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyReplicationInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
        case applyImmediately = "ApplyImmediately"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case engineVersion = "EngineVersion"
        case multiAZ = "MultiAZ"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedStorage = allocatedStorage {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if allowMajorVersionUpgrade != false {
            try encodeContainer.encode(allowMajorVersionUpgrade, forKey: .allowMajorVersionUpgrade)
        }
        if applyImmediately != false {
            try encodeContainer.encode(applyImmediately, forKey: .applyImmediately)
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let multiAZ = multiAZ {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationInstanceClass = replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let replicationInstanceIdentifier = replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for vpcsecuritygroupidlist0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(vpcsecuritygroupidlist0)
            }
        }
    }
}

public struct ModifyReplicationInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyReplicationInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyReplicationInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyReplicationInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyReplicationInstanceOutputError>
}

public struct ModifyReplicationInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyReplicationInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyReplicationInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyReplicationInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyReplicationInstanceOutputError>
}

/// <p></p>
public struct ModifyReplicationInstanceInput: Swift.Equatable {
    /// <p>The amount of storage (in gigabytes) to be allocated for the replication
    ///          instance.</p>
    public let allocatedStorage: Swift.Int?
    /// <p>Indicates that major version upgrades are allowed. Changing this parameter does not
    ///          result in an outage, and the change is asynchronously applied as soon as possible.</p>
    ///          <p>This parameter must be set to <code>true</code> when specifying a value for the
    ///             <code>EngineVersion</code> parameter that is a different major version than the
    ///          replication instance's current version.</p>
    public let allowMajorVersionUpgrade: Swift.Bool
    /// <p>Indicates whether the changes should be applied immediately or during the next
    ///          maintenance window.</p>
    public let applyImmediately: Swift.Bool
    /// <p>A value that indicates that minor version upgrades are applied automatically to the
    ///          replication instance during the maintenance window. Changing this parameter doesn't result
    ///          in an outage, except in the case described following. The change is asynchronously applied
    ///          as soon as possible. </p>
    ///          <p>An outage does result if these factors apply: </p>
    ///          <ul>
    ///             <li>
    ///                <p>This parameter is set to <code>true</code> during the maintenance window.</p>
    ///             </li>
    ///             <li>
    ///                <p>A newer minor version is available. </p>
    ///             </li>
    ///             <li>
    ///                <p>AWS DMS has enabled automatic patching for the given engine version. </p>
    ///             </li>
    ///          </ul>
    public let autoMinorVersionUpgrade: Swift.Bool?
    /// <p>The engine version number of the replication instance.</p>
    ///          <p>When modifying a major engine version of an instance, also set
    ///          <code>AllowMajorVersionUpgrade</code> to <code>true</code>.</p>
    public let engineVersion: Swift.String?
    /// <p> Specifies whether the replication instance is a Multi-AZ deployment. You can't set the
    ///             <code>AvailabilityZone</code> parameter if the Multi-AZ parameter is set to
    ///             <code>true</code>. </p>
    public let multiAZ: Swift.Bool?
    /// <p>The weekly time range (in UTC) during which system maintenance can occur, which might
    ///          result in an outage. Changing this parameter does not result in an outage, except in the
    ///          following situation, and the change is asynchronously applied as soon as possible. If
    ///          moving this window to the current time, there must be at least 30 minutes between the
    ///          current time and end of the window to ensure pending changes are applied.</p>
    ///          <p>Default: Uses existing setting</p>
    ///          <p>Format: ddd:hh24:mi-ddd:hh24:mi</p>
    ///          <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
    ///          <p>Constraints: Must be at least 30 minutes</p>
    public let preferredMaintenanceWindow: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: Swift.String?
    /// <p>The compute and memory capacity of the replication instance as defined for the specified
    ///          replication instance class. For example to specify the instance class dms.c4.large, set this parameter to <code>"dms.c4.large"</code>.</p>
    ///          <p>For more information on the settings and capacities for the available replication instance classes, see
    ///          <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth">
    ///             Selecting the right AWS DMS replication instance for your migration</a>.
    ///       </p>
    public let replicationInstanceClass: Swift.String?
    /// <p>The replication instance identifier. This parameter is stored as a lowercase
    ///          string.</p>
    public let replicationInstanceIdentifier: Swift.String?
    /// <p> Specifies the VPC security group to be used with the replication instance. The VPC
    ///          security group must work with the VPC containing the replication instance. </p>
    public let vpcSecurityGroupIds: [Swift.String]?

    public init (
        allocatedStorage: Swift.Int? = nil,
        allowMajorVersionUpgrade: Swift.Bool = false,
        applyImmediately: Swift.Bool = false,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        engineVersion: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationInstanceClass: Swift.String? = nil,
        replicationInstanceIdentifier: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.applyImmediately = applyImmediately
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.engineVersion = engineVersion
        self.multiAZ = multiAZ
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationInstanceClass = replicationInstanceClass
        self.replicationInstanceIdentifier = replicationInstanceIdentifier
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct ModifyReplicationInstanceInputBody: Swift.Equatable {
    public let replicationInstanceArn: Swift.String?
    public let allocatedStorage: Swift.Int?
    public let applyImmediately: Swift.Bool
    public let replicationInstanceClass: Swift.String?
    public let vpcSecurityGroupIds: [Swift.String]?
    public let preferredMaintenanceWindow: Swift.String?
    public let multiAZ: Swift.Bool?
    public let engineVersion: Swift.String?
    public let allowMajorVersionUpgrade: Swift.Bool
    public let autoMinorVersionUpgrade: Swift.Bool?
    public let replicationInstanceIdentifier: Swift.String?
}

extension ModifyReplicationInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
        case applyImmediately = "ApplyImmediately"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case engineVersion = "EngineVersion"
        case multiAZ = "MultiAZ"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let applyImmediatelyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyImmediately)
        applyImmediately = applyImmediatelyDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let allowMajorVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowMajorVersionUpgrade)
        allowMajorVersionUpgrade = allowMajorVersionUpgradeDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
    }
}

extension ModifyReplicationInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyReplicationInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientResourceCapacityFault" : self = .insufficientResourceCapacityFault(try InsufficientResourceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UpgradeDependencyFailureFault" : self = .upgradeDependencyFailureFault(try UpgradeDependencyFailureFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyReplicationInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case insufficientResourceCapacityFault(InsufficientResourceCapacityFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case upgradeDependencyFailureFault(UpgradeDependencyFailureFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyReplicationInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyReplicationInstanceOutputResponse(replicationInstance: \(Swift.String(describing: replicationInstance)))"}
}

extension ModifyReplicationInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyReplicationInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

/// <p></p>
public struct ModifyReplicationInstanceOutputResponse: Swift.Equatable {
    /// <p>The modified replication instance.</p>
    public let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init (
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct ModifyReplicationInstanceOutputResponseBody: Swift.Equatable {
    public let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?
}

extension ModifyReplicationInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

public struct ModifyReplicationSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyReplicationSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyReplicationSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyReplicationSubnetGroupOutputError>
}

extension ModifyReplicationSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyReplicationSubnetGroupInput(replicationSubnetGroupDescription: \(Swift.String(describing: replicationSubnetGroupDescription)), replicationSubnetGroupIdentifier: \(Swift.String(describing: replicationSubnetGroupIdentifier)), subnetIds: \(Swift.String(describing: subnetIds)))"}
}

extension ModifyReplicationSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupDescription = replicationSubnetGroupDescription {
            try encodeContainer.encode(replicationSubnetGroupDescription, forKey: .replicationSubnetGroupDescription)
        }
        if let replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidentifierlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidentifierlist0)
            }
        }
    }
}

public struct ModifyReplicationSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyReplicationSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyReplicationSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyReplicationSubnetGroupOutputError>
}

public struct ModifyReplicationSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyReplicationSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyReplicationSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyReplicationSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyReplicationSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyReplicationSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyReplicationSubnetGroupOutputError>
}

/// <p></p>
public struct ModifyReplicationSubnetGroupInput: Swift.Equatable {
    /// <p>A description for the replication instance subnet group.</p>
    public let replicationSubnetGroupDescription: Swift.String?
    /// <p>The name of the replication instance subnet group.</p>
    public let replicationSubnetGroupIdentifier: Swift.String?
    /// <p>A list of subnet IDs.</p>
    public let subnetIds: [Swift.String]?

    public init (
        replicationSubnetGroupDescription: Swift.String? = nil,
        replicationSubnetGroupIdentifier: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.subnetIds = subnetIds
    }
}

struct ModifyReplicationSubnetGroupInputBody: Swift.Equatable {
    public let replicationSubnetGroupIdentifier: Swift.String?
    public let replicationSubnetGroupDescription: Swift.String?
    public let subnetIds: [Swift.String]?
}

extension ModifyReplicationSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let replicationSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupDescription)
        replicationSubnetGroupDescription = replicationSubnetGroupDescriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension ModifyReplicationSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyReplicationSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplicationSubnetGroupDoesNotCoverEnoughAZs" : self = .replicationSubnetGroupDoesNotCoverEnoughAZs(try ReplicationSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetAlreadyInUse" : self = .subnetAlreadyInUse(try SubnetAlreadyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyReplicationSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidSubnet(InvalidSubnet)
    case replicationSubnetGroupDoesNotCoverEnoughAZs(ReplicationSubnetGroupDoesNotCoverEnoughAZs)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case subnetAlreadyInUse(SubnetAlreadyInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyReplicationSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyReplicationSubnetGroupOutputResponse(replicationSubnetGroup: \(Swift.String(describing: replicationSubnetGroup)))"}
}

extension ModifyReplicationSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyReplicationSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationSubnetGroup = output.replicationSubnetGroup
        } else {
            self.replicationSubnetGroup = nil
        }
    }
}

/// <p></p>
public struct ModifyReplicationSubnetGroupOutputResponse: Swift.Equatable {
    /// <p>The modified replication subnet group.</p>
    public let replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?

    public init (
        replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup? = nil
    )
    {
        self.replicationSubnetGroup = replicationSubnetGroup
    }
}

struct ModifyReplicationSubnetGroupOutputResponseBody: Swift.Equatable {
    public let replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?
}

extension ModifyReplicationSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroup = "ReplicationSubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationSubnetGroup.self, forKey: .replicationSubnetGroup)
        replicationSubnetGroup = replicationSubnetGroupDecoded
    }
}

public struct ModifyReplicationTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyReplicationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyReplicationTaskOutputError>
}

extension ModifyReplicationTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyReplicationTaskInput(cdcStartPosition: \(Swift.String(describing: cdcStartPosition)), cdcStartTime: \(Swift.String(describing: cdcStartTime)), cdcStopPosition: \(Swift.String(describing: cdcStopPosition)), migrationType: \(Swift.String(describing: migrationType)), replicationTaskArn: \(Swift.String(describing: replicationTaskArn)), replicationTaskIdentifier: \(Swift.String(describing: replicationTaskIdentifier)), replicationTaskSettings: \(Swift.String(describing: replicationTaskSettings)), tableMappings: \(Swift.String(describing: tableMappings)), taskData: \(Swift.String(describing: taskData)))"}
}

extension ModifyReplicationTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case tableMappings = "TableMappings"
        case taskData = "TaskData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStartTime = cdcStartTime {
            try encodeContainer.encode(cdcStartTime.timeIntervalSince1970, forKey: .cdcStartTime)
        }
        if let cdcStopPosition = cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let migrationType = migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskIdentifier = replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskSettings = replicationTaskSettings {
            try encodeContainer.encode(replicationTaskSettings, forKey: .replicationTaskSettings)
        }
        if let tableMappings = tableMappings {
            try encodeContainer.encode(tableMappings, forKey: .tableMappings)
        }
        if let taskData = taskData {
            try encodeContainer.encode(taskData, forKey: .taskData)
        }
    }
}

public struct ModifyReplicationTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyReplicationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyReplicationTaskOutputError>
}

public struct ModifyReplicationTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyReplicationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyReplicationTaskOutputError>
}

/// <p></p>
public struct ModifyReplicationTaskInput: Swift.Equatable {
    /// <p>Indicates when you want a change data capture (CDC) operation to start. Use either
    ///          CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start.
    ///          Specifying both values results in an error.</p>
    ///          <p> The value can be in date, checkpoint, or LSN/SCN format.</p>
    ///          <p>Date Example: --cdc-start-position â€œ2018-03-08T12:12:12â€</p>
    ///          <p>Checkpoint Example: --cdc-start-position
    ///          "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93"</p>
    ///          <p>LSN Example: --cdc-start-position â€œmysql-bin-changelog.000024:373â€</p>
    ///          <note>
    ///             <p>When you use this task setting with a source PostgreSQL database, a logical
    ///             replication slot should already be created and associated with the source endpoint. You
    ///             can verify this by setting the <code>slotName</code> extra connection attribute to the
    ///             name of this logical replication slot. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib">Extra Connection Attributes When Using PostgreSQL as a Source
    ///                for AWS DMS</a>.</p>
    ///          </note>
    public let cdcStartPosition: Swift.String?
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either
    ///          CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start.
    ///          Specifying both values results in an error.</p>
    ///          <p>Timestamp Example: --cdc-start-time â€œ2018-03-08T12:12:12â€</p>
    public let cdcStartTime: ClientRuntime.Date?
    /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be
    ///          either server time or commit time.</p>
    ///          <p>Server time example: --cdc-stop-position â€œserver_time:2018-02-09T12:12:12â€</p>
    ///          <p>Commit time example: --cdc-stop-position â€œcommit_time: 2018-02-09T12:12:12 â€œ</p>
    public let cdcStopPosition: Swift.String?
    /// <p>The migration type. Valid values: <code>full-load</code> | <code>cdc</code> | <code>full-load-and-cdc</code>
    ///          </p>
    public let migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// <p>The Amazon Resource Name (ARN) of the replication task.</p>
    public let replicationTaskArn: Swift.String?
    /// <p>The replication task identifier.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain 1-255 alphanumeric characters or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let replicationTaskIdentifier: Swift.String?
    /// <p>JSON file that contains settings for the task, such as task metadata settings.</p>
    public let replicationTaskSettings: Swift.String?
    /// <p>When using the AWS CLI or boto3, provide the path of the JSON file that contains the
    ///          table mappings. Precede the path with <code>file://</code>.  For example,
    ///          <code>--table-mappings file://mappingfile.json</code>. When working with the DMS API,
    ///          provide the JSON as the parameter value.
    ///     </p>
    public let tableMappings: Swift.String?
    /// <p>Supplemental information that the task requires to migrate the data for certain source and target endpoints.
    ///             For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html">Specifying Supplemental Data for Task Settings</a> in the
    ///          <i>AWS Database Migration Service User Guide.</i>
    ///          </p>
    public let taskData: Swift.String?

    public init (
        cdcStartPosition: Swift.String? = nil,
        cdcStartTime: ClientRuntime.Date? = nil,
        cdcStopPosition: Swift.String? = nil,
        migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        replicationTaskArn: Swift.String? = nil,
        replicationTaskIdentifier: Swift.String? = nil,
        replicationTaskSettings: Swift.String? = nil,
        tableMappings: Swift.String? = nil,
        taskData: Swift.String? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.migrationType = migrationType
        self.replicationTaskArn = replicationTaskArn
        self.replicationTaskIdentifier = replicationTaskIdentifier
        self.replicationTaskSettings = replicationTaskSettings
        self.tableMappings = tableMappings
        self.taskData = taskData
    }
}

struct ModifyReplicationTaskInputBody: Swift.Equatable {
    public let replicationTaskArn: Swift.String?
    public let replicationTaskIdentifier: Swift.String?
    public let migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    public let tableMappings: Swift.String?
    public let replicationTaskSettings: Swift.String?
    public let cdcStartTime: ClientRuntime.Date?
    public let cdcStartPosition: Swift.String?
    public let cdcStopPosition: Swift.String?
    public let taskData: Swift.String?
}

extension ModifyReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case tableMappings = "TableMappings"
        case taskData = "TaskData"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let tableMappingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableMappings)
        tableMappings = tableMappingsDecoded
        let replicationTaskSettingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskSettings)
        replicationTaskSettings = replicationTaskSettingsDecoded
        let cdcStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .cdcStartTime)
        cdcStartTime = cdcStartTimeDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
        let taskDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskData)
        taskData = taskDataDecoded
    }
}

extension ModifyReplicationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyReplicationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyReplicationTaskOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyReplicationTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyReplicationTaskOutputResponse(replicationTask: \(Swift.String(describing: replicationTask)))"}
}

extension ModifyReplicationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

/// <p></p>
public struct ModifyReplicationTaskOutputResponse: Swift.Equatable {
    /// <p>The replication task that was modified.</p>
    public let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init (
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct ModifyReplicationTaskOutputResponseBody: Swift.Equatable {
    public let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension ModifyReplicationTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension DatabaseMigrationClientTypes.MongoDbSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authMechanism = "AuthMechanism"
        case authSource = "AuthSource"
        case authType = "AuthType"
        case databaseName = "DatabaseName"
        case docsToInvestigate = "DocsToInvestigate"
        case extractDocId = "ExtractDocId"
        case kmsKeyId = "KmsKeyId"
        case nestingLevel = "NestingLevel"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authMechanism = authMechanism {
            try encodeContainer.encode(authMechanism.rawValue, forKey: .authMechanism)
        }
        if let authSource = authSource {
            try encodeContainer.encode(authSource, forKey: .authSource)
        }
        if let authType = authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let docsToInvestigate = docsToInvestigate {
            try encodeContainer.encode(docsToInvestigate, forKey: .docsToInvestigate)
        }
        if let extractDocId = extractDocId {
            try encodeContainer.encode(extractDocId, forKey: .extractDocId)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let nestingLevel = nestingLevel {
            try encodeContainer.encode(nestingLevel.rawValue, forKey: .nestingLevel)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.AuthTypeValue.self, forKey: .authType)
        authType = authTypeDecoded
        let authMechanismDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.AuthMechanismValue.self, forKey: .authMechanism)
        authMechanism = authMechanismDecoded
        let nestingLevelDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.NestingLevelValue.self, forKey: .nestingLevel)
        nestingLevel = nestingLevelDecoded
        let extractDocIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extractDocId)
        extractDocId = extractDocIdDecoded
        let docsToInvestigateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .docsToInvestigate)
        docsToInvestigate = docsToInvestigateDecoded
        let authSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authSource)
        authSource = authSourceDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.MongoDbSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MongoDbSettings(authMechanism: \(Swift.String(describing: authMechanism)), authSource: \(Swift.String(describing: authSource)), authType: \(Swift.String(describing: authType)), databaseName: \(Swift.String(describing: databaseName)), docsToInvestigate: \(Swift.String(describing: docsToInvestigate)), extractDocId: \(Swift.String(describing: extractDocId)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), nestingLevel: \(Swift.String(describing: nestingLevel)), password: \(Swift.String(describing: password)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), username: \(Swift.String(describing: username)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that defines a MongoDB endpoint.</p>
    public struct MongoDbSettings: Swift.Equatable {
        /// <p> The authentication mechanism you use to access the MongoDB source endpoint.</p>
        ///          <p>For the default value, in MongoDB version 2.x, <code>"default"</code> is
        ///             <code>"mongodb_cr"</code>. For MongoDB version 3.x or later, <code>"default"</code> is
        ///             <code>"scram_sha_1"</code>. This setting isn't used when <code>AuthType</code> is
        ///          set to <code>"no"</code>.</p>
        public let authMechanism: DatabaseMigrationClientTypes.AuthMechanismValue?
        /// <p> The MongoDB database name. This setting isn't used when <code>AuthType</code> is
        ///          set to <code>"no"</code>. </p>
        ///          <p>The default is <code>"admin"</code>.</p>
        public let authSource: Swift.String?
        /// <p> The authentication type you use to access the MongoDB source endpoint.</p>
        ///          <p>When when set to <code>"no"</code>, user name and password parameters are not used and
        ///          can be empty. </p>
        public let authType: DatabaseMigrationClientTypes.AuthTypeValue?
        /// <p> The database name on the MongoDB source endpoint. </p>
        public let databaseName: Swift.String?
        /// <p> Indicates the number of documents to preview to determine the document organization.
        ///          Use this setting when <code>NestingLevel</code> is set to <code>"one"</code>. </p>
        ///          <p>Must be a positive value greater than <code>0</code>. Default value is
        ///          <code>1000</code>.</p>
        public let docsToInvestigate: Swift.String?
        /// <p> Specifies the document ID. Use this setting when <code>NestingLevel</code> is set to
        ///             <code>"none"</code>. </p>
        ///          <p>Default value is <code>"false"</code>. </p>
        public let extractDocId: Swift.String?
        /// <p>The AWS KMS key identifier that is used to encrypt the content on the replication
        ///          instance. If you don't specify a value for the <code>KmsKeyId</code> parameter, then
        ///          AWS DMS uses your default encryption key. AWS KMS creates the default encryption key for
        ///          your AWS account. Your AWS account has a different default encryption key for each AWS
        ///          Region.</p>
        public let kmsKeyId: Swift.String?
        /// <p> Specifies either document or table mode. </p>
        ///          <p>Default value is <code>"none"</code>. Specify <code>"none"</code> to use document mode.
        ///          Specify <code>"one"</code> to use table mode.</p>
        public let nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue?
        /// <p> The password for the user account you use to access the MongoDB source endpoint.
        ///       </p>
        public let password: Swift.String?
        /// <p> The port value for the MongoDB source endpoint. </p>
        public let port: Swift.Int?
        /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
        ///          trusted entity and grants the required permissions to access the value in
        ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
        ///          Manager secret that allows access to the MongoDB endpoint.</p>
        ///          <note>
        ///             <p>You can specify one of two sets of values for these permissions. You can specify the
        ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
        ///             clear-text values for <code>UserName</code>, <code>Password</code>,
        ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
        ///             information on creating this <code>SecretsManagerSecret</code> and the
        ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
        ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
        ///                resources</a> in the <i>AWS Database Migration Service User
        ///                Guide</i>.</p>
        ///          </note>
        public let secretsManagerAccessRoleArn: Swift.String?
        /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the MongoDB endpoint connection details.</p>
        public let secretsManagerSecretId: Swift.String?
        /// <p> The name of the server on the MongoDB source endpoint. </p>
        public let serverName: Swift.String?
        /// <p>The user name you use to access the MongoDB source endpoint. </p>
        public let username: Swift.String?

        public init (
            authMechanism: DatabaseMigrationClientTypes.AuthMechanismValue? = nil,
            authSource: Swift.String? = nil,
            authType: DatabaseMigrationClientTypes.AuthTypeValue? = nil,
            databaseName: Swift.String? = nil,
            docsToInvestigate: Swift.String? = nil,
            extractDocId: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.authMechanism = authMechanism
            self.authSource = authSource
            self.authType = authType
            self.databaseName = databaseName
            self.docsToInvestigate = docsToInvestigate
            self.extractDocId = extractDocId
            self.kmsKeyId = kmsKeyId
            self.nestingLevel = nestingLevel
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.username = username
        }
    }

}

public struct MoveReplicationTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "MoveReplicationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<MoveReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<MoveReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<MoveReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<MoveReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<MoveReplicationTaskOutputError>
}

extension MoveReplicationTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MoveReplicationTaskInput(replicationTaskArn: \(Swift.String(describing: replicationTaskArn)), targetReplicationInstanceArn: \(Swift.String(describing: targetReplicationInstanceArn)))"}
}

extension MoveReplicationTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
        case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let targetReplicationInstanceArn = targetReplicationInstanceArn {
            try encodeContainer.encode(targetReplicationInstanceArn, forKey: .targetReplicationInstanceArn)
        }
    }
}

public struct MoveReplicationTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "MoveReplicationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<MoveReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<MoveReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<MoveReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<MoveReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<MoveReplicationTaskOutputError>
}

public struct MoveReplicationTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "MoveReplicationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<MoveReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<MoveReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<MoveReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<MoveReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<MoveReplicationTaskOutputError>
}

/// <p></p>
public struct MoveReplicationTaskInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the task that you want to move.</p>
    public let replicationTaskArn: Swift.String?
    /// <p>The ARN of the replication instance where you want to move the task to.</p>
    public let targetReplicationInstanceArn: Swift.String?

    public init (
        replicationTaskArn: Swift.String? = nil,
        targetReplicationInstanceArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
        self.targetReplicationInstanceArn = targetReplicationInstanceArn
    }
}

struct MoveReplicationTaskInputBody: Swift.Equatable {
    public let replicationTaskArn: Swift.String?
    public let targetReplicationInstanceArn: Swift.String?
}

extension MoveReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
        case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let targetReplicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetReplicationInstanceArn)
        targetReplicationInstanceArn = targetReplicationInstanceArnDecoded
    }
}

extension MoveReplicationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MoveReplicationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MoveReplicationTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension MoveReplicationTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MoveReplicationTaskOutputResponse(replicationTask: \(Swift.String(describing: replicationTask)))"}
}

extension MoveReplicationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MoveReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

/// <p></p>
public struct MoveReplicationTaskOutputResponse: Swift.Equatable {
    /// <p>The replication task that was moved.</p>
    public let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init (
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct MoveReplicationTaskOutputResponseBody: Swift.Equatable {
    public let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension MoveReplicationTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension DatabaseMigrationClientTypes.MySQLSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterConnectScript = "AfterConnectScript"
        case cleanSourceMetadataOnMismatch = "CleanSourceMetadataOnMismatch"
        case databaseName = "DatabaseName"
        case eventsPollInterval = "EventsPollInterval"
        case maxFileSize = "MaxFileSize"
        case parallelLoadThreads = "ParallelLoadThreads"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case serverTimezone = "ServerTimezone"
        case targetDbType = "TargetDbType"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterConnectScript = afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatch {
            try encodeContainer.encode(cleanSourceMetadataOnMismatch, forKey: .cleanSourceMetadataOnMismatch)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let eventsPollInterval = eventsPollInterval {
            try encodeContainer.encode(eventsPollInterval, forKey: .eventsPollInterval)
        }
        if let maxFileSize = maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let parallelLoadThreads = parallelLoadThreads {
            try encodeContainer.encode(parallelLoadThreads, forKey: .parallelLoadThreads)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serverTimezone = serverTimezone {
            try encodeContainer.encode(serverTimezone, forKey: .serverTimezone)
        }
        if let targetDbType = targetDbType {
            try encodeContainer.encode(targetDbType.rawValue, forKey: .targetDbType)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let cleanSourceMetadataOnMismatchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cleanSourceMetadataOnMismatch)
        cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatchDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let eventsPollIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventsPollInterval)
        eventsPollInterval = eventsPollIntervalDecoded
        let targetDbTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.TargetDbType.self, forKey: .targetDbType)
        targetDbType = targetDbTypeDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let parallelLoadThreadsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelLoadThreads)
        parallelLoadThreads = parallelLoadThreadsDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serverTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverTimezone)
        serverTimezone = serverTimezoneDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.MySQLSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MySQLSettings(afterConnectScript: \(Swift.String(describing: afterConnectScript)), cleanSourceMetadataOnMismatch: \(Swift.String(describing: cleanSourceMetadataOnMismatch)), databaseName: \(Swift.String(describing: databaseName)), eventsPollInterval: \(Swift.String(describing: eventsPollInterval)), maxFileSize: \(Swift.String(describing: maxFileSize)), parallelLoadThreads: \(Swift.String(describing: parallelLoadThreads)), password: \(Swift.String(describing: password)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), serverTimezone: \(Swift.String(describing: serverTimezone)), targetDbType: \(Swift.String(describing: targetDbType)), username: \(Swift.String(describing: username)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that defines a MySQL endpoint.</p>
    public struct MySQLSettings: Swift.Equatable {
        /// <p>Specifies a script to run immediately after AWS DMS
        ///          connects to the endpoint. The migration task continues
        ///          running regardless if the SQL statement succeeds or fails.</p>
        public let afterConnectScript: Swift.String?
        /// <p>Adjusts the behavior of DMS when migrating from an SQL Server source database
        ///          that is hosted as part of an Always On availability group cluster.  If you need DMS to poll
        ///          all the nodes in the Always On cluster for transaction backups, set this attribute to
        ///          <code>false</code>.</p>
        public let cleanSourceMetadataOnMismatch: Swift.Bool?
        /// <p>Database name for the endpoint.</p>
        public let databaseName: Swift.String?
        /// <p>Specifies how often to check the binary log for new
        ///          changes/events when the database is idle.</p>
        ///          <p>Example: <code>eventsPollInterval=5;</code>
        ///          </p>
        ///          <p>In the example, AWS DMS checks for changes in the binary
        ///          logs every five seconds.</p>
        public let eventsPollInterval: Swift.Int?
        /// <p>Specifies the maximum size (in KB) of any .csv file used to
        ///          transfer data to a MySQL-compatible database.</p>
        ///          <p>Example: <code>maxFileSize=512</code>
        ///          </p>
        public let maxFileSize: Swift.Int?
        /// <p>Improves performance when loading data into the MySQL-compatible target database.
        ///          Specifies how many threads to use to load the data into the MySQL-compatible target
        ///          database. Setting a large number of threads can have an adverse effect on database
        ///          performance, because a separate connection is required for each thread.</p>
        ///          <p>Example: <code>parallelLoadThreads=1</code>
        ///          </p>
        public let parallelLoadThreads: Swift.Int?
        /// <p>Endpoint connection password.</p>
        public let password: Swift.String?
        /// <p>Endpoint TCP port.</p>
        public let port: Swift.Int?
        /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
        ///          trusted entity and grants the required permissions to access the value in
        ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
        ///          Manager secret that allows access to the MySQL endpoint.</p>
        ///          <note>
        ///             <p>You can specify one of two sets of values for these permissions. You can specify the
        ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
        ///             clear-text values for <code>UserName</code>, <code>Password</code>,
        ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
        ///             information on creating this <code>SecretsManagerSecret</code> and the
        ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
        ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
        ///                resources</a> in the <i>AWS Database Migration Service User
        ///                Guide</i>.</p>
        ///          </note>
        public let secretsManagerAccessRoleArn: Swift.String?
        /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the MySQL endpoint connection details.</p>
        public let secretsManagerSecretId: Swift.String?
        /// <p>Fully qualified domain name of the endpoint.</p>
        public let serverName: Swift.String?
        /// <p>Specifies the time zone for the source MySQL database.</p>
        ///          <p>Example: <code>serverTimezone=US/Pacific;</code>
        ///          </p>
        ///          <p>Note: Do not enclose time zones in single quotes.</p>
        public let serverTimezone: Swift.String?
        /// <p>Specifies where to migrate source tables on the target, either
        ///          to a single database or multiple databases.</p>
        ///          <p>Example: <code>targetDbType=MULTIPLE_DATABASES</code>
        ///          </p>
        public let targetDbType: DatabaseMigrationClientTypes.TargetDbType?
        /// <p>Endpoint connection user name.</p>
        public let username: Swift.String?

        public init (
            afterConnectScript: Swift.String? = nil,
            cleanSourceMetadataOnMismatch: Swift.Bool? = nil,
            databaseName: Swift.String? = nil,
            eventsPollInterval: Swift.Int? = nil,
            maxFileSize: Swift.Int? = nil,
            parallelLoadThreads: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            serverTimezone: Swift.String? = nil,
            targetDbType: DatabaseMigrationClientTypes.TargetDbType? = nil,
            username: Swift.String? = nil
        )
        {
            self.afterConnectScript = afterConnectScript
            self.cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatch
            self.databaseName = databaseName
            self.eventsPollInterval = eventsPollInterval
            self.maxFileSize = maxFileSize
            self.parallelLoadThreads = parallelLoadThreads
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverTimezone = serverTimezone
            self.targetDbType = targetDbType
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.NeptuneSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorRetryDuration = "ErrorRetryDuration"
        case iamAuthEnabled = "IamAuthEnabled"
        case maxFileSize = "MaxFileSize"
        case maxRetryCount = "MaxRetryCount"
        case s3BucketFolder = "S3BucketFolder"
        case s3BucketName = "S3BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorRetryDuration = errorRetryDuration {
            try encodeContainer.encode(errorRetryDuration, forKey: .errorRetryDuration)
        }
        if let iamAuthEnabled = iamAuthEnabled {
            try encodeContainer.encode(iamAuthEnabled, forKey: .iamAuthEnabled)
        }
        if let maxFileSize = maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let maxRetryCount = maxRetryCount {
            try encodeContainer.encode(maxRetryCount, forKey: .maxRetryCount)
        }
        if let s3BucketFolder = s3BucketFolder {
            try encodeContainer.encode(s3BucketFolder, forKey: .s3BucketFolder)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3BucketFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketFolder)
        s3BucketFolder = s3BucketFolderDecoded
        let errorRetryDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorRetryDuration)
        errorRetryDuration = errorRetryDurationDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let maxRetryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetryCount)
        maxRetryCount = maxRetryCountDecoded
        let iamAuthEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .iamAuthEnabled)
        iamAuthEnabled = iamAuthEnabledDecoded
    }
}

extension DatabaseMigrationClientTypes.NeptuneSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NeptuneSettings(errorRetryDuration: \(Swift.String(describing: errorRetryDuration)), iamAuthEnabled: \(Swift.String(describing: iamAuthEnabled)), maxFileSize: \(Swift.String(describing: maxFileSize)), maxRetryCount: \(Swift.String(describing: maxRetryCount)), s3BucketFolder: \(Swift.String(describing: s3BucketFolder)), s3BucketName: \(Swift.String(describing: s3BucketName)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that defines an Amazon Neptune endpoint.</p>
    public struct NeptuneSettings: Swift.Equatable {
        /// <p>The number of milliseconds for AWS DMS to wait to retry a bulk-load of migrated graph
        ///          data to the Neptune target database before raising an error. The default is 250.</p>
        public let errorRetryDuration: Swift.Int?
        /// <p>If you want AWS Identity and Access Management (IAM) authorization enabled for this
        ///          endpoint, set this parameter to <code>true</code>. Then attach the appropriate IAM policy
        ///          document to your service role specified by <code>ServiceAccessRoleArn</code>. The default
        ///          is <code>false</code>.</p>
        public let iamAuthEnabled: Swift.Bool?
        /// <p>The maximum size in kilobytes of migrated graph data stored in a .csv file before AWS
        ///          DMS bulk-loads the data to the Neptune target database. The default is 1,048,576 KB. If the
        ///          bulk load is successful, AWS DMS clears the bucket, ready to store the next batch of
        ///          migrated graph data.</p>
        public let maxFileSize: Swift.Int?
        /// <p>The number of times for AWS DMS to retry a bulk load of migrated graph data to the
        ///          Neptune target database before raising an error. The default is 5.</p>
        public let maxRetryCount: Swift.Int?
        /// <p>A folder path where you want AWS DMS to store migrated graph data in the S3 bucket
        ///          specified by <code>S3BucketName</code>
        ///          </p>
        public let s3BucketFolder: Swift.String?
        /// <p>The name of the Amazon S3 bucket where AWS DMS can temporarily store migrated graph data
        ///          in .csv files before bulk-loading it to the Neptune target database. AWS DMS maps the SQL
        ///          source data to graph data before storing it in these .csv files.</p>
        public let s3BucketName: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the service role that you created for the Neptune
        ///          target endpoint.
        ///          For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.ServiceRole">Creating an IAM Service Role for Accessing Amazon Neptune as a Target</a> in the <i>AWS Database Migration Service User
        ///             Guide. </i>
        ///          </p>
        public let serviceAccessRoleArn: Swift.String?

        public init (
            errorRetryDuration: Swift.Int? = nil,
            iamAuthEnabled: Swift.Bool? = nil,
            maxFileSize: Swift.Int? = nil,
            maxRetryCount: Swift.Int? = nil,
            s3BucketFolder: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil
        )
        {
            self.errorRetryDuration = errorRetryDuration
            self.iamAuthEnabled = iamAuthEnabled
            self.maxFileSize = maxFileSize
            self.maxRetryCount = maxRetryCount
            self.s3BucketFolder = s3BucketFolder
            self.s3BucketName = s3BucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum NestingLevelValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case one
        case sdkUnknown(Swift.String)

        public static var allCases: [NestingLevelValue] {
            return [
                .none,
                .one,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .one: return "one"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NestingLevelValue(rawValue: rawValue) ?? NestingLevelValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.OracleSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessAlternateDirectly = "AccessAlternateDirectly"
        case addSupplementalLogging = "AddSupplementalLogging"
        case additionalArchivedLogDestId = "AdditionalArchivedLogDestId"
        case allowSelectNestedTables = "AllowSelectNestedTables"
        case archivedLogDestId = "ArchivedLogDestId"
        case archivedLogsOnly = "ArchivedLogsOnly"
        case asmPassword = "AsmPassword"
        case asmServer = "AsmServer"
        case asmUser = "AsmUser"
        case charLengthSemantics = "CharLengthSemantics"
        case databaseName = "DatabaseName"
        case directPathNoLog = "DirectPathNoLog"
        case directPathParallelLoad = "DirectPathParallelLoad"
        case enableHomogenousTablespace = "EnableHomogenousTablespace"
        case failTasksOnLobTruncation = "FailTasksOnLobTruncation"
        case numberDatatypeScale = "NumberDatatypeScale"
        case oraclePathPrefix = "OraclePathPrefix"
        case parallelAsmReadThreads = "ParallelAsmReadThreads"
        case password = "Password"
        case port = "Port"
        case readAheadBlocks = "ReadAheadBlocks"
        case readTableSpaceName = "ReadTableSpaceName"
        case replacePathPrefix = "ReplacePathPrefix"
        case retryInterval = "RetryInterval"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerOracleAsmAccessRoleArn = "SecretsManagerOracleAsmAccessRoleArn"
        case secretsManagerOracleAsmSecretId = "SecretsManagerOracleAsmSecretId"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case securityDbEncryption = "SecurityDbEncryption"
        case securityDbEncryptionName = "SecurityDbEncryptionName"
        case serverName = "ServerName"
        case spatialDataOptionToGeoJsonFunctionName = "SpatialDataOptionToGeoJsonFunctionName"
        case useAlternateFolderForOnline = "UseAlternateFolderForOnline"
        case usePathPrefix = "UsePathPrefix"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessAlternateDirectly = accessAlternateDirectly {
            try encodeContainer.encode(accessAlternateDirectly, forKey: .accessAlternateDirectly)
        }
        if let addSupplementalLogging = addSupplementalLogging {
            try encodeContainer.encode(addSupplementalLogging, forKey: .addSupplementalLogging)
        }
        if let additionalArchivedLogDestId = additionalArchivedLogDestId {
            try encodeContainer.encode(additionalArchivedLogDestId, forKey: .additionalArchivedLogDestId)
        }
        if let allowSelectNestedTables = allowSelectNestedTables {
            try encodeContainer.encode(allowSelectNestedTables, forKey: .allowSelectNestedTables)
        }
        if let archivedLogDestId = archivedLogDestId {
            try encodeContainer.encode(archivedLogDestId, forKey: .archivedLogDestId)
        }
        if let archivedLogsOnly = archivedLogsOnly {
            try encodeContainer.encode(archivedLogsOnly, forKey: .archivedLogsOnly)
        }
        if let asmPassword = asmPassword {
            try encodeContainer.encode(asmPassword, forKey: .asmPassword)
        }
        if let asmServer = asmServer {
            try encodeContainer.encode(asmServer, forKey: .asmServer)
        }
        if let asmUser = asmUser {
            try encodeContainer.encode(asmUser, forKey: .asmUser)
        }
        if let charLengthSemantics = charLengthSemantics {
            try encodeContainer.encode(charLengthSemantics.rawValue, forKey: .charLengthSemantics)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let directPathNoLog = directPathNoLog {
            try encodeContainer.encode(directPathNoLog, forKey: .directPathNoLog)
        }
        if let directPathParallelLoad = directPathParallelLoad {
            try encodeContainer.encode(directPathParallelLoad, forKey: .directPathParallelLoad)
        }
        if let enableHomogenousTablespace = enableHomogenousTablespace {
            try encodeContainer.encode(enableHomogenousTablespace, forKey: .enableHomogenousTablespace)
        }
        if let failTasksOnLobTruncation = failTasksOnLobTruncation {
            try encodeContainer.encode(failTasksOnLobTruncation, forKey: .failTasksOnLobTruncation)
        }
        if let numberDatatypeScale = numberDatatypeScale {
            try encodeContainer.encode(numberDatatypeScale, forKey: .numberDatatypeScale)
        }
        if let oraclePathPrefix = oraclePathPrefix {
            try encodeContainer.encode(oraclePathPrefix, forKey: .oraclePathPrefix)
        }
        if let parallelAsmReadThreads = parallelAsmReadThreads {
            try encodeContainer.encode(parallelAsmReadThreads, forKey: .parallelAsmReadThreads)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let readAheadBlocks = readAheadBlocks {
            try encodeContainer.encode(readAheadBlocks, forKey: .readAheadBlocks)
        }
        if let readTableSpaceName = readTableSpaceName {
            try encodeContainer.encode(readTableSpaceName, forKey: .readTableSpaceName)
        }
        if let replacePathPrefix = replacePathPrefix {
            try encodeContainer.encode(replacePathPrefix, forKey: .replacePathPrefix)
        }
        if let retryInterval = retryInterval {
            try encodeContainer.encode(retryInterval, forKey: .retryInterval)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArn {
            try encodeContainer.encode(secretsManagerOracleAsmAccessRoleArn, forKey: .secretsManagerOracleAsmAccessRoleArn)
        }
        if let secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretId {
            try encodeContainer.encode(secretsManagerOracleAsmSecretId, forKey: .secretsManagerOracleAsmSecretId)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let securityDbEncryption = securityDbEncryption {
            try encodeContainer.encode(securityDbEncryption, forKey: .securityDbEncryption)
        }
        if let securityDbEncryptionName = securityDbEncryptionName {
            try encodeContainer.encode(securityDbEncryptionName, forKey: .securityDbEncryptionName)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let spatialDataOptionToGeoJsonFunctionName = spatialDataOptionToGeoJsonFunctionName {
            try encodeContainer.encode(spatialDataOptionToGeoJsonFunctionName, forKey: .spatialDataOptionToGeoJsonFunctionName)
        }
        if let useAlternateFolderForOnline = useAlternateFolderForOnline {
            try encodeContainer.encode(useAlternateFolderForOnline, forKey: .useAlternateFolderForOnline)
        }
        if let usePathPrefix = usePathPrefix {
            try encodeContainer.encode(usePathPrefix, forKey: .usePathPrefix)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addSupplementalLoggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .addSupplementalLogging)
        addSupplementalLogging = addSupplementalLoggingDecoded
        let archivedLogDestIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .archivedLogDestId)
        archivedLogDestId = archivedLogDestIdDecoded
        let additionalArchivedLogDestIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .additionalArchivedLogDestId)
        additionalArchivedLogDestId = additionalArchivedLogDestIdDecoded
        let allowSelectNestedTablesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSelectNestedTables)
        allowSelectNestedTables = allowSelectNestedTablesDecoded
        let parallelAsmReadThreadsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelAsmReadThreads)
        parallelAsmReadThreads = parallelAsmReadThreadsDecoded
        let readAheadBlocksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .readAheadBlocks)
        readAheadBlocks = readAheadBlocksDecoded
        let accessAlternateDirectlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accessAlternateDirectly)
        accessAlternateDirectly = accessAlternateDirectlyDecoded
        let useAlternateFolderForOnlineDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useAlternateFolderForOnline)
        useAlternateFolderForOnline = useAlternateFolderForOnlineDecoded
        let oraclePathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oraclePathPrefix)
        oraclePathPrefix = oraclePathPrefixDecoded
        let usePathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usePathPrefix)
        usePathPrefix = usePathPrefixDecoded
        let replacePathPrefixDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replacePathPrefix)
        replacePathPrefix = replacePathPrefixDecoded
        let enableHomogenousTablespaceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableHomogenousTablespace)
        enableHomogenousTablespace = enableHomogenousTablespaceDecoded
        let directPathNoLogDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .directPathNoLog)
        directPathNoLog = directPathNoLogDecoded
        let archivedLogsOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .archivedLogsOnly)
        archivedLogsOnly = archivedLogsOnlyDecoded
        let asmPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asmPassword)
        asmPassword = asmPasswordDecoded
        let asmServerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asmServer)
        asmServer = asmServerDecoded
        let asmUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asmUser)
        asmUser = asmUserDecoded
        let charLengthSemanticsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.CharLengthSemantics.self, forKey: .charLengthSemantics)
        charLengthSemantics = charLengthSemanticsDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let directPathParallelLoadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .directPathParallelLoad)
        directPathParallelLoad = directPathParallelLoadDecoded
        let failTasksOnLobTruncationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failTasksOnLobTruncation)
        failTasksOnLobTruncation = failTasksOnLobTruncationDecoded
        let numberDatatypeScaleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberDatatypeScale)
        numberDatatypeScale = numberDatatypeScaleDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let readTableSpaceNameDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readTableSpaceName)
        readTableSpaceName = readTableSpaceNameDecoded
        let retryIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryInterval)
        retryInterval = retryIntervalDecoded
        let securityDbEncryptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityDbEncryption)
        securityDbEncryption = securityDbEncryptionDecoded
        let securityDbEncryptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityDbEncryptionName)
        securityDbEncryptionName = securityDbEncryptionNameDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let spatialDataOptionToGeoJsonFunctionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spatialDataOptionToGeoJsonFunctionName)
        spatialDataOptionToGeoJsonFunctionName = spatialDataOptionToGeoJsonFunctionNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
        let secretsManagerOracleAsmAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerOracleAsmAccessRoleArn)
        secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArnDecoded
        let secretsManagerOracleAsmSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerOracleAsmSecretId)
        secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.OracleSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OracleSettings(accessAlternateDirectly: \(Swift.String(describing: accessAlternateDirectly)), addSupplementalLogging: \(Swift.String(describing: addSupplementalLogging)), additionalArchivedLogDestId: \(Swift.String(describing: additionalArchivedLogDestId)), allowSelectNestedTables: \(Swift.String(describing: allowSelectNestedTables)), archivedLogDestId: \(Swift.String(describing: archivedLogDestId)), archivedLogsOnly: \(Swift.String(describing: archivedLogsOnly)), asmPassword: \(Swift.String(describing: asmPassword)), asmServer: \(Swift.String(describing: asmServer)), asmUser: \(Swift.String(describing: asmUser)), charLengthSemantics: \(Swift.String(describing: charLengthSemantics)), databaseName: \(Swift.String(describing: databaseName)), directPathNoLog: \(Swift.String(describing: directPathNoLog)), directPathParallelLoad: \(Swift.String(describing: directPathParallelLoad)), enableHomogenousTablespace: \(Swift.String(describing: enableHomogenousTablespace)), failTasksOnLobTruncation: \(Swift.String(describing: failTasksOnLobTruncation)), numberDatatypeScale: \(Swift.String(describing: numberDatatypeScale)), oraclePathPrefix: \(Swift.String(describing: oraclePathPrefix)), parallelAsmReadThreads: \(Swift.String(describing: parallelAsmReadThreads)), password: \(Swift.String(describing: password)), port: \(Swift.String(describing: port)), readAheadBlocks: \(Swift.String(describing: readAheadBlocks)), readTableSpaceName: \(Swift.String(describing: readTableSpaceName)), replacePathPrefix: \(Swift.String(describing: replacePathPrefix)), retryInterval: \(Swift.String(describing: retryInterval)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerOracleAsmAccessRoleArn: \(Swift.String(describing: secretsManagerOracleAsmAccessRoleArn)), secretsManagerOracleAsmSecretId: \(Swift.String(describing: secretsManagerOracleAsmSecretId)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), securityDbEncryption: \(Swift.String(describing: securityDbEncryption)), securityDbEncryptionName: \(Swift.String(describing: securityDbEncryptionName)), serverName: \(Swift.String(describing: serverName)), spatialDataOptionToGeoJsonFunctionName: \(Swift.String(describing: spatialDataOptionToGeoJsonFunctionName)), useAlternateFolderForOnline: \(Swift.String(describing: useAlternateFolderForOnline)), usePathPrefix: \(Swift.String(describing: usePathPrefix)), username: \(Swift.String(describing: username)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that defines an Oracle endpoint.</p>
    public struct OracleSettings: Swift.Equatable {
        /// <p>Set this attribute to <code>false</code> in order to use the Binary Reader
        ///          to capture change data for an Amazon RDS for Oracle as the
        ///          source. This tells the DMS instance to not access redo logs
        ///          through any specified path prefix replacement using direct
        ///          file access.</p>
        public let accessAlternateDirectly: Swift.Bool?
        /// <p>Set this attribute to set up table-level supplemental logging
        ///          for the Oracle database. This attribute enables PRIMARY KEY
        ///          supplemental logging on all tables selected for a migration
        ///          task.</p>
        ///          <p>If you use this option, you still need to enable
        ///          database-level supplemental logging.</p>
        public let addSupplementalLogging: Swift.Bool?
        /// <p>Set this attribute with <code>archivedLogDestId</code> in a primary/
        ///          standby setup. This attribute is useful in the case of a
        ///          switchover. In this case, AWS DMS needs to know which
        ///          destination to get archive redo logs from to read changes.
        ///          This need arises because the previous primary instance is
        ///          now a standby instance after switchover.</p>
        public let additionalArchivedLogDestId: Swift.Int?
        /// <p>Set this attribute to <code>true</code> to enable replication of Oracle
        ///          tables containing columns that are nested tables or defined
        ///          types.</p>
        public let allowSelectNestedTables: Swift.Bool?
        /// <p>Specifies the destination of the archived redo logs. The
        ///          value should be the same as the DEST_ID number in the
        ///          v$archived_log table. When working with multiple log
        ///          destinations (DEST_ID), we recommend that you to specify
        ///          an archived redo logs location identifier. Doing this improves
        ///          performance by ensuring that the correct logs are accessed
        ///          from the outset.</p>
        public let archivedLogDestId: Swift.Int?
        /// <p>When this field is set to <code>Y</code>, AWS DMS only accesses the
        ///          archived redo logs. If the archived redo logs are stored on
        ///          Oracle ASM only, the AWS DMS user account needs to be
        ///          granted ASM privileges.</p>
        public let archivedLogsOnly: Swift.Bool?
        /// <p>For an Oracle source endpoint, your Oracle Automatic Storage Management (ASM) password.
        ///          You can set this value from the <code>
        ///                <i>asm_user_password</i>
        ///             </code> value.
        ///          You set this value as part of the comma-separated value that you set to the
        ///             <code>Password</code> request parameter when you create the endpoint to access
        ///          transaction logs using Binary Reader. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration">Configuration for change data capture (CDC) on an Oracle source
        ///             database</a>.</p>
        public let asmPassword: Swift.String?
        /// <p>For an Oracle source endpoint, your ASM server address. You can set this value from the
        ///             <code>asm_server</code> value. You set <code>asm_server</code> as part of the extra
        ///          connection attribute string to access an Oracle server with Binary Reader that uses ASM.
        ///          For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration">Configuration for change data capture (CDC) on an Oracle source
        ///             database</a>.</p>
        public let asmServer: Swift.String?
        /// <p>For an Oracle source endpoint, your ASM user name. You can set this value from the
        ///             <code>asm_user</code> value. You set <code>asm_user</code> as part of the extra
        ///          connection attribute string to access an Oracle server with Binary Reader that uses ASM.
        ///          For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration">Configuration for change data capture (CDC) on an Oracle source
        ///             database</a>.</p>
        public let asmUser: Swift.String?
        /// <p>Specifies whether the length of a character column is in
        ///          bytes or in characters. To indicate that the character column
        ///          length is in characters, set this attribute to <code>CHAR</code>. Otherwise,
        ///          the character column length is in bytes.</p>
        ///          <p>Example: <code>charLengthSemantics=CHAR;</code>
        ///          </p>
        public let charLengthSemantics: DatabaseMigrationClientTypes.CharLengthSemantics?
        /// <p>Database name for the endpoint.</p>
        public let databaseName: Swift.String?
        /// <p>When set to <code>true</code>, this attribute helps to increase the
        ///          commit rate on the Oracle target database by writing
        ///          directly to tables and not writing a trail to database logs.</p>
        public let directPathNoLog: Swift.Bool?
        /// <p>When set to <code>true</code>, this attribute specifies a parallel load
        ///          when <code>useDirectPathFullLoad</code> is set to <code>Y</code>. This attribute
        ///          also only applies when you use the AWS DMS parallel load
        ///          feature.  Note that the target table cannot have any constraints or indexes.</p>
        public let directPathParallelLoad: Swift.Bool?
        /// <p>Set this attribute to enable homogenous tablespace
        ///          replication and create existing tables or indexes under the
        ///          same tablespace on the target.</p>
        public let enableHomogenousTablespace: Swift.Bool?
        /// <p>When set to <code>true</code>, this attribute causes a task to fail if the
        ///          actual size of an LOB column is greater than the specified
        ///          <code>LobMaxSize</code>.</p>
        ///          <p>If a task is set to limited LOB mode and this option is set to
        ///          <code>true</code>, the task fails instead of truncating the LOB data.</p>
        public let failTasksOnLobTruncation: Swift.Bool?
        /// <p>Specifies the number scale. You can select a scale up to 38,
        ///          or you can select FLOAT. By default, the NUMBER data type
        ///          is converted to precision 38, scale 10.</p>
        ///          <p>Example: <code>numberDataTypeScale=12</code>
        ///          </p>
        public let numberDatatypeScale: Swift.Int?
        /// <p>Set this string attribute to the required value in order to use
        ///          the Binary Reader to capture change data for an Amazon
        ///          RDS for Oracle as the source. This value specifies the
        ///          default Oracle root used to access the redo logs.</p>
        public let oraclePathPrefix: Swift.String?
        /// <p>Set this attribute to change the number of threads that
        ///          DMS configures to perform a Change Data Capture (CDC)
        ///          load using Oracle Automatic Storage Management (ASM).
        ///          You can specify an integer value between 2 (the default)
        ///          and 8 (the maximum). Use this attribute together with the
        ///          <code>readAheadBlocks</code> attribute.</p>
        public let parallelAsmReadThreads: Swift.Int?
        /// <p>Endpoint connection password.</p>
        public let password: Swift.String?
        /// <p>Endpoint TCP port.</p>
        public let port: Swift.Int?
        /// <p>Set this attribute to change the number of read-ahead
        ///          blocks that DMS configures to perform a Change Data
        ///          Capture (CDC) load using Oracle Automatic Storage
        ///          Management (ASM). You can specify an integer value
        ///          between 1000 (the default) and 200,000 (the maximum).</p>
        public let readAheadBlocks: Swift.Int?
        /// <p>When set to <code>true</code>, this attribute supports tablespace
        ///          replication.</p>
        public let readTableSpaceName: Swift.Bool?
        /// <p>Set this attribute to true in order to use the Binary Reader
        ///          to capture change data for an Amazon RDS for Oracle as the
        ///          source. This setting tells DMS instance to replace the default
        ///          Oracle root with the specified <code>usePathPrefix</code> setting to
        ///          access the redo logs.</p>
        public let replacePathPrefix: Swift.Bool?
        /// <p>Specifies the number of seconds that the system waits
        ///          before resending a query.</p>
        ///          <p>Example: <code>retryInterval=6;</code>
        ///          </p>
        public let retryInterval: Swift.Int?
        /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
        ///          trusted entity and grants the required permissions to access the value in
        ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
        ///          Manager secret that allows access to the Oracle endpoint.</p>
        ///          <note>
        ///             <p>You can specify one of two sets of values for these permissions. You can specify the
        ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
        ///             clear-text values for <code>UserName</code>, <code>Password</code>,
        ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
        ///             information on creating this <code>SecretsManagerSecret</code> and the
        ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
        ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
        ///                resources</a> in the <i>AWS Database Migration Service User
        ///                Guide</i>.</p>
        ///          </note>
        public let secretsManagerAccessRoleArn: Swift.String?
        /// <p>Required only if your Oracle endpoint uses Advanced Storage Manager (ASM). The full ARN
        ///          of the IAM role that specifies AWS DMS as the trusted entity and grants the required
        ///          permissions to access the <code>SecretsManagerOracleAsmSecret</code>. This
        ///             <code>SecretsManagerOracleAsmSecret</code> has the secret value that allows access to
        ///          the Oracle ASM of the endpoint.</p>
        ///          <note>
        ///             <p>You can specify one of two sets of values for these permissions. You can specify the
        ///             values for this setting and <code>SecretsManagerOracleAsmSecretId</code>. Or you can
        ///             specify clear-text values for <code>AsmUserName</code>, <code>AsmPassword</code>, and
        ///                <code>AsmServerName</code>. You can't specify both. For more information on
        ///             creating this <code>SecretsManagerOracleAsmSecret</code> and the
        ///                <code>SecretsManagerOracleAsmAccessRoleArn</code> and
        ///                <code>SecretsManagerOracleAsmSecretId</code> required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
        ///                resources</a> in the <i>AWS Database Migration Service User
        ///                Guide</i>.</p>
        ///          </note>
        public let secretsManagerOracleAsmAccessRoleArn: Swift.String?
        /// <p>Required only if your Oracle endpoint uses Advanced Storage Manager (ASM). The full ARN, partial ARN, or friendly name of the <code>SecretsManagerOracleAsmSecret</code>
        ///          that contains the Oracle ASM connection details for the Oracle endpoint.</p>
        public let secretsManagerOracleAsmSecretId: Swift.String?
        /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the Oracle endpoint connection details.</p>
        public let secretsManagerSecretId: Swift.String?
        /// <p>For an Oracle source endpoint, the transparent data encryption (TDE) password required
        ///          by AWM DMS to access Oracle redo logs encrypted by TDE using Binary Reader. It is also the
        ///                <code>
        ///                <i>TDE_Password</i>
        ///             </code> part of the comma-separated value you
        ///          set to the <code>Password</code> request parameter when you create the endpoint. The
        ///             <code>SecurityDbEncryptian</code> setting is related to this
        ///             <code>SecurityDbEncryptionName</code> setting. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.Encryption"> Supported encryption methods for using Oracle as a source for AWS
        ///             DMS</a> in the <i>AWS Database Migration Service User Guide</i>. </p>
        public let securityDbEncryption: Swift.String?
        /// <p>For an Oracle source endpoint, the name of a key used for the transparent data
        ///          encryption (TDE) of the columns and tablespaces in an Oracle source database that is
        ///          encrypted using TDE. The key value is the value of the <code>SecurityDbEncryption</code>
        ///          setting. For more information on setting the key name value of
        ///             <code>SecurityDbEncryptionName</code>, see the information and example for setting the
        ///             <code>securityDbEncryptionName</code> extra connection attribute in <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.Encryption"> Supported encryption methods for using Oracle as a source for AWS
        ///             DMS</a> in the <i>AWS Database Migration Service User
        ///          Guide</i>.</p>
        public let securityDbEncryptionName: Swift.String?
        /// <p>Fully qualified domain name of the endpoint.</p>
        public let serverName: Swift.String?
        /// <p>Use this attribute to convert <code>SDO_GEOMETRY</code> to
        ///          <code>GEOJSON</code> format. By default, DMS calls the
        ///          <code>SDO2GEOJSON</code> custom function if present and accessible.
        ///          Or you can create your own custom function that mimics the operation of
        ///          <code>SDOGEOJSON</code> and set
        ///          <code>SpatialDataOptionToGeoJsonFunctionName</code> to call it instead. </p>
        public let spatialDataOptionToGeoJsonFunctionName: Swift.String?
        /// <p>Set this attribute to <code>true</code> in order to use the Binary Reader
        ///          to capture change data for an Amazon RDS for Oracle as
        ///          the source. This tells the DMS instance to use any specified
        ///          prefix replacement to access all online redo logs.</p>
        public let useAlternateFolderForOnline: Swift.Bool?
        /// <p>Set this string attribute to the required value in order to use
        ///          the Binary Reader to capture change data for an Amazon
        ///          RDS for Oracle as the source. This value specifies the path
        ///          prefix used to replace the default Oracle root to access the
        ///          redo logs.</p>
        public let usePathPrefix: Swift.String?
        /// <p>Endpoint connection user name.</p>
        public let username: Swift.String?

        public init (
            accessAlternateDirectly: Swift.Bool? = nil,
            addSupplementalLogging: Swift.Bool? = nil,
            additionalArchivedLogDestId: Swift.Int? = nil,
            allowSelectNestedTables: Swift.Bool? = nil,
            archivedLogDestId: Swift.Int? = nil,
            archivedLogsOnly: Swift.Bool? = nil,
            asmPassword: Swift.String? = nil,
            asmServer: Swift.String? = nil,
            asmUser: Swift.String? = nil,
            charLengthSemantics: DatabaseMigrationClientTypes.CharLengthSemantics? = nil,
            databaseName: Swift.String? = nil,
            directPathNoLog: Swift.Bool? = nil,
            directPathParallelLoad: Swift.Bool? = nil,
            enableHomogenousTablespace: Swift.Bool? = nil,
            failTasksOnLobTruncation: Swift.Bool? = nil,
            numberDatatypeScale: Swift.Int? = nil,
            oraclePathPrefix: Swift.String? = nil,
            parallelAsmReadThreads: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            readAheadBlocks: Swift.Int? = nil,
            readTableSpaceName: Swift.Bool? = nil,
            replacePathPrefix: Swift.Bool? = nil,
            retryInterval: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerOracleAsmAccessRoleArn: Swift.String? = nil,
            secretsManagerOracleAsmSecretId: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            securityDbEncryption: Swift.String? = nil,
            securityDbEncryptionName: Swift.String? = nil,
            serverName: Swift.String? = nil,
            spatialDataOptionToGeoJsonFunctionName: Swift.String? = nil,
            useAlternateFolderForOnline: Swift.Bool? = nil,
            usePathPrefix: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.accessAlternateDirectly = accessAlternateDirectly
            self.addSupplementalLogging = addSupplementalLogging
            self.additionalArchivedLogDestId = additionalArchivedLogDestId
            self.allowSelectNestedTables = allowSelectNestedTables
            self.archivedLogDestId = archivedLogDestId
            self.archivedLogsOnly = archivedLogsOnly
            self.asmPassword = asmPassword
            self.asmServer = asmServer
            self.asmUser = asmUser
            self.charLengthSemantics = charLengthSemantics
            self.databaseName = databaseName
            self.directPathNoLog = directPathNoLog
            self.directPathParallelLoad = directPathParallelLoad
            self.enableHomogenousTablespace = enableHomogenousTablespace
            self.failTasksOnLobTruncation = failTasksOnLobTruncation
            self.numberDatatypeScale = numberDatatypeScale
            self.oraclePathPrefix = oraclePathPrefix
            self.parallelAsmReadThreads = parallelAsmReadThreads
            self.password = password
            self.port = port
            self.readAheadBlocks = readAheadBlocks
            self.readTableSpaceName = readTableSpaceName
            self.replacePathPrefix = replacePathPrefix
            self.retryInterval = retryInterval
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArn
            self.secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretId
            self.secretsManagerSecretId = secretsManagerSecretId
            self.securityDbEncryption = securityDbEncryption
            self.securityDbEncryptionName = securityDbEncryptionName
            self.serverName = serverName
            self.spatialDataOptionToGeoJsonFunctionName = spatialDataOptionToGeoJsonFunctionName
            self.useAlternateFolderForOnline = useAlternateFolderForOnline
            self.usePathPrefix = usePathPrefix
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.OrderableReplicationInstance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case defaultAllocatedStorage = "DefaultAllocatedStorage"
        case engineVersion = "EngineVersion"
        case includedAllocatedStorage = "IncludedAllocatedStorage"
        case maxAllocatedStorage = "MaxAllocatedStorage"
        case minAllocatedStorage = "MinAllocatedStorage"
        case releaseStatus = "ReleaseStatus"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzoneslist0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzoneslist0)
            }
        }
        if defaultAllocatedStorage != 0 {
            try encodeContainer.encode(defaultAllocatedStorage, forKey: .defaultAllocatedStorage)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if includedAllocatedStorage != 0 {
            try encodeContainer.encode(includedAllocatedStorage, forKey: .includedAllocatedStorage)
        }
        if maxAllocatedStorage != 0 {
            try encodeContainer.encode(maxAllocatedStorage, forKey: .maxAllocatedStorage)
        }
        if minAllocatedStorage != 0 {
            try encodeContainer.encode(minAllocatedStorage, forKey: .minAllocatedStorage)
        }
        if let releaseStatus = releaseStatus {
            try encodeContainer.encode(releaseStatus.rawValue, forKey: .releaseStatus)
        }
        if let replicationInstanceClass = replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType, forKey: .storageType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let minAllocatedStorageDecoded = try containerValues.decode(Swift.Int.self, forKey: .minAllocatedStorage)
        minAllocatedStorage = minAllocatedStorageDecoded
        let maxAllocatedStorageDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxAllocatedStorage)
        maxAllocatedStorage = maxAllocatedStorageDecoded
        let defaultAllocatedStorageDecoded = try containerValues.decode(Swift.Int.self, forKey: .defaultAllocatedStorage)
        defaultAllocatedStorage = defaultAllocatedStorageDecoded
        let includedAllocatedStorageDecoded = try containerValues.decode(Swift.Int.self, forKey: .includedAllocatedStorage)
        includedAllocatedStorage = includedAllocatedStorageDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let releaseStatusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReleaseStatusValues.self, forKey: .releaseStatus)
        releaseStatus = releaseStatusDecoded
    }
}

extension DatabaseMigrationClientTypes.OrderableReplicationInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrderableReplicationInstance(availabilityZones: \(Swift.String(describing: availabilityZones)), defaultAllocatedStorage: \(Swift.String(describing: defaultAllocatedStorage)), engineVersion: \(Swift.String(describing: engineVersion)), includedAllocatedStorage: \(Swift.String(describing: includedAllocatedStorage)), maxAllocatedStorage: \(Swift.String(describing: maxAllocatedStorage)), minAllocatedStorage: \(Swift.String(describing: minAllocatedStorage)), releaseStatus: \(Swift.String(describing: releaseStatus)), replicationInstanceClass: \(Swift.String(describing: replicationInstanceClass)), storageType: \(Swift.String(describing: storageType)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>In response to the <code>DescribeOrderableReplicationInstances</code> operation, this
    ///          object describes an available replication instance. This description includes the
    ///          replication instance's type, engine version, and allocated storage.</p>
    public struct OrderableReplicationInstance: Swift.Equatable {
        /// <p>List of Availability Zones for this replication instance.</p>
        public let availabilityZones: [Swift.String]?
        /// <p>The default amount of storage (in gigabytes) that is allocated for the replication
        ///          instance.</p>
        public let defaultAllocatedStorage: Swift.Int
        /// <p>The version of the replication engine.</p>
        public let engineVersion: Swift.String?
        /// <p>The amount of storage (in gigabytes) that is allocated for the replication
        ///          instance.</p>
        public let includedAllocatedStorage: Swift.Int
        /// <p>The minimum amount of storage (in gigabytes) that can be allocated for the replication
        ///          instance.</p>
        public let maxAllocatedStorage: Swift.Int
        /// <p>The minimum amount of storage (in gigabytes) that can be allocated for the replication
        ///          instance.</p>
        public let minAllocatedStorage: Swift.Int
        /// <p>The value returned when the specified <code>EngineVersion</code> of the replication
        ///          instance is in Beta or test mode. This indicates some features might not work as expected.</p>
        ///          <note>
        ///             <p>AWS DMS supports the <code>ReleaseStatus</code> parameter in versions 3.1.4 and later.</p>
        ///          </note>
        public let releaseStatus: DatabaseMigrationClientTypes.ReleaseStatusValues?
        /// <p>The compute and memory capacity of the replication instance as defined for the specified
        ///          replication instance class. For example to specify the instance class dms.c4.large, set this parameter to <code>"dms.c4.large"</code>.</p>
        ///          <p>For more information on the settings and capacities for the available replication instance classes, see
        ///          <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth">
        ///             Selecting the right AWS DMS replication instance for your migration</a>.
        ///       </p>
        public let replicationInstanceClass: Swift.String?
        /// <p>The type of storage used by the replication instance.</p>
        public let storageType: Swift.String?

        public init (
            availabilityZones: [Swift.String]? = nil,
            defaultAllocatedStorage: Swift.Int = 0,
            engineVersion: Swift.String? = nil,
            includedAllocatedStorage: Swift.Int = 0,
            maxAllocatedStorage: Swift.Int = 0,
            minAllocatedStorage: Swift.Int = 0,
            releaseStatus: DatabaseMigrationClientTypes.ReleaseStatusValues? = nil,
            replicationInstanceClass: Swift.String? = nil,
            storageType: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.defaultAllocatedStorage = defaultAllocatedStorage
            self.engineVersion = engineVersion
            self.includedAllocatedStorage = includedAllocatedStorage
            self.maxAllocatedStorage = maxAllocatedStorage
            self.minAllocatedStorage = minAllocatedStorage
            self.releaseStatus = releaseStatus
            self.replicationInstanceClass = replicationInstanceClass
            self.storageType = storageType
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum ParquetVersionValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case parquet10
        case parquet20
        case sdkUnknown(Swift.String)

        public static var allCases: [ParquetVersionValue] {
            return [
                .parquet10,
                .parquet20,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .parquet10: return "parquet-1-0"
            case .parquet20: return "parquet-2-0"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParquetVersionValue(rawValue: rawValue) ?? ParquetVersionValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.PendingMaintenanceAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case autoAppliedAfterDate = "AutoAppliedAfterDate"
        case currentApplyDate = "CurrentApplyDate"
        case description = "Description"
        case forcedApplyDate = "ForcedApplyDate"
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let autoAppliedAfterDate = autoAppliedAfterDate {
            try encodeContainer.encode(autoAppliedAfterDate.timeIntervalSince1970, forKey: .autoAppliedAfterDate)
        }
        if let currentApplyDate = currentApplyDate {
            try encodeContainer.encode(currentApplyDate.timeIntervalSince1970, forKey: .currentApplyDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forcedApplyDate = forcedApplyDate {
            try encodeContainer.encode(forcedApplyDate.timeIntervalSince1970, forKey: .forcedApplyDate)
        }
        if let optInStatus = optInStatus {
            try encodeContainer.encode(optInStatus, forKey: .optInStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let autoAppliedAfterDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .autoAppliedAfterDate)
        autoAppliedAfterDate = autoAppliedAfterDateDecoded
        let forcedApplyDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .forcedApplyDate)
        forcedApplyDate = forcedApplyDateDecoded
        let optInStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
        let currentApplyDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .currentApplyDate)
        currentApplyDate = currentApplyDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DatabaseMigrationClientTypes.PendingMaintenanceAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PendingMaintenanceAction(action: \(Swift.String(describing: action)), autoAppliedAfterDate: \(Swift.String(describing: autoAppliedAfterDate)), currentApplyDate: \(Swift.String(describing: currentApplyDate)), description: \(Swift.String(describing: description)), forcedApplyDate: \(Swift.String(describing: forcedApplyDate)), optInStatus: \(Swift.String(describing: optInStatus)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Describes a maintenance action pending for an AWS DMS resource, including when and how
    ///          it will be applied. This data type is a response element to the
    ///             <code>DescribePendingMaintenanceActions</code> operation.</p>
    public struct PendingMaintenanceAction: Swift.Equatable {
        /// <p>The type of pending maintenance action that is available for the resource.</p>
        public let action: Swift.String?
        /// <p>The date of the maintenance window when the action is to be applied. The maintenance
        ///          action is applied to the resource during its first maintenance window after this date. If
        ///          this date is specified, any <code>next-maintenance</code> opt-in requests are
        ///          ignored.</p>
        public let autoAppliedAfterDate: ClientRuntime.Date?
        /// <p>The effective date when the pending maintenance action will be applied to the resource.
        ///          This date takes into account opt-in requests received from the
        ///             <code>ApplyPendingMaintenanceAction</code> API operation, and also the
        ///             <code>AutoAppliedAfterDate</code> and <code>ForcedApplyDate</code> parameter values.
        ///          This value is blank if an opt-in request has not been received and nothing has been
        ///          specified for <code>AutoAppliedAfterDate</code> or <code>ForcedApplyDate</code>.</p>
        public let currentApplyDate: ClientRuntime.Date?
        /// <p>A description providing more detail about the maintenance action.</p>
        public let description: Swift.String?
        /// <p>The date when the maintenance action will be automatically applied. The maintenance
        ///          action is applied to the resource on this date regardless of the maintenance window for the
        ///          resource. If this date is specified, any <code>immediate</code> opt-in requests are
        ///          ignored.</p>
        public let forcedApplyDate: ClientRuntime.Date?
        /// <p>The type of opt-in request that has been received for the resource.</p>
        public let optInStatus: Swift.String?

        public init (
            action: Swift.String? = nil,
            autoAppliedAfterDate: ClientRuntime.Date? = nil,
            currentApplyDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            forcedApplyDate: ClientRuntime.Date? = nil,
            optInStatus: Swift.String? = nil
        )
        {
            self.action = action
            self.autoAppliedAfterDate = autoAppliedAfterDate
            self.currentApplyDate = currentApplyDate
            self.description = description
            self.forcedApplyDate = forcedApplyDate
            self.optInStatus = optInStatus
        }
    }

}

extension DatabaseMigrationClientTypes.PostgreSQLSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterConnectScript = "AfterConnectScript"
        case captureDdls = "CaptureDdls"
        case databaseName = "DatabaseName"
        case ddlArtifactsSchema = "DdlArtifactsSchema"
        case executeTimeout = "ExecuteTimeout"
        case failTasksOnLobTruncation = "FailTasksOnLobTruncation"
        case maxFileSize = "MaxFileSize"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case slotName = "SlotName"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterConnectScript = afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let captureDdls = captureDdls {
            try encodeContainer.encode(captureDdls, forKey: .captureDdls)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let ddlArtifactsSchema = ddlArtifactsSchema {
            try encodeContainer.encode(ddlArtifactsSchema, forKey: .ddlArtifactsSchema)
        }
        if let executeTimeout = executeTimeout {
            try encodeContainer.encode(executeTimeout, forKey: .executeTimeout)
        }
        if let failTasksOnLobTruncation = failTasksOnLobTruncation {
            try encodeContainer.encode(failTasksOnLobTruncation, forKey: .failTasksOnLobTruncation)
        }
        if let maxFileSize = maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let slotName = slotName {
            try encodeContainer.encode(slotName, forKey: .slotName)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let captureDdlsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .captureDdls)
        captureDdls = captureDdlsDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let ddlArtifactsSchemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ddlArtifactsSchema)
        ddlArtifactsSchema = ddlArtifactsSchemaDecoded
        let executeTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executeTimeout)
        executeTimeout = executeTimeoutDecoded
        let failTasksOnLobTruncationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failTasksOnLobTruncation)
        failTasksOnLobTruncation = failTasksOnLobTruncationDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.PostgreSQLSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PostgreSQLSettings(afterConnectScript: \(Swift.String(describing: afterConnectScript)), captureDdls: \(Swift.String(describing: captureDdls)), databaseName: \(Swift.String(describing: databaseName)), ddlArtifactsSchema: \(Swift.String(describing: ddlArtifactsSchema)), executeTimeout: \(Swift.String(describing: executeTimeout)), failTasksOnLobTruncation: \(Swift.String(describing: failTasksOnLobTruncation)), maxFileSize: \(Swift.String(describing: maxFileSize)), password: \(Swift.String(describing: password)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), slotName: \(Swift.String(describing: slotName)), username: \(Swift.String(describing: username)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that defines a PostgreSQL endpoint.</p>
    public struct PostgreSQLSettings: Swift.Equatable {
        /// <p>For use with change data capture (CDC) only, this attribute
        ///          has AWS DMS bypass foreign keys and user triggers to
        ///          reduce the time it takes to bulk load data.</p>
        ///          <p>Example: <code>afterConnectScript=SET
        ///          session_replication_role='replica'</code>
        ///          </p>
        public let afterConnectScript: Swift.String?
        /// <p>To capture DDL events, AWS DMS creates various artifacts in
        ///          the PostgreSQL database when the task starts. You can later
        ///          remove these artifacts.</p>
        ///          <p>If this value is set to <code>N</code>, you don't have to create tables or
        ///          triggers on the source database.</p>
        public let captureDdls: Swift.Bool?
        /// <p>Database name for the endpoint.</p>
        public let databaseName: Swift.String?
        /// <p>The schema in which the operational DDL database artifacts
        ///          are created.</p>
        ///          <p>Example: <code>ddlArtifactsSchema=xyzddlschema;</code>
        ///          </p>
        public let ddlArtifactsSchema: Swift.String?
        /// <p>Sets the client statement timeout for the PostgreSQL
        ///          instance, in seconds. The default value is 60 seconds.</p>
        ///          <p>Example: <code>executeTimeout=100;</code>
        ///          </p>
        public let executeTimeout: Swift.Int?
        /// <p>When set to <code>true</code>, this value causes a task to fail if the
        ///          actual size of a LOB column is greater than the specified
        ///          <code>LobMaxSize</code>.</p>
        ///          <p>If task is set to Limited LOB mode and this option is set to
        ///          true, the task fails instead of truncating the LOB data.</p>
        public let failTasksOnLobTruncation: Swift.Bool?
        /// <p>Specifies the maximum size (in KB) of any .csv file used to
        ///          transfer data to PostgreSQL.</p>
        ///          <p>Example: <code>maxFileSize=512</code>
        ///          </p>
        public let maxFileSize: Swift.Int?
        /// <p>Endpoint connection password.</p>
        public let password: Swift.String?
        /// <p>Endpoint TCP port.</p>
        public let port: Swift.Int?
        /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
        ///          trusted entity and grants the required permissions to access the value in
        ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
        ///          Manager secret that allows access to the PostgreSQL endpoint.</p>
        ///          <note>
        ///             <p>You can specify one of two sets of values for these permissions. You can specify the
        ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
        ///             clear-text values for <code>UserName</code>, <code>Password</code>,
        ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
        ///             information on creating this <code>SecretsManagerSecret</code> and the
        ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
        ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
        ///                resources</a> in the <i>AWS Database Migration Service User
        ///                Guide</i>.</p>
        ///          </note>
        public let secretsManagerAccessRoleArn: Swift.String?
        /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the PostgreSQL endpoint connection details.</p>
        public let secretsManagerSecretId: Swift.String?
        /// <p>Fully qualified domain name of the endpoint.</p>
        public let serverName: Swift.String?
        /// <p>Sets the name of a previously created logical replication slot
        ///          for a CDC load of the PostgreSQL source instance.</p>
        ///          <p>When used with the AWS DMS API <code>CdcStartPosition</code>
        ///          request parameter, this attribute also enables using native
        ///          CDC start points.</p>
        public let slotName: Swift.String?
        /// <p>Endpoint connection user name.</p>
        public let username: Swift.String?

        public init (
            afterConnectScript: Swift.String? = nil,
            captureDdls: Swift.Bool? = nil,
            databaseName: Swift.String? = nil,
            ddlArtifactsSchema: Swift.String? = nil,
            executeTimeout: Swift.Int? = nil,
            failTasksOnLobTruncation: Swift.Bool? = nil,
            maxFileSize: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            slotName: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.afterConnectScript = afterConnectScript
            self.captureDdls = captureDdls
            self.databaseName = databaseName
            self.ddlArtifactsSchema = ddlArtifactsSchema
            self.executeTimeout = executeTimeout
            self.failTasksOnLobTruncation = failTasksOnLobTruncation
            self.maxFileSize = maxFileSize
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.slotName = slotName
            self.username = username
        }
    }

}

public struct RebootReplicationInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootReplicationInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootReplicationInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootReplicationInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootReplicationInstanceOutputError>
}

extension RebootReplicationInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootReplicationInstanceInput(forceFailover: \(Swift.String(describing: forceFailover)), replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)))"}
}

extension RebootReplicationInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceFailover = "ForceFailover"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forceFailover = forceFailover {
            try encodeContainer.encode(forceFailover, forKey: .forceFailover)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct RebootReplicationInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootReplicationInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootReplicationInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootReplicationInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootReplicationInstanceOutputError>
}

public struct RebootReplicationInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootReplicationInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootReplicationInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootReplicationInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootReplicationInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootReplicationInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootReplicationInstanceOutputError>
}

public struct RebootReplicationInstanceInput: Swift.Equatable {
    /// <p>If this parameter is <code>true</code>, the reboot is conducted through a Multi-AZ
    ///          failover. (If the instance isn't configured for Multi-AZ, then you can't specify
    ///             <code>true</code>.)</p>
    public let forceFailover: Swift.Bool?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: Swift.String?

    public init (
        forceFailover: Swift.Bool? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.forceFailover = forceFailover
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct RebootReplicationInstanceInputBody: Swift.Equatable {
    public let replicationInstanceArn: Swift.String?
    public let forceFailover: Swift.Bool?
}

extension RebootReplicationInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceFailover = "ForceFailover"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let forceFailoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceFailover)
        forceFailover = forceFailoverDecoded
    }
}

extension RebootReplicationInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootReplicationInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootReplicationInstanceOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootReplicationInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootReplicationInstanceOutputResponse(replicationInstance: \(Swift.String(describing: replicationInstance)))"}
}

extension RebootReplicationInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RebootReplicationInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

public struct RebootReplicationInstanceOutputResponse: Swift.Equatable {
    /// <p>The replication instance that is being rebooted. </p>
    public let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init (
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct RebootReplicationInstanceOutputResponseBody: Swift.Equatable {
    public let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?
}

extension RebootReplicationInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

extension DatabaseMigrationClientTypes.RedshiftSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptAnyDate = "AcceptAnyDate"
        case afterConnectScript = "AfterConnectScript"
        case bucketFolder = "BucketFolder"
        case bucketName = "BucketName"
        case caseSensitiveNames = "CaseSensitiveNames"
        case compUpdate = "CompUpdate"
        case connectionTimeout = "ConnectionTimeout"
        case databaseName = "DatabaseName"
        case dateFormat = "DateFormat"
        case emptyAsNull = "EmptyAsNull"
        case encryptionMode = "EncryptionMode"
        case explicitIds = "ExplicitIds"
        case fileTransferUploadStreams = "FileTransferUploadStreams"
        case loadTimeout = "LoadTimeout"
        case maxFileSize = "MaxFileSize"
        case password = "Password"
        case port = "Port"
        case removeQuotes = "RemoveQuotes"
        case replaceChars = "ReplaceChars"
        case replaceInvalidChars = "ReplaceInvalidChars"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case timeFormat = "TimeFormat"
        case trimBlanks = "TrimBlanks"
        case truncateColumns = "TruncateColumns"
        case username = "Username"
        case writeBufferSize = "WriteBufferSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptAnyDate = acceptAnyDate {
            try encodeContainer.encode(acceptAnyDate, forKey: .acceptAnyDate)
        }
        if let afterConnectScript = afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let bucketFolder = bucketFolder {
            try encodeContainer.encode(bucketFolder, forKey: .bucketFolder)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let caseSensitiveNames = caseSensitiveNames {
            try encodeContainer.encode(caseSensitiveNames, forKey: .caseSensitiveNames)
        }
        if let compUpdate = compUpdate {
            try encodeContainer.encode(compUpdate, forKey: .compUpdate)
        }
        if let connectionTimeout = connectionTimeout {
            try encodeContainer.encode(connectionTimeout, forKey: .connectionTimeout)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dateFormat = dateFormat {
            try encodeContainer.encode(dateFormat, forKey: .dateFormat)
        }
        if let emptyAsNull = emptyAsNull {
            try encodeContainer.encode(emptyAsNull, forKey: .emptyAsNull)
        }
        if let encryptionMode = encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let explicitIds = explicitIds {
            try encodeContainer.encode(explicitIds, forKey: .explicitIds)
        }
        if let fileTransferUploadStreams = fileTransferUploadStreams {
            try encodeContainer.encode(fileTransferUploadStreams, forKey: .fileTransferUploadStreams)
        }
        if let loadTimeout = loadTimeout {
            try encodeContainer.encode(loadTimeout, forKey: .loadTimeout)
        }
        if let maxFileSize = maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let removeQuotes = removeQuotes {
            try encodeContainer.encode(removeQuotes, forKey: .removeQuotes)
        }
        if let replaceChars = replaceChars {
            try encodeContainer.encode(replaceChars, forKey: .replaceChars)
        }
        if let replaceInvalidChars = replaceInvalidChars {
            try encodeContainer.encode(replaceInvalidChars, forKey: .replaceInvalidChars)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId {
            try encodeContainer.encode(serverSideEncryptionKmsKeyId, forKey: .serverSideEncryptionKmsKeyId)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let timeFormat = timeFormat {
            try encodeContainer.encode(timeFormat, forKey: .timeFormat)
        }
        if let trimBlanks = trimBlanks {
            try encodeContainer.encode(trimBlanks, forKey: .trimBlanks)
        }
        if let truncateColumns = truncateColumns {
            try encodeContainer.encode(truncateColumns, forKey: .truncateColumns)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
        if let writeBufferSize = writeBufferSize {
            try encodeContainer.encode(writeBufferSize, forKey: .writeBufferSize)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptAnyDateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .acceptAnyDate)
        acceptAnyDate = acceptAnyDateDecoded
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let bucketFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketFolder)
        bucketFolder = bucketFolderDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let caseSensitiveNamesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .caseSensitiveNames)
        caseSensitiveNames = caseSensitiveNamesDecoded
        let compUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .compUpdate)
        compUpdate = compUpdateDecoded
        let connectionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionTimeout)
        connectionTimeout = connectionTimeoutDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dateFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateFormat)
        dateFormat = dateFormatDecoded
        let emptyAsNullDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .emptyAsNull)
        emptyAsNull = emptyAsNullDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EncryptionModeValue.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let explicitIdsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .explicitIds)
        explicitIds = explicitIdsDecoded
        let fileTransferUploadStreamsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileTransferUploadStreams)
        fileTransferUploadStreams = fileTransferUploadStreamsDecoded
        let loadTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .loadTimeout)
        loadTimeout = loadTimeoutDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let removeQuotesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeQuotes)
        removeQuotes = removeQuotesDecoded
        let replaceInvalidCharsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replaceInvalidChars)
        replaceInvalidChars = replaceInvalidCharsDecoded
        let replaceCharsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replaceChars)
        replaceChars = replaceCharsDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let serverSideEncryptionKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverSideEncryptionKmsKeyId)
        serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyIdDecoded
        let timeFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeFormat)
        timeFormat = timeFormatDecoded
        let trimBlanksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .trimBlanks)
        trimBlanks = trimBlanksDecoded
        let truncateColumnsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .truncateColumns)
        truncateColumns = truncateColumnsDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let writeBufferSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .writeBufferSize)
        writeBufferSize = writeBufferSizeDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.RedshiftSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedshiftSettings(acceptAnyDate: \(Swift.String(describing: acceptAnyDate)), afterConnectScript: \(Swift.String(describing: afterConnectScript)), bucketFolder: \(Swift.String(describing: bucketFolder)), bucketName: \(Swift.String(describing: bucketName)), caseSensitiveNames: \(Swift.String(describing: caseSensitiveNames)), compUpdate: \(Swift.String(describing: compUpdate)), connectionTimeout: \(Swift.String(describing: connectionTimeout)), databaseName: \(Swift.String(describing: databaseName)), dateFormat: \(Swift.String(describing: dateFormat)), emptyAsNull: \(Swift.String(describing: emptyAsNull)), encryptionMode: \(Swift.String(describing: encryptionMode)), explicitIds: \(Swift.String(describing: explicitIds)), fileTransferUploadStreams: \(Swift.String(describing: fileTransferUploadStreams)), loadTimeout: \(Swift.String(describing: loadTimeout)), maxFileSize: \(Swift.String(describing: maxFileSize)), password: \(Swift.String(describing: password)), port: \(Swift.String(describing: port)), removeQuotes: \(Swift.String(describing: removeQuotes)), replaceChars: \(Swift.String(describing: replaceChars)), replaceInvalidChars: \(Swift.String(describing: replaceInvalidChars)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), serverSideEncryptionKmsKeyId: \(Swift.String(describing: serverSideEncryptionKmsKeyId)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), timeFormat: \(Swift.String(describing: timeFormat)), trimBlanks: \(Swift.String(describing: trimBlanks)), truncateColumns: \(Swift.String(describing: truncateColumns)), username: \(Swift.String(describing: username)), writeBufferSize: \(Swift.String(describing: writeBufferSize)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that defines an Amazon Redshift endpoint.</p>
    public struct RedshiftSettings: Swift.Equatable {
        /// <p>A value that indicates to allow any date format, including invalid formats such as
        ///          00/00/00 00:00:00, to be loaded without generating an error. You can choose
        ///             <code>true</code> or <code>false</code> (the default).</p>
        ///          <p>This parameter applies only to TIMESTAMP and DATE columns. Always use ACCEPTANYDATE with
        ///          the DATEFORMAT parameter. If the date format for the data doesn't match the DATEFORMAT
        ///          specification, Amazon Redshift inserts a NULL value into that field. </p>
        public let acceptAnyDate: Swift.Bool?
        /// <p>Code to run after connecting. This parameter should contain the code itself, not the
        ///          name of a file containing the code.</p>
        public let afterConnectScript: Swift.String?
        /// <p>An S3 folder where the comma-separated-value (.csv) files are stored before being
        ///          uploaded to the target Redshift cluster. </p>
        ///          <p>For full load mode, AWS DMS converts source records into .csv files and loads them to
        ///          the <i>BucketFolder/TableID</i> path. AWS DMS uses the Redshift
        ///             <code>COPY</code> command to upload the .csv files to the target table. The files are
        ///          deleted once the <code>COPY</code> operation has finished. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_COPY.html">COPY</a> in the
        ///             <i>Amazon Redshift Database Developer Guide</i>.</p>
        ///          <p>For change-data-capture (CDC) mode, AWS DMS creates a <i>NetChanges</i> table,
        ///          and loads the .csv files to this <i>BucketFolder/NetChangesTableID</i> path.</p>
        public let bucketFolder: Swift.String?
        /// <p>The name of the intermediate S3 bucket used to store .csv files before uploading data to Redshift.</p>
        public let bucketName: Swift.String?
        /// <p>If Amazon Redshift is configured to support case sensitive schema names, set
        ///             <code>CaseSensitiveNames</code> to <code>true</code>. The default is
        ///          <code>false</code>.</p>
        public let caseSensitiveNames: Swift.Bool?
        /// <p>If you set <code>CompUpdate</code> to <code>true</code> Amazon Redshift applies
        ///          automatic compression if the table is empty. This applies even if the table columns already
        ///          have encodings other than <code>RAW</code>. If you set <code>CompUpdate</code> to
        ///             <code>false</code>, automatic compression is disabled and existing column encodings
        ///          aren't changed. The default is <code>true</code>.</p>
        public let compUpdate: Swift.Bool?
        /// <p>A value that sets the amount of time to wait (in milliseconds) before timing out,
        ///          beginning from when you initially establish a connection.</p>
        public let connectionTimeout: Swift.Int?
        /// <p>The name of the Amazon Redshift data warehouse (service) that you are working
        ///          with.</p>
        public let databaseName: Swift.String?
        /// <p>The date format that you are using. Valid values are <code>auto</code> (case-sensitive),
        ///          your date format string enclosed in quotes, or NULL. If this parameter is left unset
        ///          (NULL), it defaults to a format of 'YYYY-MM-DD'. Using <code>auto</code> recognizes most
        ///          strings, even some that aren't supported when you use a date format string. </p>
        ///          <p>If your date and time values use formats different from each other, set this to
        ///          <code>auto</code>. </p>
        public let dateFormat: Swift.String?
        /// <p>A value that specifies whether AWS DMS should migrate empty CHAR and VARCHAR fields as
        ///          NULL. A value of <code>true</code> sets empty CHAR and VARCHAR fields to null. The default
        ///          is <code>false</code>.</p>
        public let emptyAsNull: Swift.Bool?
        /// <p>The type of server-side encryption that you want to use for your data. This encryption
        ///          type is part of the endpoint settings or the extra connections attributes for Amazon S3.
        ///          You can choose either <code>SSE_S3</code> (the default) or <code>SSE_KMS</code>. </p>
        ///          <note>
        ///             <p>For the <code>ModifyEndpoint</code> operation, you can change the existing value of the
        ///                <code>EncryptionMode</code> parameter from <code>SSE_KMS</code> to
        ///                <code>SSE_S3</code>. But you canâ€™t change the existing value from <code>SSE_S3</code>
        ///             to <code>SSE_KMS</code>.</p>
        ///          </note>
        ///          <p>To use <code>SSE_S3</code>, create an AWS Identity and Access Management (IAM) role with
        ///          a policy that allows <code>"arn:aws:s3:::*"</code> to use the following actions:
        ///             <code>"s3:PutObject", "s3:ListBucket"</code>
        ///          </p>
        public let encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue?
        /// <p>This setting is only valid for a full-load migration task. Set <code>ExplicitIds</code>
        ///          to <code>true</code> to have tables with <code>IDENTITY</code> columns override their
        ///          auto-generated values with explicit values loaded from the source data files used to
        ///          populate the tables. The default is <code>false</code>.</p>
        public let explicitIds: Swift.Bool?
        /// <p>The number of threads used to upload a single file. This parameter accepts a value from
        ///          1 through 64. It defaults to 10.</p>
        ///          <p>The number of parallel streams used to upload a single .csv file to an S3 bucket using
        ///          S3 Multipart Upload. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html">Multipart upload
        ///             overview</a>. </p>
        ///          <p>
        ///             <code>FileTransferUploadStreams</code> accepts a value from 1 through 64. It
        ///          defaults to 10.</p>
        public let fileTransferUploadStreams: Swift.Int?
        /// <p>The amount of time to wait (in milliseconds) before timing out of operations performed
        ///             by AWS DMS on a Redshift cluster, such as Redshift COPY, INSERT, DELETE, and UPDATE.</p>
        public let loadTimeout: Swift.Int?
        /// <p>The maximum size (in KB) of any .csv file used to load data on an S3 bucket and transfer
        ///             data to Amazon Redshift. It defaults to 1048576KB (1 GB).</p>
        public let maxFileSize: Swift.Int?
        /// <p>The password for the user named in the <code>username</code> property.</p>
        public let password: Swift.String?
        /// <p>The port number for Amazon Redshift. The default value is 5439.</p>
        public let port: Swift.Int?
        /// <p>A value that specifies to remove surrounding quotation marks from strings in the
        ///          incoming data. All characters within the quotation marks, including delimiters, are
        ///          retained. Choose <code>true</code> to remove quotation marks. The default is
        ///             <code>false</code>.</p>
        public let removeQuotes: Swift.Bool?
        /// <p>A value that specifies to replaces the invalid characters specified in
        ///          <code>ReplaceInvalidChars</code>, substituting the specified characters instead. The
        ///          default is <code>"?"</code>.</p>
        public let replaceChars: Swift.String?
        /// <p>A list of characters that you want to replace. Use with
        ///          <code>ReplaceChars</code>.</p>
        public let replaceInvalidChars: Swift.String?
        /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
        ///          trusted entity and grants the required permissions to access the value in
        ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
        ///          Manager secret that allows access to the Amazon Redshift endpoint.</p>
        ///          <note>
        ///             <p>You can specify one of two sets of values for these permissions. You can specify the
        ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
        ///             clear-text values for <code>UserName</code>, <code>Password</code>,
        ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
        ///             information on creating this <code>SecretsManagerSecret</code> and the
        ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
        ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
        ///                resources</a> in the <i>AWS Database Migration Service User
        ///                Guide</i>.</p>
        ///          </note>
        public let secretsManagerAccessRoleArn: Swift.String?
        /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the Amazon Redshift endpoint connection details.</p>
        public let secretsManagerSecretId: Swift.String?
        /// <p>The name of the Amazon Redshift cluster you are using.</p>
        public let serverName: Swift.String?
        /// <p>The AWS KMS key ID. If you are using <code>SSE_KMS</code> for the <code>EncryptionMode</code>,
        ///          provide this key ID. The key that you use needs an attached policy that enables IAM user
        ///          permissions and allows use of the key.</p>
        public let serverSideEncryptionKmsKeyId: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the IAM role that has access to the Amazon Redshift
        ///          service.</p>
        public let serviceAccessRoleArn: Swift.String?
        /// <p>The time format that you want to use. Valid values are <code>auto</code>
        ///          (case-sensitive), <code>'timeformat_string'</code>, <code>'epochsecs'</code>, or
        ///          <code>'epochmillisecs'</code>. It defaults to 10. Using <code>auto</code> recognizes
        ///          most strings, even some that aren't supported when you use a time format string. </p>
        ///          <p>If your date and time values use formats different from each other, set this parameter
        ///          to <code>auto</code>. </p>
        public let timeFormat: Swift.String?
        /// <p>A value that specifies to remove the trailing white space characters from a VARCHAR
        ///          string. This parameter applies only to columns with a VARCHAR data type. Choose
        ///             <code>true</code> to remove unneeded white space. The default is
        ///          <code>false</code>.</p>
        public let trimBlanks: Swift.Bool?
        /// <p>A value that specifies to truncate data in columns to the appropriate number of
        ///          characters, so that the data fits in the column. This parameter applies only to columns
        ///          with a VARCHAR or CHAR data type, and rows with a size of 4 MB or less. Choose
        ///             <code>true</code> to truncate data. The default is <code>false</code>.</p>
        public let truncateColumns: Swift.Bool?
        /// <p>An Amazon Redshift user name for a registered user.</p>
        public let username: Swift.String?
        /// <p>The size (in KB) of the in-memory file write buffer used when generating .csv files
        ///          on the local disk at the DMS replication instance. The default value is 1000
        ///          (buffer size is 1000KB).</p>
        public let writeBufferSize: Swift.Int?

        public init (
            acceptAnyDate: Swift.Bool? = nil,
            afterConnectScript: Swift.String? = nil,
            bucketFolder: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            caseSensitiveNames: Swift.Bool? = nil,
            compUpdate: Swift.Bool? = nil,
            connectionTimeout: Swift.Int? = nil,
            databaseName: Swift.String? = nil,
            dateFormat: Swift.String? = nil,
            emptyAsNull: Swift.Bool? = nil,
            encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue? = nil,
            explicitIds: Swift.Bool? = nil,
            fileTransferUploadStreams: Swift.Int? = nil,
            loadTimeout: Swift.Int? = nil,
            maxFileSize: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            removeQuotes: Swift.Bool? = nil,
            replaceChars: Swift.String? = nil,
            replaceInvalidChars: Swift.String? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            serverSideEncryptionKmsKeyId: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            timeFormat: Swift.String? = nil,
            trimBlanks: Swift.Bool? = nil,
            truncateColumns: Swift.Bool? = nil,
            username: Swift.String? = nil,
            writeBufferSize: Swift.Int? = nil
        )
        {
            self.acceptAnyDate = acceptAnyDate
            self.afterConnectScript = afterConnectScript
            self.bucketFolder = bucketFolder
            self.bucketName = bucketName
            self.caseSensitiveNames = caseSensitiveNames
            self.compUpdate = compUpdate
            self.connectionTimeout = connectionTimeout
            self.databaseName = databaseName
            self.dateFormat = dateFormat
            self.emptyAsNull = emptyAsNull
            self.encryptionMode = encryptionMode
            self.explicitIds = explicitIds
            self.fileTransferUploadStreams = fileTransferUploadStreams
            self.loadTimeout = loadTimeout
            self.maxFileSize = maxFileSize
            self.password = password
            self.port = port
            self.removeQuotes = removeQuotes
            self.replaceChars = replaceChars
            self.replaceInvalidChars = replaceInvalidChars
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.timeFormat = timeFormat
            self.trimBlanks = trimBlanks
            self.truncateColumns = truncateColumns
            self.username = username
            self.writeBufferSize = writeBufferSize
        }
    }

}

public struct RefreshSchemasInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshSchemasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RefreshSchemasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RefreshSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RefreshSchemasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RefreshSchemasOutputError>
}

extension RefreshSchemasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RefreshSchemasInput(endpointArn: \(Swift.String(describing: endpointArn)), replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)))"}
}

extension RefreshSchemasInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct RefreshSchemasInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshSchemasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RefreshSchemasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RefreshSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RefreshSchemasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RefreshSchemasOutputError>
}

public struct RefreshSchemasInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshSchemasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RefreshSchemasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RefreshSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RefreshSchemasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RefreshSchemasOutputError>
}

/// <p></p>
public struct RefreshSchemasInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct RefreshSchemasInputBody: Swift.Equatable {
    public let endpointArn: Swift.String?
    public let replicationInstanceArn: Swift.String?
}

extension RefreshSchemasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
    }
}

extension RefreshSchemasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RefreshSchemasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RefreshSchemasOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RefreshSchemasOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RefreshSchemasOutputResponse(refreshSchemasStatus: \(Swift.String(describing: refreshSchemasStatus)))"}
}

extension RefreshSchemasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RefreshSchemasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.refreshSchemasStatus = output.refreshSchemasStatus
        } else {
            self.refreshSchemasStatus = nil
        }
    }
}

/// <p></p>
public struct RefreshSchemasOutputResponse: Swift.Equatable {
    /// <p>The status of the refreshed schema.</p>
    public let refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus?

    public init (
        refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus? = nil
    )
    {
        self.refreshSchemasStatus = refreshSchemasStatus
    }
}

struct RefreshSchemasOutputResponseBody: Swift.Equatable {
    public let refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus?
}

extension RefreshSchemasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case refreshSchemasStatus = "RefreshSchemasStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refreshSchemasStatusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RefreshSchemasStatus.self, forKey: .refreshSchemasStatus)
        refreshSchemasStatus = refreshSchemasStatusDecoded
    }
}

extension DatabaseMigrationClientTypes.RefreshSchemasStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case lastFailureMessage = "LastFailureMessage"
        case lastRefreshDate = "LastRefreshDate"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let lastFailureMessage = lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let lastRefreshDate = lastRefreshDate {
            try encodeContainer.encode(lastRefreshDate.timeIntervalSince1970, forKey: .lastRefreshDate)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RefreshSchemasStatusTypeValue.self, forKey: .status)
        status = statusDecoded
        let lastRefreshDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastRefreshDate)
        lastRefreshDate = lastRefreshDateDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
    }
}

extension DatabaseMigrationClientTypes.RefreshSchemasStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RefreshSchemasStatus(endpointArn: \(Swift.String(describing: endpointArn)), lastFailureMessage: \(Swift.String(describing: lastFailureMessage)), lastRefreshDate: \(Swift.String(describing: lastRefreshDate)), replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)), status: \(Swift.String(describing: status)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that describes status of a schema at an endpoint specified by the
    ///          <code>DescribeRefreshSchemaStatus</code> operation.</p>
    public struct RefreshSchemasStatus: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
        public let endpointArn: Swift.String?
        /// <p>The last failure message for the schema.</p>
        public let lastFailureMessage: Swift.String?
        /// <p>The date the schema was last refreshed.</p>
        public let lastRefreshDate: ClientRuntime.Date?
        /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
        public let replicationInstanceArn: Swift.String?
        /// <p>The status of the schema.</p>
        public let status: DatabaseMigrationClientTypes.RefreshSchemasStatusTypeValue?

        public init (
            endpointArn: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            lastRefreshDate: ClientRuntime.Date? = nil,
            replicationInstanceArn: Swift.String? = nil,
            status: DatabaseMigrationClientTypes.RefreshSchemasStatusTypeValue? = nil
        )
        {
            self.endpointArn = endpointArn
            self.lastFailureMessage = lastFailureMessage
            self.lastRefreshDate = lastRefreshDate
            self.replicationInstanceArn = replicationInstanceArn
            self.status = status
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum RefreshSchemasStatusTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case refreshing
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [RefreshSchemasStatusTypeValue] {
            return [
                .failed,
                .refreshing,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "failed"
            case .refreshing: return "refreshing"
            case .successful: return "successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RefreshSchemasStatusTypeValue(rawValue: rawValue) ?? RefreshSchemasStatusTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum ReleaseStatusValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beta
        case sdkUnknown(Swift.String)

        public static var allCases: [ReleaseStatusValues] {
            return [
                .beta,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beta: return "beta"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReleaseStatusValues(rawValue: rawValue) ?? ReleaseStatusValues.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum ReloadOptionValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dataReload
        case validateOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [ReloadOptionValue] {
            return [
                .dataReload,
                .validateOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dataReload: return "data-reload"
            case .validateOnly: return "validate-only"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReloadOptionValue(rawValue: rawValue) ?? ReloadOptionValue.sdkUnknown(rawValue)
        }
    }
}

public struct ReloadTablesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReloadTablesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReloadTablesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReloadTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReloadTablesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReloadTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReloadTablesOutputError>
}

extension ReloadTablesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReloadTablesInput(reloadOption: \(Swift.String(describing: reloadOption)), replicationTaskArn: \(Swift.String(describing: replicationTaskArn)), tablesToReload: \(Swift.String(describing: tablesToReload)))"}
}

extension ReloadTablesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reloadOption = "ReloadOption"
        case replicationTaskArn = "ReplicationTaskArn"
        case tablesToReload = "TablesToReload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reloadOption = reloadOption {
            try encodeContainer.encode(reloadOption.rawValue, forKey: .reloadOption)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let tablesToReload = tablesToReload {
            var tablesToReloadContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tablesToReload)
            for tablelisttoreload0 in tablesToReload {
                try tablesToReloadContainer.encode(tablelisttoreload0)
            }
        }
    }
}

public struct ReloadTablesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReloadTablesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReloadTablesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReloadTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReloadTablesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReloadTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReloadTablesOutputError>
}

public struct ReloadTablesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReloadTablesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReloadTablesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReloadTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReloadTablesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReloadTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReloadTablesOutputError>
}

public struct ReloadTablesInput: Swift.Equatable {
    /// <p>Options for reload. Specify <code>data-reload</code> to reload the data and re-validate
    ///          it if validation is enabled. Specify <code>validate-only</code> to re-validate the table.
    ///          This option applies only when validation is enabled for the task. </p>
    ///          <p>Valid values: data-reload, validate-only</p>
    ///          <p>Default value is data-reload.</p>
    public let reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue?
    /// <p>The Amazon Resource Name (ARN) of the replication task. </p>
    public let replicationTaskArn: Swift.String?
    /// <p>The name and schema of the table to be reloaded. </p>
    public let tablesToReload: [DatabaseMigrationClientTypes.TableToReload]?

    public init (
        reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue? = nil,
        replicationTaskArn: Swift.String? = nil,
        tablesToReload: [DatabaseMigrationClientTypes.TableToReload]? = nil
    )
    {
        self.reloadOption = reloadOption
        self.replicationTaskArn = replicationTaskArn
        self.tablesToReload = tablesToReload
    }
}

struct ReloadTablesInputBody: Swift.Equatable {
    public let replicationTaskArn: Swift.String?
    public let tablesToReload: [DatabaseMigrationClientTypes.TableToReload]?
    public let reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue?
}

extension ReloadTablesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reloadOption = "ReloadOption"
        case replicationTaskArn = "ReplicationTaskArn"
        case tablesToReload = "TablesToReload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let tablesToReloadContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.TableToReload?].self, forKey: .tablesToReload)
        var tablesToReloadDecoded0:[DatabaseMigrationClientTypes.TableToReload]? = nil
        if let tablesToReloadContainer = tablesToReloadContainer {
            tablesToReloadDecoded0 = [DatabaseMigrationClientTypes.TableToReload]()
            for structure0 in tablesToReloadContainer {
                if let structure0 = structure0 {
                    tablesToReloadDecoded0?.append(structure0)
                }
            }
        }
        tablesToReload = tablesToReloadDecoded0
        let reloadOptionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReloadOptionValue.self, forKey: .reloadOption)
        reloadOption = reloadOptionDecoded
    }
}

extension ReloadTablesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReloadTablesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReloadTablesOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReloadTablesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReloadTablesOutputResponse(replicationTaskArn: \(Swift.String(describing: replicationTaskArn)))"}
}

extension ReloadTablesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReloadTablesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTaskArn = output.replicationTaskArn
        } else {
            self.replicationTaskArn = nil
        }
    }
}

public struct ReloadTablesOutputResponse: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the replication task. </p>
    public let replicationTaskArn: Swift.String?

    public init (
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct ReloadTablesOutputResponseBody: Swift.Equatable {
    public let replicationTaskArn: Swift.String?
}

extension ReloadTablesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

public struct RemoveTagsFromResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

extension RemoveTagsFromResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension RemoveTagsFromResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for keylist0 in tagKeys {
                try tagKeysContainer.encode(keylist0)
            }
        }
    }
}

public struct RemoveTagsFromResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

/// <p>Removes one or more tags from an AWS DMS resource.</p>
public struct RemoveTagsFromResourceInput: Swift.Equatable {
    /// <p>An AWS DMS resource from which you want to remove tag(s). The value for this parameter is an Amazon Resource Name (ARN).</p>
    public let resourceArn: Swift.String?
    /// <p>The tag key (name) of the tag to be removed.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsFromResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension RemoveTagsFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromResourceOutputResponse()"}
}

extension RemoveTagsFromResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p></p>
public struct RemoveTagsFromResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemoveTagsFromResourceOutputResponseBody: Swift.Equatable {
}

extension RemoveTagsFromResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DatabaseMigrationClientTypes {
    public enum ReplicationEndpointTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case source
        case target
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationEndpointTypeValue] {
            return [
                .source,
                .target,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .source: return "source"
            case .target: return "target"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationEndpointTypeValue(rawValue: rawValue) ?? ReplicationEndpointTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.ReplicationInstance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case dnsNameServers = "DnsNameServers"
        case engineVersion = "EngineVersion"
        case freeUntil = "FreeUntil"
        case instanceCreateTime = "InstanceCreateTime"
        case kmsKeyId = "KmsKeyId"
        case multiAZ = "MultiAZ"
        case pendingModifiedValues = "PendingModifiedValues"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case replicationInstancePrivateIpAddress = "ReplicationInstancePrivateIpAddress"
        case replicationInstancePrivateIpAddresses = "ReplicationInstancePrivateIpAddresses"
        case replicationInstancePublicIpAddress = "ReplicationInstancePublicIpAddress"
        case replicationInstancePublicIpAddresses = "ReplicationInstancePublicIpAddresses"
        case replicationInstanceStatus = "ReplicationInstanceStatus"
        case replicationSubnetGroup = "ReplicationSubnetGroup"
        case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedStorage != 0 {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if autoMinorVersionUpgrade != false {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let dnsNameServers = dnsNameServers {
            try encodeContainer.encode(dnsNameServers, forKey: .dnsNameServers)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let freeUntil = freeUntil {
            try encodeContainer.encode(freeUntil.timeIntervalSince1970, forKey: .freeUntil)
        }
        if let instanceCreateTime = instanceCreateTime {
            try encodeContainer.encode(instanceCreateTime.timeIntervalSince1970, forKey: .instanceCreateTime)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if multiAZ != false {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try encodeContainer.encode(pendingModifiedValues, forKey: .pendingModifiedValues)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if publiclyAccessible != false {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationInstanceClass = replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let replicationInstanceIdentifier = replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let replicationInstancePrivateIpAddress = replicationInstancePrivateIpAddress {
            try encodeContainer.encode(replicationInstancePrivateIpAddress, forKey: .replicationInstancePrivateIpAddress)
        }
        if let replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses {
            var replicationInstancePrivateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationInstancePrivateIpAddresses)
            for replicationinstanceprivateipaddresslist0 in replicationInstancePrivateIpAddresses {
                try replicationInstancePrivateIpAddressesContainer.encode(replicationinstanceprivateipaddresslist0)
            }
        }
        if let replicationInstancePublicIpAddress = replicationInstancePublicIpAddress {
            try encodeContainer.encode(replicationInstancePublicIpAddress, forKey: .replicationInstancePublicIpAddress)
        }
        if let replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses {
            var replicationInstancePublicIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationInstancePublicIpAddresses)
            for replicationinstancepublicipaddresslist0 in replicationInstancePublicIpAddresses {
                try replicationInstancePublicIpAddressesContainer.encode(replicationinstancepublicipaddresslist0)
            }
        }
        if let replicationInstanceStatus = replicationInstanceStatus {
            try encodeContainer.encode(replicationInstanceStatus, forKey: .replicationInstanceStatus)
        }
        if let replicationSubnetGroup = replicationSubnetGroup {
            try encodeContainer.encode(replicationSubnetGroup, forKey: .replicationSubnetGroup)
        }
        if let secondaryAvailabilityZone = secondaryAvailabilityZone {
            try encodeContainer.encode(secondaryAvailabilityZone, forKey: .secondaryAvailabilityZone)
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroups)
            for vpcsecuritygroupmembershiplist0 in vpcSecurityGroups {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembershiplist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let replicationInstanceStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceStatus)
        replicationInstanceStatus = replicationInstanceStatusDecoded
        let allocatedStorageDecoded = try containerValues.decode(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .instanceCreateTime)
        instanceCreateTime = instanceCreateTimeDecoded
        let vpcSecurityGroupsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.VpcSecurityGroupMembership?].self, forKey: .vpcSecurityGroups)
        var vpcSecurityGroupsDecoded0:[DatabaseMigrationClientTypes.VpcSecurityGroupMembership]? = nil
        if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
            vpcSecurityGroupsDecoded0 = [DatabaseMigrationClientTypes.VpcSecurityGroupMembership]()
            for structure0 in vpcSecurityGroupsContainer {
                if let structure0 = structure0 {
                    vpcSecurityGroupsDecoded0?.append(structure0)
                }
            }
        }
        vpcSecurityGroups = vpcSecurityGroupsDecoded0
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let replicationSubnetGroupDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationSubnetGroup.self, forKey: .replicationSubnetGroup)
        replicationSubnetGroup = replicationSubnetGroupDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationPendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let multiAZDecoded = try containerValues.decode(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let replicationInstancePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstancePublicIpAddress)
        replicationInstancePublicIpAddress = replicationInstancePublicIpAddressDecoded
        let replicationInstancePrivateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstancePrivateIpAddress)
        replicationInstancePrivateIpAddress = replicationInstancePrivateIpAddressDecoded
        let replicationInstancePublicIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationInstancePublicIpAddresses)
        var replicationInstancePublicIpAddressesDecoded0:[Swift.String]? = nil
        if let replicationInstancePublicIpAddressesContainer = replicationInstancePublicIpAddressesContainer {
            replicationInstancePublicIpAddressesDecoded0 = [Swift.String]()
            for string0 in replicationInstancePublicIpAddressesContainer {
                if let string0 = string0 {
                    replicationInstancePublicIpAddressesDecoded0?.append(string0)
                }
            }
        }
        replicationInstancePublicIpAddresses = replicationInstancePublicIpAddressesDecoded0
        let replicationInstancePrivateIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationInstancePrivateIpAddresses)
        var replicationInstancePrivateIpAddressesDecoded0:[Swift.String]? = nil
        if let replicationInstancePrivateIpAddressesContainer = replicationInstancePrivateIpAddressesContainer {
            replicationInstancePrivateIpAddressesDecoded0 = [Swift.String]()
            for string0 in replicationInstancePrivateIpAddressesContainer {
                if let string0 = string0 {
                    replicationInstancePrivateIpAddressesDecoded0?.append(string0)
                }
            }
        }
        replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddressesDecoded0
        let publiclyAccessibleDecoded = try containerValues.decode(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let secondaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryAvailabilityZone)
        secondaryAvailabilityZone = secondaryAvailabilityZoneDecoded
        let freeUntilDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .freeUntil)
        freeUntil = freeUntilDecoded
        let dnsNameServersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsNameServers)
        dnsNameServers = dnsNameServersDecoded
    }
}

extension DatabaseMigrationClientTypes.ReplicationInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationInstance(allocatedStorage: \(Swift.String(describing: allocatedStorage)), autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), availabilityZone: \(Swift.String(describing: availabilityZone)), dnsNameServers: \(Swift.String(describing: dnsNameServers)), engineVersion: \(Swift.String(describing: engineVersion)), freeUntil: \(Swift.String(describing: freeUntil)), instanceCreateTime: \(Swift.String(describing: instanceCreateTime)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), multiAZ: \(Swift.String(describing: multiAZ)), pendingModifiedValues: \(Swift.String(describing: pendingModifiedValues)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)), replicationInstanceClass: \(Swift.String(describing: replicationInstanceClass)), replicationInstanceIdentifier: \(Swift.String(describing: replicationInstanceIdentifier)), replicationInstancePrivateIpAddress: \(Swift.String(describing: replicationInstancePrivateIpAddress)), replicationInstancePrivateIpAddresses: \(Swift.String(describing: replicationInstancePrivateIpAddresses)), replicationInstancePublicIpAddress: \(Swift.String(describing: replicationInstancePublicIpAddress)), replicationInstancePublicIpAddresses: \(Swift.String(describing: replicationInstancePublicIpAddresses)), replicationInstanceStatus: \(Swift.String(describing: replicationInstanceStatus)), replicationSubnetGroup: \(Swift.String(describing: replicationSubnetGroup)), secondaryAvailabilityZone: \(Swift.String(describing: secondaryAvailabilityZone)), vpcSecurityGroups: \(Swift.String(describing: vpcSecurityGroups)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that defines a replication instance.</p>
    public struct ReplicationInstance: Swift.Equatable {
        /// <p>The amount of storage (in gigabytes) that is allocated for the replication
        ///          instance.</p>
        public let allocatedStorage: Swift.Int
        /// <p>Boolean value indicating if minor version upgrades will be automatically applied to the
        ///          instance.</p>
        public let autoMinorVersionUpgrade: Swift.Bool
        /// <p>The Availability Zone for the instance.</p>
        public let availabilityZone: Swift.String?
        /// <p>The DNS name servers supported for the replication instance to access your on-premise source or target database.</p>
        public let dnsNameServers: Swift.String?
        /// <p>The engine version number of the replication instance.</p>
        ///          <p>If an engine version number is not specified when a replication
        ///          instance is created, the default is the latest engine version available.</p>
        ///          <p>When modifying a major engine version of an instance, also set
        ///          <code>AllowMajorVersionUpgrade</code> to <code>true</code>.</p>
        public let engineVersion: Swift.String?
        /// <p> The expiration date of the free replication instance that is part of the Free DMS
        ///          program. </p>
        public let freeUntil: ClientRuntime.Date?
        /// <p>The time the replication instance was created.</p>
        public let instanceCreateTime: ClientRuntime.Date?
        /// <p>An AWS KMS key identifier that is used to encrypt the data on the replication
        ///            instance.</p>
        ///          <p>If you don't specify a value for the <code>KmsKeyId</code> parameter, then
        ///            AWS DMS uses your default encryption key.</p>
        ///          <p>AWS KMS creates the default encryption key for your AWS account. Your AWS account has a
        ///          different default encryption key for each AWS Region.</p>
        public let kmsKeyId: Swift.String?
        /// <p> Specifies whether the replication instance is a Multi-AZ deployment. You can't set the
        ///             <code>AvailabilityZone</code> parameter if the Multi-AZ parameter is set to
        ///             <code>true</code>. </p>
        public let multiAZ: Swift.Bool
        /// <p>The pending modification values.</p>
        public let pendingModifiedValues: DatabaseMigrationClientTypes.ReplicationPendingModifiedValues?
        /// <p>The maintenance window times for the replication instance. Any pending upgrades to the
        ///          replication instance are performed during this time.</p>
        public let preferredMaintenanceWindow: Swift.String?
        /// <p> Specifies the accessibility options for the replication instance. A value of
        ///             <code>true</code> represents an instance with a public IP address. A value of
        ///             <code>false</code> represents an instance with a private IP address. The default value
        ///          is <code>true</code>. </p>
        public let publiclyAccessible: Swift.Bool
        /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
        public let replicationInstanceArn: Swift.String?
        /// <p>The compute and memory capacity of the replication instance as defined for the specified
        ///          replication instance class. It is a required parameter, although a defualt value is
        ///          pre-selected in the DMS console.</p>
        ///          <p>For more information on the settings and capacities for the available replication instance classes, see
        ///          <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth">
        ///             Selecting the right AWS DMS replication instance for your migration</a>.
        ///       </p>
        public let replicationInstanceClass: Swift.String?
        /// <p>The replication instance identifier is a required parameter. This parameter is stored as
        ///          a lowercase string.</p>
        ///          <p>Constraints:</p>
        ///          <ul>
        ///             <li>
        ///                <p>Must contain 1-63 alphanumeric characters or hyphens.</p>
        ///             </li>
        ///             <li>
        ///                <p>First character must be a letter.</p>
        ///             </li>
        ///             <li>
        ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
        ///             </li>
        ///          </ul>
        ///          <p>Example: <code>myrepinstance</code>
        ///          </p>
        public let replicationInstanceIdentifier: Swift.String?
        /// <p>The private IP address of the replication instance.</p>
        @available(*, deprecated)
        public let replicationInstancePrivateIpAddress: Swift.String?
        /// <p>One or more private IP addresses for the replication instance.</p>
        public let replicationInstancePrivateIpAddresses: [Swift.String]?
        /// <p>The public IP address of the replication instance.</p>
        @available(*, deprecated)
        public let replicationInstancePublicIpAddress: Swift.String?
        /// <p>One or more public IP addresses for the replication instance.</p>
        public let replicationInstancePublicIpAddresses: [Swift.String]?
        /// <p>The status of the replication instance. The possible return values include:</p>
        ///
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>"available"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"creating"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"deleted"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"deleting"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"failed"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"modifying"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"upgrading"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"rebooting"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"resetting-master-credentials"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"storage-full"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"incompatible-credentials"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"incompatible-network"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"maintenance"</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        public let replicationInstanceStatus: Swift.String?
        /// <p>The subnet group for the replication instance.</p>
        public let replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?
        /// <p>The Availability Zone of the standby replication instance in a Multi-AZ
        ///          deployment.</p>
        public let secondaryAvailabilityZone: Swift.String?
        /// <p>The VPC security group for the instance.</p>
        public let vpcSecurityGroups: [DatabaseMigrationClientTypes.VpcSecurityGroupMembership]?

        public init (
            allocatedStorage: Swift.Int = 0,
            autoMinorVersionUpgrade: Swift.Bool = false,
            availabilityZone: Swift.String? = nil,
            dnsNameServers: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            freeUntil: ClientRuntime.Date? = nil,
            instanceCreateTime: ClientRuntime.Date? = nil,
            kmsKeyId: Swift.String? = nil,
            multiAZ: Swift.Bool = false,
            pendingModifiedValues: DatabaseMigrationClientTypes.ReplicationPendingModifiedValues? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            publiclyAccessible: Swift.Bool = false,
            replicationInstanceArn: Swift.String? = nil,
            replicationInstanceClass: Swift.String? = nil,
            replicationInstanceIdentifier: Swift.String? = nil,
            replicationInstancePrivateIpAddress: Swift.String? = nil,
            replicationInstancePrivateIpAddresses: [Swift.String]? = nil,
            replicationInstancePublicIpAddress: Swift.String? = nil,
            replicationInstancePublicIpAddresses: [Swift.String]? = nil,
            replicationInstanceStatus: Swift.String? = nil,
            replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup? = nil,
            secondaryAvailabilityZone: Swift.String? = nil,
            vpcSecurityGroups: [DatabaseMigrationClientTypes.VpcSecurityGroupMembership]? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.dnsNameServers = dnsNameServers
            self.engineVersion = engineVersion
            self.freeUntil = freeUntil
            self.instanceCreateTime = instanceCreateTime
            self.kmsKeyId = kmsKeyId
            self.multiAZ = multiAZ
            self.pendingModifiedValues = pendingModifiedValues
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationInstancePrivateIpAddress = replicationInstancePrivateIpAddress
            self.replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses
            self.replicationInstancePublicIpAddress = replicationInstancePublicIpAddress
            self.replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses
            self.replicationInstanceStatus = replicationInstanceStatus
            self.replicationSubnetGroup = replicationSubnetGroup
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationInstanceTaskLog: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstanceTaskLogSize = "ReplicationInstanceTaskLogSize"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskName = "ReplicationTaskName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if replicationInstanceTaskLogSize != 0 {
            try encodeContainer.encode(replicationInstanceTaskLogSize, forKey: .replicationInstanceTaskLogSize)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskName = replicationTaskName {
            try encodeContainer.encode(replicationTaskName, forKey: .replicationTaskName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskName)
        replicationTaskName = replicationTaskNameDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationInstanceTaskLogSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .replicationInstanceTaskLogSize)
        replicationInstanceTaskLogSize = replicationInstanceTaskLogSizeDecoded
    }
}

extension DatabaseMigrationClientTypes.ReplicationInstanceTaskLog: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationInstanceTaskLog(replicationInstanceTaskLogSize: \(Swift.String(describing: replicationInstanceTaskLogSize)), replicationTaskArn: \(Swift.String(describing: replicationTaskArn)), replicationTaskName: \(Swift.String(describing: replicationTaskName)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Contains metadata for a replication instance task log.</p>
    public struct ReplicationInstanceTaskLog: Swift.Equatable {
        /// <p>The size, in bytes, of the replication task log.</p>
        public let replicationInstanceTaskLogSize: Swift.Int
        /// <p>The Amazon Resource Name (ARN) of the replication task.</p>
        public let replicationTaskArn: Swift.String?
        /// <p>The name of the replication task.</p>
        public let replicationTaskName: Swift.String?

        public init (
            replicationInstanceTaskLogSize: Swift.Int = 0,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskName: Swift.String? = nil
        )
        {
            self.replicationInstanceTaskLogSize = replicationInstanceTaskLogSize
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskName = replicationTaskName
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationPendingModifiedValues: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case engineVersion = "EngineVersion"
        case multiAZ = "MultiAZ"
        case replicationInstanceClass = "ReplicationInstanceClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedStorage = allocatedStorage {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let multiAZ = multiAZ {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let replicationInstanceClass = replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension DatabaseMigrationClientTypes.ReplicationPendingModifiedValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationPendingModifiedValues(allocatedStorage: \(Swift.String(describing: allocatedStorage)), engineVersion: \(Swift.String(describing: engineVersion)), multiAZ: \(Swift.String(describing: multiAZ)), replicationInstanceClass: \(Swift.String(describing: replicationInstanceClass)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information about the values of pending modifications to a replication
    ///          instance. This data type is an object of the
    ///          <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_ReplicationInstance.html">
    ///                <code>ReplicationInstance</code>
    ///             </a> user-defined
    ///          data type. </p>
    public struct ReplicationPendingModifiedValues: Swift.Equatable {
        /// <p>The amount of storage (in gigabytes) that is allocated for the replication
        ///          instance.</p>
        public let allocatedStorage: Swift.Int?
        /// <p>The engine version number of the replication instance.</p>
        public let engineVersion: Swift.String?
        /// <p> Specifies whether the replication instance is a Multi-AZ deployment. You can't set the
        ///             <code>AvailabilityZone</code> parameter if the Multi-AZ parameter is set to
        ///             <code>true</code>. </p>
        public let multiAZ: Swift.Bool?
        /// <p>The compute and memory capacity of the replication instance as defined for the specified
        ///          replication instance class.</p>
        ///          <p>For more information on the settings and capacities for the available replication instance classes, see
        ///          <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth">
        ///             Selecting the right AWS DMS replication instance for your migration</a>.
        ///       </p>
        public let replicationInstanceClass: Swift.String?

        public init (
            allocatedStorage: Swift.Int? = nil,
            engineVersion: Swift.String? = nil,
            multiAZ: Swift.Bool? = nil,
            replicationInstanceClass: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.engineVersion = engineVersion
            self.multiAZ = multiAZ
            self.replicationInstanceClass = replicationInstanceClass
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationSubnetGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetGroupStatus = "SubnetGroupStatus"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupDescription = replicationSubnetGroupDescription {
            try encodeContainer.encode(replicationSubnetGroupDescription, forKey: .replicationSubnetGroupDescription)
        }
        if let replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let subnetGroupStatus = subnetGroupStatus {
            try encodeContainer.encode(subnetGroupStatus, forKey: .subnetGroupStatus)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnetlist0 in subnets {
                try subnetsContainer.encode(subnetlist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let replicationSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupDescription)
        replicationSubnetGroupDescription = replicationSubnetGroupDescriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupStatus)
        subnetGroupStatus = subnetGroupStatusDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Subnet?].self, forKey: .subnets)
        var subnetsDecoded0:[DatabaseMigrationClientTypes.Subnet]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [DatabaseMigrationClientTypes.Subnet]()
            for structure0 in subnetsContainer {
                if let structure0 = structure0 {
                    subnetsDecoded0?.append(structure0)
                }
            }
        }
        subnets = subnetsDecoded0
    }
}

extension DatabaseMigrationClientTypes.ReplicationSubnetGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationSubnetGroup(replicationSubnetGroupDescription: \(Swift.String(describing: replicationSubnetGroupDescription)), replicationSubnetGroupIdentifier: \(Swift.String(describing: replicationSubnetGroupIdentifier)), subnetGroupStatus: \(Swift.String(describing: subnetGroupStatus)), subnets: \(Swift.String(describing: subnets)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Describes a subnet group in response to a request by the
    ///             <code>DescribeReplicationSubnetGroups</code> operation.</p>
    public struct ReplicationSubnetGroup: Swift.Equatable {
        /// <p>A description for the replication subnet group.</p>
        public let replicationSubnetGroupDescription: Swift.String?
        /// <p>The identifier of the replication instance subnet group.</p>
        public let replicationSubnetGroupIdentifier: Swift.String?
        /// <p>The status of the subnet group.</p>
        public let subnetGroupStatus: Swift.String?
        /// <p>The subnets that are in the subnet group.</p>
        public let subnets: [DatabaseMigrationClientTypes.Subnet]?
        /// <p>The ID of the VPC.</p>
        public let vpcId: Swift.String?

        public init (
            replicationSubnetGroupDescription: Swift.String? = nil,
            replicationSubnetGroupIdentifier: Swift.String? = nil,
            subnetGroupStatus: Swift.String? = nil,
            subnets: [DatabaseMigrationClientTypes.Subnet]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension ReplicationSubnetGroupDoesNotCoverEnoughAZs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationSubnetGroupDoesNotCoverEnoughAZs(message: \(Swift.String(describing: message)))"}
}

extension ReplicationSubnetGroupDoesNotCoverEnoughAZs: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReplicationSubnetGroupDoesNotCoverEnoughAZsBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The replication subnet group does not cover enough Availability Zones (AZs). Edit the replication subnet group and add more AZs.</p>
public struct ReplicationSubnetGroupDoesNotCoverEnoughAZs: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p></p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReplicationSubnetGroupDoesNotCoverEnoughAZsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ReplicationSubnetGroupDoesNotCoverEnoughAZsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.ReplicationTask: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStopPosition = "CdcStopPosition"
        case lastFailureMessage = "LastFailureMessage"
        case migrationType = "MigrationType"
        case recoveryCheckpoint = "RecoveryCheckpoint"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskCreationDate = "ReplicationTaskCreationDate"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case replicationTaskStartDate = "ReplicationTaskStartDate"
        case replicationTaskStats = "ReplicationTaskStats"
        case sourceEndpointArn = "SourceEndpointArn"
        case status = "Status"
        case stopReason = "StopReason"
        case tableMappings = "TableMappings"
        case targetEndpointArn = "TargetEndpointArn"
        case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
        case taskData = "TaskData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStopPosition = cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let lastFailureMessage = lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let migrationType = migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let recoveryCheckpoint = recoveryCheckpoint {
            try encodeContainer.encode(recoveryCheckpoint, forKey: .recoveryCheckpoint)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskCreationDate = replicationTaskCreationDate {
            try encodeContainer.encode(replicationTaskCreationDate.timeIntervalSince1970, forKey: .replicationTaskCreationDate)
        }
        if let replicationTaskIdentifier = replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskSettings = replicationTaskSettings {
            try encodeContainer.encode(replicationTaskSettings, forKey: .replicationTaskSettings)
        }
        if let replicationTaskStartDate = replicationTaskStartDate {
            try encodeContainer.encode(replicationTaskStartDate.timeIntervalSince1970, forKey: .replicationTaskStartDate)
        }
        if let replicationTaskStats = replicationTaskStats {
            try encodeContainer.encode(replicationTaskStats, forKey: .replicationTaskStats)
        }
        if let sourceEndpointArn = sourceEndpointArn {
            try encodeContainer.encode(sourceEndpointArn, forKey: .sourceEndpointArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let stopReason = stopReason {
            try encodeContainer.encode(stopReason, forKey: .stopReason)
        }
        if let tableMappings = tableMappings {
            try encodeContainer.encode(tableMappings, forKey: .tableMappings)
        }
        if let targetEndpointArn = targetEndpointArn {
            try encodeContainer.encode(targetEndpointArn, forKey: .targetEndpointArn)
        }
        if let targetReplicationInstanceArn = targetReplicationInstanceArn {
            try encodeContainer.encode(targetReplicationInstanceArn, forKey: .targetReplicationInstanceArn)
        }
        if let taskData = taskData {
            try encodeContainer.encode(taskData, forKey: .taskData)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let sourceEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEndpointArn)
        sourceEndpointArn = sourceEndpointArnDecoded
        let targetEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEndpointArn)
        targetEndpointArn = targetEndpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let tableMappingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableMappings)
        tableMappings = tableMappingsDecoded
        let replicationTaskSettingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskSettings)
        replicationTaskSettings = replicationTaskSettingsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
        let stopReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stopReason)
        stopReason = stopReasonDecoded
        let replicationTaskCreationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .replicationTaskCreationDate)
        replicationTaskCreationDate = replicationTaskCreationDateDecoded
        let replicationTaskStartDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .replicationTaskStartDate)
        replicationTaskStartDate = replicationTaskStartDateDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
        let recoveryCheckpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryCheckpoint)
        recoveryCheckpoint = recoveryCheckpointDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationTaskStatsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTaskStats.self, forKey: .replicationTaskStats)
        replicationTaskStats = replicationTaskStatsDecoded
        let taskDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskData)
        taskData = taskDataDecoded
        let targetReplicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetReplicationInstanceArn)
        targetReplicationInstanceArn = targetReplicationInstanceArnDecoded
    }
}

extension DatabaseMigrationClientTypes.ReplicationTask: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationTask(cdcStartPosition: \(Swift.String(describing: cdcStartPosition)), cdcStopPosition: \(Swift.String(describing: cdcStopPosition)), lastFailureMessage: \(Swift.String(describing: lastFailureMessage)), migrationType: \(Swift.String(describing: migrationType)), recoveryCheckpoint: \(Swift.String(describing: recoveryCheckpoint)), replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)), replicationTaskArn: \(Swift.String(describing: replicationTaskArn)), replicationTaskCreationDate: \(Swift.String(describing: replicationTaskCreationDate)), replicationTaskIdentifier: \(Swift.String(describing: replicationTaskIdentifier)), replicationTaskSettings: \(Swift.String(describing: replicationTaskSettings)), replicationTaskStartDate: \(Swift.String(describing: replicationTaskStartDate)), replicationTaskStats: \(Swift.String(describing: replicationTaskStats)), sourceEndpointArn: \(Swift.String(describing: sourceEndpointArn)), status: \(Swift.String(describing: status)), stopReason: \(Swift.String(describing: stopReason)), tableMappings: \(Swift.String(describing: tableMappings)), targetEndpointArn: \(Swift.String(describing: targetEndpointArn)), targetReplicationInstanceArn: \(Swift.String(describing: targetReplicationInstanceArn)), taskData: \(Swift.String(describing: taskData)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that describes a replication task created by the
    ///             <code>CreateReplicationTask</code> operation.</p>
    public struct ReplicationTask: Swift.Equatable {
        /// <p>Indicates when you want a change data capture (CDC) operation to start. Use either
        ///          <code>CdcStartPosition</code> or <code>CdcStartTime</code> to specify when you want the CDC operation to start.
        ///          Specifying both values results in an error.</p>
        ///          <p>The value can be in date, checkpoint, or LSN/SCN format.</p>
        ///          <p>Date Example: --cdc-start-position â€œ2018-03-08T12:12:12â€</p>
        ///          <p>Checkpoint Example: --cdc-start-position
        ///          "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93"</p>
        ///          <p>LSN Example: --cdc-start-position â€œmysql-bin-changelog.000024:373â€</p>
        public let cdcStartPosition: Swift.String?
        /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be
        ///          either server time or commit time.</p>
        ///          <p>Server time example: --cdc-stop-position â€œserver_time:2018-02-09T12:12:12â€</p>
        ///          <p>Commit time example: --cdc-stop-position â€œcommit_time: 2018-02-09T12:12:12 â€œ</p>
        public let cdcStopPosition: Swift.String?
        /// <p>The last error (failure) message generated for the replication task.</p>
        public let lastFailureMessage: Swift.String?
        /// <p>The type of migration.</p>
        public let migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
        /// <p>Indicates the last checkpoint that occurred during a change data capture (CDC)
        ///          operation. You can provide this value to the <code>CdcStartPosition</code> parameter to
        ///          start a CDC operation that begins at that checkpoint.</p>
        public let recoveryCheckpoint: Swift.String?
        /// <p>The ARN of the replication instance.</p>
        public let replicationInstanceArn: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the replication task.</p>
        public let replicationTaskArn: Swift.String?
        /// <p>The date the replication task was created.</p>
        public let replicationTaskCreationDate: ClientRuntime.Date?
        /// <p>The user-assigned replication task identifier or name.</p>
        ///          <p>Constraints:</p>
        ///          <ul>
        ///             <li>
        ///                <p>Must contain 1-255 alphanumeric characters or hyphens.</p>
        ///             </li>
        ///             <li>
        ///                <p>First character must be a letter.</p>
        ///             </li>
        ///             <li>
        ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
        ///             </li>
        ///          </ul>
        public let replicationTaskIdentifier: Swift.String?
        /// <p>The settings for the replication task.</p>
        public let replicationTaskSettings: Swift.String?
        /// <p>The date the replication task is scheduled to start.</p>
        public let replicationTaskStartDate: ClientRuntime.Date?
        /// <p>The statistics for the task, including elapsed time, tables loaded, and table
        ///          errors.</p>
        public let replicationTaskStats: DatabaseMigrationClientTypes.ReplicationTaskStats?
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the endpoint.</p>
        public let sourceEndpointArn: Swift.String?
        /// <p>The status of the replication task. This response parameter can return one of
        ///          the following values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>"moving"</code> â€“ The task is being moved in response to running the
        ///                   <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_MoveReplicationTask.html">
        ///                      <code>MoveReplicationTask</code>
        ///                   </a> operation.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"creating"</code> â€“ The task is being created in response to running
        ///                the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationTask.html">
        ///                      <code>CreateReplicationTask</code>
        ///                   </a> operation.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"deleting"</code> â€“ The task is being deleted in response to running
        ///                the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_DeleteReplicationTask.html">
        ///                      <code>DeleteReplicationTask</code>
        ///                   </a> operation.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"failed"</code> â€“ The task failed to successfully complete the database
        ///                migration in response to running the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html">
        ///                      <code>StartReplicationTask</code>
        ///                   </a> operation.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"failed-move"</code> â€“ The task failed to move in response to running
        ///                the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_MoveReplicationTask.html">
        ///                      <code>MoveReplicationTask</code>
        ///                   </a> operation.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"modifying"</code> â€“ The task definition is being modified in response
        ///                to running the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_ModifyReplicationTask.html">
        ///                      <code>ModifyReplicationTask</code>
        ///                   </a> operation.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"ready"</code> â€“ The task is in a <code>ready</code> state where it can
        ///                respond to other task operations, such as <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html">
        ///                      <code>StartReplicationTask</code>
        ///                   </a> or <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_DeleteReplicationTask.html">
        ///                      <code>DeleteReplicationTask</code>
        ///                   </a>. </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"running"</code> â€“ The task is performing a database migration in
        ///                response to running the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html">
        ///                      <code>StartReplicationTask</code>
        ///                   </a> operation.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"starting"</code> â€“ The task is preparing to perform a database
        ///                migration in response to running the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html">
        ///                      <code>StartReplicationTask</code>
        ///                   </a> operation.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"stopped"</code> â€“ The task has stopped in response to running the
        ///                   <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StopReplicationTask.html">
        ///                      <code>StopReplicationTask</code>
        ///                   </a> operation.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"stopping"</code> â€“ The task is preparing to stop in response to
        ///                running the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StopReplicationTask.html">
        ///                      <code>StopReplicationTask</code>
        ///                   </a> operation.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"testing"</code> â€“ The database migration specified for this task is
        ///                being tested in response to running either the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessmentRun.html">
        ///                      <code>StartReplicationTaskAssessmentRun</code>
        ///                   </a> or the
        ///                   <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessment.html">
        ///                      <code>StartReplicationTaskAssessment</code>
        ///                   </a>
        ///                operation.</p>
        ///                <note>
        ///                   <p>
        ///                      <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessmentRun.html">
        ///                         <code>StartReplicationTaskAssessmentRun</code>
        ///                      </a> is
        ///                   an improved premigration task assessment operation. The <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessment.html">
        ///                         <code>StartReplicationTaskAssessment</code>
        ///                      </a>
        ///                   operation assesses data type compatibility only between the source and target
        ///                   database of a given migration task. In contrast, <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessmentRun.html">
        ///                         <code>StartReplicationTaskAssessmentRun</code>
        ///                      </a>
        ///                   enables you to specify a variety of premigration task assessments in addition to
        ///                   data type compatibility. These assessments include ones for the validity of primary key definitions and
        ///                   likely issues with database migration performance, among others.</p>
        ///                </note>
        ///             </li>
        ///          </ul>
        public let status: Swift.String?
        /// <p>The reason the replication task was stopped. This response parameter can return one of
        ///          the following values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>"STOP_REASON_FULL_LOAD_COMPLETED"</code> â€“ Full-load migration
        ///                completed.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"STOP_REASON_CACHED_CHANGES_APPLIED"</code> â€“ Change data capture (CDC)
        ///                load completed.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"STOP_REASON_CACHED_CHANGES_NOT_APPLIED"</code> â€“ In a
        ///                full-load and CDC migration, the full load stopped as specified before starting the
        ///                CDC migration.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"STOP_REASON_SERVER_TIME"</code> â€“ The migration stopped at the
        ///                specified server time.</p>
        ///             </li>
        ///          </ul>
        public let stopReason: Swift.String?
        /// <p>Table mappings specified in the task.</p>
        public let tableMappings: Swift.String?
        /// <p>The ARN that uniquely identifies the endpoint.</p>
        public let targetEndpointArn: Swift.String?
        /// <p>The ARN of the replication instance to which this task is moved in response to running
        ///          the <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_MoveReplicationTask.html">
        ///                <code>MoveReplicationTask</code>
        ///             </a> operation. Otherwise, this response
        ///          parameter isn't a member of the <code>ReplicationTask</code> object.</p>
        public let targetReplicationInstanceArn: Swift.String?
        /// <p>Supplemental information that the task requires to migrate the data for certain source and target endpoints.
        ///             For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html">Specifying Supplemental Data for Task Settings</a> in the
        ///          <i>AWS Database Migration Service User Guide.</i>
        ///          </p>
        public let taskData: Swift.String?

        public init (
            cdcStartPosition: Swift.String? = nil,
            cdcStopPosition: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
            recoveryCheckpoint: Swift.String? = nil,
            replicationInstanceArn: Swift.String? = nil,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskCreationDate: ClientRuntime.Date? = nil,
            replicationTaskIdentifier: Swift.String? = nil,
            replicationTaskSettings: Swift.String? = nil,
            replicationTaskStartDate: ClientRuntime.Date? = nil,
            replicationTaskStats: DatabaseMigrationClientTypes.ReplicationTaskStats? = nil,
            sourceEndpointArn: Swift.String? = nil,
            status: Swift.String? = nil,
            stopReason: Swift.String? = nil,
            tableMappings: Swift.String? = nil,
            targetEndpointArn: Swift.String? = nil,
            targetReplicationInstanceArn: Swift.String? = nil,
            taskData: Swift.String? = nil
        )
        {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStopPosition = cdcStopPosition
            self.lastFailureMessage = lastFailureMessage
            self.migrationType = migrationType
            self.recoveryCheckpoint = recoveryCheckpoint
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskCreationDate = replicationTaskCreationDate
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskSettings = replicationTaskSettings
            self.replicationTaskStartDate = replicationTaskStartDate
            self.replicationTaskStats = replicationTaskStats
            self.sourceEndpointArn = sourceEndpointArn
            self.status = status
            self.stopReason = stopReason
            self.tableMappings = tableMappings
            self.targetEndpointArn = targetEndpointArn
            self.targetReplicationInstanceArn = targetReplicationInstanceArn
            self.taskData = taskData
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentResults = "AssessmentResults"
        case assessmentResultsFile = "AssessmentResultsFile"
        case assessmentStatus = "AssessmentStatus"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskLastAssessmentDate = "ReplicationTaskLastAssessmentDate"
        case s3ObjectUrl = "S3ObjectUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentResults = assessmentResults {
            try encodeContainer.encode(assessmentResults, forKey: .assessmentResults)
        }
        if let assessmentResultsFile = assessmentResultsFile {
            try encodeContainer.encode(assessmentResultsFile, forKey: .assessmentResultsFile)
        }
        if let assessmentStatus = assessmentStatus {
            try encodeContainer.encode(assessmentStatus, forKey: .assessmentStatus)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskIdentifier = replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskLastAssessmentDate = replicationTaskLastAssessmentDate {
            try encodeContainer.encode(replicationTaskLastAssessmentDate.timeIntervalSince1970, forKey: .replicationTaskLastAssessmentDate)
        }
        if let s3ObjectUrl = s3ObjectUrl {
            try encodeContainer.encode(s3ObjectUrl, forKey: .s3ObjectUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationTaskLastAssessmentDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .replicationTaskLastAssessmentDate)
        replicationTaskLastAssessmentDate = replicationTaskLastAssessmentDateDecoded
        let assessmentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentStatus)
        assessmentStatus = assessmentStatusDecoded
        let assessmentResultsFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentResultsFile)
        assessmentResultsFile = assessmentResultsFileDecoded
        let assessmentResultsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentResults)
        assessmentResults = assessmentResultsDecoded
        let s3ObjectUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectUrl)
        s3ObjectUrl = s3ObjectUrlDecoded
    }
}

extension DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationTaskAssessmentResult(assessmentResults: \(Swift.String(describing: assessmentResults)), assessmentResultsFile: \(Swift.String(describing: assessmentResultsFile)), assessmentStatus: \(Swift.String(describing: assessmentStatus)), replicationTaskArn: \(Swift.String(describing: replicationTaskArn)), replicationTaskIdentifier: \(Swift.String(describing: replicationTaskIdentifier)), replicationTaskLastAssessmentDate: \(Swift.String(describing: replicationTaskLastAssessmentDate)), s3ObjectUrl: \(Swift.String(describing: s3ObjectUrl)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p> The task assessment report in JSON format. </p>
    public struct ReplicationTaskAssessmentResult: Swift.Equatable {
        /// <p> The task assessment results in JSON format. </p>
        public let assessmentResults: Swift.String?
        /// <p> The file containing the results of the task assessment. </p>
        public let assessmentResultsFile: Swift.String?
        /// <p> The status of the task assessment. </p>
        public let assessmentStatus: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the replication task. </p>
        public let replicationTaskArn: Swift.String?
        /// <p> The replication task identifier of the task on which the task assessment was run.
        ///       </p>
        public let replicationTaskIdentifier: Swift.String?
        /// <p>The date the task assessment was completed. </p>
        public let replicationTaskLastAssessmentDate: ClientRuntime.Date?
        /// <p> The URL of the S3 object containing the task assessment results. </p>
        public let s3ObjectUrl: Swift.String?

        public init (
            assessmentResults: Swift.String? = nil,
            assessmentResultsFile: Swift.String? = nil,
            assessmentStatus: Swift.String? = nil,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskIdentifier: Swift.String? = nil,
            replicationTaskLastAssessmentDate: ClientRuntime.Date? = nil,
            s3ObjectUrl: Swift.String? = nil
        )
        {
            self.assessmentResults = assessmentResults
            self.assessmentResultsFile = assessmentResultsFile
            self.assessmentStatus = assessmentStatus
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskLastAssessmentDate = replicationTaskLastAssessmentDate
            self.s3ObjectUrl = s3ObjectUrl
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentProgress = "AssessmentProgress"
        case assessmentRunName = "AssessmentRunName"
        case lastFailureMessage = "LastFailureMessage"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
        case replicationTaskAssessmentRunCreationDate = "ReplicationTaskAssessmentRunCreationDate"
        case resultEncryptionMode = "ResultEncryptionMode"
        case resultKmsKeyArn = "ResultKmsKeyArn"
        case resultLocationBucket = "ResultLocationBucket"
        case resultLocationFolder = "ResultLocationFolder"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentProgress = assessmentProgress {
            try encodeContainer.encode(assessmentProgress, forKey: .assessmentProgress)
        }
        if let assessmentRunName = assessmentRunName {
            try encodeContainer.encode(assessmentRunName, forKey: .assessmentRunName)
        }
        if let lastFailureMessage = lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
        if let replicationTaskAssessmentRunCreationDate = replicationTaskAssessmentRunCreationDate {
            try encodeContainer.encode(replicationTaskAssessmentRunCreationDate.timeIntervalSince1970, forKey: .replicationTaskAssessmentRunCreationDate)
        }
        if let resultEncryptionMode = resultEncryptionMode {
            try encodeContainer.encode(resultEncryptionMode, forKey: .resultEncryptionMode)
        }
        if let resultKmsKeyArn = resultKmsKeyArn {
            try encodeContainer.encode(resultKmsKeyArn, forKey: .resultKmsKeyArn)
        }
        if let resultLocationBucket = resultLocationBucket {
            try encodeContainer.encode(resultLocationBucket, forKey: .resultLocationBucket)
        }
        if let resultLocationFolder = resultLocationFolder {
            try encodeContainer.encode(resultLocationFolder, forKey: .resultLocationFolder)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let replicationTaskAssessmentRunCreationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .replicationTaskAssessmentRunCreationDate)
        replicationTaskAssessmentRunCreationDate = replicationTaskAssessmentRunCreationDateDecoded
        let assessmentProgressDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress.self, forKey: .assessmentProgress)
        assessmentProgress = assessmentProgressDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let resultLocationBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultLocationBucket)
        resultLocationBucket = resultLocationBucketDecoded
        let resultLocationFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultLocationFolder)
        resultLocationFolder = resultLocationFolderDecoded
        let resultEncryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultEncryptionMode)
        resultEncryptionMode = resultEncryptionModeDecoded
        let resultKmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultKmsKeyArn)
        resultKmsKeyArn = resultKmsKeyArnDecoded
        let assessmentRunNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunName)
        assessmentRunName = assessmentRunNameDecoded
    }
}

extension DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationTaskAssessmentRun(assessmentProgress: \(Swift.String(describing: assessmentProgress)), assessmentRunName: \(Swift.String(describing: assessmentRunName)), lastFailureMessage: \(Swift.String(describing: lastFailureMessage)), replicationTaskArn: \(Swift.String(describing: replicationTaskArn)), replicationTaskAssessmentRunArn: \(Swift.String(describing: replicationTaskAssessmentRunArn)), replicationTaskAssessmentRunCreationDate: \(Swift.String(describing: replicationTaskAssessmentRunCreationDate)), resultEncryptionMode: \(Swift.String(describing: resultEncryptionMode)), resultKmsKeyArn: \(Swift.String(describing: resultKmsKeyArn)), resultLocationBucket: \(Swift.String(describing: resultLocationBucket)), resultLocationFolder: \(Swift.String(describing: resultLocationFolder)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), status: \(Swift.String(describing: status)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that describes a premigration assessment run that you have started
    ///          using the <code>StartReplicationTaskAssessmentRun</code> operation.</p>
    ///          <p>Some of the information appears based on other operations that can return the
    ///             <code>ReplicationTaskAssessmentRun</code> object.</p>
    public struct ReplicationTaskAssessmentRun: Swift.Equatable {
        /// <p>Indication of the completion progress for the individual assessments specified to
        ///          run.</p>
        public let assessmentProgress: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress?
        /// <p>Unique name of the assessment run.</p>
        public let assessmentRunName: Swift.String?
        /// <p>Last message generated by an individual assessment failure.</p>
        public let lastFailureMessage: Swift.String?
        /// <p>ARN of the migration task associated with this premigration
        ///          assessment run.</p>
        public let replicationTaskArn: Swift.String?
        /// <p>Amazon Resource Name (ARN) of this assessment run.</p>
        public let replicationTaskAssessmentRunArn: Swift.String?
        /// <p>Date on which the assessment run was created using the
        ///             <code>StartReplicationTaskAssessmentRun</code> operation.</p>
        public let replicationTaskAssessmentRunCreationDate: ClientRuntime.Date?
        /// <p>Encryption mode used to encrypt the assessment run results.</p>
        public let resultEncryptionMode: Swift.String?
        /// <p>ARN of the AWS KMS encryption key used to encrypt the assessment run results.</p>
        public let resultKmsKeyArn: Swift.String?
        /// <p>Amazon S3 bucket where AWS DMS stores the results of this assessment run.</p>
        public let resultLocationBucket: Swift.String?
        /// <p>Folder in an Amazon S3 bucket where AWS DMS stores the results of this assessment
        ///          run.</p>
        public let resultLocationFolder: Swift.String?
        /// <p>ARN of the service role used to start the assessment run using the
        ///             <code>StartReplicationTaskAssessmentRun</code> operation.</p>
        public let serviceAccessRoleArn: Swift.String?
        /// <p>Assessment run status. </p>
        ///          <p>This status can have one of the following values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>"cancelling"</code> â€“ The assessment run was canceled by the
        ///                   <code>CancelReplicationTaskAssessmentRun</code> operation.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"deleting"</code> â€“ The assessment run was deleted by the
        ///                   <code>DeleteReplicationTaskAssessmentRun</code> operation.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"failed"</code> â€“ At least one individual assessment completed with a
        ///                   <code>failed</code> status.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"error-provisioning"</code> â€“ An internal error occurred while
        ///                resources were provisioned (during <code>provisioning</code> status).</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"error-executing"</code> â€“ An internal error occurred while
        ///                individual assessments ran (during <code>running</code> status).</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"invalid state"</code> â€“ The assessment run is in an unknown state.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"passed"</code> â€“ All individual assessments have completed, and none
        ///                has a <code>failed</code> status.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"provisioning"</code> â€“ Resources required to run individual
        ///                assessments are being provisioned.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"running"</code> â€“ Individual assessments are being run.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"starting"</code> â€“ The assessment run is starting, but resources are not yet
        ///                being provisioned for individual assessments.</p>
        ///             </li>
        ///          </ul>
        public let status: Swift.String?

        public init (
            assessmentProgress: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress? = nil,
            assessmentRunName: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskAssessmentRunArn: Swift.String? = nil,
            replicationTaskAssessmentRunCreationDate: ClientRuntime.Date? = nil,
            resultEncryptionMode: Swift.String? = nil,
            resultKmsKeyArn: Swift.String? = nil,
            resultLocationBucket: Swift.String? = nil,
            resultLocationFolder: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.assessmentProgress = assessmentProgress
            self.assessmentRunName = assessmentRunName
            self.lastFailureMessage = lastFailureMessage
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
            self.replicationTaskAssessmentRunCreationDate = replicationTaskAssessmentRunCreationDate
            self.resultEncryptionMode = resultEncryptionMode
            self.resultKmsKeyArn = resultKmsKeyArn
            self.resultLocationBucket = resultLocationBucket
            self.resultLocationFolder = resultLocationFolder
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.status = status
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case individualAssessmentCompletedCount = "IndividualAssessmentCompletedCount"
        case individualAssessmentCount = "IndividualAssessmentCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if individualAssessmentCompletedCount != 0 {
            try encodeContainer.encode(individualAssessmentCompletedCount, forKey: .individualAssessmentCompletedCount)
        }
        if individualAssessmentCount != 0 {
            try encodeContainer.encode(individualAssessmentCount, forKey: .individualAssessmentCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let individualAssessmentCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .individualAssessmentCount)
        individualAssessmentCount = individualAssessmentCountDecoded
        let individualAssessmentCompletedCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .individualAssessmentCompletedCount)
        individualAssessmentCompletedCount = individualAssessmentCompletedCountDecoded
    }
}

extension DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationTaskAssessmentRunProgress(individualAssessmentCompletedCount: \(Swift.String(describing: individualAssessmentCompletedCount)), individualAssessmentCount: \(Swift.String(describing: individualAssessmentCount)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>The progress values reported by the <code>AssessmentProgress</code> response
    ///          element.</p>
    public struct ReplicationTaskAssessmentRunProgress: Swift.Equatable {
        /// <p>The number of individual assessments that have completed, successfully or not.</p>
        public let individualAssessmentCompletedCount: Swift.Int
        /// <p>The number of individual assessments that are specified to run.</p>
        public let individualAssessmentCount: Swift.Int

        public init (
            individualAssessmentCompletedCount: Swift.Int = 0,
            individualAssessmentCount: Swift.Int = 0
        )
        {
            self.individualAssessmentCompletedCount = individualAssessmentCompletedCount
            self.individualAssessmentCount = individualAssessmentCount
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case individualAssessmentName = "IndividualAssessmentName"
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
        case replicationTaskIndividualAssessmentArn = "ReplicationTaskIndividualAssessmentArn"
        case replicationTaskIndividualAssessmentStartDate = "ReplicationTaskIndividualAssessmentStartDate"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let individualAssessmentName = individualAssessmentName {
            try encodeContainer.encode(individualAssessmentName, forKey: .individualAssessmentName)
        }
        if let replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
        if let replicationTaskIndividualAssessmentArn = replicationTaskIndividualAssessmentArn {
            try encodeContainer.encode(replicationTaskIndividualAssessmentArn, forKey: .replicationTaskIndividualAssessmentArn)
        }
        if let replicationTaskIndividualAssessmentStartDate = replicationTaskIndividualAssessmentStartDate {
            try encodeContainer.encode(replicationTaskIndividualAssessmentStartDate.timeIntervalSince1970, forKey: .replicationTaskIndividualAssessmentStartDate)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIndividualAssessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskIndividualAssessmentArn)
        replicationTaskIndividualAssessmentArn = replicationTaskIndividualAssessmentArnDecoded
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
        let individualAssessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .individualAssessmentName)
        individualAssessmentName = individualAssessmentNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let replicationTaskIndividualAssessmentStartDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .replicationTaskIndividualAssessmentStartDate)
        replicationTaskIndividualAssessmentStartDate = replicationTaskIndividualAssessmentStartDateDecoded
    }
}

extension DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationTaskIndividualAssessment(individualAssessmentName: \(Swift.String(describing: individualAssessmentName)), replicationTaskAssessmentRunArn: \(Swift.String(describing: replicationTaskAssessmentRunArn)), replicationTaskIndividualAssessmentArn: \(Swift.String(describing: replicationTaskIndividualAssessmentArn)), replicationTaskIndividualAssessmentStartDate: \(Swift.String(describing: replicationTaskIndividualAssessmentStartDate)), status: \(Swift.String(describing: status)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that describes an individual assessment from a premigration
    ///          assessment run.</p>
    public struct ReplicationTaskIndividualAssessment: Swift.Equatable {
        /// <p>Name of this individual assessment.</p>
        public let individualAssessmentName: Swift.String?
        /// <p>ARN of the premigration assessment run that is created to run this individual
        ///          assessment.</p>
        public let replicationTaskAssessmentRunArn: Swift.String?
        /// <p>Amazon Resource Name (ARN) of this individual assessment.</p>
        public let replicationTaskIndividualAssessmentArn: Swift.String?
        /// <p>Date when this individual assessment was started as part of running the
        ///             <code>StartReplicationTaskAssessmentRun</code> operation.</p>
        public let replicationTaskIndividualAssessmentStartDate: ClientRuntime.Date?
        /// <p>Individual assessment status.</p>
        ///          <p>This status can have one of the following values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>"cancelled"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"error"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"failed"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"passed"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"pending"</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>"running"</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        public let status: Swift.String?

        public init (
            individualAssessmentName: Swift.String? = nil,
            replicationTaskAssessmentRunArn: Swift.String? = nil,
            replicationTaskIndividualAssessmentArn: Swift.String? = nil,
            replicationTaskIndividualAssessmentStartDate: ClientRuntime.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.individualAssessmentName = individualAssessmentName
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
            self.replicationTaskIndividualAssessmentArn = replicationTaskIndividualAssessmentArn
            self.replicationTaskIndividualAssessmentStartDate = replicationTaskIndividualAssessmentStartDate
            self.status = status
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationTaskStats: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elapsedTimeMillis = "ElapsedTimeMillis"
        case freshStartDate = "FreshStartDate"
        case fullLoadFinishDate = "FullLoadFinishDate"
        case fullLoadProgressPercent = "FullLoadProgressPercent"
        case fullLoadStartDate = "FullLoadStartDate"
        case startDate = "StartDate"
        case stopDate = "StopDate"
        case tablesErrored = "TablesErrored"
        case tablesLoaded = "TablesLoaded"
        case tablesLoading = "TablesLoading"
        case tablesQueued = "TablesQueued"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if elapsedTimeMillis != 0 {
            try encodeContainer.encode(elapsedTimeMillis, forKey: .elapsedTimeMillis)
        }
        if let freshStartDate = freshStartDate {
            try encodeContainer.encode(freshStartDate.timeIntervalSince1970, forKey: .freshStartDate)
        }
        if let fullLoadFinishDate = fullLoadFinishDate {
            try encodeContainer.encode(fullLoadFinishDate.timeIntervalSince1970, forKey: .fullLoadFinishDate)
        }
        if fullLoadProgressPercent != 0 {
            try encodeContainer.encode(fullLoadProgressPercent, forKey: .fullLoadProgressPercent)
        }
        if let fullLoadStartDate = fullLoadStartDate {
            try encodeContainer.encode(fullLoadStartDate.timeIntervalSince1970, forKey: .fullLoadStartDate)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate.timeIntervalSince1970, forKey: .startDate)
        }
        if let stopDate = stopDate {
            try encodeContainer.encode(stopDate.timeIntervalSince1970, forKey: .stopDate)
        }
        if tablesErrored != 0 {
            try encodeContainer.encode(tablesErrored, forKey: .tablesErrored)
        }
        if tablesLoaded != 0 {
            try encodeContainer.encode(tablesLoaded, forKey: .tablesLoaded)
        }
        if tablesLoading != 0 {
            try encodeContainer.encode(tablesLoading, forKey: .tablesLoading)
        }
        if tablesQueued != 0 {
            try encodeContainer.encode(tablesQueued, forKey: .tablesQueued)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullLoadProgressPercentDecoded = try containerValues.decode(Swift.Int.self, forKey: .fullLoadProgressPercent)
        fullLoadProgressPercent = fullLoadProgressPercentDecoded
        let elapsedTimeMillisDecoded = try containerValues.decode(Swift.Int.self, forKey: .elapsedTimeMillis)
        elapsedTimeMillis = elapsedTimeMillisDecoded
        let tablesLoadedDecoded = try containerValues.decode(Swift.Int.self, forKey: .tablesLoaded)
        tablesLoaded = tablesLoadedDecoded
        let tablesLoadingDecoded = try containerValues.decode(Swift.Int.self, forKey: .tablesLoading)
        tablesLoading = tablesLoadingDecoded
        let tablesQueuedDecoded = try containerValues.decode(Swift.Int.self, forKey: .tablesQueued)
        tablesQueued = tablesQueuedDecoded
        let tablesErroredDecoded = try containerValues.decode(Swift.Int.self, forKey: .tablesErrored)
        tablesErrored = tablesErroredDecoded
        let freshStartDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .freshStartDate)
        freshStartDate = freshStartDateDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let stopDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopDate)
        stopDate = stopDateDecoded
        let fullLoadStartDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .fullLoadStartDate)
        fullLoadStartDate = fullLoadStartDateDecoded
        let fullLoadFinishDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .fullLoadFinishDate)
        fullLoadFinishDate = fullLoadFinishDateDecoded
    }
}

extension DatabaseMigrationClientTypes.ReplicationTaskStats: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationTaskStats(elapsedTimeMillis: \(Swift.String(describing: elapsedTimeMillis)), freshStartDate: \(Swift.String(describing: freshStartDate)), fullLoadFinishDate: \(Swift.String(describing: fullLoadFinishDate)), fullLoadProgressPercent: \(Swift.String(describing: fullLoadProgressPercent)), fullLoadStartDate: \(Swift.String(describing: fullLoadStartDate)), startDate: \(Swift.String(describing: startDate)), stopDate: \(Swift.String(describing: stopDate)), tablesErrored: \(Swift.String(describing: tablesErrored)), tablesLoaded: \(Swift.String(describing: tablesLoaded)), tablesLoading: \(Swift.String(describing: tablesLoading)), tablesQueued: \(Swift.String(describing: tablesQueued)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>In response to a request by the <code>DescribeReplicationTasks</code> operation, this object provides
    ///          a collection of statistics about a replication task.</p>
    public struct ReplicationTaskStats: Swift.Equatable {
        /// <p>The elapsed time of the task, in milliseconds.</p>
        public let elapsedTimeMillis: Swift.Int
        /// <p>The date the replication task was started either with a fresh start or a target reload.</p>
        public let freshStartDate: ClientRuntime.Date?
        /// <p>The date the replication task full load was completed.</p>
        public let fullLoadFinishDate: ClientRuntime.Date?
        /// <p>The percent complete for the full load migration task.</p>
        public let fullLoadProgressPercent: Swift.Int
        /// <p>The date the replication task full load was started.</p>
        public let fullLoadStartDate: ClientRuntime.Date?
        /// <p>The date the replication task was started either with a fresh start or a resume. For more information, see
        ///          <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html#DMS-StartReplicationTask-request-StartReplicationTaskType">StartReplicationTaskType</a>.</p>
        public let startDate: ClientRuntime.Date?
        /// <p>The date the replication task was stopped.</p>
        public let stopDate: ClientRuntime.Date?
        /// <p>The number of errors that have occurred during this task.</p>
        public let tablesErrored: Swift.Int
        /// <p>The number of tables loaded for this task.</p>
        public let tablesLoaded: Swift.Int
        /// <p>The number of tables currently loading for this task.</p>
        public let tablesLoading: Swift.Int
        /// <p>The number of tables queued for this task.</p>
        public let tablesQueued: Swift.Int

        public init (
            elapsedTimeMillis: Swift.Int = 0,
            freshStartDate: ClientRuntime.Date? = nil,
            fullLoadFinishDate: ClientRuntime.Date? = nil,
            fullLoadProgressPercent: Swift.Int = 0,
            fullLoadStartDate: ClientRuntime.Date? = nil,
            startDate: ClientRuntime.Date? = nil,
            stopDate: ClientRuntime.Date? = nil,
            tablesErrored: Swift.Int = 0,
            tablesLoaded: Swift.Int = 0,
            tablesLoading: Swift.Int = 0,
            tablesQueued: Swift.Int = 0
        )
        {
            self.elapsedTimeMillis = elapsedTimeMillis
            self.freshStartDate = freshStartDate
            self.fullLoadFinishDate = fullLoadFinishDate
            self.fullLoadProgressPercent = fullLoadProgressPercent
            self.fullLoadStartDate = fullLoadStartDate
            self.startDate = startDate
            self.stopDate = stopDate
            self.tablesErrored = tablesErrored
            self.tablesLoaded = tablesLoaded
            self.tablesLoading = tablesLoading
            self.tablesQueued = tablesQueued
        }
    }

}

extension ResourceAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAlreadyExistsFault(message: \(Swift.String(describing: message)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ResourceAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceArn = output.resourceArn
        } else {
            self.message = nil
            self.resourceArn = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource you are attempting to create already exists.</p>
public struct ResourceAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p></p>
    public var message: Swift.String?
    public var resourceArn: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
    }
}

struct ResourceAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceArn: Swift.String?
}

extension ResourceAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ResourceNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource could not be found.</p>
public struct ResourceNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p></p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pendingMaintenanceActionDetails = "PendingMaintenanceActionDetails"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pendingMaintenanceActionDetails = pendingMaintenanceActionDetails {
            var pendingMaintenanceActionDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pendingMaintenanceActionDetails)
            for pendingmaintenanceactiondetails0 in pendingMaintenanceActionDetails {
                try pendingMaintenanceActionDetailsContainer.encode(pendingmaintenanceactiondetails0)
            }
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let pendingMaintenanceActionDetailsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.PendingMaintenanceAction?].self, forKey: .pendingMaintenanceActionDetails)
        var pendingMaintenanceActionDetailsDecoded0:[DatabaseMigrationClientTypes.PendingMaintenanceAction]? = nil
        if let pendingMaintenanceActionDetailsContainer = pendingMaintenanceActionDetailsContainer {
            pendingMaintenanceActionDetailsDecoded0 = [DatabaseMigrationClientTypes.PendingMaintenanceAction]()
            for structure0 in pendingMaintenanceActionDetailsContainer {
                if let structure0 = structure0 {
                    pendingMaintenanceActionDetailsDecoded0?.append(structure0)
                }
            }
        }
        pendingMaintenanceActionDetails = pendingMaintenanceActionDetailsDecoded0
    }
}

extension DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourcePendingMaintenanceActions(pendingMaintenanceActionDetails: \(Swift.String(describing: pendingMaintenanceActionDetails)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Identifies an AWS DMS resource and any pending actions for it.</p>
    public struct ResourcePendingMaintenanceActions: Swift.Equatable {
        /// <p>Detailed information about the pending maintenance action.</p>
        public let pendingMaintenanceActionDetails: [DatabaseMigrationClientTypes.PendingMaintenanceAction]?
        /// <p>The Amazon Resource Name (ARN) of the DMS resource that the pending maintenance action
        ///          applies to. For information about creating an ARN, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Introduction.AWS.ARN.html"> Constructing an Amazon
        ///             Resource Name (ARN) for AWS DMS</a> in the DMS documentation.</p>
        public let resourceIdentifier: Swift.String?

        public init (
            pendingMaintenanceActionDetails: [DatabaseMigrationClientTypes.PendingMaintenanceAction]? = nil,
            resourceIdentifier: Swift.String? = nil
        )
        {
            self.pendingMaintenanceActionDetails = pendingMaintenanceActionDetails
            self.resourceIdentifier = resourceIdentifier
        }
    }

}

extension ResourceQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension ResourceQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The quota for this resource quota has been exceeded.</p>
public struct ResourceQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p></p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3AccessDeniedFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3AccessDeniedFault(message: \(Swift.String(describing: message)))"}
}

extension S3AccessDeniedFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: S3AccessDeniedFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Insufficient privileges are preventing access to an Amazon S3 object.</p>
public struct S3AccessDeniedFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct S3AccessDeniedFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension S3AccessDeniedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ResourceNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3ResourceNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension S3ResourceNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: S3ResourceNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified Amazon S3 bucket, bucket folder, or other object can't be
///             found.</p>
public struct S3ResourceNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct S3ResourceNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension S3ResourceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.S3Settings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketFolder = "BucketFolder"
        case bucketName = "BucketName"
        case cdcInsertsAndUpdates = "CdcInsertsAndUpdates"
        case cdcInsertsOnly = "CdcInsertsOnly"
        case cdcPath = "CdcPath"
        case compressionType = "CompressionType"
        case csvDelimiter = "CsvDelimiter"
        case csvNoSupValue = "CsvNoSupValue"
        case csvRowDelimiter = "CsvRowDelimiter"
        case dataFormat = "DataFormat"
        case dataPageSize = "DataPageSize"
        case datePartitionDelimiter = "DatePartitionDelimiter"
        case datePartitionEnabled = "DatePartitionEnabled"
        case datePartitionSequence = "DatePartitionSequence"
        case dictPageSizeLimit = "DictPageSizeLimit"
        case enableStatistics = "EnableStatistics"
        case encodingType = "EncodingType"
        case encryptionMode = "EncryptionMode"
        case externalTableDefinition = "ExternalTableDefinition"
        case includeOpForFullLoad = "IncludeOpForFullLoad"
        case parquetTimestampInMillisecond = "ParquetTimestampInMillisecond"
        case parquetVersion = "ParquetVersion"
        case preserveTransactions = "PreserveTransactions"
        case rowGroupLength = "RowGroupLength"
        case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case timestampColumnName = "TimestampColumnName"
        case useCsvNoSupValue = "UseCsvNoSupValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketFolder = bucketFolder {
            try encodeContainer.encode(bucketFolder, forKey: .bucketFolder)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let cdcInsertsAndUpdates = cdcInsertsAndUpdates {
            try encodeContainer.encode(cdcInsertsAndUpdates, forKey: .cdcInsertsAndUpdates)
        }
        if let cdcInsertsOnly = cdcInsertsOnly {
            try encodeContainer.encode(cdcInsertsOnly, forKey: .cdcInsertsOnly)
        }
        if let cdcPath = cdcPath {
            try encodeContainer.encode(cdcPath, forKey: .cdcPath)
        }
        if let compressionType = compressionType {
            try encodeContainer.encode(compressionType.rawValue, forKey: .compressionType)
        }
        if let csvDelimiter = csvDelimiter {
            try encodeContainer.encode(csvDelimiter, forKey: .csvDelimiter)
        }
        if let csvNoSupValue = csvNoSupValue {
            try encodeContainer.encode(csvNoSupValue, forKey: .csvNoSupValue)
        }
        if let csvRowDelimiter = csvRowDelimiter {
            try encodeContainer.encode(csvRowDelimiter, forKey: .csvRowDelimiter)
        }
        if let dataFormat = dataFormat {
            try encodeContainer.encode(dataFormat.rawValue, forKey: .dataFormat)
        }
        if let dataPageSize = dataPageSize {
            try encodeContainer.encode(dataPageSize, forKey: .dataPageSize)
        }
        if let datePartitionDelimiter = datePartitionDelimiter {
            try encodeContainer.encode(datePartitionDelimiter.rawValue, forKey: .datePartitionDelimiter)
        }
        if let datePartitionEnabled = datePartitionEnabled {
            try encodeContainer.encode(datePartitionEnabled, forKey: .datePartitionEnabled)
        }
        if let datePartitionSequence = datePartitionSequence {
            try encodeContainer.encode(datePartitionSequence.rawValue, forKey: .datePartitionSequence)
        }
        if let dictPageSizeLimit = dictPageSizeLimit {
            try encodeContainer.encode(dictPageSizeLimit, forKey: .dictPageSizeLimit)
        }
        if let enableStatistics = enableStatistics {
            try encodeContainer.encode(enableStatistics, forKey: .enableStatistics)
        }
        if let encodingType = encodingType {
            try encodeContainer.encode(encodingType.rawValue, forKey: .encodingType)
        }
        if let encryptionMode = encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let externalTableDefinition = externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let includeOpForFullLoad = includeOpForFullLoad {
            try encodeContainer.encode(includeOpForFullLoad, forKey: .includeOpForFullLoad)
        }
        if let parquetTimestampInMillisecond = parquetTimestampInMillisecond {
            try encodeContainer.encode(parquetTimestampInMillisecond, forKey: .parquetTimestampInMillisecond)
        }
        if let parquetVersion = parquetVersion {
            try encodeContainer.encode(parquetVersion.rawValue, forKey: .parquetVersion)
        }
        if let preserveTransactions = preserveTransactions {
            try encodeContainer.encode(preserveTransactions, forKey: .preserveTransactions)
        }
        if let rowGroupLength = rowGroupLength {
            try encodeContainer.encode(rowGroupLength, forKey: .rowGroupLength)
        }
        if let serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId {
            try encodeContainer.encode(serverSideEncryptionKmsKeyId, forKey: .serverSideEncryptionKmsKeyId)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let timestampColumnName = timestampColumnName {
            try encodeContainer.encode(timestampColumnName, forKey: .timestampColumnName)
        }
        if let useCsvNoSupValue = useCsvNoSupValue {
            try encodeContainer.encode(useCsvNoSupValue, forKey: .useCsvNoSupValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let csvRowDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvRowDelimiter)
        csvRowDelimiter = csvRowDelimiterDecoded
        let csvDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvDelimiter)
        csvDelimiter = csvDelimiterDecoded
        let bucketFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketFolder)
        bucketFolder = bucketFolderDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let compressionTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.CompressionTypeValue.self, forKey: .compressionType)
        compressionType = compressionTypeDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EncryptionModeValue.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let serverSideEncryptionKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverSideEncryptionKmsKeyId)
        serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyIdDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DataFormatValue.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let encodingTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EncodingTypeValue.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
        let dictPageSizeLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dictPageSizeLimit)
        dictPageSizeLimit = dictPageSizeLimitDecoded
        let rowGroupLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rowGroupLength)
        rowGroupLength = rowGroupLengthDecoded
        let dataPageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataPageSize)
        dataPageSize = dataPageSizeDecoded
        let parquetVersionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ParquetVersionValue.self, forKey: .parquetVersion)
        parquetVersion = parquetVersionDecoded
        let enableStatisticsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableStatistics)
        enableStatistics = enableStatisticsDecoded
        let includeOpForFullLoadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeOpForFullLoad)
        includeOpForFullLoad = includeOpForFullLoadDecoded
        let cdcInsertsOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cdcInsertsOnly)
        cdcInsertsOnly = cdcInsertsOnlyDecoded
        let timestampColumnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampColumnName)
        timestampColumnName = timestampColumnNameDecoded
        let parquetTimestampInMillisecondDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .parquetTimestampInMillisecond)
        parquetTimestampInMillisecond = parquetTimestampInMillisecondDecoded
        let cdcInsertsAndUpdatesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cdcInsertsAndUpdates)
        cdcInsertsAndUpdates = cdcInsertsAndUpdatesDecoded
        let datePartitionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .datePartitionEnabled)
        datePartitionEnabled = datePartitionEnabledDecoded
        let datePartitionSequenceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DatePartitionSequenceValue.self, forKey: .datePartitionSequence)
        datePartitionSequence = datePartitionSequenceDecoded
        let datePartitionDelimiterDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DatePartitionDelimiterValue.self, forKey: .datePartitionDelimiter)
        datePartitionDelimiter = datePartitionDelimiterDecoded
        let useCsvNoSupValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useCsvNoSupValue)
        useCsvNoSupValue = useCsvNoSupValueDecoded
        let csvNoSupValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvNoSupValue)
        csvNoSupValue = csvNoSupValueDecoded
        let preserveTransactionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preserveTransactions)
        preserveTransactions = preserveTransactionsDecoded
        let cdcPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcPath)
        cdcPath = cdcPathDecoded
    }
}

extension DatabaseMigrationClientTypes.S3Settings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Settings(bucketFolder: \(Swift.String(describing: bucketFolder)), bucketName: \(Swift.String(describing: bucketName)), cdcInsertsAndUpdates: \(Swift.String(describing: cdcInsertsAndUpdates)), cdcInsertsOnly: \(Swift.String(describing: cdcInsertsOnly)), cdcPath: \(Swift.String(describing: cdcPath)), compressionType: \(Swift.String(describing: compressionType)), csvDelimiter: \(Swift.String(describing: csvDelimiter)), csvNoSupValue: \(Swift.String(describing: csvNoSupValue)), csvRowDelimiter: \(Swift.String(describing: csvRowDelimiter)), dataFormat: \(Swift.String(describing: dataFormat)), dataPageSize: \(Swift.String(describing: dataPageSize)), datePartitionDelimiter: \(Swift.String(describing: datePartitionDelimiter)), datePartitionEnabled: \(Swift.String(describing: datePartitionEnabled)), datePartitionSequence: \(Swift.String(describing: datePartitionSequence)), dictPageSizeLimit: \(Swift.String(describing: dictPageSizeLimit)), enableStatistics: \(Swift.String(describing: enableStatistics)), encodingType: \(Swift.String(describing: encodingType)), encryptionMode: \(Swift.String(describing: encryptionMode)), externalTableDefinition: \(Swift.String(describing: externalTableDefinition)), includeOpForFullLoad: \(Swift.String(describing: includeOpForFullLoad)), parquetTimestampInMillisecond: \(Swift.String(describing: parquetTimestampInMillisecond)), parquetVersion: \(Swift.String(describing: parquetVersion)), preserveTransactions: \(Swift.String(describing: preserveTransactions)), rowGroupLength: \(Swift.String(describing: rowGroupLength)), serverSideEncryptionKmsKeyId: \(Swift.String(describing: serverSideEncryptionKmsKeyId)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), timestampColumnName: \(Swift.String(describing: timestampColumnName)), useCsvNoSupValue: \(Swift.String(describing: useCsvNoSupValue)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Settings for exporting data to Amazon S3. </p>
    public struct S3Settings: Swift.Equatable {
        /// <p> An optional parameter to set a folder name in the S3 bucket. If provided, tables are
        ///          created in the path
        ///                <code>
        ///                <i>bucketFolder</i>/<i>schema_name</i>/<i>table_name</i>/</code>.
        ///          If this parameter isn't specified, then the path used is
        ///                <code>
        ///                <i>schema_name</i>/<i>table_name</i>/</code>. </p>
        public let bucketFolder: Swift.String?
        /// <p> The name of the S3 bucket. </p>
        public let bucketName: Swift.String?
        /// <p>A value that enables a change data capture (CDC) load to write INSERT and UPDATE
        ///          operations to .csv or .parquet (columnar storage) output files. The default setting is
        ///             <code>false</code>, but when <code>CdcInsertsAndUpdates</code> is set to
        ///             <code>true</code> or <code>y</code>, only INSERTs and UPDATEs from the source database
        ///          are migrated to the .csv or .parquet file. </p>
        ///          <p>For .csv file format only, how these INSERTs and UPDATEs are recorded depends on the
        ///          value of the <code>IncludeOpForFullLoad</code> parameter. If
        ///             <code>IncludeOpForFullLoad</code> is set to <code>true</code>, the first field of every
        ///          CDC record is set to either <code>I</code> or <code>U</code> to indicate INSERT and UPDATE
        ///          operations at the source. But if <code>IncludeOpForFullLoad</code> is set to
        ///             <code>false</code>, CDC records are written without an indication of INSERT or UPDATE
        ///          operations at the source. For more information about how these settings work together, see
        ///             <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring.InsertOps">Indicating Source DB Operations in Migrated S3 Data</a> in the <i>AWS
        ///             Database Migration Service User Guide.</i>.</p>
        ///          <note>
        ///
        ///             <p>AWS DMS supports the use of the <code>CdcInsertsAndUpdates</code> parameter in
        ///             versions 3.3.1 and later.</p>
        ///
        ///             <p>
        ///                <code>CdcInsertsOnly</code> and <code>CdcInsertsAndUpdates</code> can't
        ///             both be set to <code>true</code> for the same endpoint. Set either
        ///             <code>CdcInsertsOnly</code> or <code>CdcInsertsAndUpdates</code> to <code>true</code>
        ///             for the same endpoint, but not both.</p>
        ///
        ///          </note>
        public let cdcInsertsAndUpdates: Swift.Bool?
        /// <p>A value that enables a change data capture (CDC) load to write only INSERT operations to
        ///          .csv or columnar storage (.parquet) output files. By default (the
        ///             <code>false</code> setting), the first field in a .csv or .parquet record contains the
        ///          letter I (INSERT), U (UPDATE), or D (DELETE). These values indicate whether the row was
        ///          inserted, updated, or deleted at the source database for a CDC load to the target.</p>
        ///          <p>If <code>CdcInsertsOnly</code> is set to <code>true</code> or <code>y</code>, only
        ///          INSERTs from the source database are migrated to the .csv or .parquet file. For .csv format
        ///          only, how these INSERTs are recorded depends on the value of
        ///             <code>IncludeOpForFullLoad</code>. If <code>IncludeOpForFullLoad</code> is set to
        ///             <code>true</code>, the first field of every CDC record is set to I to indicate the
        ///          INSERT operation at the source. If <code>IncludeOpForFullLoad</code> is set to
        ///             <code>false</code>, every CDC record is written without a first field to indicate the
        ///          INSERT operation at the source. For more information about how these settings work
        ///          together, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring.InsertOps">Indicating Source DB Operations in Migrated S3 Data</a> in the <i>AWS
        ///             Database Migration Service User Guide.</i>.</p>
        ///
        ///          <note>
        ///
        ///                <p>AWS DMS supports the interaction described preceding between the
        ///                <code>CdcInsertsOnly</code> and <code>IncludeOpForFullLoad</code> parameters in
        ///             versions 3.1.4 and later. </p>
        ///
        ///                <p>
        ///                <code>CdcInsertsOnly</code> and <code>CdcInsertsAndUpdates</code> can't
        ///             both be set to <code>true</code> for the same endpoint. Set either
        ///                <code>CdcInsertsOnly</code> or <code>CdcInsertsAndUpdates</code> to <code>true</code>
        ///             for the same endpoint, but not both.</p>
        ///
        ///          </note>
        public let cdcInsertsOnly: Swift.Bool?
        /// <p>Specifies the folder path of CDC files. For an S3 source, this setting is required if a
        ///          task captures change data; otherwise, it's optional. If <code>CdcPath</code> is set, AWS
        ///          DMS reads CDC files from this path and replicates the data changes to the target endpoint.
        ///          For an S3 target if you set <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-PreserveTransactions">
        ///                <code>PreserveTransactions</code>
        ///             </a> to <code>true</code>, AWS
        ///          DMS verifies that you have set this parameter to a folder path on your S3 target where AWS
        ///          DMS can save the transaction order for the CDC load. AWS DMS creates this CDC folder path
        ///          in either your S3 target working directory or the S3 target location specified by <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-BucketFolder">
        ///                <code>BucketFolder</code>
        ///             </a> and <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-BucketName">
        ///                <code>BucketName</code>
        ///             </a>.</p>
        ///          <p>For example, if you specify <code>CdcPath</code> as <code>MyChangedData</code>, and you
        ///          specify <code>BucketName</code> as <code>MyTargetBucket</code> but do not specify
        ///             <code>BucketFolder</code>, AWS DMS creates the CDC folder path following:
        ///             <code>MyTargetBucket/MyChangedData</code>.</p>
        ///          <p>If you specify the same <code>CdcPath</code>, and you specify <code>BucketName</code> as
        ///             <code>MyTargetBucket</code> and <code>BucketFolder</code> as <code>MyTargetData</code>,
        ///          AWS DMS creates the CDC folder path following:
        ///             <code>MyTargetBucket/MyTargetData/MyChangedData</code>.</p>
        ///          <p>For more information on CDC including transaction order on an S3 target, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.EndpointSettings.CdcPath">Capturing data changes (CDC) including transaction order on the S3
        ///             target</a>.</p>
        ///          <note>
        ///             <p>This setting is supported in AWS DMS versions 3.4.2 and later.</p>
        ///          </note>
        public let cdcPath: Swift.String?
        /// <p>An optional parameter to use GZIP to compress the target files. Set to GZIP to compress
        ///          the target files. Either set this parameter to NONE (the default) or don't use it to leave the files uncompressed.
        ///          This parameter applies to both .csv and .parquet file formats. </p>
        public let compressionType: DatabaseMigrationClientTypes.CompressionTypeValue?
        /// <p> The delimiter used to separate columns in the .csv file for both source and target. The default is a comma.
        ///       </p>
        public let csvDelimiter: Swift.String?
        /// <p>This setting only applies if your Amazon S3 output files during a change data capture
        ///          (CDC) load are written in .csv format. If <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-UseCsvNoSupValue">
        ///                <code>UseCsvNoSupValue</code>
        ///             </a> is set to true, specify a
        ///          string value that you want AWS DMS to use for all columns not included in the supplemental
        ///          log. If you do not specify a string value, AWS DMS uses the null value for these columns
        ///          regardless of the <code>UseCsvNoSupValue</code> setting.</p>
        ///          <note>
        ///             <p>This setting is supported in AWS DMS versions 3.4.1 and later.</p>
        ///          </note>
        public let csvNoSupValue: Swift.String?
        /// <p> The delimiter used to separate rows in the .csv file for both source and target. The default is a carriage
        ///          return (<code>\n</code>). </p>
        public let csvRowDelimiter: Swift.String?
        /// <p>The format of the data that you want to use for output. You can choose one of the
        ///          following: </p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>csv</code> : This is a row-based file format with comma-separated values
        ///                (.csv). </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>parquet</code> : Apache Parquet (.parquet) is a columnar storage file format
        ///                that features efficient compression and provides faster query response. </p>
        ///             </li>
        ///          </ul>
        public let dataFormat: DatabaseMigrationClientTypes.DataFormatValue?
        /// <p>The size of one data page in bytes. This parameter defaults to 1024 * 1024 bytes (1 MiB).
        ///          This number is used for .parquet file format only. </p>
        public let dataPageSize: Swift.Int?
        /// <p>Specifies a date separating delimiter to use during folder partitioning. The default value is
        ///          <code>SLASH</code>. Use this parameter when <code>DatePartitionedEnabled</code> is set to <code>true</code>.</p>
        public let datePartitionDelimiter: DatabaseMigrationClientTypes.DatePartitionDelimiterValue?
        /// <p>When set to <code>true</code>, this parameter partitions S3 bucket folders based on transaction commit
        ///          dates. The default value is <code>false</code>. For more information about date-based folder partitoning,
        ///          see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.DatePartitioning">Using date-based folder partitioning</a>.</p>
        public let datePartitionEnabled: Swift.Bool?
        /// <p>Identifies the sequence of the date format to use during folder partitioning. The default value is
        ///          <code>YYYYMMDD</code>. Use this parameter when <code>DatePartitionedEnabled</code> is set to <code>true</code>.</p>
        public let datePartitionSequence: DatabaseMigrationClientTypes.DatePartitionSequenceValue?
        /// <p>The maximum size of an encoded dictionary page of a column. If the dictionary page
        ///          exceeds this, this column is stored using an encoding type of <code>PLAIN</code>. This
        ///          parameter defaults to 1024 * 1024 bytes (1 MiB), the maximum size of a dictionary page
        ///          before it reverts to <code>PLAIN</code> encoding. This size is used for
        ///            .parquet file format only. </p>
        public let dictPageSizeLimit: Swift.Int?
        /// <p>A value that enables statistics for Parquet pages and row groups. Choose
        ///             <code>true</code> to enable statistics, <code>false</code> to disable. Statistics
        ///          include <code>NULL</code>, <code>DISTINCT</code>, <code>MAX</code>, and <code>MIN</code>
        ///          values. This parameter defaults to <code>true</code>. This value is used for
        ///             .parquet file format only.</p>
        public let enableStatistics: Swift.Bool?
        /// <p>The type of encoding you are using: </p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>RLE_DICTIONARY</code> uses a combination of bit-packing and run-length
        ///                encoding to store repeated values more efficiently. This is the default.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>PLAIN</code> doesn't use encoding at all. Values are stored as they
        ///                are.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>PLAIN_DICTIONARY</code> builds a dictionary of the values encountered in a
        ///                given column. The dictionary is stored in a dictionary page for each column
        ///                chunk.</p>
        ///             </li>
        ///          </ul>
        public let encodingType: DatabaseMigrationClientTypes.EncodingTypeValue?
        /// <p>The type of server-side encryption that you want to use for your data. This encryption
        ///          type is part of the endpoint settings or the extra connections attributes for Amazon S3.
        ///          You can choose either <code>SSE_S3</code> (the default) or <code>SSE_KMS</code>. </p>
        ///          <note>
        ///             <p>For the <code>ModifyEndpoint</code> operation, you can change the existing value of
        ///             the <code>EncryptionMode</code> parameter from <code>SSE_KMS</code> to
        ///                <code>SSE_S3</code>. But you canâ€™t change the existing value from <code>SSE_S3</code>
        ///             to <code>SSE_KMS</code>.</p>
        ///          </note>
        ///          <p>To use <code>SSE_S3</code>, you need an AWS Identity and Access Management (IAM) role
        ///          with permission to allow <code>"arn:aws:s3:::dms-*"</code> to use the following
        ///          actions:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>s3:CreateBucket</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>s3:ListBucket</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>s3:DeleteBucket</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>s3:GetBucketLocation</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>s3:GetObject</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>s3:PutObject</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>s3:DeleteObject</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>s3:GetObjectVersion</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>s3:GetBucketPolicy</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>s3:PutBucketPolicy</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>s3:DeleteBucketPolicy</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        public let encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue?
        /// <p> Specifies how tables are defined in the S3 source files only. </p>
        public let externalTableDefinition: Swift.String?
        /// <p>A value that enables a full load to write INSERT operations to the comma-separated value
        ///          (.csv) output files only to indicate how the rows were added to the source database.</p>
        ///          <note>
        ///             <p>AWS DMS supports the <code>IncludeOpForFullLoad</code> parameter in versions 3.1.4 and
        ///             later.</p>
        ///          </note>
        ///          <p>For full load, records can only be inserted. By default (the <code>false</code>
        ///          setting), no information is recorded in these output files for a full load to indicate that
        ///          the rows were inserted at the source database. If <code>IncludeOpForFullLoad</code> is set
        ///          to <code>true</code> or <code>y</code>, the INSERT is recorded as an I annotation in the
        ///          first field of the .csv file. This allows the format of your target records from a full
        ///          load to be consistent with the target records from a CDC load.</p>
        ///          <note>
        ///             <p>This setting works together with the <code>CdcInsertsOnly</code> and the
        ///                <code>CdcInsertsAndUpdates</code> parameters for output to .csv files only. For more
        ///             information about how these settings work together, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring.InsertOps">Indicating Source DB Operations in Migrated S3 Data</a> in the <i>AWS
        ///                Database Migration Service User Guide.</i>.</p>
        ///          </note>
        public let includeOpForFullLoad: Swift.Bool?
        /// <p>A value that specifies the precision of any <code>TIMESTAMP</code> column values that
        ///          are written to an Amazon S3 object file in .parquet format.</p>
        ///          <note>
        ///             <p>AWS DMS supports the <code>ParquetTimestampInMillisecond</code> parameter in versions
        ///             3.1.4 and later.</p>
        ///          </note>
        ///          <p>When <code>ParquetTimestampInMillisecond</code> is set to <code>true</code> or
        ///             <code>y</code>, AWS DMS writes all <code>TIMESTAMP</code> columns in a .parquet
        ///          formatted file with millisecond precision. Otherwise, DMS writes them with microsecond
        ///          precision.</p>
        ///          <p>Currently, Amazon Athena and AWS Glue can handle only
        ///          millisecond precision for <code>TIMESTAMP</code> values. Set
        ///          this parameter to <code>true</code> for S3 endpoint object
        ///          files that are .parquet formatted only if you plan to query or process the data with Athena or AWS Glue.</p>
        ///          <note>
        ///
        ///                <p>AWS DMS writes any <code>TIMESTAMP</code> column
        ///                   values written to an S3 file in .csv format with
        ///                   microsecond precision.</p>
        ///
        ///                <p>Setting <code>ParquetTimestampInMillisecond</code> has no effect on the string
        ///             format of the timestamp column value that is inserted by setting the
        ///                <code>TimestampColumnName</code> parameter.</p>
        ///
        ///          </note>
        public let parquetTimestampInMillisecond: Swift.Bool?
        /// <p>The version of the Apache Parquet format that you want to use: <code>parquet_1_0</code>
        ///          (the default) or <code>parquet_2_0</code>.</p>
        public let parquetVersion: DatabaseMigrationClientTypes.ParquetVersionValue?
        /// <p>If set to <code>true</code>, AWS DMS saves the transaction order for a change data
        ///          capture (CDC) load on the Amazon S3 target specified by <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-CdcPath">
        ///                <code>CdcPath</code>
        ///             </a>. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.EndpointSettings.CdcPath">Capturing data changes (CDC) including transaction order on the S3
        ///             target</a>.</p>
        ///          <note>
        ///             <p>This setting is supported in AWS DMS versions 3.4.2 and later.</p>
        ///          </note>
        public let preserveTransactions: Swift.Bool?
        /// <p>The number of rows in a row group. A smaller row group size provides faster reads. But
        ///          as the number of row groups grows, the slower writes become. This parameter defaults to
        ///          10,000 rows. This number is used for .parquet file format only. </p>
        ///          <p>If you choose a value larger than the maximum, <code>RowGroupLength</code> is set to the
        ///          max row group length in bytes (64 * 1024 * 1024). </p>
        public let rowGroupLength: Swift.Int?
        /// <p>If you are using <code>SSE_KMS</code> for the <code>EncryptionMode</code>, provide the
        ///          AWS KMS key ID. The key that you use needs an attached policy that enables AWS Identity and
        ///          Access Management (IAM) user permissions and allows use of the key.</p>
        ///          <p>Here is a CLI example: <code>aws dms create-endpoint --endpoint-identifier
        ///                <i>value</i> --endpoint-type target --engine-name s3 --s3-settings
        ///                ServiceAccessRoleArn=<i>value</i>,BucketFolder=<i>value</i>,BucketName=<i>value</i>,EncryptionMode=SSE_KMS,ServerSideEncryptionKmsKeyId=<i>value</i>
        ///             </code>
        ///          </p>
        public let serverSideEncryptionKmsKeyId: Swift.String?
        /// <p> The Amazon Resource Name (ARN) used by the service access IAM role. It is a required
        ///          parameter that enables DMS to write and read objects from an S3 bucket.</p>
        public let serviceAccessRoleArn: Swift.String?
        /// <p>A value that when nonblank causes AWS DMS to add a column with timestamp information to
        ///          the endpoint data for an Amazon S3 target.</p>
        ///          <note>
        ///             <p>AWS DMS supports the <code>TimestampColumnName</code> parameter in versions 3.1.4 and later.</p>
        ///          </note>
        ///          <p>DMS includes an additional <code>STRING</code> column in the
        ///          .csv or .parquet object files of your migrated data when you set
        ///          <code>TimestampColumnName</code> to a nonblank value.</p>
        ///          <p>For a full load, each row of this timestamp column contains a
        ///          timestamp for when the data was transferred from the source to
        ///          the target by DMS. </p>
        ///          <p>For a change data capture (CDC) load, each row of the timestamp column contains the
        ///          timestamp for the commit of that row in the source
        ///          database.</p>
        ///          <p>The string format for this timestamp column value is
        ///          <code>yyyy-MM-dd HH:mm:ss.SSSSSS</code>. By default, the
        ///          precision of this value is in microseconds. For a CDC load, the
        ///          rounding of the precision depends on the commit timestamp
        ///          supported by DMS for the source database.</p>
        ///          <p>When the <code>AddColumnName</code> parameter is set to <code>true</code>, DMS also
        ///          includes a name for the timestamp column that you set with
        ///          <code>TimestampColumnName</code>.</p>
        public let timestampColumnName: Swift.String?
        /// <p>This setting applies if the S3 output files during a change data capture (CDC) load are
        ///          written in .csv format. If set to <code>true</code> for columns not included in the
        ///          supplemental log, AWS DMS uses the value specified by <a href="https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-CsvNoSupValue">
        ///                <code>CsvNoSupValue</code>
        ///             </a>. If not set or set to
        ///             <code>false</code>, AWS DMS uses the null value for these columns.</p>
        ///          <note>
        ///             <p>This setting is supported in AWS DMS versions 3.4.1 and later.</p>
        ///          </note>
        public let useCsvNoSupValue: Swift.Bool?

        public init (
            bucketFolder: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            cdcInsertsAndUpdates: Swift.Bool? = nil,
            cdcInsertsOnly: Swift.Bool? = nil,
            cdcPath: Swift.String? = nil,
            compressionType: DatabaseMigrationClientTypes.CompressionTypeValue? = nil,
            csvDelimiter: Swift.String? = nil,
            csvNoSupValue: Swift.String? = nil,
            csvRowDelimiter: Swift.String? = nil,
            dataFormat: DatabaseMigrationClientTypes.DataFormatValue? = nil,
            dataPageSize: Swift.Int? = nil,
            datePartitionDelimiter: DatabaseMigrationClientTypes.DatePartitionDelimiterValue? = nil,
            datePartitionEnabled: Swift.Bool? = nil,
            datePartitionSequence: DatabaseMigrationClientTypes.DatePartitionSequenceValue? = nil,
            dictPageSizeLimit: Swift.Int? = nil,
            enableStatistics: Swift.Bool? = nil,
            encodingType: DatabaseMigrationClientTypes.EncodingTypeValue? = nil,
            encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue? = nil,
            externalTableDefinition: Swift.String? = nil,
            includeOpForFullLoad: Swift.Bool? = nil,
            parquetTimestampInMillisecond: Swift.Bool? = nil,
            parquetVersion: DatabaseMigrationClientTypes.ParquetVersionValue? = nil,
            preserveTransactions: Swift.Bool? = nil,
            rowGroupLength: Swift.Int? = nil,
            serverSideEncryptionKmsKeyId: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            timestampColumnName: Swift.String? = nil,
            useCsvNoSupValue: Swift.Bool? = nil
        )
        {
            self.bucketFolder = bucketFolder
            self.bucketName = bucketName
            self.cdcInsertsAndUpdates = cdcInsertsAndUpdates
            self.cdcInsertsOnly = cdcInsertsOnly
            self.cdcPath = cdcPath
            self.compressionType = compressionType
            self.csvDelimiter = csvDelimiter
            self.csvNoSupValue = csvNoSupValue
            self.csvRowDelimiter = csvRowDelimiter
            self.dataFormat = dataFormat
            self.dataPageSize = dataPageSize
            self.datePartitionDelimiter = datePartitionDelimiter
            self.datePartitionEnabled = datePartitionEnabled
            self.datePartitionSequence = datePartitionSequence
            self.dictPageSizeLimit = dictPageSizeLimit
            self.enableStatistics = enableStatistics
            self.encodingType = encodingType
            self.encryptionMode = encryptionMode
            self.externalTableDefinition = externalTableDefinition
            self.includeOpForFullLoad = includeOpForFullLoad
            self.parquetTimestampInMillisecond = parquetTimestampInMillisecond
            self.parquetVersion = parquetVersion
            self.preserveTransactions = preserveTransactions
            self.rowGroupLength = rowGroupLength
            self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.timestampColumnName = timestampColumnName
            self.useCsvNoSupValue = useCsvNoSupValue
        }
    }

}

extension SNSInvalidTopicFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SNSInvalidTopicFault(message: \(Swift.String(describing: message)))"}
}

extension SNSInvalidTopicFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SNSInvalidTopicFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The SNS topic is invalid.</p>
public struct SNSInvalidTopicFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p></p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSInvalidTopicFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SNSInvalidTopicFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSNoAuthorizationFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SNSNoAuthorizationFault(message: \(Swift.String(describing: message)))"}
}

extension SNSNoAuthorizationFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SNSNoAuthorizationFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are not authorized for the SNS subscription.</p>
public struct SNSNoAuthorizationFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p></p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSNoAuthorizationFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SNSNoAuthorizationFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum SafeguardPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case exclusiveAutomaticTruncation
        case relyOnSqlServerReplicationAgent
        case sharedAutomaticTruncation
        case sdkUnknown(Swift.String)

        public static var allCases: [SafeguardPolicy] {
            return [
                .exclusiveAutomaticTruncation,
                .relyOnSqlServerReplicationAgent,
                .sharedAutomaticTruncation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .exclusiveAutomaticTruncation: return "exclusive-automatic-truncation"
            case .relyOnSqlServerReplicationAgent: return "rely-on-sql-server-replication-agent"
            case .sharedAutomaticTruncation: return "shared-automatic-truncation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SafeguardPolicy(rawValue: rawValue) ?? SafeguardPolicy.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case replicationInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .replicationInstance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .replicationInstance: return "replication-instance"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

public struct StartReplicationTaskAssessmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReplicationTaskAssessmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartReplicationTaskAssessmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReplicationTaskAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartReplicationTaskAssessmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartReplicationTaskAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReplicationTaskAssessmentOutputError>
}

extension StartReplicationTaskAssessmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartReplicationTaskAssessmentInput(replicationTaskArn: \(Swift.String(describing: replicationTaskArn)))"}
}

extension StartReplicationTaskAssessmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

public struct StartReplicationTaskAssessmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReplicationTaskAssessmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartReplicationTaskAssessmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReplicationTaskAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartReplicationTaskAssessmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartReplicationTaskAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReplicationTaskAssessmentOutputError>
}

public struct StartReplicationTaskAssessmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReplicationTaskAssessmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartReplicationTaskAssessmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReplicationTaskAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartReplicationTaskAssessmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartReplicationTaskAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReplicationTaskAssessmentOutputError>
}

/// <p></p>
public struct StartReplicationTaskAssessmentInput: Swift.Equatable {
    /// <p> The Amazon Resource Name (ARN) of the replication task. </p>
    public let replicationTaskArn: Swift.String?

    public init (
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct StartReplicationTaskAssessmentInputBody: Swift.Equatable {
    public let replicationTaskArn: Swift.String?
}

extension StartReplicationTaskAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

extension StartReplicationTaskAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReplicationTaskAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartReplicationTaskAssessmentOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReplicationTaskAssessmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartReplicationTaskAssessmentOutputResponse(replicationTask: \(Swift.String(describing: replicationTask)))"}
}

extension StartReplicationTaskAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartReplicationTaskAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

/// <p></p>
public struct StartReplicationTaskAssessmentOutputResponse: Swift.Equatable {
    /// <p> The assessed replication task. </p>
    public let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init (
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct StartReplicationTaskAssessmentOutputResponseBody: Swift.Equatable {
    public let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension StartReplicationTaskAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

public struct StartReplicationTaskAssessmentRunInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReplicationTaskAssessmentRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartReplicationTaskAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReplicationTaskAssessmentRunOutputError>
}

extension StartReplicationTaskAssessmentRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartReplicationTaskAssessmentRunInput(assessmentRunName: \(Swift.String(describing: assessmentRunName)), exclude: \(Swift.String(describing: exclude)), includeOnly: \(Swift.String(describing: includeOnly)), replicationTaskArn: \(Swift.String(describing: replicationTaskArn)), resultEncryptionMode: \(Swift.String(describing: resultEncryptionMode)), resultKmsKeyArn: \(Swift.String(describing: resultKmsKeyArn)), resultLocationBucket: \(Swift.String(describing: resultLocationBucket)), resultLocationFolder: \(Swift.String(describing: resultLocationFolder)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)))"}
}

extension StartReplicationTaskAssessmentRunInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunName = "AssessmentRunName"
        case exclude = "Exclude"
        case includeOnly = "IncludeOnly"
        case replicationTaskArn = "ReplicationTaskArn"
        case resultEncryptionMode = "ResultEncryptionMode"
        case resultKmsKeyArn = "ResultKmsKeyArn"
        case resultLocationBucket = "ResultLocationBucket"
        case resultLocationFolder = "ResultLocationFolder"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunName = assessmentRunName {
            try encodeContainer.encode(assessmentRunName, forKey: .assessmentRunName)
        }
        if let exclude = exclude {
            var excludeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclude)
            for excludetestlist0 in exclude {
                try excludeContainer.encode(excludetestlist0)
            }
        }
        if let includeOnly = includeOnly {
            var includeOnlyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includeOnly)
            for includetestlist0 in includeOnly {
                try includeOnlyContainer.encode(includetestlist0)
            }
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let resultEncryptionMode = resultEncryptionMode {
            try encodeContainer.encode(resultEncryptionMode, forKey: .resultEncryptionMode)
        }
        if let resultKmsKeyArn = resultKmsKeyArn {
            try encodeContainer.encode(resultKmsKeyArn, forKey: .resultKmsKeyArn)
        }
        if let resultLocationBucket = resultLocationBucket {
            try encodeContainer.encode(resultLocationBucket, forKey: .resultLocationBucket)
        }
        if let resultLocationFolder = resultLocationFolder {
            try encodeContainer.encode(resultLocationFolder, forKey: .resultLocationFolder)
        }
        if let serviceAccessRoleArn = serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }
}

public struct StartReplicationTaskAssessmentRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReplicationTaskAssessmentRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartReplicationTaskAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReplicationTaskAssessmentRunOutputError>
}

public struct StartReplicationTaskAssessmentRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReplicationTaskAssessmentRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartReplicationTaskAssessmentRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReplicationTaskAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartReplicationTaskAssessmentRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartReplicationTaskAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReplicationTaskAssessmentRunOutputError>
}

/// <p></p>
public struct StartReplicationTaskAssessmentRunInput: Swift.Equatable {
    /// <p>Unique name to identify the assessment run.</p>
    public let assessmentRunName: Swift.String?
    /// <p>Space-separated list of names for specific individual assessments that you want to
    ///          exclude. These names come from the default list of individual assessments that AWS DMS
    ///          supports for the associated migration task. This task is specified by
    ///             <code>ReplicationTaskArn</code>.</p>
    ///          <note>
    ///             <p>You can't set a value for <code>Exclude</code> if you also set a value for
    ///             <code>IncludeOnly</code> in the API operation.</p>
    ///             <p>To identify the names of the default individual assessments that AWS DMS
    ///             supports for the associated migration task, run the
    ///             <code>DescribeApplicableIndividualAssessments</code> operation using its own
    ///             <code>ReplicationTaskArn</code> request parameter.</p>
    ///          </note>
    public let exclude: [Swift.String]?
    /// <p>Space-separated list of names for specific individual assessments that you want to
    ///          include. These names come from the default list of individual assessments that AWS DMS
    ///          supports for the associated migration task. This task is specified by
    ///             <code>ReplicationTaskArn</code>.</p>
    ///          <note>
    ///             <p>You can't set a value for <code>IncludeOnly</code> if you also set a value for
    ///             <code>Exclude</code> in the API operation. </p>
    ///             <p>To identify the names of the default individual assessments that AWS DMS
    ///             supports for the associated migration task, run the
    ///             <code>DescribeApplicableIndividualAssessments</code> operation using its own
    ///             <code>ReplicationTaskArn</code> request parameter.</p>
    ///          </note>
    public let includeOnly: [Swift.String]?
    /// <p>Amazon Resource Name (ARN) of the migration task associated with the premigration
    ///          assessment run that you want to start.</p>
    public let replicationTaskArn: Swift.String?
    /// <p>Encryption mode that you can specify to encrypt the results of this assessment run. If
    ///          you don't specify this request parameter, AWS DMS stores the assessment run results
    ///          without encryption. You can specify one of the options following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>"SSE_S3"</code> â€“ The server-side encryption provided as a default by
    ///                Amazon S3.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>"SSE_KMS"</code> â€“ AWS Key Management Service (AWS KMS) encryption.
    ///                This encryption can use either a custom KMS encryption key that you specify or the
    ///                default KMS encryption key that DMS provides.</p>
    ///             </li>
    ///          </ul>
    public let resultEncryptionMode: Swift.String?
    /// <p>ARN of a custom KMS encryption key that you specify when you set
    ///             <code>ResultEncryptionMode</code> to <code>"SSE_KMS</code>".</p>
    public let resultKmsKeyArn: Swift.String?
    /// <p>Amazon S3 bucket where you want AWS DMS to store the results of this assessment
    ///          run.</p>
    public let resultLocationBucket: Swift.String?
    /// <p>Folder within an Amazon S3 bucket where you want AWS DMS to store the results of this assessment
    ///          run.</p>
    public let resultLocationFolder: Swift.String?
    /// <p>ARN of a service role needed to start the assessment run.</p>
    public let serviceAccessRoleArn: Swift.String?

    public init (
        assessmentRunName: Swift.String? = nil,
        exclude: [Swift.String]? = nil,
        includeOnly: [Swift.String]? = nil,
        replicationTaskArn: Swift.String? = nil,
        resultEncryptionMode: Swift.String? = nil,
        resultKmsKeyArn: Swift.String? = nil,
        resultLocationBucket: Swift.String? = nil,
        resultLocationFolder: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil
    )
    {
        self.assessmentRunName = assessmentRunName
        self.exclude = exclude
        self.includeOnly = includeOnly
        self.replicationTaskArn = replicationTaskArn
        self.resultEncryptionMode = resultEncryptionMode
        self.resultKmsKeyArn = resultKmsKeyArn
        self.resultLocationBucket = resultLocationBucket
        self.resultLocationFolder = resultLocationFolder
        self.serviceAccessRoleArn = serviceAccessRoleArn
    }
}

struct StartReplicationTaskAssessmentRunInputBody: Swift.Equatable {
    public let replicationTaskArn: Swift.String?
    public let serviceAccessRoleArn: Swift.String?
    public let resultLocationBucket: Swift.String?
    public let resultLocationFolder: Swift.String?
    public let resultEncryptionMode: Swift.String?
    public let resultKmsKeyArn: Swift.String?
    public let assessmentRunName: Swift.String?
    public let includeOnly: [Swift.String]?
    public let exclude: [Swift.String]?
}

extension StartReplicationTaskAssessmentRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunName = "AssessmentRunName"
        case exclude = "Exclude"
        case includeOnly = "IncludeOnly"
        case replicationTaskArn = "ReplicationTaskArn"
        case resultEncryptionMode = "ResultEncryptionMode"
        case resultKmsKeyArn = "ResultKmsKeyArn"
        case resultLocationBucket = "ResultLocationBucket"
        case resultLocationFolder = "ResultLocationFolder"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let resultLocationBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultLocationBucket)
        resultLocationBucket = resultLocationBucketDecoded
        let resultLocationFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultLocationFolder)
        resultLocationFolder = resultLocationFolderDecoded
        let resultEncryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultEncryptionMode)
        resultEncryptionMode = resultEncryptionModeDecoded
        let resultKmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultKmsKeyArn)
        resultKmsKeyArn = resultKmsKeyArnDecoded
        let assessmentRunNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunName)
        assessmentRunName = assessmentRunNameDecoded
        let includeOnlyContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .includeOnly)
        var includeOnlyDecoded0:[Swift.String]? = nil
        if let includeOnlyContainer = includeOnlyContainer {
            includeOnlyDecoded0 = [Swift.String]()
            for string0 in includeOnlyContainer {
                if let string0 = string0 {
                    includeOnlyDecoded0?.append(string0)
                }
            }
        }
        includeOnly = includeOnlyDecoded0
        let excludeContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exclude)
        var excludeDecoded0:[Swift.String]? = nil
        if let excludeContainer = excludeContainer {
            excludeDecoded0 = [Swift.String]()
            for string0 in excludeContainer {
                if let string0 = string0 {
                    excludeDecoded0?.append(string0)
                }
            }
        }
        exclude = excludeDecoded0
    }
}

extension StartReplicationTaskAssessmentRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReplicationTaskAssessmentRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedFault" : self = .kMSAccessDeniedFault(try KMSAccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledFault" : self = .kMSDisabledFault(try KMSDisabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSFault" : self = .kMSFault(try KMSFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateFault" : self = .kMSInvalidStateFault(try KMSInvalidStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundFault" : self = .kMSNotFoundFault(try KMSNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3AccessDeniedFault" : self = .s3AccessDeniedFault(try S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3ResourceNotFoundFault" : self = .s3ResourceNotFoundFault(try S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartReplicationTaskAssessmentRunOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSAccessDeniedFault(KMSAccessDeniedFault)
    case kMSDisabledFault(KMSDisabledFault)
    case kMSFault(KMSFault)
    case kMSInvalidStateFault(KMSInvalidStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case kMSNotFoundFault(KMSNotFoundFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case s3AccessDeniedFault(S3AccessDeniedFault)
    case s3ResourceNotFoundFault(S3ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReplicationTaskAssessmentRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartReplicationTaskAssessmentRunOutputResponse(replicationTaskAssessmentRun: \(Swift.String(describing: replicationTaskAssessmentRun)))"}
}

extension StartReplicationTaskAssessmentRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartReplicationTaskAssessmentRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTaskAssessmentRun = output.replicationTaskAssessmentRun
        } else {
            self.replicationTaskAssessmentRun = nil
        }
    }
}

/// <p></p>
public struct StartReplicationTaskAssessmentRunOutputResponse: Swift.Equatable {
    /// <p>The premigration assessment run that was started.</p>
    public let replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?

    public init (
        replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun? = nil
    )
    {
        self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
    }
}

struct StartReplicationTaskAssessmentRunOutputResponseBody: Swift.Equatable {
    public let replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?
}

extension StartReplicationTaskAssessmentRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun.self, forKey: .replicationTaskAssessmentRun)
        replicationTaskAssessmentRun = replicationTaskAssessmentRunDecoded
    }
}

public struct StartReplicationTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReplicationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReplicationTaskOutputError>
}

extension StartReplicationTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartReplicationTaskInput(cdcStartPosition: \(Swift.String(describing: cdcStartPosition)), cdcStartTime: \(Swift.String(describing: cdcStartTime)), cdcStopPosition: \(Swift.String(describing: cdcStopPosition)), replicationTaskArn: \(Swift.String(describing: replicationTaskArn)), startReplicationTaskType: \(Swift.String(describing: startReplicationTaskType)))"}
}

extension StartReplicationTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case replicationTaskArn = "ReplicationTaskArn"
        case startReplicationTaskType = "StartReplicationTaskType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStartTime = cdcStartTime {
            try encodeContainer.encode(cdcStartTime.timeIntervalSince1970, forKey: .cdcStartTime)
        }
        if let cdcStopPosition = cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let startReplicationTaskType = startReplicationTaskType {
            try encodeContainer.encode(startReplicationTaskType.rawValue, forKey: .startReplicationTaskType)
        }
    }
}

public struct StartReplicationTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReplicationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReplicationTaskOutputError>
}

public struct StartReplicationTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReplicationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReplicationTaskOutputError>
}

/// <p></p>
public struct StartReplicationTaskInput: Swift.Equatable {
    /// <p>Indicates when you want a change data capture (CDC) operation to start. Use either
    ///          CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start.
    ///          Specifying both values results in an error.</p>
    ///          <p> The value can be in date, checkpoint, or LSN/SCN format.</p>
    ///          <p>Date Example: --cdc-start-position â€œ2018-03-08T12:12:12â€</p>
    ///          <p>Checkpoint Example: --cdc-start-position
    ///          "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93"</p>
    ///          <p>LSN Example: --cdc-start-position â€œmysql-bin-changelog.000024:373â€</p>
    ///          <note>
    ///             <p>When you use this task setting with a source PostgreSQL database, a logical
    ///             replication slot should already be created and associated with the source endpoint. You
    ///             can verify this by setting the <code>slotName</code> extra connection attribute to the
    ///             name of this logical replication slot. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib">Extra Connection Attributes When Using PostgreSQL as a Source
    ///                for AWS DMS</a>.</p>
    ///          </note>
    public let cdcStartPosition: Swift.String?
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either
    ///          CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start.
    ///          Specifying both values results in an error.</p>
    ///          <p>Timestamp Example: --cdc-start-time â€œ2018-03-08T12:12:12â€</p>
    public let cdcStartTime: ClientRuntime.Date?
    /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be
    ///          either server time or commit time.</p>
    ///          <p>Server time example: --cdc-stop-position â€œserver_time:2018-02-09T12:12:12â€</p>
    ///          <p>Commit time example: --cdc-stop-position â€œcommit_time: 2018-02-09T12:12:12 â€œ</p>
    public let cdcStopPosition: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the replication task to be started.</p>
    public let replicationTaskArn: Swift.String?
    /// <p>A type of replication task.</p>
    public let startReplicationTaskType: DatabaseMigrationClientTypes.StartReplicationTaskTypeValue?

    public init (
        cdcStartPosition: Swift.String? = nil,
        cdcStartTime: ClientRuntime.Date? = nil,
        cdcStopPosition: Swift.String? = nil,
        replicationTaskArn: Swift.String? = nil,
        startReplicationTaskType: DatabaseMigrationClientTypes.StartReplicationTaskTypeValue? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.replicationTaskArn = replicationTaskArn
        self.startReplicationTaskType = startReplicationTaskType
    }
}

struct StartReplicationTaskInputBody: Swift.Equatable {
    public let replicationTaskArn: Swift.String?
    public let startReplicationTaskType: DatabaseMigrationClientTypes.StartReplicationTaskTypeValue?
    public let cdcStartTime: ClientRuntime.Date?
    public let cdcStartPosition: Swift.String?
    public let cdcStopPosition: Swift.String?
}

extension StartReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case replicationTaskArn = "ReplicationTaskArn"
        case startReplicationTaskType = "StartReplicationTaskType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let startReplicationTaskTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.StartReplicationTaskTypeValue.self, forKey: .startReplicationTaskType)
        startReplicationTaskType = startReplicationTaskTypeDecoded
        let cdcStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .cdcStartTime)
        cdcStartTime = cdcStartTimeDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
    }
}

extension StartReplicationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReplicationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartReplicationTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReplicationTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartReplicationTaskOutputResponse(replicationTask: \(Swift.String(describing: replicationTask)))"}
}

extension StartReplicationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

/// <p></p>
public struct StartReplicationTaskOutputResponse: Swift.Equatable {
    /// <p>The replication task started.</p>
    public let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init (
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct StartReplicationTaskOutputResponseBody: Swift.Equatable {
    public let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension StartReplicationTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum StartReplicationTaskTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case reloadTarget
        case resumeProcessing
        case startReplication
        case sdkUnknown(Swift.String)

        public static var allCases: [StartReplicationTaskTypeValue] {
            return [
                .reloadTarget,
                .resumeProcessing,
                .startReplication,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .reloadTarget: return "reload-target"
            case .resumeProcessing: return "resume-processing"
            case .startReplication: return "start-replication"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StartReplicationTaskTypeValue(rawValue: rawValue) ?? StartReplicationTaskTypeValue.sdkUnknown(rawValue)
        }
    }
}

public struct StopReplicationTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopReplicationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopReplicationTaskOutputError>
}

extension StopReplicationTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopReplicationTaskInput(replicationTaskArn: \(Swift.String(describing: replicationTaskArn)))"}
}

extension StopReplicationTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

public struct StopReplicationTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopReplicationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopReplicationTaskOutputError>
}

public struct StopReplicationTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopReplicationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopReplicationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopReplicationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopReplicationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopReplicationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopReplicationTaskOutputError>
}

/// <p></p>
public struct StopReplicationTaskInput: Swift.Equatable {
    /// <p>The Amazon Resource Name(ARN) of the replication task to be stopped.</p>
    public let replicationTaskArn: Swift.String?

    public init (
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct StopReplicationTaskInputBody: Swift.Equatable {
    public let replicationTaskArn: Swift.String?
}

extension StopReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

extension StopReplicationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopReplicationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopReplicationTaskOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopReplicationTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopReplicationTaskOutputResponse(replicationTask: \(Swift.String(describing: replicationTask)))"}
}

extension StopReplicationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

/// <p></p>
public struct StopReplicationTaskOutputResponse: Swift.Equatable {
    /// <p>The replication task stopped.</p>
    public let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init (
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct StopReplicationTaskOutputResponseBody: Swift.Equatable {
    public let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension StopReplicationTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension StorageQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StorageQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension StorageQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StorageQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The storage quota has been exceeded.</p>
public struct StorageQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p></p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StorageQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension StorageQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.Subnet: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
        case subnetStatus = "SubnetStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetAvailabilityZone = subnetAvailabilityZone {
            try encodeContainer.encode(subnetAvailabilityZone, forKey: .subnetAvailabilityZone)
        }
        if let subnetIdentifier = subnetIdentifier {
            try encodeContainer.encode(subnetIdentifier, forKey: .subnetIdentifier)
        }
        if let subnetStatus = subnetStatus {
            try encodeContainer.encode(subnetStatus, forKey: .subnetStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.AvailabilityZone.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetStatus)
        subnetStatus = subnetStatusDecoded
    }
}

extension DatabaseMigrationClientTypes.Subnet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Subnet(subnetAvailabilityZone: \(Swift.String(describing: subnetAvailabilityZone)), subnetIdentifier: \(Swift.String(describing: subnetIdentifier)), subnetStatus: \(Swift.String(describing: subnetStatus)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>In response to a request by the <code>DescribeReplicationSubnetGroups</code> operation,
    ///          this object identifies a subnet by its given Availability Zone, subnet identifier, and
    ///          status.</p>
    public struct Subnet: Swift.Equatable {
        /// <p>The Availability Zone of the subnet.</p>
        public let subnetAvailabilityZone: DatabaseMigrationClientTypes.AvailabilityZone?
        /// <p>The subnet identifier.</p>
        public let subnetIdentifier: Swift.String?
        /// <p>The status of the subnet.</p>
        public let subnetStatus: Swift.String?

        public init (
            subnetAvailabilityZone: DatabaseMigrationClientTypes.AvailabilityZone? = nil,
            subnetIdentifier: Swift.String? = nil,
            subnetStatus: Swift.String? = nil
        )
        {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetStatus = subnetStatus
        }
    }

}

extension SubnetAlreadyInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetAlreadyInUse(message: \(Swift.String(describing: message)))"}
}

extension SubnetAlreadyInUse: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetAlreadyInUseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified subnet is already in use.</p>
public struct SubnetAlreadyInUse: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p></p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetAlreadyInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetAlreadyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.SupportedEndpointType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointType = "EndpointType"
        case engineDisplayName = "EngineDisplayName"
        case engineName = "EngineName"
        case replicationInstanceEngineMinimumVersion = "ReplicationInstanceEngineMinimumVersion"
        case supportsCDC = "SupportsCDC"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineDisplayName = engineDisplayName {
            try encodeContainer.encode(engineDisplayName, forKey: .engineDisplayName)
        }
        if let engineName = engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let replicationInstanceEngineMinimumVersion = replicationInstanceEngineMinimumVersion {
            try encodeContainer.encode(replicationInstanceEngineMinimumVersion, forKey: .replicationInstanceEngineMinimumVersion)
        }
        if supportsCDC != false {
            try encodeContainer.encode(supportsCDC, forKey: .supportsCDC)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let supportsCDCDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsCDC)
        supportsCDC = supportsCDCDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let replicationInstanceEngineMinimumVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceEngineMinimumVersion)
        replicationInstanceEngineMinimumVersion = replicationInstanceEngineMinimumVersionDecoded
        let engineDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineDisplayName)
        engineDisplayName = engineDisplayNameDecoded
    }
}

extension DatabaseMigrationClientTypes.SupportedEndpointType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SupportedEndpointType(endpointType: \(Swift.String(describing: endpointType)), engineDisplayName: \(Swift.String(describing: engineDisplayName)), engineName: \(Swift.String(describing: engineName)), replicationInstanceEngineMinimumVersion: \(Swift.String(describing: replicationInstanceEngineMinimumVersion)), supportsCDC: \(Swift.String(describing: supportsCDC)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information about types of supported endpoints in response to a request by the
    ///             <code>DescribeEndpointTypes</code> operation. This information includes the type of
    ///          endpoint, the database engine name, and whether change data capture (CDC) is
    ///          supported.</p>
    public struct SupportedEndpointType: Swift.Equatable {
        /// <p>The type of endpoint.  Valid values are <code>source</code> and <code>target</code>.</p>
        public let endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
        /// <p>The expanded name for the engine name. For example, if the <code>EngineName</code>
        ///          parameter is "aurora," this value would be "Amazon Aurora MySQL."</p>
        public let engineDisplayName: Swift.String?
        /// <p>The database engine name. Valid values, depending on the EndpointType,  include
        ///          <code>"mysql"</code>, <code>"oracle"</code>, <code>"postgres"</code>,
        ///          <code>"mariadb"</code>, <code>"aurora"</code>, <code>"aurora-postgresql"</code>,
        ///          <code>"redshift"</code>, <code>"s3"</code>, <code>"db2"</code>, <code>"azuredb"</code>,
        ///          <code>"sybase"</code>, <code>"dynamodb"</code>, <code>"mongodb"</code>,
        ///          <code>"kinesis"</code>, <code>"kafka"</code>, <code>"elasticsearch"</code>,
        ///          <code>"documentdb"</code>, <code>"sqlserver"</code>, and <code>"neptune"</code>.</p>
        public let engineName: Swift.String?
        /// <p>The earliest AWS DMS engine version that supports this endpoint engine. Note that endpoint engines released with AWS DMS versions earlier than 3.1.1 do not return a value for this parameter.</p>
        public let replicationInstanceEngineMinimumVersion: Swift.String?
        /// <p>Indicates if Change Data Capture (CDC) is supported.</p>
        public let supportsCDC: Swift.Bool

        public init (
            endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
            engineDisplayName: Swift.String? = nil,
            engineName: Swift.String? = nil,
            replicationInstanceEngineMinimumVersion: Swift.String? = nil,
            supportsCDC: Swift.Bool = false
        )
        {
            self.endpointType = endpointType
            self.engineDisplayName = engineDisplayName
            self.engineName = engineName
            self.replicationInstanceEngineMinimumVersion = replicationInstanceEngineMinimumVersion
            self.supportsCDC = supportsCDC
        }
    }

}

extension DatabaseMigrationClientTypes.SybaseSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.SybaseSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SybaseSettings(databaseName: \(Swift.String(describing: databaseName)), password: \(Swift.String(describing: password)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), username: \(Swift.String(describing: username)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides information that defines a SAP ASE endpoint.</p>
    public struct SybaseSettings: Swift.Equatable {
        /// <p>Database name for the endpoint.</p>
        public let databaseName: Swift.String?
        /// <p>Endpoint connection password.</p>
        public let password: Swift.String?
        /// <p>Endpoint TCP port.</p>
        public let port: Swift.Int?
        /// <p>The full Amazon Resource Name (ARN) of the IAM role that specifies AWS DMS as the
        ///          trusted entity and grants the required permissions to access the value in
        ///             <code>SecretsManagerSecret</code>. <code>SecretsManagerSecret</code> has the value of the AWS Secrets
        ///          Manager secret that allows access to the SAP ASE endpoint.</p>
        ///          <note>
        ///             <p>You can specify one of two sets of values for these permissions. You can specify the
        ///             values for this setting and <code>SecretsManagerSecretId</code>. Or you can specify
        ///             clear-text values for <code>UserName</code>, <code>Password</code>,
        ///                <code>ServerName</code>, and <code>Port</code>. You can't specify both. For more
        ///             information on creating this <code>SecretsManagerSecret</code> and the
        ///                <code>SecretsManagerAccessRoleArn</code> and <code>SecretsManagerSecretId</code>
        ///             required to access it, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager">Using secrets to access AWS Database Migration Service
        ///                resources</a> in the <i>AWS Database Migration Service User
        ///                Guide</i>.</p>
        ///          </note>
        public let secretsManagerAccessRoleArn: Swift.String?
        /// <p>The full ARN, partial ARN, or friendly name of the <code>SecretsManagerSecret</code> that contains the SAP SAE endpoint connection details.</p>
        public let secretsManagerSecretId: Swift.String?
        /// <p>Fully qualified domain name of the endpoint.</p>
        public let serverName: Swift.String?
        /// <p>Endpoint connection user name.</p>
        public let username: Swift.String?

        public init (
            databaseName: Swift.String? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.TableStatistics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ddls = "Ddls"
        case deletes = "Deletes"
        case fullLoadCondtnlChkFailedRows = "FullLoadCondtnlChkFailedRows"
        case fullLoadEndTime = "FullLoadEndTime"
        case fullLoadErrorRows = "FullLoadErrorRows"
        case fullLoadReloaded = "FullLoadReloaded"
        case fullLoadRows = "FullLoadRows"
        case fullLoadStartTime = "FullLoadStartTime"
        case inserts = "Inserts"
        case lastUpdateTime = "LastUpdateTime"
        case schemaName = "SchemaName"
        case tableName = "TableName"
        case tableState = "TableState"
        case updates = "Updates"
        case validationFailedRecords = "ValidationFailedRecords"
        case validationPendingRecords = "ValidationPendingRecords"
        case validationState = "ValidationState"
        case validationStateDetails = "ValidationStateDetails"
        case validationSuspendedRecords = "ValidationSuspendedRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if ddls != 0 {
            try encodeContainer.encode(ddls, forKey: .ddls)
        }
        if deletes != 0 {
            try encodeContainer.encode(deletes, forKey: .deletes)
        }
        if fullLoadCondtnlChkFailedRows != 0 {
            try encodeContainer.encode(fullLoadCondtnlChkFailedRows, forKey: .fullLoadCondtnlChkFailedRows)
        }
        if let fullLoadEndTime = fullLoadEndTime {
            try encodeContainer.encode(fullLoadEndTime.timeIntervalSince1970, forKey: .fullLoadEndTime)
        }
        if fullLoadErrorRows != 0 {
            try encodeContainer.encode(fullLoadErrorRows, forKey: .fullLoadErrorRows)
        }
        if let fullLoadReloaded = fullLoadReloaded {
            try encodeContainer.encode(fullLoadReloaded, forKey: .fullLoadReloaded)
        }
        if fullLoadRows != 0 {
            try encodeContainer.encode(fullLoadRows, forKey: .fullLoadRows)
        }
        if let fullLoadStartTime = fullLoadStartTime {
            try encodeContainer.encode(fullLoadStartTime.timeIntervalSince1970, forKey: .fullLoadStartTime)
        }
        if inserts != 0 {
            try encodeContainer.encode(inserts, forKey: .inserts)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tableState = tableState {
            try encodeContainer.encode(tableState, forKey: .tableState)
        }
        if updates != 0 {
            try encodeContainer.encode(updates, forKey: .updates)
        }
        if validationFailedRecords != 0 {
            try encodeContainer.encode(validationFailedRecords, forKey: .validationFailedRecords)
        }
        if validationPendingRecords != 0 {
            try encodeContainer.encode(validationPendingRecords, forKey: .validationPendingRecords)
        }
        if let validationState = validationState {
            try encodeContainer.encode(validationState, forKey: .validationState)
        }
        if let validationStateDetails = validationStateDetails {
            try encodeContainer.encode(validationStateDetails, forKey: .validationStateDetails)
        }
        if validationSuspendedRecords != 0 {
            try encodeContainer.encode(validationSuspendedRecords, forKey: .validationSuspendedRecords)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let insertsDecoded = try containerValues.decode(Swift.Int.self, forKey: .inserts)
        inserts = insertsDecoded
        let deletesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deletes)
        deletes = deletesDecoded
        let updatesDecoded = try containerValues.decode(Swift.Int.self, forKey: .updates)
        updates = updatesDecoded
        let ddlsDecoded = try containerValues.decode(Swift.Int.self, forKey: .ddls)
        ddls = ddlsDecoded
        let fullLoadRowsDecoded = try containerValues.decode(Swift.Int.self, forKey: .fullLoadRows)
        fullLoadRows = fullLoadRowsDecoded
        let fullLoadCondtnlChkFailedRowsDecoded = try containerValues.decode(Swift.Int.self, forKey: .fullLoadCondtnlChkFailedRows)
        fullLoadCondtnlChkFailedRows = fullLoadCondtnlChkFailedRowsDecoded
        let fullLoadErrorRowsDecoded = try containerValues.decode(Swift.Int.self, forKey: .fullLoadErrorRows)
        fullLoadErrorRows = fullLoadErrorRowsDecoded
        let fullLoadStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .fullLoadStartTime)
        fullLoadStartTime = fullLoadStartTimeDecoded
        let fullLoadEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .fullLoadEndTime)
        fullLoadEndTime = fullLoadEndTimeDecoded
        let fullLoadReloadedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fullLoadReloaded)
        fullLoadReloaded = fullLoadReloadedDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tableStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableState)
        tableState = tableStateDecoded
        let validationPendingRecordsDecoded = try containerValues.decode(Swift.Int.self, forKey: .validationPendingRecords)
        validationPendingRecords = validationPendingRecordsDecoded
        let validationFailedRecordsDecoded = try containerValues.decode(Swift.Int.self, forKey: .validationFailedRecords)
        validationFailedRecords = validationFailedRecordsDecoded
        let validationSuspendedRecordsDecoded = try containerValues.decode(Swift.Int.self, forKey: .validationSuspendedRecords)
        validationSuspendedRecords = validationSuspendedRecordsDecoded
        let validationStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationState)
        validationState = validationStateDecoded
        let validationStateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationStateDetails)
        validationStateDetails = validationStateDetailsDecoded
    }
}

extension DatabaseMigrationClientTypes.TableStatistics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TableStatistics(ddls: \(Swift.String(describing: ddls)), deletes: \(Swift.String(describing: deletes)), fullLoadCondtnlChkFailedRows: \(Swift.String(describing: fullLoadCondtnlChkFailedRows)), fullLoadEndTime: \(Swift.String(describing: fullLoadEndTime)), fullLoadErrorRows: \(Swift.String(describing: fullLoadErrorRows)), fullLoadReloaded: \(Swift.String(describing: fullLoadReloaded)), fullLoadRows: \(Swift.String(describing: fullLoadRows)), fullLoadStartTime: \(Swift.String(describing: fullLoadStartTime)), inserts: \(Swift.String(describing: inserts)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), schemaName: \(Swift.String(describing: schemaName)), tableName: \(Swift.String(describing: tableName)), tableState: \(Swift.String(describing: tableState)), updates: \(Swift.String(describing: updates)), validationFailedRecords: \(Swift.String(describing: validationFailedRecords)), validationPendingRecords: \(Swift.String(describing: validationPendingRecords)), validationState: \(Swift.String(describing: validationState)), validationStateDetails: \(Swift.String(describing: validationStateDetails)), validationSuspendedRecords: \(Swift.String(describing: validationSuspendedRecords)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides a collection of table statistics in response to a request by the
    ///          <code>DescribeTableStatistics</code> operation.</p>
    public struct TableStatistics: Swift.Equatable {
        /// <p>The data definition language (DDL) used to build and modify the structure of your tables.</p>
        public let ddls: Swift.Int
        /// <p>The number of delete actions performed on a table.</p>
        public let deletes: Swift.Int
        /// <p>The number of rows that failed conditional checks during the full load operation (valid
        ///          only for migrations where DynamoDB is the target).</p>
        public let fullLoadCondtnlChkFailedRows: Swift.Int
        /// <p>The time when the full load operation completed.</p>
        public let fullLoadEndTime: ClientRuntime.Date?
        /// <p>The number of rows that failed to load during the full load operation (valid only for
        ///          migrations where DynamoDB is the target).</p>
        public let fullLoadErrorRows: Swift.Int
        /// <p>A value that indicates if the table was reloaded (<code>true</code>)
        ///          or loaded as part of a new full load operation (<code>false</code>).</p>
        public let fullLoadReloaded: Swift.Bool?
        /// <p>The number of rows added during the full load operation.</p>
        public let fullLoadRows: Swift.Int
        /// <p>The time when the full load operation started.</p>
        public let fullLoadStartTime: ClientRuntime.Date?
        /// <p>The number of insert actions performed on a table.</p>
        public let inserts: Swift.Int
        /// <p>The last time a table was updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The schema name.</p>
        public let schemaName: Swift.String?
        /// <p>The name of the table.</p>
        public let tableName: Swift.String?
        /// <p>The state of the tables described.</p>
        ///          <p>Valid states: Table does not exist | Before load | Full load | Table completed | Table
        ///          cancelled | Table error | Table all | Table updates | Table is being reloaded</p>
        public let tableState: Swift.String?
        /// <p>The number of update actions performed on a table.</p>
        public let updates: Swift.Int
        /// <p>The number of records that failed validation.</p>
        public let validationFailedRecords: Swift.Int
        /// <p>The number of records that have yet to be validated.</p>
        public let validationPendingRecords: Swift.Int
        /// <p>The validation state of the table.</p>
        ///          <p>This parameter can have the following values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>Not enabled â€“ Validation isn't enabled for the table in the migration
        ///                task.</p>
        ///             </li>
        ///             <li>
        ///                <p>Pending records â€“ Some records in the table are waiting for validation.</p>
        ///             </li>
        ///             <li>
        ///                <p>Mismatched records â€“ Some records in the table don't match between the source
        ///                and target.</p>
        ///             </li>
        ///             <li>
        ///                <p>Suspended records â€“ Some records in the table couldn't be validated.</p>
        ///             </li>
        ///             <li>
        ///                <p>No primary key  â€“The table couldn't be validated because it has no primary
        ///                key.</p>
        ///             </li>
        ///             <li>
        ///                <p>Table error â€“ The table wasn't validated because it's in an error state
        ///                and some data wasn't migrated.</p>
        ///             </li>
        ///             <li>
        ///                <p>Validated â€“ All rows in the table are validated. If the table is updated, the
        ///                status can change from Validated.</p>
        ///             </li>
        ///             <li>
        ///                <p>Error â€“ The table couldn't be validated because of an unexpected
        ///                error.</p>
        ///             </li>
        ///             <li>
        ///                <p>Pending validation â€“ The table is waiting validation.</p>
        ///             </li>
        ///             <li>
        ///                <p>Preparing table â€“ Preparing the table enabled in the migration task for validation.</p>
        ///             </li>
        ///             <li>
        ///                <p>Pending revalidation â€“ All rows in the table are pending validation after the table was updated.</p>
        ///             </li>
        ///          </ul>
        public let validationState: Swift.String?
        /// <p>Additional details about the state of validation.</p>
        public let validationStateDetails: Swift.String?
        /// <p>The number of records that couldn't be validated.</p>
        public let validationSuspendedRecords: Swift.Int

        public init (
            ddls: Swift.Int = 0,
            deletes: Swift.Int = 0,
            fullLoadCondtnlChkFailedRows: Swift.Int = 0,
            fullLoadEndTime: ClientRuntime.Date? = nil,
            fullLoadErrorRows: Swift.Int = 0,
            fullLoadReloaded: Swift.Bool? = nil,
            fullLoadRows: Swift.Int = 0,
            fullLoadStartTime: ClientRuntime.Date? = nil,
            inserts: Swift.Int = 0,
            lastUpdateTime: ClientRuntime.Date? = nil,
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            tableState: Swift.String? = nil,
            updates: Swift.Int = 0,
            validationFailedRecords: Swift.Int = 0,
            validationPendingRecords: Swift.Int = 0,
            validationState: Swift.String? = nil,
            validationStateDetails: Swift.String? = nil,
            validationSuspendedRecords: Swift.Int = 0
        )
        {
            self.ddls = ddls
            self.deletes = deletes
            self.fullLoadCondtnlChkFailedRows = fullLoadCondtnlChkFailedRows
            self.fullLoadEndTime = fullLoadEndTime
            self.fullLoadErrorRows = fullLoadErrorRows
            self.fullLoadReloaded = fullLoadReloaded
            self.fullLoadRows = fullLoadRows
            self.fullLoadStartTime = fullLoadStartTime
            self.inserts = inserts
            self.lastUpdateTime = lastUpdateTime
            self.schemaName = schemaName
            self.tableName = tableName
            self.tableState = tableState
            self.updates = updates
            self.validationFailedRecords = validationFailedRecords
            self.validationPendingRecords = validationPendingRecords
            self.validationState = validationState
            self.validationStateDetails = validationStateDetails
            self.validationSuspendedRecords = validationSuspendedRecords
        }
    }

}

extension DatabaseMigrationClientTypes.TableToReload: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaName = "SchemaName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension DatabaseMigrationClientTypes.TableToReload: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TableToReload(schemaName: \(Swift.String(describing: schemaName)), tableName: \(Swift.String(describing: tableName)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Provides the name of the schema and table to be reloaded.</p>
    public struct TableToReload: Swift.Equatable {
        /// <p>The schema name of the table to be reloaded.</p>
        public let schemaName: Swift.String?
        /// <p>The table name of the table to be reloaded.</p>
        public let tableName: Swift.String?

        public init (
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.schemaName = schemaName
            self.tableName = tableName
        }
    }

}

extension DatabaseMigrationClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DatabaseMigrationClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>A user-defined key-value pair that describes metadata added to an AWS DMS resource and
    ///          that is used by operations such as the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AddTagsToResource</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ListTagsForResource</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RemoveTagsFromResource</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public struct Tag: Swift.Equatable {
        /// <p>A key is the required name of the tag. The string value can be 1-128 Unicode characters
        ///          in length and can't be prefixed with "aws:" or "dms:". The string can only contain
        ///          only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java
        ///          regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").</p>
        public let key: Swift.String?
        /// <p>A value is the optional value of the tag. The string value can be 1-256 Unicode
        ///          characters in length and can't be prefixed with "aws:" or "dms:". The string can only
        ///          contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-'
        ///          (Java regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum TargetDbType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multipleDatabases
        case specificDatabase
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetDbType] {
            return [
                .multipleDatabases,
                .specificDatabase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multipleDatabases: return "multiple-databases"
            case .specificDatabase: return "specific-database"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetDbType(rawValue: rawValue) ?? TargetDbType.sdkUnknown(rawValue)
        }
    }
}

public struct TestConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestConnectionOutputError>
}

extension TestConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestConnectionInput(endpointArn: \(Swift.String(describing: endpointArn)), replicationInstanceArn: \(Swift.String(describing: replicationInstanceArn)))"}
}

extension TestConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let replicationInstanceArn = replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

public struct TestConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestConnectionOutputError>
}

public struct TestConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestConnectionOutputError>
}

/// <p></p>
public struct TestConnectionInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
    public let endpointArn: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
    public let replicationInstanceArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct TestConnectionInputBody: Swift.Equatable {
    public let replicationInstanceArn: Swift.String?
    public let endpointArn: Swift.String?
}

extension TestConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension TestConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestConnectionOutputResponse(connection: \(Swift.String(describing: connection)))"}
}

extension TestConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TestConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

/// <p></p>
public struct TestConnectionOutputResponse: Swift.Equatable {
    /// <p>The connection tested.</p>
    public let connection: DatabaseMigrationClientTypes.Connection?

    public init (
        connection: DatabaseMigrationClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct TestConnectionOutputResponseBody: Swift.Equatable {
    public let connection: DatabaseMigrationClientTypes.Connection?
}

extension TestConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension UpgradeDependencyFailureFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpgradeDependencyFailureFault(message: \(Swift.String(describing: message)))"}
}

extension UpgradeDependencyFailureFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpgradeDependencyFailureFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An upgrade dependency is preventing the database migration.</p>
public struct UpgradeDependencyFailureFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p></p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UpgradeDependencyFailureFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UpgradeDependencyFailureFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.VpcSecurityGroupMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case vpcSecurityGroupId = "VpcSecurityGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let vpcSecurityGroupId = vpcSecurityGroupId {
            try encodeContainer.encode(vpcSecurityGroupId, forKey: .vpcSecurityGroupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DatabaseMigrationClientTypes.VpcSecurityGroupMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VpcSecurityGroupMembership(status: \(Swift.String(describing: status)), vpcSecurityGroupId: \(Swift.String(describing: vpcSecurityGroupId)))"}
}

extension DatabaseMigrationClientTypes {
    /// <p>Describes the status of a security group associated with the virtual private cloud (VPC)
    ///          hosting your replication and DB instances.</p>
    public struct VpcSecurityGroupMembership: Swift.Equatable {
        /// <p>The status of the VPC security group.</p>
        public let status: Swift.String?
        /// <p>The VPC security group ID.</p>
        public let vpcSecurityGroupId: Swift.String?

        public init (
            status: Swift.String? = nil,
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}
