// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EndpointSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicability = "Applicability"
        case enumValues = "EnumValues"
        case intValueMax = "IntValueMax"
        case intValueMin = "IntValueMin"
        case name = "Name"
        case sensitive = "Sensitive"
        case type = "Type"
        case units = "Units"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicability = applicability {
            try encodeContainer.encode(applicability, forKey: .applicability)
        }
        if let enumValues = enumValues {
            var enumValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enumValues)
            for endpointsettingenumvalues0 in enumValues {
                try enumValuesContainer.encode(endpointsettingenumvalues0)
            }
        }
        if let intValueMax = intValueMax {
            try encodeContainer.encode(intValueMax, forKey: .intValueMax)
        }
        if let intValueMin = intValueMin {
            try encodeContainer.encode(intValueMin, forKey: .intValueMin)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sensitive = sensitive {
            try encodeContainer.encode(sensitive, forKey: .sensitive)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let units = units {
            try encodeContainer.encode(units, forKey: .units)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EndpointSettingTypeValue.self, forKey: .type)
        type = typeDecoded
        let enumValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .enumValues)
        var enumValuesDecoded0:[String]? = nil
        if let enumValuesContainer = enumValuesContainer {
            enumValuesDecoded0 = [String]()
            for string0 in enumValuesContainer {
                if let string0 = string0 {
                    enumValuesDecoded0?.append(string0)
                }
            }
        }
        enumValues = enumValuesDecoded0
        let sensitiveDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sensitive)
        sensitive = sensitiveDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .units)
        units = unitsDecoded
        let applicabilityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicability)
        applicability = applicabilityDecoded
        let intValueMinDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .intValueMin)
        intValueMin = intValueMinDecoded
        let intValueMaxDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .intValueMax)
        intValueMax = intValueMaxDecoded
    }
}
