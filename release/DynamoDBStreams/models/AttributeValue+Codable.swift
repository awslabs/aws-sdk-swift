// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AttributeValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case b = "B"
        case bOOL = "BOOL"
        case bS = "BS"
        case l = "L"
        case m = "M"
        case n = "N"
        case nS = "NS"
        case nULL = "NULL"
        case s = "S"
        case sS = "SS"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .b(b):
                if let b = b {
                    try container.encode(b.base64EncodedString(), forKey: .b)
                }
            case let .bOOL(bOOL):
                if let bOOL = bOOL {
                    try container.encode(bOOL, forKey: .bOOL)
                }
            case let .bS(bS):
                if let bS = bS {
                    var bSContainer = container.nestedUnkeyedContainer(forKey: .bS)
                    for binarysetattributevalue0 in bS {
                        try bSContainer.encode(binarysetattributevalue0.base64EncodedString())
                    }
                }
            case let .l(l):
                if let l = l {
                    var lContainer = container.nestedUnkeyedContainer(forKey: .l)
                    for listattributevalue0 in l {
                        try lContainer.encode(listattributevalue0)
                    }
                }
            case let .m(m):
                if let m = m {
                    var mContainer = container.nestedContainer(keyedBy: Key.self, forKey: .m)
                    for (dictKey0, mapattributevalue0) in m {
                        try mContainer.encode(mapattributevalue0, forKey: Key(stringValue: dictKey0))
                    }
                }
            case let .n(n):
                if let n = n {
                    try container.encode(n, forKey: .n)
                }
            case let .nS(nS):
                if let nS = nS {
                    var nSContainer = container.nestedUnkeyedContainer(forKey: .nS)
                    for numbersetattributevalue0 in nS {
                        try nSContainer.encode(numbersetattributevalue0)
                    }
                }
            case let .nULL(nULL):
                if let nULL = nULL {
                    try container.encode(nULL, forKey: .nULL)
                }
            case let .s(s):
                if let s = s {
                    try container.encode(s, forKey: .s)
                }
            case let .sS(sS):
                if let sS = sS {
                    var sSContainer = container.nestedUnkeyedContainer(forKey: .sS)
                    for stringsetattributevalue0 in sS {
                        try sSContainer.encode(stringsetattributevalue0)
                    }
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let sDecoded = try values.decodeIfPresent(String.self, forKey: .s)
        if let s = sDecoded {
            self = .s(s)
            return
        }
        let nDecoded = try values.decodeIfPresent(String.self, forKey: .n)
        if let n = nDecoded {
            self = .n(n)
            return
        }
        let bDecoded = try values.decodeIfPresent(Data.self, forKey: .b)
        if let b = bDecoded {
            self = .b(b)
            return
        }
        let sSContainer = try values.decodeIfPresent([String].self, forKey: .sS)
        var sSDecoded0:[String]? = nil
        if let sSContainer = sSContainer {
            sSDecoded0 = [String]()
            for string0 in sSContainer {
                sSDecoded0?.append(string0)
            }
        }
        if let sS = sSDecoded0 {
            self = .sS(sS)
            return
        }
        let nSContainer = try values.decodeIfPresent([String].self, forKey: .nS)
        var nSDecoded0:[String]? = nil
        if let nSContainer = nSContainer {
            nSDecoded0 = [String]()
            for string0 in nSContainer {
                nSDecoded0?.append(string0)
            }
        }
        if let nS = nSDecoded0 {
            self = .nS(nS)
            return
        }
        let bSContainer = try values.decodeIfPresent([Data].self, forKey: .bS)
        var bSDecoded0:[Data]? = nil
        if let bSContainer = bSContainer {
            bSDecoded0 = [Data]()
            for blob0 in bSContainer {
                bSDecoded0?.append(blob0)
            }
        }
        if let bS = bSDecoded0 {
            self = .bS(bS)
            return
        }
        let mContainer = try values.decodeIfPresent([String:AttributeValue].self, forKey: .m)
        var mDecoded0: [String:AttributeValue]? = nil
        if let mContainer = mContainer {
            mDecoded0 = [String:AttributeValue]()
            for (key0, attributevalue0) in mContainer {
                mDecoded0?[key0] = attributevalue0
            }
        }
        if let m = mDecoded0 {
            self = .m(m)
            return
        }
        let lContainer = try values.decodeIfPresent([AttributeValue].self, forKey: .l)
        var lDecoded0:[AttributeValue]? = nil
        if let lContainer = lContainer {
            lDecoded0 = [AttributeValue]()
            for union0 in lContainer {
                lDecoded0?.append(union0)
            }
        }
        if let l = lDecoded0 {
            self = .l(l)
            return
        }
        let nULLDecoded = try values.decodeIfPresent(Bool.self, forKey: .nULL)
        if let nULL = nULLDecoded {
            self = .nULL(nULL)
            return
        }
        let bOOLDecoded = try values.decodeIfPresent(Bool.self, forKey: .bOOL)
        if let bOOL = bOOLDecoded {
            self = .bOOL(bOOL)
            return
        }
        self = .sdkUnknown("")
    }
}
