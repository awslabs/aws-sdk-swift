// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AttributeValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case b = "B"
        case bool = "BOOL"
        case bs = "BS"
        case l = "L"
        case m = "M"
        case n = "N"
        case ns = "NS"
        case null = "NULL"
        case s = "S"
        case ss = "SS"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .b(b):
                try container.encode(b.base64EncodedString(), forKey: .b)
            case let .bool(bool):
                try container.encode(bool, forKey: .bool)
            case let .bs(bs):
                var bsContainer = container.nestedUnkeyedContainer(forKey: .bs)
                for binarysetattributevalue0 in bs {
                    try bsContainer.encode(binarysetattributevalue0.base64EncodedString())
                }
            case let .l(l):
                var lContainer = container.nestedUnkeyedContainer(forKey: .l)
                for listattributevalue0 in l {
                    try lContainer.encode(listattributevalue0)
                }
            case let .m(m):
                var mContainer = container.nestedContainer(keyedBy: Key.self, forKey: .m)
                for (dictKey0, mapattributevalue0) in m {
                    try mContainer.encode(mapattributevalue0, forKey: Key(stringValue: dictKey0))
                }
            case let .n(n):
                try container.encode(n, forKey: .n)
            case let .ns(ns):
                var nsContainer = container.nestedUnkeyedContainer(forKey: .ns)
                for numbersetattributevalue0 in ns {
                    try nsContainer.encode(numbersetattributevalue0)
                }
            case let .null(null):
                try container.encode(null, forKey: .null)
            case let .s(s):
                try container.encode(s, forKey: .s)
            case let .ss(ss):
                var ssContainer = container.nestedUnkeyedContainer(forKey: .ss)
                for stringsetattributevalue0 in ss {
                    try ssContainer.encode(stringsetattributevalue0)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let sDecoded = try values.decodeIfPresent(String.self, forKey: .s)
        if let s = sDecoded {
            self = .s(s)
            return
        }
        let nDecoded = try values.decodeIfPresent(String.self, forKey: .n)
        if let n = nDecoded {
            self = .n(n)
            return
        }
        let bDecoded = try values.decodeIfPresent(Data.self, forKey: .b)
        if let b = bDecoded {
            self = .b(b)
            return
        }
        let ssContainer = try values.decodeIfPresent([String?].self, forKey: .ss)
        var ssDecoded0:[String]? = nil
        if let ssContainer = ssContainer {
            ssDecoded0 = [String]()
            for string0 in ssContainer {
                if let string0 = string0 {
                    ssDecoded0?.append(string0)
                }
            }
        }
        if let ss = ssDecoded0 {
            self = .ss(ss)
            return
        }
        let nsContainer = try values.decodeIfPresent([String?].self, forKey: .ns)
        var nsDecoded0:[String]? = nil
        if let nsContainer = nsContainer {
            nsDecoded0 = [String]()
            for string0 in nsContainer {
                if let string0 = string0 {
                    nsDecoded0?.append(string0)
                }
            }
        }
        if let ns = nsDecoded0 {
            self = .ns(ns)
            return
        }
        let bsContainer = try values.decodeIfPresent([ClientRuntime.Data?].self, forKey: .bs)
        var bsDecoded0:[Data]? = nil
        if let bsContainer = bsContainer {
            bsDecoded0 = [Data]()
            for blob0 in bsContainer {
                if let blob0 = blob0 {
                    bsDecoded0?.append(blob0)
                }
            }
        }
        if let bs = bsDecoded0 {
            self = .bs(bs)
            return
        }
        let mContainer = try values.decodeIfPresent([String: AttributeValue?].self, forKey: .m)
        var mDecoded0: [String:AttributeValue]? = nil
        if let mContainer = mContainer {
            mDecoded0 = [String:AttributeValue]()
            for (key0, attributevalue0) in mContainer {
                if let attributevalue0 = attributevalue0 {
                    mDecoded0?[key0] = attributevalue0
                }
            }
        }
        if let m = mDecoded0 {
            self = .m(m)
            return
        }
        let lContainer = try values.decodeIfPresent([AttributeValue?].self, forKey: .l)
        var lDecoded0:[AttributeValue]? = nil
        if let lContainer = lContainer {
            lDecoded0 = [AttributeValue]()
            for union0 in lContainer {
                if let union0 = union0 {
                    lDecoded0?.append(union0)
                }
            }
        }
        if let l = lDecoded0 {
            self = .l(l)
            return
        }
        let nullDecoded = try values.decodeIfPresent(Bool.self, forKey: .null)
        if let null = nullDecoded {
            self = .null(null)
            return
        }
        let boolDecoded = try values.decodeIfPresent(Bool.self, forKey: .bool)
        if let bool = boolDecoded {
            self = .bool(bool)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Represents the data for an attribute.</p>
///          <p>Each attribute value is described as a name-value pair.  The name is the data type, and the value is the data itself.</p>
///          <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes">Data Types</a> in the
///                              <i>Amazon DynamoDB Developer Guide</i>.</p>
public enum AttributeValue: Equatable {
    /// <p>An attribute of type  String. For example:</p>
    ///          <p>
    ///             <code>"S": "Hello"</code>
    ///          </p>
    case s(String)
    /// <p>An attribute of type Number. For example:</p>
    ///          <p>
    ///             <code>"N": "123.45"</code>
    ///          </p>
    ///          <p>Numbers are sent across the network to DynamoDB as strings, to maximize compatibility across languages and libraries. However, DynamoDB treats them as number type attributes for mathematical operations.</p>
    case n(String)
    /// <p>An attribute of type Binary.  For example:</p>
    ///          <p>
    ///             <code>"B": "dGhpcyB0ZXh0IGlzIGJhc2U2NC1lbmNvZGVk"</code>
    ///          </p>
    case b(ClientRuntime.Data)
    /// <p>An attribute of type String Set.  For example:</p>
    ///          <p>
    ///             <code>"SS": ["Giraffe", "Hippo" ,"Zebra"]</code>
    ///          </p>
    case ss([String])
    /// <p>An attribute of type Number Set.  For example:</p>
    ///          <p>
    ///             <code>"NS": ["42.2", "-19", "7.5", "3.14"]</code>
    ///          </p>
    ///          <p>Numbers are sent across the network to DynamoDB as strings, to maximize compatibility across languages and libraries. However, DynamoDB treats them as number type attributes for mathematical operations.</p>
    case ns([String])
    /// <p>An attribute of type Binary Set.  For example:</p>
    ///          <p>
    ///             <code>"BS": ["U3Vubnk=", "UmFpbnk=", "U25vd3k="]</code>
    ///          </p>
    case bs([Data])
    /// <p>An attribute of type Map.  For example:</p>
    ///          <p>
    ///             <code>"M": {"Name": {"S": "Joe"}, "Age": {"N": "35"}}</code>
    ///          </p>
    case m([String:AttributeValue])
    /// <p>An attribute of type List.  For example:</p>
    ///          <p>
    ///             <code>"L": [ {"S": "Cookies"} , {"S": "Coffee"}, {"N", "3.14159"}]</code>
    ///          </p>
    case l([AttributeValue])
    /// <p>An attribute of type Null.  For example:</p>
    ///          <p>
    ///             <code>"NULL": true</code>
    ///          </p>
    case null(Bool)
    /// <p>An attribute of type Boolean.  For example:</p>
    ///          <p>
    ///             <code>"BOOL": true</code>
    ///          </p>
    case bool(Bool)
    case sdkUnknown(String)
}

public struct DescribeStreamInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamInput>
    public typealias MOutput = OperationOutput<DescribeStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamOutputError>
}

extension DescribeStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStreamInput(exclusiveStartShardId: \(String(describing: exclusiveStartShardId)), limit: \(String(describing: limit)), streamArn: \(String(describing: streamArn)))"}
}

extension DescribeStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exclusiveStartShardId = "ExclusiveStartShardId"
        case limit = "Limit"
        case streamArn = "StreamArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveStartShardId = exclusiveStartShardId {
            try encodeContainer.encode(exclusiveStartShardId, forKey: .exclusiveStartShardId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let streamArn = streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
    }
}

public struct DescribeStreamInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamInput>
    public typealias MOutput = OperationOutput<DescribeStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamOutputError>
}

public struct DescribeStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamInput>
    public typealias MOutput = OperationOutput<DescribeStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamOutputError>
}

/// <p>Represents the input of a <code>DescribeStream</code> operation.</p>
public struct DescribeStreamInput: Equatable {
    /// <p>The shard ID of the first item that this operation will evaluate. Use the value that was
    ///       returned for <code>LastEvaluatedShardId</code> in the previous operation. </p>
    public let exclusiveStartShardId: String?
    /// <p>The maximum number of shard objects to return. The upper limit is 100.</p>
    public let limit: Int?
    /// <p>The Amazon Resource Name (ARN) for the stream.</p>
    public let streamArn: String?

    public init (
        exclusiveStartShardId: String? = nil,
        limit: Int? = nil,
        streamArn: String? = nil
    )
    {
        self.exclusiveStartShardId = exclusiveStartShardId
        self.limit = limit
        self.streamArn = streamArn
    }
}

struct DescribeStreamInputBody: Equatable {
    public let streamArn: String?
    public let limit: Int?
    public let exclusiveStartShardId: String?
}

extension DescribeStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exclusiveStartShardId = "ExclusiveStartShardId"
        case limit = "Limit"
        case streamArn = "StreamArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let exclusiveStartShardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exclusiveStartShardId)
        exclusiveStartShardId = exclusiveStartShardIdDecoded
    }
}

extension DescribeStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStreamOutputError: Swift.Error, Equatable {
    case internalServerError(InternalServerError)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStreamOutputResponse(streamDescription: \(String(describing: streamDescription)))"}
}

extension DescribeStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamDescription = output.streamDescription
        } else {
            self.streamDescription = nil
        }
    }
}

/// <p>Represents the output of a <code>DescribeStream</code> operation.</p>
public struct DescribeStreamOutputResponse: Equatable {
    /// <p>A complete description of the stream, including its creation date and time, the DynamoDB table associated with the stream, the shard IDs within the stream, and the beginning and ending sequence numbers of stream records within the shards.</p>
    public let streamDescription: StreamDescription?

    public init (
        streamDescription: StreamDescription? = nil
    )
    {
        self.streamDescription = streamDescription
    }
}

struct DescribeStreamOutputResponseBody: Equatable {
    public let streamDescription: StreamDescription?
}

extension DescribeStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamDescription = "StreamDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDescriptionDecoded = try containerValues.decodeIfPresent(StreamDescription.self, forKey: .streamDescription)
        streamDescription = streamDescriptionDecoded
    }
}

extension ExpiredIteratorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExpiredIteratorException(message: \(String(describing: message)))"}
}

extension ExpiredIteratorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExpiredIteratorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The shard iterator has expired and can no longer be used to retrieve stream records. A shard
///       iterator expires 15 minutes after it is retrieved using the <code>GetShardIterator</code>
///       action.</p>
public struct ExpiredIteratorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The provided iterator exceeds the maximum age allowed.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredIteratorExceptionBody: Equatable {
    public let message: String?
}

extension ExpiredIteratorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetRecordsInputBodyMiddleware: Middleware {
    public let id: String = "GetRecordsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecordsInput>
    public typealias MOutput = OperationOutput<GetRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecordsOutputError>
}

extension GetRecordsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecordsInput(limit: \(String(describing: limit)), shardIterator: \(String(describing: shardIterator)))"}
}

extension GetRecordsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case shardIterator = "ShardIterator"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let shardIterator = shardIterator {
            try encodeContainer.encode(shardIterator, forKey: .shardIterator)
        }
    }
}

public struct GetRecordsInputHeadersMiddleware: Middleware {
    public let id: String = "GetRecordsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecordsInput>
    public typealias MOutput = OperationOutput<GetRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecordsOutputError>
}

public struct GetRecordsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRecordsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecordsInput>
    public typealias MOutput = OperationOutput<GetRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecordsOutputError>
}

/// <p>Represents the input of a <code>GetRecords</code> operation.</p>
public struct GetRecordsInput: Equatable {
    /// <p>The maximum number of records to return from the shard. The upper limit is 1000.</p>
    public let limit: Int?
    /// <p>A shard iterator that was retrieved from a previous GetShardIterator operation. This iterator can be used to access the stream records in this shard.</p>
    public let shardIterator: String?

    public init (
        limit: Int? = nil,
        shardIterator: String? = nil
    )
    {
        self.limit = limit
        self.shardIterator = shardIterator
    }
}

struct GetRecordsInputBody: Equatable {
    public let shardIterator: String?
    public let limit: Int?
}

extension GetRecordsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case shardIterator = "ShardIterator"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIteratorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shardIterator)
        shardIterator = shardIteratorDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension GetRecordsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecordsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExpiredIteratorException" : self = .expiredIteratorException(try ExpiredIteratorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrimmedDataAccessException" : self = .trimmedDataAccessException(try TrimmedDataAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecordsOutputError: Swift.Error, Equatable {
    case expiredIteratorException(ExpiredIteratorException)
    case internalServerError(InternalServerError)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case trimmedDataAccessException(TrimmedDataAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecordsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecordsOutputResponse(nextShardIterator: \(String(describing: nextShardIterator)), records: \(String(describing: records)))"}
}

extension GetRecordsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRecordsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextShardIterator = output.nextShardIterator
            self.records = output.records
        } else {
            self.nextShardIterator = nil
            self.records = nil
        }
    }
}

/// <p>Represents the output of a <code>GetRecords</code> operation.</p>
public struct GetRecordsOutputResponse: Equatable {
    /// <p>The next position in the shard from which to start sequentially reading stream records. If
    ///       set to <code>null</code>, the shard has been closed and the requested iterator will not return
    ///       any more data.</p>
    public let nextShardIterator: String?
    /// <p>The stream records from the shard, which were retrieved using the shard iterator.</p>
    public let records: [Record]?

    public init (
        nextShardIterator: String? = nil,
        records: [Record]? = nil
    )
    {
        self.nextShardIterator = nextShardIterator
        self.records = records
    }
}

struct GetRecordsOutputResponseBody: Equatable {
    public let records: [Record]?
    public let nextShardIterator: String?
}

extension GetRecordsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextShardIterator = "NextShardIterator"
        case records = "Records"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([Record?].self, forKey: .records)
        var recordsDecoded0:[Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let nextShardIteratorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextShardIterator)
        nextShardIterator = nextShardIteratorDecoded
    }
}

public struct GetShardIteratorInputBodyMiddleware: Middleware {
    public let id: String = "GetShardIteratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetShardIteratorInput>,
                  next: H) -> Swift.Result<OperationOutput<GetShardIteratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetShardIteratorInput>
    public typealias MOutput = OperationOutput<GetShardIteratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetShardIteratorOutputError>
}

extension GetShardIteratorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetShardIteratorInput(sequenceNumber: \(String(describing: sequenceNumber)), shardId: \(String(describing: shardId)), shardIteratorType: \(String(describing: shardIteratorType)), streamArn: \(String(describing: streamArn)))"}
}

extension GetShardIteratorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sequenceNumber = "SequenceNumber"
        case shardId = "ShardId"
        case shardIteratorType = "ShardIteratorType"
        case streamArn = "StreamArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sequenceNumber = sequenceNumber {
            try encodeContainer.encode(sequenceNumber, forKey: .sequenceNumber)
        }
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
        if let shardIteratorType = shardIteratorType {
            try encodeContainer.encode(shardIteratorType.rawValue, forKey: .shardIteratorType)
        }
        if let streamArn = streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
    }
}

public struct GetShardIteratorInputHeadersMiddleware: Middleware {
    public let id: String = "GetShardIteratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetShardIteratorInput>,
                  next: H) -> Swift.Result<OperationOutput<GetShardIteratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetShardIteratorInput>
    public typealias MOutput = OperationOutput<GetShardIteratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetShardIteratorOutputError>
}

public struct GetShardIteratorInputQueryItemMiddleware: Middleware {
    public let id: String = "GetShardIteratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetShardIteratorInput>,
                  next: H) -> Swift.Result<OperationOutput<GetShardIteratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetShardIteratorInput>
    public typealias MOutput = OperationOutput<GetShardIteratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetShardIteratorOutputError>
}

/// <p>Represents the input of a <code>GetShardIterator</code> operation.</p>
public struct GetShardIteratorInput: Equatable {
    /// <p>The sequence number of a stream record in the shard from which to start reading.</p>
    public let sequenceNumber: String?
    /// <p>The identifier of the shard. The iterator will be returned for this shard ID.</p>
    public let shardId: String?
    /// <p>Determines how the shard iterator is used to start reading stream records from the shard:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AT_SEQUENCE_NUMBER</code> - Start reading exactly from the position denoted by a
    ///           specific sequence number.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AFTER_SEQUENCE_NUMBER</code> - Start reading right after the position denoted by a
    ///           specific sequence number.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TRIM_HORIZON</code> - Start reading at the last (untrimmed) stream record, which is
    ///           the oldest record in the shard. In DynamoDB Streams, there is a 24 hour limit on data retention.
    ///           Stream records whose age exceeds this limit are subject to removal (trimming) from the
    ///           stream.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LATEST</code> - Start reading just after the most recent stream record in the
    ///           shard, so that you always read the most recent data in the shard.</p>
    ///             </li>
    ///          </ul>
    public let shardIteratorType: ShardIteratorType?
    /// <p>The Amazon Resource Name (ARN) for the stream.</p>
    public let streamArn: String?

    public init (
        sequenceNumber: String? = nil,
        shardId: String? = nil,
        shardIteratorType: ShardIteratorType? = nil,
        streamArn: String? = nil
    )
    {
        self.sequenceNumber = sequenceNumber
        self.shardId = shardId
        self.shardIteratorType = shardIteratorType
        self.streamArn = streamArn
    }
}

struct GetShardIteratorInputBody: Equatable {
    public let streamArn: String?
    public let shardId: String?
    public let shardIteratorType: ShardIteratorType?
    public let sequenceNumber: String?
}

extension GetShardIteratorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sequenceNumber = "SequenceNumber"
        case shardId = "ShardId"
        case shardIteratorType = "ShardIteratorType"
        case streamArn = "StreamArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let shardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let shardIteratorTypeDecoded = try containerValues.decodeIfPresent(ShardIteratorType.self, forKey: .shardIteratorType)
        shardIteratorType = shardIteratorTypeDecoded
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
    }
}

extension GetShardIteratorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetShardIteratorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrimmedDataAccessException" : self = .trimmedDataAccessException(try TrimmedDataAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetShardIteratorOutputError: Swift.Error, Equatable {
    case internalServerError(InternalServerError)
    case resourceNotFoundException(ResourceNotFoundException)
    case trimmedDataAccessException(TrimmedDataAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetShardIteratorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetShardIteratorOutputResponse(shardIterator: \(String(describing: shardIterator)))"}
}

extension GetShardIteratorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetShardIteratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.shardIterator = output.shardIterator
        } else {
            self.shardIterator = nil
        }
    }
}

/// <p>Represents the output of a <code>GetShardIterator</code> operation.</p>
public struct GetShardIteratorOutputResponse: Equatable {
    /// <p>The position in the shard from which to start reading stream records sequentially. A shard iterator specifies this position using the sequence number of a stream record in a shard.</p>
    public let shardIterator: String?

    public init (
        shardIterator: String? = nil
    )
    {
        self.shardIterator = shardIterator
    }
}

struct GetShardIteratorOutputResponseBody: Equatable {
    public let shardIterator: String?
}

extension GetShardIteratorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case shardIterator = "ShardIterator"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIteratorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shardIterator)
        shardIterator = shardIteratorDecoded
    }
}

extension Identity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case principalId = "PrincipalId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension Identity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Identity(principalId: \(String(describing: principalId)), type: \(String(describing: type)))"}
}

/// <p>Contains details about the type of identity that made the request.</p>
public struct Identity: Equatable {
    /// <p>A unique identifier for the entity that made the call. For Time To Live, the
    ///       principalId is "dynamodb.amazonaws.com".</p>
    public let principalId: String?
    /// <p>The type of the identity. For Time To Live, the type is "Service".</p>
    public let type: String?

    public init (
        principalId: String? = nil,
        type: String? = nil
    )
    {
        self.principalId = principalId
        self.type = type
    }
}

extension InternalServerError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerError(message: \(String(describing: message)))"}
}

extension InternalServerError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error occurred on the server side.</p>
public struct InternalServerError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The server encountered an internal error trying to fulfill the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Equatable {
    public let message: String?
}

extension InternalServerErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KeySchemaElement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case keyType = "KeyType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let keyType = keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(KeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
    }
}

extension KeySchemaElement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeySchemaElement(attributeName: \(String(describing: attributeName)), keyType: \(String(describing: keyType)))"}
}

/// <p>Represents <i>a single element</i> of a key schema. A key schema specifies
///             the attributes that make up the primary key of a table, or the key attributes of an
///             index.</p>
///          <p>A <code>KeySchemaElement</code> represents exactly one attribute of the primary key. For
///             example, a simple primary key would be represented by one <code>KeySchemaElement</code>
///             (for the partition key). A composite primary key would require one
///                 <code>KeySchemaElement</code> for the partition key, and another
///                 <code>KeySchemaElement</code> for the sort key.</p>
///          <p>A <code>KeySchemaElement</code> must be a scalar, top-level attribute (not a nested
///             attribute). The data type must be one of String, Number, or Binary. The attribute cannot
///             be nested within a List or a Map.</p>
public struct KeySchemaElement: Equatable {
    /// <p>The name of a key attribute.</p>
    public let attributeName: String?
    /// <p>The role that this key attribute will assume:</p>
    ///          <ul>
    ///             <li>
    ///               <p>
    ///                   <code>HASH</code> - partition key</p>
    ///             </li>
    ///             <li>
    ///               <p>
    ///                   <code>RANGE</code> - sort key</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>The partition key of an item is also known as its <i>hash
    ///                     attribute</i>. The term "hash attribute" derives from DynamoDB's usage of
    ///                 an internal hash function to evenly distribute data items across partitions, based
    ///                 on their partition key values.</p>
    ///             <p>The sort key of an item is also known as its <i>range
    ///                 attribute</i>. The term "range attribute" derives from the way DynamoDB
    ///                 stores items with the same partition key physically close together, in sorted order
    ///                 by the sort key value.</p>
    ///          </note>
    public let keyType: KeyType?

    public init (
        attributeName: String? = nil,
        keyType: KeyType? = nil
    )
    {
        self.attributeName = attributeName
        self.keyType = keyType
    }
}

public enum KeyType {
    case hash
    case range
    case sdkUnknown(String)
}

extension KeyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [KeyType] {
        return [
            .hash,
            .range,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hash: return "HASH"
        case .range: return "RANGE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = KeyType(rawValue: rawValue) ?? KeyType.sdkUnknown(rawValue)
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is no limit to the number of daily on-demand backups that can be
///             taken.</p>
///          <p>Up to 50 simultaneous table operations are allowed per account. These operations
///             include <code>CreateTable</code>, <code>UpdateTable</code>,
///                 <code>DeleteTable</code>,<code>UpdateTimeToLive</code>,
///                 <code>RestoreTableFromBackup</code>, and
///             <code>RestoreTableToPointInTime</code>.</p>
///          <p>The only exception is when you are creating a table with one or more secondary
///             indexes. You can have up to 25 such requests running at a time; however, if the table or
///             index specifications are complex, DynamoDB might temporarily reduce the number of
///             concurrent operations.</p>
///          <p>There is a soft account quota of 256 tables.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Too many operations for a given subscriber.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListStreamsInputBodyMiddleware: Middleware {
    public let id: String = "ListStreamsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamsInput>
    public typealias MOutput = OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamsOutputError>
}

extension ListStreamsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamsInput(exclusiveStartStreamArn: \(String(describing: exclusiveStartStreamArn)), limit: \(String(describing: limit)), tableName: \(String(describing: tableName)))"}
}

extension ListStreamsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exclusiveStartStreamArn = "ExclusiveStartStreamArn"
        case limit = "Limit"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveStartStreamArn = exclusiveStartStreamArn {
            try encodeContainer.encode(exclusiveStartStreamArn, forKey: .exclusiveStartStreamArn)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct ListStreamsInputHeadersMiddleware: Middleware {
    public let id: String = "ListStreamsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamsInput>
    public typealias MOutput = OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamsOutputError>
}

public struct ListStreamsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStreamsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamsInput>
    public typealias MOutput = OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamsOutputError>
}

/// <p>Represents the input of a <code>ListStreams</code> operation.</p>
public struct ListStreamsInput: Equatable {
    /// <p>The ARN (Amazon Resource Name) of the first item that this operation will evaluate. Use the
    ///       value that was returned for <code>LastEvaluatedStreamArn</code> in the previous operation.
    ///     </p>
    public let exclusiveStartStreamArn: String?
    /// <p>The maximum number of streams to return. The upper limit is 100.</p>
    public let limit: Int?
    /// <p>If this parameter is provided, then only the streams associated with this table name are returned.</p>
    public let tableName: String?

    public init (
        exclusiveStartStreamArn: String? = nil,
        limit: Int? = nil,
        tableName: String? = nil
    )
    {
        self.exclusiveStartStreamArn = exclusiveStartStreamArn
        self.limit = limit
        self.tableName = tableName
    }
}

struct ListStreamsInputBody: Equatable {
    public let tableName: String?
    public let limit: Int?
    public let exclusiveStartStreamArn: String?
}

extension ListStreamsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exclusiveStartStreamArn = "ExclusiveStartStreamArn"
        case limit = "Limit"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let exclusiveStartStreamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exclusiveStartStreamArn)
        exclusiveStartStreamArn = exclusiveStartStreamArnDecoded
    }
}

extension ListStreamsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamsOutputError: Swift.Error, Equatable {
    case internalServerError(InternalServerError)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamsOutputResponse(lastEvaluatedStreamArn: \(String(describing: lastEvaluatedStreamArn)), streams: \(String(describing: streams)))"}
}

extension ListStreamsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStreamsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastEvaluatedStreamArn = output.lastEvaluatedStreamArn
            self.streams = output.streams
        } else {
            self.lastEvaluatedStreamArn = nil
            self.streams = nil
        }
    }
}

/// <p>Represents the output of a <code>ListStreams</code> operation.</p>
public struct ListStreamsOutputResponse: Equatable {
    /// <p>The stream ARN of the item where the operation stopped, inclusive of the previous result set. Use this value to start a new operation, excluding this value in the new request.</p>
    ///          <p>If <code>LastEvaluatedStreamArn</code> is empty, then the "last page" of results has been
    ///       processed and there is no more data to be retrieved.</p>
    ///          <p>If <code>LastEvaluatedStreamArn</code> is not empty, it does not necessarily mean that there
    ///       is more data in the result set. The only way to know when you have reached the end of the
    ///       result set is when <code>LastEvaluatedStreamArn</code> is empty.</p>
    public let lastEvaluatedStreamArn: String?
    /// <p>A list of stream descriptors associated with the current account and endpoint.</p>
    public let streams: [Stream]?

    public init (
        lastEvaluatedStreamArn: String? = nil,
        streams: [Stream]? = nil
    )
    {
        self.lastEvaluatedStreamArn = lastEvaluatedStreamArn
        self.streams = streams
    }
}

struct ListStreamsOutputResponseBody: Equatable {
    public let streams: [Stream]?
    public let lastEvaluatedStreamArn: String?
}

extension ListStreamsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lastEvaluatedStreamArn = "LastEvaluatedStreamArn"
        case streams = "Streams"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamsContainer = try containerValues.decodeIfPresent([Stream?].self, forKey: .streams)
        var streamsDecoded0:[Stream]? = nil
        if let streamsContainer = streamsContainer {
            streamsDecoded0 = [Stream]()
            for structure0 in streamsContainer {
                if let structure0 = structure0 {
                    streamsDecoded0?.append(structure0)
                }
            }
        }
        streams = streamsDecoded0
        let lastEvaluatedStreamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastEvaluatedStreamArn)
        lastEvaluatedStreamArn = lastEvaluatedStreamArnDecoded
    }
}

public enum OperationType {
    case insert
    case modify
    case remove
    case sdkUnknown(String)
}

extension OperationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperationType] {
        return [
            .insert,
            .modify,
            .remove,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .insert: return "INSERT"
        case .modify: return "MODIFY"
        case .remove: return "REMOVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperationType(rawValue: rawValue) ?? OperationType.sdkUnknown(rawValue)
    }
}

extension Record: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsRegion
        case dynamodb
        case eventID
        case eventName
        case eventSource
        case eventVersion
        case userIdentity
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let dynamodb = dynamodb {
            try encodeContainer.encode(dynamodb, forKey: .dynamodb)
        }
        if let eventID = eventID {
            try encodeContainer.encode(eventID, forKey: .eventID)
        }
        if let eventName = eventName {
            try encodeContainer.encode(eventName.rawValue, forKey: .eventName)
        }
        if let eventSource = eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let eventVersion = eventVersion {
            try encodeContainer.encode(eventVersion, forKey: .eventVersion)
        }
        if let userIdentity = userIdentity {
            try encodeContainer.encode(userIdentity, forKey: .userIdentity)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventID)
        eventID = eventIDDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(OperationType.self, forKey: .eventName)
        eventName = eventNameDecoded
        let eventVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventVersion)
        eventVersion = eventVersionDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let dynamodbDecoded = try containerValues.decodeIfPresent(StreamRecord.self, forKey: .dynamodb)
        dynamodb = dynamodbDecoded
        let userIdentityDecoded = try containerValues.decodeIfPresent(Identity.self, forKey: .userIdentity)
        userIdentity = userIdentityDecoded
    }
}

extension Record: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Record(awsRegion: \(String(describing: awsRegion)), dynamodb: \(String(describing: dynamodb)), eventID: \(String(describing: eventID)), eventName: \(String(describing: eventName)), eventSource: \(String(describing: eventSource)), eventVersion: \(String(describing: eventVersion)), userIdentity: \(String(describing: userIdentity)))"}
}

/// <p>A description of a unique event within a stream.</p>
public struct Record: Equatable {
    /// <p>The region in which the <code>GetRecords</code> request was received.</p>
    public let awsRegion: String?
    /// <p>The main body of the stream record, containing all of the DynamoDB-specific fields.</p>
    public let dynamodb: StreamRecord?
    /// <p>A globally unique identifier for the event that was recorded in this stream record.</p>
    public let eventID: String?
    /// <p>The type of data modification that was performed on the DynamoDB table:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>INSERT</code> - a new item was added to the table.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MODIFY</code> - one or more of an existing item's attributes were modified.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>REMOVE</code> - the item was deleted from the table</p>
    ///             </li>
    ///          </ul>
    public let eventName: OperationType?
    /// <p>The AWS service from which the stream record originated.  For DynamoDB Streams, this is <code>aws:dynamodb</code>.</p>
    public let eventSource: String?
    /// <p>The version number of the stream record format.  This number is updated whenever the structure of <code>Record</code> is modified.</p>
    ///          <p>Client applications must not assume that <code>eventVersion</code> will remain at a particular
    ///       value, as this number is subject to change at any time. In general, <code>eventVersion</code> will
    ///       only increase as the low-level DynamoDB Streams API evolves.</p>
    public let eventVersion: String?
    /// <p>Items that are deleted by the Time to Live process after expiration have the following fields: </p>
    ///          <ul>
    ///             <li>
    ///                <p>Records[].userIdentity.type</p>
    ///                <p>"Service"</p>
    ///             </li>
    ///             <li>
    ///                <p>Records[].userIdentity.principalId</p>
    ///                <p>"dynamodb.amazonaws.com"</p>
    ///             </li>
    ///          </ul>
    public let userIdentity: Identity?

    public init (
        awsRegion: String? = nil,
        dynamodb: StreamRecord? = nil,
        eventID: String? = nil,
        eventName: OperationType? = nil,
        eventSource: String? = nil,
        eventVersion: String? = nil,
        userIdentity: Identity? = nil
    )
    {
        self.awsRegion = awsRegion
        self.dynamodb = dynamodb
        self.eventID = eventID
        self.eventName = eventName
        self.eventSource = eventSource
        self.eventVersion = eventVersion
        self.userIdentity = userIdentity
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation tried to access a nonexistent table or index. The resource
///             might not be specified correctly, or its status might not be
///             <code>ACTIVE</code>.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The resource which is being requested does not exist.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SequenceNumberRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endingSequenceNumber = "EndingSequenceNumber"
        case startingSequenceNumber = "StartingSequenceNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endingSequenceNumber = endingSequenceNumber {
            try encodeContainer.encode(endingSequenceNumber, forKey: .endingSequenceNumber)
        }
        if let startingSequenceNumber = startingSequenceNumber {
            try encodeContainer.encode(startingSequenceNumber, forKey: .startingSequenceNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startingSequenceNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startingSequenceNumber)
        startingSequenceNumber = startingSequenceNumberDecoded
        let endingSequenceNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endingSequenceNumber)
        endingSequenceNumber = endingSequenceNumberDecoded
    }
}

extension SequenceNumberRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SequenceNumberRange(endingSequenceNumber: \(String(describing: endingSequenceNumber)), startingSequenceNumber: \(String(describing: startingSequenceNumber)))"}
}

/// <p>The beginning and ending sequence numbers for the stream records contained within a shard.</p>
public struct SequenceNumberRange: Equatable {
    /// <p>The last sequence number for the stream records contained within a shard. String contains numeric characters only.</p>
    public let endingSequenceNumber: String?
    /// <p>The first sequence number for the stream records contained within a shard. String contains numeric characters only.</p>
    public let startingSequenceNumber: String?

    public init (
        endingSequenceNumber: String? = nil,
        startingSequenceNumber: String? = nil
    )
    {
        self.endingSequenceNumber = endingSequenceNumber
        self.startingSequenceNumber = startingSequenceNumber
    }
}

extension Shard: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parentShardId = "ParentShardId"
        case sequenceNumberRange = "SequenceNumberRange"
        case shardId = "ShardId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parentShardId = parentShardId {
            try encodeContainer.encode(parentShardId, forKey: .parentShardId)
        }
        if let sequenceNumberRange = sequenceNumberRange {
            try encodeContainer.encode(sequenceNumberRange, forKey: .sequenceNumberRange)
        }
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let sequenceNumberRangeDecoded = try containerValues.decodeIfPresent(SequenceNumberRange.self, forKey: .sequenceNumberRange)
        sequenceNumberRange = sequenceNumberRangeDecoded
        let parentShardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentShardId)
        parentShardId = parentShardIdDecoded
    }
}

extension Shard: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Shard(parentShardId: \(String(describing: parentShardId)), sequenceNumberRange: \(String(describing: sequenceNumberRange)), shardId: \(String(describing: shardId)))"}
}

/// <p>A uniquely identified group of stream records within a stream.</p>
public struct Shard: Equatable {
    /// <p>The shard ID of the current shard's parent.</p>
    public let parentShardId: String?
    /// <p>The range of possible sequence numbers for the shard.</p>
    public let sequenceNumberRange: SequenceNumberRange?
    /// <p>The system-generated identifier for this shard.</p>
    public let shardId: String?

    public init (
        parentShardId: String? = nil,
        sequenceNumberRange: SequenceNumberRange? = nil,
        shardId: String? = nil
    )
    {
        self.parentShardId = parentShardId
        self.sequenceNumberRange = sequenceNumberRange
        self.shardId = shardId
    }
}

public enum ShardIteratorType {
    case afterSequenceNumber
    case atSequenceNumber
    case latest
    case trimHorizon
    case sdkUnknown(String)
}

extension ShardIteratorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ShardIteratorType] {
        return [
            .afterSequenceNumber,
            .atSequenceNumber,
            .latest,
            .trimHorizon,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .afterSequenceNumber: return "AFTER_SEQUENCE_NUMBER"
        case .atSequenceNumber: return "AT_SEQUENCE_NUMBER"
        case .latest: return "LATEST"
        case .trimHorizon: return "TRIM_HORIZON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ShardIteratorType(rawValue: rawValue) ?? ShardIteratorType.sdkUnknown(rawValue)
    }
}

extension Stream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case streamArn = "StreamArn"
        case streamLabel = "StreamLabel"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamArn = streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
        if let streamLabel = streamLabel {
            try encodeContainer.encode(streamLabel, forKey: .streamLabel)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let streamLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamLabel)
        streamLabel = streamLabelDecoded
    }
}

extension Stream: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Stream(streamArn: \(String(describing: streamArn)), streamLabel: \(String(describing: streamLabel)), tableName: \(String(describing: tableName)))"}
}

/// <p>Represents all of the data describing a particular stream.</p>
public struct Stream: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the stream.</p>
    public let streamArn: String?
    /// <p>A timestamp, in ISO 8601 format, for this stream.</p>
    ///          <p>Note that <code>LatestStreamLabel</code> is not a unique identifier for the stream, because it is
    ///       possible that a stream from another table might have the same timestamp. However, the
    ///       combination of the following three elements is guaranteed to be unique:</p>
    ///          <ul>
    ///             <li>
    ///                <p>the AWS customer ID.</p>
    ///             </li>
    ///             <li>
    ///                <p>the table name</p>
    ///             </li>
    ///             <li>
    ///                <p>the <code>StreamLabel</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let streamLabel: String?
    /// <p>The DynamoDB table with which the stream is associated.</p>
    public let tableName: String?

    public init (
        streamArn: String? = nil,
        streamLabel: String? = nil,
        tableName: String? = nil
    )
    {
        self.streamArn = streamArn
        self.streamLabel = streamLabel
        self.tableName = tableName
    }
}

extension StreamDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationRequestDateTime = "CreationRequestDateTime"
        case keySchema = "KeySchema"
        case lastEvaluatedShardId = "LastEvaluatedShardId"
        case shards = "Shards"
        case streamArn = "StreamArn"
        case streamLabel = "StreamLabel"
        case streamStatus = "StreamStatus"
        case streamViewType = "StreamViewType"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationRequestDateTime = creationRequestDateTime {
            try encodeContainer.encode(creationRequestDateTime.timeIntervalSince1970, forKey: .creationRequestDateTime)
        }
        if let keySchema = keySchema {
            var keySchemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keySchema)
            for keyschema0 in keySchema {
                try keySchemaContainer.encode(keyschema0)
            }
        }
        if let lastEvaluatedShardId = lastEvaluatedShardId {
            try encodeContainer.encode(lastEvaluatedShardId, forKey: .lastEvaluatedShardId)
        }
        if let shards = shards {
            var shardsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shards)
            for sharddescriptionlist0 in shards {
                try shardsContainer.encode(sharddescriptionlist0)
            }
        }
        if let streamArn = streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
        if let streamLabel = streamLabel {
            try encodeContainer.encode(streamLabel, forKey: .streamLabel)
        }
        if let streamStatus = streamStatus {
            try encodeContainer.encode(streamStatus.rawValue, forKey: .streamStatus)
        }
        if let streamViewType = streamViewType {
            try encodeContainer.encode(streamViewType.rawValue, forKey: .streamViewType)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let streamLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamLabel)
        streamLabel = streamLabelDecoded
        let streamStatusDecoded = try containerValues.decodeIfPresent(StreamStatus.self, forKey: .streamStatus)
        streamStatus = streamStatusDecoded
        let streamViewTypeDecoded = try containerValues.decodeIfPresent(StreamViewType.self, forKey: .streamViewType)
        streamViewType = streamViewTypeDecoded
        let creationRequestDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationRequestDateTime)
        creationRequestDateTime = creationRequestDateTimeDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let keySchemaContainer = try containerValues.decodeIfPresent([KeySchemaElement?].self, forKey: .keySchema)
        var keySchemaDecoded0:[KeySchemaElement]? = nil
        if let keySchemaContainer = keySchemaContainer {
            keySchemaDecoded0 = [KeySchemaElement]()
            for structure0 in keySchemaContainer {
                if let structure0 = structure0 {
                    keySchemaDecoded0?.append(structure0)
                }
            }
        }
        keySchema = keySchemaDecoded0
        let shardsContainer = try containerValues.decodeIfPresent([Shard?].self, forKey: .shards)
        var shardsDecoded0:[Shard]? = nil
        if let shardsContainer = shardsContainer {
            shardsDecoded0 = [Shard]()
            for structure0 in shardsContainer {
                if let structure0 = structure0 {
                    shardsDecoded0?.append(structure0)
                }
            }
        }
        shards = shardsDecoded0
        let lastEvaluatedShardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastEvaluatedShardId)
        lastEvaluatedShardId = lastEvaluatedShardIdDecoded
    }
}

extension StreamDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamDescription(creationRequestDateTime: \(String(describing: creationRequestDateTime)), keySchema: \(String(describing: keySchema)), lastEvaluatedShardId: \(String(describing: lastEvaluatedShardId)), shards: \(String(describing: shards)), streamArn: \(String(describing: streamArn)), streamLabel: \(String(describing: streamLabel)), streamStatus: \(String(describing: streamStatus)), streamViewType: \(String(describing: streamViewType)), tableName: \(String(describing: tableName)))"}
}

/// <p>Represents all of the data describing a particular stream.</p>
public struct StreamDescription: Equatable {
    /// <p>The date and time when the request to create this stream was issued.</p>
    public let creationRequestDateTime: Date?
    /// <p>The key attribute(s) of the stream's DynamoDB table.</p>
    public let keySchema: [KeySchemaElement]?
    /// <p>The shard ID of the item where the operation stopped, inclusive of the previous result set. Use this value to start a new operation, excluding this value in the new request.</p>
    ///          <p>If <code>LastEvaluatedShardId</code> is empty, then the "last page" of results has been
    ///       processed and there is currently no more data to be retrieved.</p>
    ///          <p>If <code>LastEvaluatedShardId</code> is not empty, it does not necessarily mean that there is
    ///       more data in the result set. The only way to know when you have reached the end of the result
    ///       set is when <code>LastEvaluatedShardId</code> is empty.</p>
    public let lastEvaluatedShardId: String?
    /// <p>The shards that comprise the stream.</p>
    public let shards: [Shard]?
    /// <p>The Amazon Resource Name (ARN) for the stream.</p>
    public let streamArn: String?
    /// <p>A timestamp, in ISO 8601 format, for this stream.</p>
    ///          <p>Note that <code>LatestStreamLabel</code> is not a unique identifier for the stream, because it is
    ///       possible that a stream from another table might have the same timestamp. However, the
    ///       combination of the following three elements is guaranteed to be unique:</p>
    ///          <ul>
    ///             <li>
    ///                <p>the AWS customer ID.</p>
    ///             </li>
    ///             <li>
    ///                <p>the table name</p>
    ///             </li>
    ///             <li>
    ///                <p>the <code>StreamLabel</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let streamLabel: String?
    /// <p>Indicates the current status of the stream:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ENABLING</code> - Streams is currently being enabled on the DynamoDB table.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ENABLED</code> - the stream is enabled.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DISABLING</code> - Streams is currently being disabled on the DynamoDB table.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DISABLED</code> - the stream is disabled.</p>
    ///             </li>
    ///          </ul>
    public let streamStatus: StreamStatus?
    /// <p>Indicates the format of the records within this stream:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>KEYS_ONLY</code> - only the key attributes of items that were modified in the DynamoDB table.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NEW_IMAGE</code> - entire items from the table, as they appeared after they were modified.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OLD_IMAGE</code> - entire items from the table, as they appeared before they were modified.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NEW_AND_OLD_IMAGES</code> - both the new and the old images of the items from the table.</p>
    ///             </li>
    ///          </ul>
    public let streamViewType: StreamViewType?
    /// <p>The DynamoDB table with which the stream is associated.</p>
    public let tableName: String?

    public init (
        creationRequestDateTime: Date? = nil,
        keySchema: [KeySchemaElement]? = nil,
        lastEvaluatedShardId: String? = nil,
        shards: [Shard]? = nil,
        streamArn: String? = nil,
        streamLabel: String? = nil,
        streamStatus: StreamStatus? = nil,
        streamViewType: StreamViewType? = nil,
        tableName: String? = nil
    )
    {
        self.creationRequestDateTime = creationRequestDateTime
        self.keySchema = keySchema
        self.lastEvaluatedShardId = lastEvaluatedShardId
        self.shards = shards
        self.streamArn = streamArn
        self.streamLabel = streamLabel
        self.streamStatus = streamStatus
        self.streamViewType = streamViewType
        self.tableName = tableName
    }
}

extension StreamRecord: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approximateCreationDateTime = "ApproximateCreationDateTime"
        case keys = "Keys"
        case newImage = "NewImage"
        case oldImage = "OldImage"
        case sequenceNumber = "SequenceNumber"
        case sizeBytes = "SizeBytes"
        case streamViewType = "StreamViewType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approximateCreationDateTime = approximateCreationDateTime {
            try encodeContainer.encode(approximateCreationDateTime.timeIntervalSince1970, forKey: .approximateCreationDateTime)
        }
        if let keys = keys {
            var keysContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .keys)
            for (dictKey0, attributemap0) in keys {
                try keysContainer.encode(attributemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let newImage = newImage {
            var newImageContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .newImage)
            for (dictKey0, attributemap0) in newImage {
                try newImageContainer.encode(attributemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let oldImage = oldImage {
            var oldImageContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .oldImage)
            for (dictKey0, attributemap0) in oldImage {
                try oldImageContainer.encode(attributemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let sequenceNumber = sequenceNumber {
            try encodeContainer.encode(sequenceNumber, forKey: .sequenceNumber)
        }
        if let sizeBytes = sizeBytes {
            try encodeContainer.encode(sizeBytes, forKey: .sizeBytes)
        }
        if let streamViewType = streamViewType {
            try encodeContainer.encode(streamViewType.rawValue, forKey: .streamViewType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approximateCreationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .approximateCreationDateTime)
        approximateCreationDateTime = approximateCreationDateTimeDecoded
        let keysContainer = try containerValues.decodeIfPresent([String: AttributeValue?].self, forKey: .keys)
        var keysDecoded0: [String:AttributeValue]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [String:AttributeValue]()
            for (key0, attributevalue0) in keysContainer {
                if let attributevalue0 = attributevalue0 {
                    keysDecoded0?[key0] = attributevalue0
                }
            }
        }
        keys = keysDecoded0
        let newImageContainer = try containerValues.decodeIfPresent([String: AttributeValue?].self, forKey: .newImage)
        var newImageDecoded0: [String:AttributeValue]? = nil
        if let newImageContainer = newImageContainer {
            newImageDecoded0 = [String:AttributeValue]()
            for (key0, attributevalue0) in newImageContainer {
                if let attributevalue0 = attributevalue0 {
                    newImageDecoded0?[key0] = attributevalue0
                }
            }
        }
        newImage = newImageDecoded0
        let oldImageContainer = try containerValues.decodeIfPresent([String: AttributeValue?].self, forKey: .oldImage)
        var oldImageDecoded0: [String:AttributeValue]? = nil
        if let oldImageContainer = oldImageContainer {
            oldImageDecoded0 = [String:AttributeValue]()
            for (key0, attributevalue0) in oldImageContainer {
                if let attributevalue0 = attributevalue0 {
                    oldImageDecoded0?[key0] = attributevalue0
                }
            }
        }
        oldImage = oldImageDecoded0
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
        let sizeBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .sizeBytes)
        sizeBytes = sizeBytesDecoded
        let streamViewTypeDecoded = try containerValues.decodeIfPresent(StreamViewType.self, forKey: .streamViewType)
        streamViewType = streamViewTypeDecoded
    }
}

extension StreamRecord: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamRecord(approximateCreationDateTime: \(String(describing: approximateCreationDateTime)), keys: \(String(describing: keys)), newImage: \(String(describing: newImage)), oldImage: \(String(describing: oldImage)), sequenceNumber: \(String(describing: sequenceNumber)), sizeBytes: \(String(describing: sizeBytes)), streamViewType: \(String(describing: streamViewType)))"}
}

/// <p>A description of a single data modification that was performed on an item in a DynamoDB table.</p>
public struct StreamRecord: Equatable {
    /// <p>The approximate date and time when the stream record was created, in <a href="http://www.epochconverter.com/">UNIX epoch time</a> format.</p>
    public let approximateCreationDateTime: Date?
    /// <p>The primary key attribute(s) for the DynamoDB item that was modified.</p>
    public let keys: [String:AttributeValue]?
    /// <p>The item in the DynamoDB table as it appeared after it was modified.</p>
    public let newImage: [String:AttributeValue]?
    /// <p>The item in the DynamoDB table as it appeared before it was modified.</p>
    public let oldImage: [String:AttributeValue]?
    /// <p>The sequence number of the stream record.</p>
    public let sequenceNumber: String?
    /// <p>The size of the stream record, in bytes.</p>
    public let sizeBytes: Int?
    /// <p>The type of data from the modified DynamoDB item that was captured in this stream record:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>KEYS_ONLY</code> - only the key attributes of the modified item.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NEW_IMAGE</code> - the entire item, as it appeared after it was modified.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OLD_IMAGE</code> - the entire item, as it appeared before it was modified.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NEW_AND_OLD_IMAGES</code> - both the new and the old item images of the item.</p>
    ///             </li>
    ///          </ul>
    public let streamViewType: StreamViewType?

    public init (
        approximateCreationDateTime: Date? = nil,
        keys: [String:AttributeValue]? = nil,
        newImage: [String:AttributeValue]? = nil,
        oldImage: [String:AttributeValue]? = nil,
        sequenceNumber: String? = nil,
        sizeBytes: Int? = nil,
        streamViewType: StreamViewType? = nil
    )
    {
        self.approximateCreationDateTime = approximateCreationDateTime
        self.keys = keys
        self.newImage = newImage
        self.oldImage = oldImage
        self.sequenceNumber = sequenceNumber
        self.sizeBytes = sizeBytes
        self.streamViewType = streamViewType
    }
}

public enum StreamStatus {
    case disabled
    case disabling
    case enabled
    case enabling
    case sdkUnknown(String)
}

extension StreamStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamStatus] {
        return [
            .disabled,
            .disabling,
            .enabled,
            .enabling,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .disabling: return "DISABLING"
        case .enabled: return "ENABLED"
        case .enabling: return "ENABLING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamStatus(rawValue: rawValue) ?? StreamStatus.sdkUnknown(rawValue)
    }
}

public enum StreamViewType {
    case keysOnly
    case newAndOldImages
    case newImage
    case oldImage
    case sdkUnknown(String)
}

extension StreamViewType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamViewType] {
        return [
            .keysOnly,
            .newAndOldImages,
            .newImage,
            .oldImage,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .keysOnly: return "KEYS_ONLY"
        case .newAndOldImages: return "NEW_AND_OLD_IMAGES"
        case .newImage: return "NEW_IMAGE"
        case .oldImage: return "OLD_IMAGE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamViewType(rawValue: rawValue) ?? StreamViewType.sdkUnknown(rawValue)
    }
}

extension TrimmedDataAccessException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrimmedDataAccessException(message: \(String(describing: message)))"}
}

extension TrimmedDataAccessException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TrimmedDataAccessExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation attempted to read past the oldest stream record in a shard.</p>
///          <p>In DynamoDB Streams, there is a 24 hour limit on data retention. Stream records whose age exceeds this limit are subject to removal (trimming) from the stream. You might receive a TrimmedDataAccessException if:</p>
///          <ul>
///             <li>
///                <p>You request a shard iterator with a sequence number older than the trim point (24 hours).</p>
///             </li>
///             <li>
///                <p>You obtain a shard iterator, but before you use the iterator in a <code>GetRecords</code>
///         request, a stream record in the shard exceeds the 24 hour period and is trimmed. This causes
///         the iterator to access a record that no longer exists.</p>
///             </li>
///          </ul>
public struct TrimmedDataAccessException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>"The data you are trying to access has been trimmed.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TrimmedDataAccessExceptionBody: Equatable {
    public let message: String?
}

extension TrimmedDataAccessExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
