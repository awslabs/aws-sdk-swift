// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension MqClientTypes {
    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public enum AuthenticationStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ldap
        case simple
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationStrategy] {
            return [
                .ldap,
                .simple,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ldap: return "LDAP"
            case .simple: return "SIMPLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationStrategy(rawValue: rawValue) ?? AuthenticationStrategy.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes.AvailabilityZone: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MqClientTypes {
    /// Name of the availability zone.
    public struct AvailabilityZone: Swift.Equatable {
        /// Id for the availability zone.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The attribute which caused the error.
    public var errorAttribute: Swift.String?
    /// The explanation of the error.
    public var message: Swift.String?

    public init (
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let errorAttribute: Swift.String?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MqClientTypes.BrokerEngineType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineType = "engineType"
        case engineVersions = "engineVersions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersions = engineVersions {
            var engineVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineVersions)
            for __listofengineversion0 in engineVersions {
                try engineVersionsContainer.encode(__listofengineversion0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionsContainer = try containerValues.decodeIfPresent([MqClientTypes.EngineVersion?].self, forKey: .engineVersions)
        var engineVersionsDecoded0:[MqClientTypes.EngineVersion]? = nil
        if let engineVersionsContainer = engineVersionsContainer {
            engineVersionsDecoded0 = [MqClientTypes.EngineVersion]()
            for structure0 in engineVersionsContainer {
                if let structure0 = structure0 {
                    engineVersionsDecoded0?.append(structure0)
                }
            }
        }
        engineVersions = engineVersionsDecoded0
    }
}

extension MqClientTypes {
    /// Types of broker engines.
    public struct BrokerEngineType: Swift.Equatable {
        /// The broker's engine type.
        public var engineType: MqClientTypes.EngineType?
        /// The list of engine versions.
        public var engineVersions: [MqClientTypes.EngineVersion]?

        public init (
            engineType: MqClientTypes.EngineType? = nil,
            engineVersions: [MqClientTypes.EngineVersion]? = nil
        )
        {
            self.engineType = engineType
            self.engineVersions = engineVersions
        }
    }

}

extension MqClientTypes.BrokerInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleURL = "consoleURL"
        case endpoints = "endpoints"
        case ipAddress = "ipAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleURL = consoleURL {
            try encodeContainer.encode(consoleURL, forKey: .consoleURL)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for __listof__string0 in endpoints {
                try endpointsContainer.encode(__listof__string0)
            }
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consoleURL)
        consoleURL = consoleURLDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .endpoints)
        var endpointsDecoded0:[Swift.String]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Swift.String]()
            for string0 in endpointsContainer {
                if let string0 = string0 {
                    endpointsDecoded0?.append(string0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension MqClientTypes {
    /// Returns information about all brokers.
    public struct BrokerInstance: Swift.Equatable {
        /// The brokers web console URL.
        public var consoleURL: Swift.String?
        /// The broker's wire-level protocol endpoints.
        public var endpoints: [Swift.String]?
        /// The IP address of the Elastic Network Interface (ENI) attached to the broker. Does not apply to RabbitMQ brokers.
        public var ipAddress: Swift.String?

        public init (
            consoleURL: Swift.String? = nil,
            endpoints: [Swift.String]? = nil,
            ipAddress: Swift.String? = nil
        )
        {
            self.consoleURL = consoleURL
            self.endpoints = endpoints
            self.ipAddress = ipAddress
        }
    }

}

extension MqClientTypes.BrokerInstanceOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "availabilityZones"
        case engineType = "engineType"
        case hostInstanceType = "hostInstanceType"
        case storageType = "storageType"
        case supportedDeploymentModes = "supportedDeploymentModes"
        case supportedEngineVersions = "supportedEngineVersions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for __listofavailabilityzone0 in availabilityZones {
                try availabilityZonesContainer.encode(__listofavailabilityzone0)
            }
        }
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let hostInstanceType = hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
        if let supportedDeploymentModes = supportedDeploymentModes {
            var supportedDeploymentModesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDeploymentModes)
            for __listofdeploymentmode0 in supportedDeploymentModes {
                try supportedDeploymentModesContainer.encode(__listofdeploymentmode0.rawValue)
            }
        }
        if let supportedEngineVersions = supportedEngineVersions {
            var supportedEngineVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedEngineVersions)
            for __listof__string0 in supportedEngineVersions {
                try supportedEngineVersionsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZonesContainer = try containerValues.decodeIfPresent([MqClientTypes.AvailabilityZone?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[MqClientTypes.AvailabilityZone]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [MqClientTypes.AvailabilityZone]()
            for structure0 in availabilityZonesContainer {
                if let structure0 = structure0 {
                    availabilityZonesDecoded0?.append(structure0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.BrokerStorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let supportedDeploymentModesContainer = try containerValues.decodeIfPresent([MqClientTypes.DeploymentMode?].self, forKey: .supportedDeploymentModes)
        var supportedDeploymentModesDecoded0:[MqClientTypes.DeploymentMode]? = nil
        if let supportedDeploymentModesContainer = supportedDeploymentModesContainer {
            supportedDeploymentModesDecoded0 = [MqClientTypes.DeploymentMode]()
            for string0 in supportedDeploymentModesContainer {
                if let string0 = string0 {
                    supportedDeploymentModesDecoded0?.append(string0)
                }
            }
        }
        supportedDeploymentModes = supportedDeploymentModesDecoded0
        let supportedEngineVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedEngineVersions)
        var supportedEngineVersionsDecoded0:[Swift.String]? = nil
        if let supportedEngineVersionsContainer = supportedEngineVersionsContainer {
            supportedEngineVersionsDecoded0 = [Swift.String]()
            for string0 in supportedEngineVersionsContainer {
                if let string0 = string0 {
                    supportedEngineVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedEngineVersions = supportedEngineVersionsDecoded0
    }
}

extension MqClientTypes {
    /// Option for host instance type.
    public struct BrokerInstanceOption: Swift.Equatable {
        /// The list of available az.
        public var availabilityZones: [MqClientTypes.AvailabilityZone]?
        /// The broker's engine type.
        public var engineType: MqClientTypes.EngineType?
        /// The broker's instance type.
        public var hostInstanceType: Swift.String?
        /// The broker's storage type.
        public var storageType: MqClientTypes.BrokerStorageType?
        /// The list of supported deployment modes.
        public var supportedDeploymentModes: [MqClientTypes.DeploymentMode]?
        /// The list of supported engine versions.
        public var supportedEngineVersions: [Swift.String]?

        public init (
            availabilityZones: [MqClientTypes.AvailabilityZone]? = nil,
            engineType: MqClientTypes.EngineType? = nil,
            hostInstanceType: Swift.String? = nil,
            storageType: MqClientTypes.BrokerStorageType? = nil,
            supportedDeploymentModes: [MqClientTypes.DeploymentMode]? = nil,
            supportedEngineVersions: [Swift.String]? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
            self.storageType = storageType
            self.supportedDeploymentModes = supportedDeploymentModes
            self.supportedEngineVersions = supportedEngineVersions
        }
    }

}

extension MqClientTypes {
    /// The broker's status.
    public enum BrokerState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationFailed
        case creationInProgress
        case deletionInProgress
        case rebootInProgress
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [BrokerState] {
            return [
                .creationFailed,
                .creationInProgress,
                .deletionInProgress,
                .rebootInProgress,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .deletionInProgress: return "DELETION_IN_PROGRESS"
            case .rebootInProgress: return "REBOOT_IN_PROGRESS"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BrokerState(rawValue: rawValue) ?? BrokerState.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes {
    /// The broker's storage type. EFS is not supported for RabbitMQ engine type.
    public enum BrokerStorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ebs
        case efs
        case sdkUnknown(Swift.String)

        public static var allCases: [BrokerStorageType] {
            return [
                .ebs,
                .efs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ebs: return "EBS"
            case .efs: return "EFS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BrokerStorageType(rawValue: rawValue) ?? BrokerStorageType.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes.BrokerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerArn = "brokerArn"
        case brokerId = "brokerId"
        case brokerName = "brokerName"
        case brokerState = "brokerState"
        case created = "created"
        case deploymentMode = "deploymentMode"
        case engineType = "engineType"
        case hostInstanceType = "hostInstanceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerArn = brokerArn {
            try encodeContainer.encode(brokerArn, forKey: .brokerArn)
        }
        if let brokerId = brokerId {
            try encodeContainer.encode(brokerId, forKey: .brokerId)
        }
        if let brokerName = brokerName {
            try encodeContainer.encode(brokerName, forKey: .brokerName)
        }
        if let brokerState = brokerState {
            try encodeContainer.encode(brokerState.rawValue, forKey: .brokerState)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let deploymentMode = deploymentMode {
            try encodeContainer.encode(deploymentMode.rawValue, forKey: .deploymentMode)
        }
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let hostInstanceType = hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerArn)
        brokerArn = brokerArnDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let brokerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerName)
        brokerName = brokerNameDecoded
        let brokerStateDecoded = try containerValues.decodeIfPresent(MqClientTypes.BrokerState.self, forKey: .brokerState)
        brokerState = brokerStateDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let deploymentModeDecoded = try containerValues.decodeIfPresent(MqClientTypes.DeploymentMode.self, forKey: .deploymentMode)
        deploymentMode = deploymentModeDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
    }
}

extension MqClientTypes {
    /// Returns information about all brokers.
    public struct BrokerSummary: Swift.Equatable {
        /// The broker's Amazon Resource Name (ARN).
        public var brokerArn: Swift.String?
        /// The unique ID that Amazon MQ generates for the broker.
        public var brokerId: Swift.String?
        /// The broker's name. This value is unique in your AWS account, 1-50 characters long, and containing only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
        public var brokerName: Swift.String?
        /// The broker's status.
        public var brokerState: MqClientTypes.BrokerState?
        /// The time when the broker was created.
        public var created: ClientRuntime.Date?
        /// The broker's deployment mode.
        /// This member is required.
        public var deploymentMode: MqClientTypes.DeploymentMode?
        /// The type of broker engine.
        /// This member is required.
        public var engineType: MqClientTypes.EngineType?
        /// The broker's instance type.
        public var hostInstanceType: Swift.String?

        public init (
            brokerArn: Swift.String? = nil,
            brokerId: Swift.String? = nil,
            brokerName: Swift.String? = nil,
            brokerState: MqClientTypes.BrokerState? = nil,
            created: ClientRuntime.Date? = nil,
            deploymentMode: MqClientTypes.DeploymentMode? = nil,
            engineType: MqClientTypes.EngineType? = nil,
            hostInstanceType: Swift.String? = nil
        )
        {
            self.brokerArn = brokerArn
            self.brokerId = brokerId
            self.brokerName = brokerName
            self.brokerState = brokerState
            self.created = created
            self.deploymentMode = deploymentMode
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
        }
    }

}

extension MqClientTypes {
    /// The type of change pending for the ActiveMQ user.
    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .create,
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes.Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authenticationStrategy = "authenticationStrategy"
        case created = "created"
        case description = "description"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authenticationStrategy = authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let latestRevision = latestRevision {
            try encodeContainer.encode(latestRevision, forKey: .latestRevision)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MqClientTypes {
    /// Returns information about all configurations.
    public struct Configuration: Swift.Equatable {
        /// Required. The ARN of the configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
        /// This member is required.
        public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
        /// Required. The date and time of the configuration revision.
        /// This member is required.
        public var created: ClientRuntime.Date?
        /// Required. The description of the configuration.
        /// This member is required.
        public var description: Swift.String?
        /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        /// This member is required.
        public var engineType: MqClientTypes.EngineType?
        /// Required. The broker engine's version. For a list of supported engine versions, see, [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
        /// This member is required.
        public var engineVersion: Swift.String?
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        /// This member is required.
        public var id: Swift.String?
        /// Required. The latest revision of the configuration.
        /// This member is required.
        public var latestRevision: MqClientTypes.ConfigurationRevision?
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        /// This member is required.
        public var name: Swift.String?
        /// The list of all tags associated with this configuration.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            engineType: MqClientTypes.EngineType? = nil,
            engineVersion: Swift.String? = nil,
            id: Swift.String? = nil,
            latestRevision: MqClientTypes.ConfigurationRevision? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.authenticationStrategy = authenticationStrategy
            self.created = created
            self.description = description
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
            self.tags = tags
        }
    }

}

extension MqClientTypes.ConfigurationId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "id"
        case revision = "revision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension MqClientTypes {
    /// A list of information about the configuration. Does not apply to RabbitMQ brokers.
    public struct ConfigurationId: Swift.Equatable {
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        /// This member is required.
        public var id: Swift.String?
        /// The revision number of the configuration.
        public var revision: Swift.Int?

        public init (
            id: Swift.String? = nil,
            revision: Swift.Int? = nil
        )
        {
            self.id = id
            self.revision = revision
        }
    }

}

extension MqClientTypes.ConfigurationRevision: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "created"
        case description = "description"
        case revision = "revision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension MqClientTypes {
    /// Returns information about the specified configuration revision.
    public struct ConfigurationRevision: Swift.Equatable {
        /// Required. The date and time of the configuration revision.
        /// This member is required.
        public var created: ClientRuntime.Date?
        /// The description of the configuration revision.
        public var description: Swift.String?
        /// Required. The revision number of the configuration.
        /// This member is required.
        public var revision: Swift.Int?

        public init (
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            revision: Swift.Int? = nil
        )
        {
            self.created = created
            self.description = description
            self.revision = revision
        }
    }

}

extension MqClientTypes.Configurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case current = "current"
        case history = "history"
        case pending = "pending"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let current = current {
            try encodeContainer.encode(current, forKey: .current)
        }
        if let history = history {
            var historyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .history)
            for __listofconfigurationid0 in history {
                try historyContainer.encode(__listofconfigurationid0)
            }
        }
        if let pending = pending {
            try encodeContainer.encode(pending, forKey: .pending)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationId.self, forKey: .current)
        current = currentDecoded
        let historyContainer = try containerValues.decodeIfPresent([MqClientTypes.ConfigurationId?].self, forKey: .history)
        var historyDecoded0:[MqClientTypes.ConfigurationId]? = nil
        if let historyContainer = historyContainer {
            historyDecoded0 = [MqClientTypes.ConfigurationId]()
            for structure0 in historyContainer {
                if let structure0 = structure0 {
                    historyDecoded0?.append(structure0)
                }
            }
        }
        history = historyDecoded0
        let pendingDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationId.self, forKey: .pending)
        pending = pendingDecoded
    }
}

extension MqClientTypes {
    /// Broker configuration information
    public struct Configurations: Swift.Equatable {
        /// The broker's current configuration.
        public var current: MqClientTypes.ConfigurationId?
        /// The history of configurations applied to the broker.
        public var history: [MqClientTypes.ConfigurationId]?
        /// The broker's pending configuration.
        public var pending: MqClientTypes.ConfigurationId?

        public init (
            current: MqClientTypes.ConfigurationId? = nil,
            history: [MqClientTypes.ConfigurationId]? = nil,
            pending: MqClientTypes.ConfigurationId? = nil
        )
        {
            self.current = current
            self.history = history
            self.pending = pending
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The attribute which caused the error.
    public var errorAttribute: Swift.String?
    /// The explanation of the error.
    public var message: Swift.String?

    public init (
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let errorAttribute: Swift.String?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateBrokerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerName = "brokerName"
        case configuration = "configuration"
        case creatorRequestId = "creatorRequestId"
        case deploymentMode = "deploymentMode"
        case encryptionOptions = "encryptionOptions"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case publiclyAccessible = "publiclyAccessible"
        case securityGroups = "securityGroups"
        case storageType = "storageType"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case users = "users"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationStrategy = authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let brokerName = brokerName {
            try encodeContainer.encode(brokerName, forKey: .brokerName)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let deploymentMode = deploymentMode {
            try encodeContainer.encode(deploymentMode.rawValue, forKey: .deploymentMode)
        }
        if let encryptionOptions = encryptionOptions {
            try encodeContainer.encode(encryptionOptions, forKey: .encryptionOptions)
        }
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let hostInstanceType = hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
        if let ldapServerMetadata = ldapServerMetadata {
            try encodeContainer.encode(ldapServerMetadata, forKey: .ldapServerMetadata)
        }
        if let logs = logs {
            try encodeContainer.encode(logs, forKey: .logs)
        }
        if let maintenanceWindowStartTime = maintenanceWindowStartTime {
            try encodeContainer.encode(maintenanceWindowStartTime, forKey: .maintenanceWindowStartTime)
        }
        if let publiclyAccessible = publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for __listof__string0 in securityGroups {
                try securityGroupsContainer.encode(__listof__string0)
            }
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for __listof__string0 in subnetIds {
                try subnetIdsContainer.encode(__listof__string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for __listofuser0 in users {
                try usersContainer.encode(__listofuser0)
            }
        }
    }
}

extension CreateBrokerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/brokers"
    }
}

/// Creates a broker using the specified properties.
public struct CreateBrokerInput: Swift.Equatable {
    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Enables automatic upgrades to new minor versions for brokers, as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window of the broker or after a manual broker reboot. Set to true by default, if no value is specified.
    /// This member is required.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// Required. The broker's name. This value must be unique in your AWS account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
    /// This member is required.
    public var brokerName: Swift.String?
    /// A list of information about the configuration.
    public var configuration: MqClientTypes.ConfigurationId?
    /// The unique ID that the requester receives for the created broker. Amazon MQ passes your ID with the API action. Note: We recommend using a Universally Unique Identifier (UUID) for the creatorRequestId. You may omit the creatorRequestId if your application doesn't require idempotency.
    public var creatorRequestId: Swift.String?
    /// Required. The broker's deployment mode.
    /// This member is required.
    public var deploymentMode: MqClientTypes.DeploymentMode?
    /// Encryption options for the broker. Does not apply to RabbitMQ brokers.
    public var encryptionOptions: MqClientTypes.EncryptionOptions?
    /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    /// This member is required.
    public var engineType: MqClientTypes.EngineType?
    /// Required. The broker engine's version. For a list of supported engine versions, see [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
    /// This member is required.
    public var engineVersion: Swift.String?
    /// Required. The broker's instance type.
    /// This member is required.
    public var hostInstanceType: Swift.String?
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataInput?
    /// Enables Amazon CloudWatch logging for brokers.
    public var logs: MqClientTypes.Logs?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// Enables connections from applications outside of the VPC that hosts the broker's subnets. Set to false by default, if no value is provided.
    /// This member is required.
    public var publiclyAccessible: Swift.Bool?
    /// The list of rules (1 minimum, 125 maximum) that authorize connections to brokers.
    public var securityGroups: [Swift.String]?
    /// The broker's storage type.
    public var storageType: MqClientTypes.BrokerStorageType?
    /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones. If you specify more than one subnet, the subnets must be in different Availability Zones. Amazon MQ will not be able to create VPC endpoints for your broker with multiple subnets in the same Availability Zone. A SINGLE_INSTANCE deployment requires one subnet (for example, the default subnet). An ACTIVE_STANDBY_MULTI_AZ Amazon MQ for ActiveMQ deployment requires two subnets. A CLUSTER_MULTI_AZ Amazon MQ for RabbitMQ deployment has no subnet requirements when deployed with public accessibility. Deployment without public accessibility requires at least one subnet. If you specify subnets in a [shared VPC](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-sharing.html) for a RabbitMQ broker, the associated VPC to which the specified subnets belong must be owned by your AWS account. Amazon MQ will not be able to create VPC endpoints in VPCs that are not owned by your AWS account.
    public var subnetIds: [Swift.String]?
    /// Create tags when creating the broker.
    public var tags: [Swift.String:Swift.String]?
    /// Required. The list of broker users (persons or applications) who can access queues and topics. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long. Amazon MQ for RabbitMQ When you create an Amazon MQ for RabbitMQ broker, one and only one administrative user is accepted and created when a broker is first provisioned. All subsequent broker users are created by making RabbitMQ API calls directly to brokers or via the RabbitMQ web console.
    /// This member is required.
    public var users: [MqClientTypes.User]?

    public init (
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerName: Swift.String? = nil,
        configuration: MqClientTypes.ConfigurationId? = nil,
        creatorRequestId: Swift.String? = nil,
        deploymentMode: MqClientTypes.DeploymentMode? = nil,
        encryptionOptions: MqClientTypes.EncryptionOptions? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataInput? = nil,
        logs: MqClientTypes.Logs? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        securityGroups: [Swift.String]? = nil,
        storageType: MqClientTypes.BrokerStorageType? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        users: [MqClientTypes.User]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerName = brokerName
        self.configuration = configuration
        self.creatorRequestId = creatorRequestId
        self.deploymentMode = deploymentMode
        self.encryptionOptions = encryptionOptions
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.publiclyAccessible = publiclyAccessible
        self.securityGroups = securityGroups
        self.storageType = storageType
        self.subnetIds = subnetIds
        self.tags = tags
        self.users = users
    }
}

struct CreateBrokerInputBody: Swift.Equatable {
    let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let autoMinorVersionUpgrade: Swift.Bool?
    let brokerName: Swift.String?
    let configuration: MqClientTypes.ConfigurationId?
    let creatorRequestId: Swift.String?
    let deploymentMode: MqClientTypes.DeploymentMode?
    let encryptionOptions: MqClientTypes.EncryptionOptions?
    let engineType: MqClientTypes.EngineType?
    let engineVersion: Swift.String?
    let hostInstanceType: Swift.String?
    let ldapServerMetadata: MqClientTypes.LdapServerMetadataInput?
    let logs: MqClientTypes.Logs?
    let maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    let publiclyAccessible: Swift.Bool?
    let securityGroups: [Swift.String]?
    let storageType: MqClientTypes.BrokerStorageType?
    let subnetIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let users: [MqClientTypes.User]?
}

extension CreateBrokerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerName = "brokerName"
        case configuration = "configuration"
        case creatorRequestId = "creatorRequestId"
        case deploymentMode = "deploymentMode"
        case encryptionOptions = "encryptionOptions"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case publiclyAccessible = "publiclyAccessible"
        case securityGroups = "securityGroups"
        case storageType = "storageType"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case users = "users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let brokerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerName)
        brokerName = brokerNameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationId.self, forKey: .configuration)
        configuration = configurationDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let deploymentModeDecoded = try containerValues.decodeIfPresent(MqClientTypes.DeploymentMode.self, forKey: .deploymentMode)
        deploymentMode = deploymentModeDecoded
        let encryptionOptionsDecoded = try containerValues.decodeIfPresent(MqClientTypes.EncryptionOptions.self, forKey: .encryptionOptions)
        encryptionOptions = encryptionOptionsDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.LdapServerMetadataInput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(MqClientTypes.Logs.self, forKey: .logs)
        logs = logsDecoded
        let maintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(MqClientTypes.WeeklyStartTime.self, forKey: .maintenanceWindowStartTime)
        maintenanceWindowStartTime = maintenanceWindowStartTimeDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let storageTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.BrokerStorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([MqClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[MqClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [MqClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension CreateBrokerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBrokerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBrokerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBrokerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBrokerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.brokerArn = output.brokerArn
            self.brokerId = output.brokerId
        } else {
            self.brokerArn = nil
            self.brokerId = nil
        }
    }
}

public struct CreateBrokerOutputResponse: Swift.Equatable {
    /// The broker's Amazon Resource Name (ARN).
    public var brokerArn: Swift.String?
    /// The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?

    public init (
        brokerArn: Swift.String? = nil,
        brokerId: Swift.String? = nil
    )
    {
        self.brokerArn = brokerArn
        self.brokerId = brokerId
    }
}

struct CreateBrokerOutputResponseBody: Swift.Equatable {
    let brokerArn: Swift.String?
    let brokerId: Swift.String?
}

extension CreateBrokerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerArn = "brokerArn"
        case brokerId = "brokerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerArn)
        brokerArn = brokerArnDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
    }
}

extension CreateConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationStrategy = authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/configurations"
    }
}

/// Creates a new configuration for the specified configuration name. Amazon MQ uses the default configuration (the engine type and version).
public struct CreateConfigurationInput: Swift.Equatable {
    /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    /// This member is required.
    public var engineType: MqClientTypes.EngineType?
    /// Required. The broker engine's version. For a list of supported engine versions, see [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
    /// This member is required.
    public var engineVersion: Swift.String?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    /// This member is required.
    public var name: Swift.String?
    /// Create tags when creating the configuration.
    public var tags: [Swift.String:Swift.String]?

    public init (
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateConfigurationInputBody: Swift.Equatable {
    let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let engineType: MqClientTypes.EngineType?
    let engineVersion: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case name = "name"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authenticationStrategy = output.authenticationStrategy
            self.created = output.created
            self.id = output.id
            self.latestRevision = output.latestRevision
            self.name = output.name
        } else {
            self.arn = nil
            self.authenticationStrategy = nil
            self.created = nil
            self.id = nil
            self.latestRevision = nil
            self.name = nil
        }
    }
}

public struct CreateConfigurationOutputResponse: Swift.Equatable {
    /// Required. The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Required. The date and time of the configuration.
    public var created: ClientRuntime.Date?
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public var id: Swift.String?
    /// The latest revision of the configuration.
    public var latestRevision: MqClientTypes.ConfigurationRevision?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        created: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        latestRevision: MqClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authenticationStrategy = authenticationStrategy
        self.created = created
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
    }
}

struct CreateConfigurationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let created: ClientRuntime.Date?
    let id: Swift.String?
    let latestRevision: MqClientTypes.ConfigurationRevision?
    let name: Swift.String?
}

extension CreateConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authenticationStrategy = "authenticationStrategy"
        case created = "created"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// A map of the key-value pairs for the resource tag.
public struct CreateTagsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct CreateTagsInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension CreateTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTagsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateTagsOutputResponse: Swift.Equatable {

}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleAccess = consoleAccess {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __listof__string0 in groups {
                try groupsContainer.encode(__listof__string0)
            }
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        guard let username = username else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
    }
}

/// Creates a new ActiveMQ user.
public struct CreateUserInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// Enables access to the ActiveMQ Web Console for the ActiveMQ user.
    public var consoleAccess: Swift.Bool?
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var groups: [Swift.String]?
    /// Required. The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
    /// This member is required.
    public var password: Swift.String?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init (
        brokerId: Swift.String? = nil,
        consoleAccess: Swift.Bool? = nil,
        groups: [Swift.String]? = nil,
        password: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.password = password
        self.username = username
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let consoleAccess: Swift.Bool?
    let groups: [Swift.String]?
    let password: Swift.String?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateUserOutputResponse: Swift.Equatable {

}

extension MqClientTypes {
    public enum DayOfWeek: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DayOfWeek(rawValue: rawValue) ?? DayOfWeek.sdkUnknown(rawValue)
        }
    }
}

extension DeleteBrokerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())"
    }
}

public struct DeleteBrokerInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?

    public init (
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct DeleteBrokerInputBody: Swift.Equatable {
}

extension DeleteBrokerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBrokerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBrokerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBrokerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBrokerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteBrokerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.brokerId = output.brokerId
        } else {
            self.brokerId = nil
        }
    }
}

public struct DeleteBrokerOutputResponse: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?

    public init (
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct DeleteBrokerOutputResponseBody: Swift.Equatable {
    let brokerId: Swift.String?
}

extension DeleteBrokerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerId = "brokerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
    }
}

extension DeleteTagsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension DeleteTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct DeleteTagsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of tag keys to delete
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct DeleteTagsInputBody: Swift.Equatable {
}

extension DeleteTagsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTagsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagsOutputResponse: Swift.Equatable {

}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        guard let username = username else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init (
        brokerId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.username = username
    }
}

struct DeleteUserInputBody: Swift.Equatable {
}

extension DeleteUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {

}

extension MqClientTypes {
    /// The broker's deployment mode.
    public enum DeploymentMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeStandbyMultiAz
        case clusterMultiAz
        case singleInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentMode] {
            return [
                .activeStandbyMultiAz,
                .clusterMultiAz,
                .singleInstance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeStandbyMultiAz: return "ACTIVE_STANDBY_MULTI_AZ"
            case .clusterMultiAz: return "CLUSTER_MULTI_AZ"
            case .singleInstance: return "SINGLE_INSTANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentMode(rawValue: rawValue) ?? DeploymentMode.sdkUnknown(rawValue)
        }
    }
}

extension DescribeBrokerEngineTypesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let engineType = engineType {
            let engineTypeQueryItem = ClientRuntime.URLQueryItem(name: "engineType".urlPercentEncoding(), value: Swift.String(engineType).urlPercentEncoding())
            items.append(engineTypeQueryItem)
        }
        return items
    }
}

extension DescribeBrokerEngineTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/broker-engine-types"
    }
}

public struct DescribeBrokerEngineTypesInput: Swift.Equatable {
    /// Filter response by engine type.
    public var engineType: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        engineType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineType = engineType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBrokerEngineTypesInputBody: Swift.Equatable {
}

extension DescribeBrokerEngineTypesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBrokerEngineTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBrokerEngineTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBrokerEngineTypesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBrokerEngineTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBrokerEngineTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.brokerEngineTypes = output.brokerEngineTypes
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.brokerEngineTypes = nil
            self.maxResults = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBrokerEngineTypesOutputResponse: Swift.Equatable {
    /// List of available engine types and versions.
    public var brokerEngineTypes: [MqClientTypes.BrokerEngineType]?
    /// Required. The maximum number of engine types that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        brokerEngineTypes: [MqClientTypes.BrokerEngineType]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerEngineTypes = brokerEngineTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBrokerEngineTypesOutputResponseBody: Swift.Equatable {
    let brokerEngineTypes: [MqClientTypes.BrokerEngineType]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBrokerEngineTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerEngineTypes = "brokerEngineTypes"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerEngineTypesContainer = try containerValues.decodeIfPresent([MqClientTypes.BrokerEngineType?].self, forKey: .brokerEngineTypes)
        var brokerEngineTypesDecoded0:[MqClientTypes.BrokerEngineType]? = nil
        if let brokerEngineTypesContainer = brokerEngineTypesContainer {
            brokerEngineTypesDecoded0 = [MqClientTypes.BrokerEngineType]()
            for structure0 in brokerEngineTypesContainer {
                if let structure0 = structure0 {
                    brokerEngineTypesDecoded0?.append(structure0)
                }
            }
        }
        brokerEngineTypes = brokerEngineTypesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBrokerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())"
    }
}

public struct DescribeBrokerInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?

    public init (
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct DescribeBrokerInputBody: Swift.Equatable {
}

extension DescribeBrokerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBrokerInstanceOptionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let storageType = storageType {
            let storageTypeQueryItem = ClientRuntime.URLQueryItem(name: "storageType".urlPercentEncoding(), value: Swift.String(storageType).urlPercentEncoding())
            items.append(storageTypeQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let engineType = engineType {
            let engineTypeQueryItem = ClientRuntime.URLQueryItem(name: "engineType".urlPercentEncoding(), value: Swift.String(engineType).urlPercentEncoding())
            items.append(engineTypeQueryItem)
        }
        if let hostInstanceType = hostInstanceType {
            let hostInstanceTypeQueryItem = ClientRuntime.URLQueryItem(name: "hostInstanceType".urlPercentEncoding(), value: Swift.String(hostInstanceType).urlPercentEncoding())
            items.append(hostInstanceTypeQueryItem)
        }
        return items
    }
}

extension DescribeBrokerInstanceOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/broker-instance-options"
    }
}

public struct DescribeBrokerInstanceOptionsInput: Swift.Equatable {
    /// Filter response by engine type.
    public var engineType: Swift.String?
    /// Filter response by host instance type.
    public var hostInstanceType: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?
    /// Filter response by storage type.
    public var storageType: Swift.String?

    public init (
        engineType: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        storageType: Swift.String? = nil
    )
    {
        self.engineType = engineType
        self.hostInstanceType = hostInstanceType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.storageType = storageType
    }
}

struct DescribeBrokerInstanceOptionsInputBody: Swift.Equatable {
}

extension DescribeBrokerInstanceOptionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBrokerInstanceOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBrokerInstanceOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBrokerInstanceOptionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBrokerInstanceOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBrokerInstanceOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.brokerInstanceOptions = output.brokerInstanceOptions
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.brokerInstanceOptions = nil
            self.maxResults = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBrokerInstanceOptionsOutputResponse: Swift.Equatable {
    /// List of available broker instance options.
    public var brokerInstanceOptions: [MqClientTypes.BrokerInstanceOption]?
    /// Required. The maximum number of instance options that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        brokerInstanceOptions: [MqClientTypes.BrokerInstanceOption]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerInstanceOptions = brokerInstanceOptions
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBrokerInstanceOptionsOutputResponseBody: Swift.Equatable {
    let brokerInstanceOptions: [MqClientTypes.BrokerInstanceOption]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBrokerInstanceOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerInstanceOptions = "brokerInstanceOptions"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerInstanceOptionsContainer = try containerValues.decodeIfPresent([MqClientTypes.BrokerInstanceOption?].self, forKey: .brokerInstanceOptions)
        var brokerInstanceOptionsDecoded0:[MqClientTypes.BrokerInstanceOption]? = nil
        if let brokerInstanceOptionsContainer = brokerInstanceOptionsContainer {
            brokerInstanceOptionsDecoded0 = [MqClientTypes.BrokerInstanceOption]()
            for structure0 in brokerInstanceOptionsContainer {
                if let structure0 = structure0 {
                    brokerInstanceOptionsDecoded0?.append(structure0)
                }
            }
        }
        brokerInstanceOptions = brokerInstanceOptionsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBrokerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBrokerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBrokerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBrokerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBrokerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authenticationStrategy = output.authenticationStrategy
            self.autoMinorVersionUpgrade = output.autoMinorVersionUpgrade
            self.brokerArn = output.brokerArn
            self.brokerId = output.brokerId
            self.brokerInstances = output.brokerInstances
            self.brokerName = output.brokerName
            self.brokerState = output.brokerState
            self.configurations = output.configurations
            self.created = output.created
            self.deploymentMode = output.deploymentMode
            self.encryptionOptions = output.encryptionOptions
            self.engineType = output.engineType
            self.engineVersion = output.engineVersion
            self.hostInstanceType = output.hostInstanceType
            self.ldapServerMetadata = output.ldapServerMetadata
            self.logs = output.logs
            self.maintenanceWindowStartTime = output.maintenanceWindowStartTime
            self.pendingAuthenticationStrategy = output.pendingAuthenticationStrategy
            self.pendingEngineVersion = output.pendingEngineVersion
            self.pendingHostInstanceType = output.pendingHostInstanceType
            self.pendingLdapServerMetadata = output.pendingLdapServerMetadata
            self.pendingSecurityGroups = output.pendingSecurityGroups
            self.publiclyAccessible = output.publiclyAccessible
            self.securityGroups = output.securityGroups
            self.storageType = output.storageType
            self.subnetIds = output.subnetIds
            self.tags = output.tags
            self.users = output.users
        } else {
            self.authenticationStrategy = nil
            self.autoMinorVersionUpgrade = nil
            self.brokerArn = nil
            self.brokerId = nil
            self.brokerInstances = nil
            self.brokerName = nil
            self.brokerState = nil
            self.configurations = nil
            self.created = nil
            self.deploymentMode = nil
            self.encryptionOptions = nil
            self.engineType = nil
            self.engineVersion = nil
            self.hostInstanceType = nil
            self.ldapServerMetadata = nil
            self.logs = nil
            self.maintenanceWindowStartTime = nil
            self.pendingAuthenticationStrategy = nil
            self.pendingEngineVersion = nil
            self.pendingHostInstanceType = nil
            self.pendingLdapServerMetadata = nil
            self.pendingSecurityGroups = nil
            self.publiclyAccessible = nil
            self.securityGroups = nil
            self.storageType = nil
            self.subnetIds = nil
            self.tags = nil
            self.users = nil
        }
    }
}

public struct DescribeBrokerOutputResponse: Swift.Equatable {
    /// The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Enables automatic upgrades to new minor versions for brokers, as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window of the broker or after a manual broker reboot.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The broker's Amazon Resource Name (ARN).
    public var brokerArn: Swift.String?
    /// The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// A list of information about allocated brokers.
    public var brokerInstances: [MqClientTypes.BrokerInstance]?
    /// The broker's name. This value must be unique in your AWS account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
    public var brokerName: Swift.String?
    /// The broker's status.
    public var brokerState: MqClientTypes.BrokerState?
    /// The list of all revisions for the specified configuration.
    public var configurations: MqClientTypes.Configurations?
    /// The time when the broker was created.
    public var created: ClientRuntime.Date?
    /// The broker's deployment mode.
    public var deploymentMode: MqClientTypes.DeploymentMode?
    /// Encryption options for the broker. Does not apply to RabbitMQ brokers.
    public var encryptionOptions: MqClientTypes.EncryptionOptions?
    /// The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    public var engineType: MqClientTypes.EngineType?
    /// The broker engine's version. For a list of supported engine versions, see [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
    public var engineVersion: Swift.String?
    /// The broker's instance type.
    public var hostInstanceType: Swift.String?
    /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    /// The list of information about logs currently enabled and pending to be deployed for the specified broker.
    public var logs: MqClientTypes.LogsSummary?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// The authentication strategy that will be applied when the broker is rebooted. The default is SIMPLE.
    public var pendingAuthenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// The broker engine version to upgrade to. For a list of supported engine versions, see [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
    public var pendingEngineVersion: Swift.String?
    /// The broker's host instance type to upgrade to. For a list of supported instance types, see [Broker instance types](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker.html#broker-instance-types).
    public var pendingHostInstanceType: Swift.String?
    /// The metadata of the LDAP server that will be used to authenticate and authorize connections to the broker after it is rebooted.
    public var pendingLdapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    /// The list of pending security groups to authorize connections to brokers.
    public var pendingSecurityGroups: [Swift.String]?
    /// Enables connections from applications outside of the VPC that hosts the broker's subnets.
    public var publiclyAccessible: Swift.Bool?
    /// The list of rules (1 minimum, 125 maximum) that authorize connections to brokers.
    public var securityGroups: [Swift.String]?
    /// The broker's storage type.
    public var storageType: MqClientTypes.BrokerStorageType?
    /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones.
    public var subnetIds: [Swift.String]?
    /// The list of all tags associated with this broker.
    public var tags: [Swift.String:Swift.String]?
    /// The list of all broker usernames for the specified broker.
    public var users: [MqClientTypes.UserSummary]?

    public init (
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerArn: Swift.String? = nil,
        brokerId: Swift.String? = nil,
        brokerInstances: [MqClientTypes.BrokerInstance]? = nil,
        brokerName: Swift.String? = nil,
        brokerState: MqClientTypes.BrokerState? = nil,
        configurations: MqClientTypes.Configurations? = nil,
        created: ClientRuntime.Date? = nil,
        deploymentMode: MqClientTypes.DeploymentMode? = nil,
        encryptionOptions: MqClientTypes.EncryptionOptions? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput? = nil,
        logs: MqClientTypes.LogsSummary? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        pendingAuthenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        pendingEngineVersion: Swift.String? = nil,
        pendingHostInstanceType: Swift.String? = nil,
        pendingLdapServerMetadata: MqClientTypes.LdapServerMetadataOutput? = nil,
        pendingSecurityGroups: [Swift.String]? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        securityGroups: [Swift.String]? = nil,
        storageType: MqClientTypes.BrokerStorageType? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        users: [MqClientTypes.UserSummary]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerArn = brokerArn
        self.brokerId = brokerId
        self.brokerInstances = brokerInstances
        self.brokerName = brokerName
        self.brokerState = brokerState
        self.configurations = configurations
        self.created = created
        self.deploymentMode = deploymentMode
        self.encryptionOptions = encryptionOptions
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.pendingAuthenticationStrategy = pendingAuthenticationStrategy
        self.pendingEngineVersion = pendingEngineVersion
        self.pendingHostInstanceType = pendingHostInstanceType
        self.pendingLdapServerMetadata = pendingLdapServerMetadata
        self.pendingSecurityGroups = pendingSecurityGroups
        self.publiclyAccessible = publiclyAccessible
        self.securityGroups = securityGroups
        self.storageType = storageType
        self.subnetIds = subnetIds
        self.tags = tags
        self.users = users
    }
}

struct DescribeBrokerOutputResponseBody: Swift.Equatable {
    let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let autoMinorVersionUpgrade: Swift.Bool?
    let brokerArn: Swift.String?
    let brokerId: Swift.String?
    let brokerInstances: [MqClientTypes.BrokerInstance]?
    let brokerName: Swift.String?
    let brokerState: MqClientTypes.BrokerState?
    let configurations: MqClientTypes.Configurations?
    let created: ClientRuntime.Date?
    let deploymentMode: MqClientTypes.DeploymentMode?
    let encryptionOptions: MqClientTypes.EncryptionOptions?
    let engineType: MqClientTypes.EngineType?
    let engineVersion: Swift.String?
    let hostInstanceType: Swift.String?
    let ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    let logs: MqClientTypes.LogsSummary?
    let maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    let pendingAuthenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let pendingEngineVersion: Swift.String?
    let pendingHostInstanceType: Swift.String?
    let pendingLdapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    let pendingSecurityGroups: [Swift.String]?
    let publiclyAccessible: Swift.Bool?
    let securityGroups: [Swift.String]?
    let storageType: MqClientTypes.BrokerStorageType?
    let subnetIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let users: [MqClientTypes.UserSummary]?
}

extension DescribeBrokerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerArn = "brokerArn"
        case brokerId = "brokerId"
        case brokerInstances = "brokerInstances"
        case brokerName = "brokerName"
        case brokerState = "brokerState"
        case configurations = "configurations"
        case created = "created"
        case deploymentMode = "deploymentMode"
        case encryptionOptions = "encryptionOptions"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case pendingAuthenticationStrategy = "pendingAuthenticationStrategy"
        case pendingEngineVersion = "pendingEngineVersion"
        case pendingHostInstanceType = "pendingHostInstanceType"
        case pendingLdapServerMetadata = "pendingLdapServerMetadata"
        case pendingSecurityGroups = "pendingSecurityGroups"
        case publiclyAccessible = "publiclyAccessible"
        case securityGroups = "securityGroups"
        case storageType = "storageType"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case users = "users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let brokerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerArn)
        brokerArn = brokerArnDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let brokerInstancesContainer = try containerValues.decodeIfPresent([MqClientTypes.BrokerInstance?].self, forKey: .brokerInstances)
        var brokerInstancesDecoded0:[MqClientTypes.BrokerInstance]? = nil
        if let brokerInstancesContainer = brokerInstancesContainer {
            brokerInstancesDecoded0 = [MqClientTypes.BrokerInstance]()
            for structure0 in brokerInstancesContainer {
                if let structure0 = structure0 {
                    brokerInstancesDecoded0?.append(structure0)
                }
            }
        }
        brokerInstances = brokerInstancesDecoded0
        let brokerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerName)
        brokerName = brokerNameDecoded
        let brokerStateDecoded = try containerValues.decodeIfPresent(MqClientTypes.BrokerState.self, forKey: .brokerState)
        brokerState = brokerStateDecoded
        let configurationsDecoded = try containerValues.decodeIfPresent(MqClientTypes.Configurations.self, forKey: .configurations)
        configurations = configurationsDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let deploymentModeDecoded = try containerValues.decodeIfPresent(MqClientTypes.DeploymentMode.self, forKey: .deploymentMode)
        deploymentMode = deploymentModeDecoded
        let encryptionOptionsDecoded = try containerValues.decodeIfPresent(MqClientTypes.EncryptionOptions.self, forKey: .encryptionOptions)
        encryptionOptions = encryptionOptionsDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.LdapServerMetadataOutput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(MqClientTypes.LogsSummary.self, forKey: .logs)
        logs = logsDecoded
        let maintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(MqClientTypes.WeeklyStartTime.self, forKey: .maintenanceWindowStartTime)
        maintenanceWindowStartTime = maintenanceWindowStartTimeDecoded
        let pendingAuthenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .pendingAuthenticationStrategy)
        pendingAuthenticationStrategy = pendingAuthenticationStrategyDecoded
        let pendingEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pendingEngineVersion)
        pendingEngineVersion = pendingEngineVersionDecoded
        let pendingHostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pendingHostInstanceType)
        pendingHostInstanceType = pendingHostInstanceTypeDecoded
        let pendingLdapServerMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.LdapServerMetadataOutput.self, forKey: .pendingLdapServerMetadata)
        pendingLdapServerMetadata = pendingLdapServerMetadataDecoded
        let pendingSecurityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pendingSecurityGroups)
        var pendingSecurityGroupsDecoded0:[Swift.String]? = nil
        if let pendingSecurityGroupsContainer = pendingSecurityGroupsContainer {
            pendingSecurityGroupsDecoded0 = [Swift.String]()
            for string0 in pendingSecurityGroupsContainer {
                if let string0 = string0 {
                    pendingSecurityGroupsDecoded0?.append(string0)
                }
            }
        }
        pendingSecurityGroups = pendingSecurityGroupsDecoded0
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let storageTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.BrokerStorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([MqClientTypes.UserSummary?].self, forKey: .users)
        var usersDecoded0:[MqClientTypes.UserSummary]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [MqClientTypes.UserSummary]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension DescribeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationId = configurationId else {
            return nil
        }
        return "/v1/configurations/\(configurationId.urlPercentEncoding())"
    }
}

public struct DescribeConfigurationInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?

    public init (
        configurationId: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
    }
}

struct DescribeConfigurationInputBody: Swift.Equatable {
}

extension DescribeConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authenticationStrategy = output.authenticationStrategy
            self.created = output.created
            self.description = output.description
            self.engineType = output.engineType
            self.engineVersion = output.engineVersion
            self.id = output.id
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.authenticationStrategy = nil
            self.created = nil
            self.description = nil
            self.engineType = nil
            self.engineVersion = nil
            self.id = nil
            self.latestRevision = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct DescribeConfigurationOutputResponse: Swift.Equatable {
    /// Required. The ARN of the configuration.
    public var arn: Swift.String?
    /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Required. The date and time of the configuration revision.
    public var created: ClientRuntime.Date?
    /// Required. The description of the configuration.
    public var description: Swift.String?
    /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    public var engineType: MqClientTypes.EngineType?
    /// Required. The broker engine's version. For a list of supported engine versions, see, [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
    public var engineVersion: Swift.String?
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public var id: Swift.String?
    /// Required. The latest revision of the configuration.
    public var latestRevision: MqClientTypes.ConfigurationRevision?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public var name: Swift.String?
    /// The list of all tags associated with this configuration.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        created: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        id: Swift.String? = nil,
        latestRevision: MqClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.authenticationStrategy = authenticationStrategy
        self.created = created
        self.description = description
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
        self.tags = tags
    }
}

struct DescribeConfigurationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let created: ClientRuntime.Date?
    let description: Swift.String?
    let engineType: MqClientTypes.EngineType?
    let engineVersion: Swift.String?
    let id: Swift.String?
    let latestRevision: MqClientTypes.ConfigurationRevision?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authenticationStrategy = "authenticationStrategy"
        case created = "created"
        case description = "description"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeConfigurationRevisionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationId = configurationId else {
            return nil
        }
        guard let configurationRevision = configurationRevision else {
            return nil
        }
        return "/v1/configurations/\(configurationId.urlPercentEncoding())/revisions/\(configurationRevision.urlPercentEncoding())"
    }
}

public struct DescribeConfigurationRevisionInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?
    /// The revision of the configuration.
    /// This member is required.
    public var configurationRevision: Swift.String?

    public init (
        configurationId: Swift.String? = nil,
        configurationRevision: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.configurationRevision = configurationRevision
    }
}

struct DescribeConfigurationRevisionInputBody: Swift.Equatable {
}

extension DescribeConfigurationRevisionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeConfigurationRevisionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationRevisionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationRevisionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationRevisionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConfigurationRevisionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationId = output.configurationId
            self.created = output.created
            self.data = output.data
            self.description = output.description
        } else {
            self.configurationId = nil
            self.created = nil
            self.data = nil
            self.description = nil
        }
    }
}

public struct DescribeConfigurationRevisionOutputResponse: Swift.Equatable {
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public var configurationId: Swift.String?
    /// Required. The date and time of the configuration.
    public var created: ClientRuntime.Date?
    /// Required. The base64-encoded XML configuration.
    public var data: Swift.String?
    /// The description of the configuration.
    public var description: Swift.String?

    public init (
        configurationId: Swift.String? = nil,
        created: ClientRuntime.Date? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.created = created
        self.data = data
        self.description = description
    }
}

struct DescribeConfigurationRevisionOutputResponseBody: Swift.Equatable {
    let configurationId: Swift.String?
    let created: ClientRuntime.Date?
    let data: Swift.String?
    let description: Swift.String?
}

extension DescribeConfigurationRevisionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId = "configurationId"
        case created = "created"
        case data = "data"
        case description = "description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DescribeUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        guard let username = username else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
    }
}

public struct DescribeUserInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init (
        brokerId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.username = username
    }
}

struct DescribeUserInputBody: Swift.Equatable {
}

extension DescribeUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.brokerId = output.brokerId
            self.consoleAccess = output.consoleAccess
            self.groups = output.groups
            self.pending = output.pending
            self.username = output.username
        } else {
            self.brokerId = nil
            self.consoleAccess = nil
            self.groups = nil
            self.pending = nil
            self.username = nil
        }
    }
}

public struct DescribeUserOutputResponse: Swift.Equatable {
    /// Required. The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
    public var consoleAccess: Swift.Bool?
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var groups: [Swift.String]?
    /// The status of the changes pending for the ActiveMQ user.
    public var pending: MqClientTypes.UserPendingChanges?
    /// Required. The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var username: Swift.String?

    public init (
        brokerId: Swift.String? = nil,
        consoleAccess: Swift.Bool? = nil,
        groups: [Swift.String]? = nil,
        pending: MqClientTypes.UserPendingChanges? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.pending = pending
        self.username = username
    }
}

struct DescribeUserOutputResponseBody: Swift.Equatable {
    let brokerId: Swift.String?
    let consoleAccess: Swift.Bool?
    let groups: [Swift.String]?
    let pending: MqClientTypes.UserPendingChanges?
    let username: Swift.String?
}

extension DescribeUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerId = "brokerId"
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case pending = "pending"
        case username = "username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let consoleAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let pendingDecoded = try containerValues.decodeIfPresent(MqClientTypes.UserPendingChanges.self, forKey: .pending)
        pending = pendingDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension MqClientTypes.EncryptionOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "kmsKeyId"
        case useAwsOwnedKey = "useAwsOwnedKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let useAwsOwnedKey = useAwsOwnedKey {
            try encodeContainer.encode(useAwsOwnedKey, forKey: .useAwsOwnedKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let useAwsOwnedKeyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useAwsOwnedKey)
        useAwsOwnedKey = useAwsOwnedKeyDecoded
    }
}

extension MqClientTypes {
    /// Does not apply to RabbitMQ brokers. Encryption options for the broker.
    public struct EncryptionOptions: Swift.Equatable {
        /// The customer master key (CMK) to use for the AWS Key Management Service (KMS). This key is used to encrypt your data at rest. If not provided, Amazon MQ will use a default CMK to encrypt your data.
        public var kmsKeyId: Swift.String?
        /// Enables the use of an AWS owned CMK using AWS Key Management Service (KMS). Set to true by default, if no value is provided, for example, for RabbitMQ brokers.
        /// This member is required.
        public var useAwsOwnedKey: Swift.Bool?

        public init (
            kmsKeyId: Swift.String? = nil,
            useAwsOwnedKey: Swift.Bool? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.useAwsOwnedKey = useAwsOwnedKey
        }
    }

}

extension MqClientTypes {
    /// The type of broker engine. Amazon MQ supports ActiveMQ and RabbitMQ.
    public enum EngineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activemq
        case rabbitmq
        case sdkUnknown(Swift.String)

        public static var allCases: [EngineType] {
            return [
                .activemq,
                .rabbitmq,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activemq: return "ACTIVEMQ"
            case .rabbitmq: return "RABBITMQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EngineType(rawValue: rawValue) ?? EngineType.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes.EngineVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MqClientTypes {
    /// Id of the engine version.
    public struct EngineVersion: Swift.Equatable {
        /// Id for the version.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The attribute which caused the error.
    public var errorAttribute: Swift.String?
    /// The explanation of the error.
    public var message: Swift.String?

    public init (
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let errorAttribute: Swift.String?
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The attribute which caused the error.
    public var errorAttribute: Swift.String?
    /// The explanation of the error.
    public var message: Swift.String?

    public init (
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let errorAttribute: Swift.String?
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MqClientTypes.LdapServerMetadataInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hosts = "hosts"
        case roleBase = "roleBase"
        case roleName = "roleName"
        case roleSearchMatching = "roleSearchMatching"
        case roleSearchSubtree = "roleSearchSubtree"
        case serviceAccountPassword = "serviceAccountPassword"
        case serviceAccountUsername = "serviceAccountUsername"
        case userBase = "userBase"
        case userRoleName = "userRoleName"
        case userSearchMatching = "userSearchMatching"
        case userSearchSubtree = "userSearchSubtree"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hosts = hosts {
            var hostsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hosts)
            for __listof__string0 in hosts {
                try hostsContainer.encode(__listof__string0)
            }
        }
        if let roleBase = roleBase {
            try encodeContainer.encode(roleBase, forKey: .roleBase)
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let roleSearchMatching = roleSearchMatching {
            try encodeContainer.encode(roleSearchMatching, forKey: .roleSearchMatching)
        }
        if let roleSearchSubtree = roleSearchSubtree {
            try encodeContainer.encode(roleSearchSubtree, forKey: .roleSearchSubtree)
        }
        if let serviceAccountPassword = serviceAccountPassword {
            try encodeContainer.encode(serviceAccountPassword, forKey: .serviceAccountPassword)
        }
        if let serviceAccountUsername = serviceAccountUsername {
            try encodeContainer.encode(serviceAccountUsername, forKey: .serviceAccountUsername)
        }
        if let userBase = userBase {
            try encodeContainer.encode(userBase, forKey: .userBase)
        }
        if let userRoleName = userRoleName {
            try encodeContainer.encode(userRoleName, forKey: .userRoleName)
        }
        if let userSearchMatching = userSearchMatching {
            try encodeContainer.encode(userSearchMatching, forKey: .userSearchMatching)
        }
        if let userSearchSubtree = userSearchSubtree {
            try encodeContainer.encode(userSearchSubtree, forKey: .userSearchSubtree)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hosts)
        var hostsDecoded0:[Swift.String]? = nil
        if let hostsContainer = hostsContainer {
            hostsDecoded0 = [Swift.String]()
            for string0 in hostsContainer {
                if let string0 = string0 {
                    hostsDecoded0?.append(string0)
                }
            }
        }
        hosts = hostsDecoded0
        let roleBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleBase)
        roleBase = roleBaseDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleSearchMatchingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleSearchMatching)
        roleSearchMatching = roleSearchMatchingDecoded
        let roleSearchSubtreeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .roleSearchSubtree)
        roleSearchSubtree = roleSearchSubtreeDecoded
        let serviceAccountPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccountPassword)
        serviceAccountPassword = serviceAccountPasswordDecoded
        let serviceAccountUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccountUsername)
        serviceAccountUsername = serviceAccountUsernameDecoded
        let userBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userBase)
        userBase = userBaseDecoded
        let userRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userRoleName)
        userRoleName = userRoleNameDecoded
        let userSearchMatchingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSearchMatching)
        userSearchMatching = userSearchMatchingDecoded
        let userSearchSubtreeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userSearchSubtree)
        userSearchSubtree = userSearchSubtreeDecoded
    }
}

extension MqClientTypes {
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public struct LdapServerMetadataInput: Swift.Equatable {
        /// Specifies the location of the LDAP server such as AWS Directory Service for Microsoft Active Directory . Optional failover server.
        /// This member is required.
        public var hosts: [Swift.String]?
        /// The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, ou=group, ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var roleBase: Swift.String?
        /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
        public var roleName: Swift.String?
        /// The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the {0} placeholder in the search filter. The client's username is substituted into the {1} placeholder. For example, if you set this option to (member=uid={1})for the user janedoe, the search filter becomes (member=uid=janedoe) after string substitution. It matches all role entries that have a member attribute equal to uid=janedoe under the subtree selected by the roleBase.
        /// This member is required.
        public var roleSearchMatching: Swift.String?
        /// The directory search scope for the role. If set to true, scope is to search the entire subtree.
        public var roleSearchSubtree: Swift.Bool?
        /// Service account password. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example, dc=com.
        /// This member is required.
        public var serviceAccountPassword: Swift.String?
        /// Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example, dc=com.
        /// This member is required.
        public var serviceAccountUsername: Swift.String?
        /// Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to ou=Users,ou=corp, dc=corp, dc=example, dc=com, the search for user entries is restricted to the subtree beneath ou=Users, ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var userBase: Swift.String?
        /// Specifies the name of the LDAP attribute for the user group membership.
        public var userRoleName: Swift.String?
        /// The LDAP search filter used to find users within the userBase. The client's username is substituted into the {0} placeholder in the search filter. For example, if this option is set to (uid={0}) and the received username is janedoe, the search filter becomes (uid=janedoe) after string substitution. It will result in matching an entry like uid=janedoe, ou=Users,ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var userSearchMatching: Swift.String?
        /// The directory search scope for the user. If set to true, scope is to search the entire subtree.
        public var userSearchSubtree: Swift.Bool?

        public init (
            hosts: [Swift.String]? = nil,
            roleBase: Swift.String? = nil,
            roleName: Swift.String? = nil,
            roleSearchMatching: Swift.String? = nil,
            roleSearchSubtree: Swift.Bool? = nil,
            serviceAccountPassword: Swift.String? = nil,
            serviceAccountUsername: Swift.String? = nil,
            userBase: Swift.String? = nil,
            userRoleName: Swift.String? = nil,
            userSearchMatching: Swift.String? = nil,
            userSearchSubtree: Swift.Bool? = nil
        )
        {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountPassword = serviceAccountPassword
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }
    }

}

extension MqClientTypes.LdapServerMetadataOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hosts = "hosts"
        case roleBase = "roleBase"
        case roleName = "roleName"
        case roleSearchMatching = "roleSearchMatching"
        case roleSearchSubtree = "roleSearchSubtree"
        case serviceAccountUsername = "serviceAccountUsername"
        case userBase = "userBase"
        case userRoleName = "userRoleName"
        case userSearchMatching = "userSearchMatching"
        case userSearchSubtree = "userSearchSubtree"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hosts = hosts {
            var hostsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hosts)
            for __listof__string0 in hosts {
                try hostsContainer.encode(__listof__string0)
            }
        }
        if let roleBase = roleBase {
            try encodeContainer.encode(roleBase, forKey: .roleBase)
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let roleSearchMatching = roleSearchMatching {
            try encodeContainer.encode(roleSearchMatching, forKey: .roleSearchMatching)
        }
        if let roleSearchSubtree = roleSearchSubtree {
            try encodeContainer.encode(roleSearchSubtree, forKey: .roleSearchSubtree)
        }
        if let serviceAccountUsername = serviceAccountUsername {
            try encodeContainer.encode(serviceAccountUsername, forKey: .serviceAccountUsername)
        }
        if let userBase = userBase {
            try encodeContainer.encode(userBase, forKey: .userBase)
        }
        if let userRoleName = userRoleName {
            try encodeContainer.encode(userRoleName, forKey: .userRoleName)
        }
        if let userSearchMatching = userSearchMatching {
            try encodeContainer.encode(userSearchMatching, forKey: .userSearchMatching)
        }
        if let userSearchSubtree = userSearchSubtree {
            try encodeContainer.encode(userSearchSubtree, forKey: .userSearchSubtree)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hosts)
        var hostsDecoded0:[Swift.String]? = nil
        if let hostsContainer = hostsContainer {
            hostsDecoded0 = [Swift.String]()
            for string0 in hostsContainer {
                if let string0 = string0 {
                    hostsDecoded0?.append(string0)
                }
            }
        }
        hosts = hostsDecoded0
        let roleBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleBase)
        roleBase = roleBaseDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleSearchMatchingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleSearchMatching)
        roleSearchMatching = roleSearchMatchingDecoded
        let roleSearchSubtreeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .roleSearchSubtree)
        roleSearchSubtree = roleSearchSubtreeDecoded
        let serviceAccountUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccountUsername)
        serviceAccountUsername = serviceAccountUsernameDecoded
        let userBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userBase)
        userBase = userBaseDecoded
        let userRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userRoleName)
        userRoleName = userRoleNameDecoded
        let userSearchMatchingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSearchMatching)
        userSearchMatching = userSearchMatchingDecoded
        let userSearchSubtreeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userSearchSubtree)
        userSearchSubtree = userSearchSubtreeDecoded
    }
}

extension MqClientTypes {
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker.
    public struct LdapServerMetadataOutput: Swift.Equatable {
        /// Specifies the location of the LDAP server such as AWS Directory Service for Microsoft Active Directory . Optional failover server.
        /// This member is required.
        public var hosts: [Swift.String]?
        /// The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, ou=group, ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var roleBase: Swift.String?
        /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
        public var roleName: Swift.String?
        /// The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the {0} placeholder in the search filter. The client's username is substituted into the {1} placeholder. For example, if you set this option to (member=uid={1})for the user janedoe, the search filter becomes (member=uid=janedoe) after string substitution. It matches all role entries that have a member attribute equal to uid=janedoe under the subtree selected by the roleBase.
        /// This member is required.
        public var roleSearchMatching: Swift.String?
        /// The directory search scope for the role. If set to true, scope is to search the entire subtree.
        public var roleSearchSubtree: Swift.Bool?
        /// Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example, dc=com.
        /// This member is required.
        public var serviceAccountUsername: Swift.String?
        /// Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to ou=Users,ou=corp, dc=corp, dc=example, dc=com, the search for user entries is restricted to the subtree beneath ou=Users, ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var userBase: Swift.String?
        /// Specifies the name of the LDAP attribute for the user group membership.
        public var userRoleName: Swift.String?
        /// The LDAP search filter used to find users within the userBase. The client's username is substituted into the {0} placeholder in the search filter. For example, if this option is set to (uid={0}) and the received username is janedoe, the search filter becomes (uid=janedoe) after string substitution. It will result in matching an entry like uid=janedoe, ou=Users,ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var userSearchMatching: Swift.String?
        /// The directory search scope for the user. If set to true, scope is to search the entire subtree.
        public var userSearchSubtree: Swift.Bool?

        public init (
            hosts: [Swift.String]? = nil,
            roleBase: Swift.String? = nil,
            roleName: Swift.String? = nil,
            roleSearchMatching: Swift.String? = nil,
            roleSearchSubtree: Swift.Bool? = nil,
            serviceAccountUsername: Swift.String? = nil,
            userBase: Swift.String? = nil,
            userRoleName: Swift.String? = nil,
            userSearchMatching: Swift.String? = nil,
            userSearchSubtree: Swift.Bool? = nil
        )
        {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }
    }

}

extension ListBrokersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListBrokersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/brokers"
    }
}

public struct ListBrokersInput: Swift.Equatable {
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBrokersInputBody: Swift.Equatable {
}

extension ListBrokersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBrokersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBrokersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBrokersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBrokersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBrokersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.brokerSummaries = output.brokerSummaries
            self.nextToken = output.nextToken
        } else {
            self.brokerSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListBrokersOutputResponse: Swift.Equatable {
    /// A list of information about all brokers.
    public var brokerSummaries: [MqClientTypes.BrokerSummary]?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        brokerSummaries: [MqClientTypes.BrokerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerSummaries = brokerSummaries
        self.nextToken = nextToken
    }
}

struct ListBrokersOutputResponseBody: Swift.Equatable {
    let brokerSummaries: [MqClientTypes.BrokerSummary]?
    let nextToken: Swift.String?
}

extension ListBrokersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerSummaries = "brokerSummaries"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerSummariesContainer = try containerValues.decodeIfPresent([MqClientTypes.BrokerSummary?].self, forKey: .brokerSummaries)
        var brokerSummariesDecoded0:[MqClientTypes.BrokerSummary]? = nil
        if let brokerSummariesContainer = brokerSummariesContainer {
            brokerSummariesDecoded0 = [MqClientTypes.BrokerSummary]()
            for structure0 in brokerSummariesContainer {
                if let structure0 = structure0 {
                    brokerSummariesDecoded0?.append(structure0)
                }
            }
        }
        brokerSummaries = brokerSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConfigurationRevisionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConfigurationRevisionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationId = configurationId else {
            return nil
        }
        return "/v1/configurations/\(configurationId.urlPercentEncoding())/revisions"
    }
}

public struct ListConfigurationRevisionsInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        configurationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationRevisionsInputBody: Swift.Equatable {
}

extension ListConfigurationRevisionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationRevisionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationRevisionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationRevisionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationRevisionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConfigurationRevisionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationId = output.configurationId
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.revisions = output.revisions
        } else {
            self.configurationId = nil
            self.maxResults = nil
            self.nextToken = nil
            self.revisions = nil
        }
    }
}

public struct ListConfigurationRevisionsOutputResponse: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    public var configurationId: Swift.String?
    /// The maximum number of configuration revisions that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?
    /// The list of all revisions for the specified configuration.
    public var revisions: [MqClientTypes.ConfigurationRevision]?

    public init (
        configurationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        revisions: [MqClientTypes.ConfigurationRevision]? = nil
    )
    {
        self.configurationId = configurationId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.revisions = revisions
    }
}

struct ListConfigurationRevisionsOutputResponseBody: Swift.Equatable {
    let configurationId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let revisions: [MqClientTypes.ConfigurationRevision]?
}

extension ListConfigurationRevisionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId = "configurationId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case revisions = "revisions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let revisionsContainer = try containerValues.decodeIfPresent([MqClientTypes.ConfigurationRevision?].self, forKey: .revisions)
        var revisionsDecoded0:[MqClientTypes.ConfigurationRevision]? = nil
        if let revisionsContainer = revisionsContainer {
            revisionsDecoded0 = [MqClientTypes.ConfigurationRevision]()
            for structure0 in revisionsContainer {
                if let structure0 = structure0 {
                    revisionsDecoded0?.append(structure0)
                }
            }
        }
        revisions = revisionsDecoded0
    }
}

extension ListConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/configurations"
    }
}

public struct ListConfigurationsInput: Swift.Equatable {
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationsInputBody: Swift.Equatable {
}

extension ListConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurations = output.configurations
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.configurations = nil
            self.maxResults = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationsOutputResponse: Swift.Equatable {
    /// The list of all revisions for the specified configuration.
    public var configurations: [MqClientTypes.Configuration]?
    /// The maximum number of configurations that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        configurations: [MqClientTypes.Configuration]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurations = configurations
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationsOutputResponseBody: Swift.Equatable {
    let configurations: [MqClientTypes.Configuration]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations = "configurations"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([MqClientTypes.Configuration?].self, forKey: .configurations)
        var configurationsDecoded0:[MqClientTypes.Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [MqClientTypes.Configuration]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsInputBody: Swift.Equatable {
}

extension ListTagsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Swift.Equatable {
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/users"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        brokerId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsersInputBody: Swift.Equatable {
}

extension ListUsersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.brokerId = output.brokerId
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.brokerId = nil
            self.maxResults = nil
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutputResponse: Swift.Equatable {
    /// Required. The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// Required. The maximum number of ActiveMQ users that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?
    /// Required. The list of all ActiveMQ usernames for the specified broker. Does not apply to RabbitMQ brokers.
    public var users: [MqClientTypes.UserSummary]?

    public init (
        brokerId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        users: [MqClientTypes.UserSummary]? = nil
    )
    {
        self.brokerId = brokerId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Swift.Equatable {
    let brokerId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let users: [MqClientTypes.UserSummary]?
}

extension ListUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerId = "brokerId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case users = "users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let usersContainer = try containerValues.decodeIfPresent([MqClientTypes.UserSummary?].self, forKey: .users)
        var usersDecoded0:[MqClientTypes.UserSummary]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [MqClientTypes.UserSummary]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension MqClientTypes.Logs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audit = "audit"
        case general = "general"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audit = audit {
            try encodeContainer.encode(audit, forKey: .audit)
        }
        if let general = general {
            try encodeContainer.encode(general, forKey: .general)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .audit)
        audit = auditDecoded
        let generalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .general)
        general = generalDecoded
    }
}

extension MqClientTypes {
    /// The list of information about logs to be enabled for the specified broker.
    public struct Logs: Swift.Equatable {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged. Does not apply to RabbitMQ brokers.
        public var audit: Swift.Bool?
        /// Enables general logging.
        public var general: Swift.Bool?

        public init (
            audit: Swift.Bool? = nil,
            general: Swift.Bool? = nil
        )
        {
            self.audit = audit
            self.general = general
        }
    }

}

extension MqClientTypes.LogsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audit = "audit"
        case auditLogGroup = "auditLogGroup"
        case general = "general"
        case generalLogGroup = "generalLogGroup"
        case pending = "pending"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audit = audit {
            try encodeContainer.encode(audit, forKey: .audit)
        }
        if let auditLogGroup = auditLogGroup {
            try encodeContainer.encode(auditLogGroup, forKey: .auditLogGroup)
        }
        if let general = general {
            try encodeContainer.encode(general, forKey: .general)
        }
        if let generalLogGroup = generalLogGroup {
            try encodeContainer.encode(generalLogGroup, forKey: .generalLogGroup)
        }
        if let pending = pending {
            try encodeContainer.encode(pending, forKey: .pending)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .audit)
        audit = auditDecoded
        let auditLogGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditLogGroup)
        auditLogGroup = auditLogGroupDecoded
        let generalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .general)
        general = generalDecoded
        let generalLogGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generalLogGroup)
        generalLogGroup = generalLogGroupDecoded
        let pendingDecoded = try containerValues.decodeIfPresent(MqClientTypes.PendingLogs.self, forKey: .pending)
        pending = pendingDecoded
    }
}

extension MqClientTypes {
    /// The list of information about logs currently enabled and pending to be deployed for the specified broker.
    public struct LogsSummary: Swift.Equatable {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
        public var audit: Swift.Bool?
        /// The location of the CloudWatch Logs log group where audit logs are sent.
        public var auditLogGroup: Swift.String?
        /// Enables general logging.
        /// This member is required.
        public var general: Swift.Bool?
        /// The location of the CloudWatch Logs log group where general logs are sent.
        /// This member is required.
        public var generalLogGroup: Swift.String?
        /// The list of information about logs pending to be deployed for the specified broker.
        public var pending: MqClientTypes.PendingLogs?

        public init (
            audit: Swift.Bool? = nil,
            auditLogGroup: Swift.String? = nil,
            general: Swift.Bool? = nil,
            generalLogGroup: Swift.String? = nil,
            pending: MqClientTypes.PendingLogs? = nil
        )
        {
            self.audit = audit
            self.auditLogGroup = auditLogGroup
            self.general = general
            self.generalLogGroup = generalLogGroup
            self.pending = pending
        }
    }

}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The attribute which caused the error.
    public var errorAttribute: Swift.String?
    /// The explanation of the error.
    public var message: Swift.String?

    public init (
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let errorAttribute: Swift.String?
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MqClientTypes.PendingLogs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audit = "audit"
        case general = "general"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audit = audit {
            try encodeContainer.encode(audit, forKey: .audit)
        }
        if let general = general {
            try encodeContainer.encode(general, forKey: .general)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .audit)
        audit = auditDecoded
        let generalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .general)
        general = generalDecoded
    }
}

extension MqClientTypes {
    /// The list of information about logs to be enabled for the specified broker.
    public struct PendingLogs: Swift.Equatable {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
        public var audit: Swift.Bool?
        /// Enables general logging.
        public var general: Swift.Bool?

        public init (
            audit: Swift.Bool? = nil,
            general: Swift.Bool? = nil
        )
        {
            self.audit = audit
            self.general = general
        }
    }

}

extension RebootBrokerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/reboot"
    }
}

public struct RebootBrokerInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?

    public init (
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct RebootBrokerInputBody: Swift.Equatable {
}

extension RebootBrokerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RebootBrokerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootBrokerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootBrokerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootBrokerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RebootBrokerOutputResponse: Swift.Equatable {

}

extension MqClientTypes.SanitizationWarning: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "attributeName"
        case elementName = "elementName"
        case reason = "reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let elementName = elementName {
            try encodeContainer.encode(elementName, forKey: .elementName)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let elementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elementName)
        elementName = elementNameDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(MqClientTypes.SanitizationWarningReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension MqClientTypes {
    /// Returns information about the XML element or attribute that was sanitized in the configuration.
    public struct SanitizationWarning: Swift.Equatable {
        /// The name of the XML attribute that has been sanitized.
        public var attributeName: Swift.String?
        /// The name of the XML element that has been sanitized.
        public var elementName: Swift.String?
        /// Required. The reason for which the XML elements or attributes were sanitized.
        /// This member is required.
        public var reason: MqClientTypes.SanitizationWarningReason?

        public init (
            attributeName: Swift.String? = nil,
            elementName: Swift.String? = nil,
            reason: MqClientTypes.SanitizationWarningReason? = nil
        )
        {
            self.attributeName = attributeName
            self.elementName = elementName
            self.reason = reason
        }
    }

}

extension MqClientTypes {
    /// The reason for which the XML elements or attributes were sanitized.
    public enum SanitizationWarningReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disallowedAttributeRemoved
        case disallowedElementRemoved
        case invalidAttributeValueRemoved
        case sdkUnknown(Swift.String)

        public static var allCases: [SanitizationWarningReason] {
            return [
                .disallowedAttributeRemoved,
                .disallowedElementRemoved,
                .invalidAttributeValueRemoved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disallowedAttributeRemoved: return "DISALLOWED_ATTRIBUTE_REMOVED"
            case .disallowedElementRemoved: return "DISALLOWED_ELEMENT_REMOVED"
            case .invalidAttributeValueRemoved: return "INVALID_ATTRIBUTE_VALUE_REMOVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SanitizationWarningReason(rawValue: rawValue) ?? SanitizationWarningReason.sdkUnknown(rawValue)
        }
    }
}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The attribute which caused the error.
    public var errorAttribute: Swift.String?
    /// The explanation of the error.
    public var message: Swift.String?

    public init (
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let errorAttribute: Swift.String?
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateBrokerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case configuration = "configuration"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case securityGroups = "securityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationStrategy = authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let hostInstanceType = hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
        if let ldapServerMetadata = ldapServerMetadata {
            try encodeContainer.encode(ldapServerMetadata, forKey: .ldapServerMetadata)
        }
        if let logs = logs {
            try encodeContainer.encode(logs, forKey: .logs)
        }
        if let maintenanceWindowStartTime = maintenanceWindowStartTime {
            try encodeContainer.encode(maintenanceWindowStartTime, forKey: .maintenanceWindowStartTime)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for __listof__string0 in securityGroups {
                try securityGroupsContainer.encode(__listof__string0)
            }
        }
    }
}

extension UpdateBrokerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())"
    }
}

/// Updates the broker using the specified properties.
public struct UpdateBrokerInput: Swift.Equatable {
    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Enables automatic upgrades to new minor versions for brokers, as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window of the broker or after a manual broker reboot.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// A list of information about the configuration.
    public var configuration: MqClientTypes.ConfigurationId?
    /// The broker engine version. For a list of supported engine versions, see [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
    public var engineVersion: Swift.String?
    /// The broker's host instance type to upgrade to. For a list of supported instance types, see [Broker instance types](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker.html#broker-instance-types).
    public var hostInstanceType: Swift.String?
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataInput?
    /// Enables Amazon CloudWatch logging for brokers.
    public var logs: MqClientTypes.Logs?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
    public var securityGroups: [Swift.String]?

    public init (
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerId: Swift.String? = nil,
        configuration: MqClientTypes.ConfigurationId? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataInput? = nil,
        logs: MqClientTypes.Logs? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerId = brokerId
        self.configuration = configuration
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.securityGroups = securityGroups
    }
}

struct UpdateBrokerInputBody: Swift.Equatable {
    let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let autoMinorVersionUpgrade: Swift.Bool?
    let configuration: MqClientTypes.ConfigurationId?
    let engineVersion: Swift.String?
    let hostInstanceType: Swift.String?
    let ldapServerMetadata: MqClientTypes.LdapServerMetadataInput?
    let logs: MqClientTypes.Logs?
    let maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    let securityGroups: [Swift.String]?
}

extension UpdateBrokerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case configuration = "configuration"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case securityGroups = "securityGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationId.self, forKey: .configuration)
        configuration = configurationDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.LdapServerMetadataInput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(MqClientTypes.Logs.self, forKey: .logs)
        logs = logsDecoded
        let maintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(MqClientTypes.WeeklyStartTime.self, forKey: .maintenanceWindowStartTime)
        maintenanceWindowStartTime = maintenanceWindowStartTimeDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension UpdateBrokerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBrokerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBrokerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBrokerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBrokerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authenticationStrategy = output.authenticationStrategy
            self.autoMinorVersionUpgrade = output.autoMinorVersionUpgrade
            self.brokerId = output.brokerId
            self.configuration = output.configuration
            self.engineVersion = output.engineVersion
            self.hostInstanceType = output.hostInstanceType
            self.ldapServerMetadata = output.ldapServerMetadata
            self.logs = output.logs
            self.maintenanceWindowStartTime = output.maintenanceWindowStartTime
            self.securityGroups = output.securityGroups
        } else {
            self.authenticationStrategy = nil
            self.autoMinorVersionUpgrade = nil
            self.brokerId = nil
            self.configuration = nil
            self.engineVersion = nil
            self.hostInstanceType = nil
            self.ldapServerMetadata = nil
            self.logs = nil
            self.maintenanceWindowStartTime = nil
            self.securityGroups = nil
        }
    }
}

public struct UpdateBrokerOutputResponse: Swift.Equatable {
    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// The new boolean value that specifies whether broker engines automatically upgrade to new minor versions as new versions are released and supported by Amazon MQ.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// Required. The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// The ID of the updated configuration.
    public var configuration: MqClientTypes.ConfigurationId?
    /// The broker engine version to upgrade to. For a list of supported engine versions, see [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
    public var engineVersion: Swift.String?
    /// The broker's host instance type to upgrade to. For a list of supported instance types, see [Broker instance types](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker.html#broker-instance-types).
    public var hostInstanceType: Swift.String?
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    /// The list of information about logs to be enabled for the specified broker.
    public var logs: MqClientTypes.Logs?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
    public var securityGroups: [Swift.String]?

    public init (
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerId: Swift.String? = nil,
        configuration: MqClientTypes.ConfigurationId? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput? = nil,
        logs: MqClientTypes.Logs? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerId = brokerId
        self.configuration = configuration
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.securityGroups = securityGroups
    }
}

struct UpdateBrokerOutputResponseBody: Swift.Equatable {
    let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let autoMinorVersionUpgrade: Swift.Bool?
    let brokerId: Swift.String?
    let configuration: MqClientTypes.ConfigurationId?
    let engineVersion: Swift.String?
    let hostInstanceType: Swift.String?
    let ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    let logs: MqClientTypes.Logs?
    let maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    let securityGroups: [Swift.String]?
}

extension UpdateBrokerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerId = "brokerId"
        case configuration = "configuration"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case securityGroups = "securityGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationId.self, forKey: .configuration)
        configuration = configurationDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.LdapServerMetadataOutput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(MqClientTypes.Logs.self, forKey: .logs)
        logs = logsDecoded
        let maintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(MqClientTypes.WeeklyStartTime.self, forKey: .maintenanceWindowStartTime)
        maintenanceWindowStartTime = maintenanceWindowStartTimeDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension UpdateConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "data"
        case description = "description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationId = configurationId else {
            return nil
        }
        return "/v1/configurations/\(configurationId.urlPercentEncoding())"
    }
}

/// Updates the specified configuration.
public struct UpdateConfigurationInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?
    /// Required. The base64-encoded XML configuration.
    /// This member is required.
    public var data: Swift.String?
    /// The description of the configuration.
    public var description: Swift.String?

    public init (
        configurationId: Swift.String? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.data = data
        self.description = description
    }
}

struct UpdateConfigurationInputBody: Swift.Equatable {
    let data: Swift.String?
    let description: Swift.String?
}

extension UpdateConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "data"
        case description = "description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.created = output.created
            self.id = output.id
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.warnings = output.warnings
        } else {
            self.arn = nil
            self.created = nil
            self.id = nil
            self.latestRevision = nil
            self.name = nil
            self.warnings = nil
        }
    }
}

public struct UpdateConfigurationOutputResponse: Swift.Equatable {
    /// Required. The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// Required. The date and time of the configuration.
    public var created: ClientRuntime.Date?
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public var id: Swift.String?
    /// The latest revision of the configuration.
    public var latestRevision: MqClientTypes.ConfigurationRevision?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public var name: Swift.String?
    /// The list of the first 20 warnings about the configuration XML elements or attributes that were sanitized.
    public var warnings: [MqClientTypes.SanitizationWarning]?

    public init (
        arn: Swift.String? = nil,
        created: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        latestRevision: MqClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil,
        warnings: [MqClientTypes.SanitizationWarning]? = nil
    )
    {
        self.arn = arn
        self.created = created
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
        self.warnings = warnings
    }
}

struct UpdateConfigurationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let created: ClientRuntime.Date?
    let id: Swift.String?
    let latestRevision: MqClientTypes.ConfigurationRevision?
    let name: Swift.String?
    let warnings: [MqClientTypes.SanitizationWarning]?
}

extension UpdateConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case created = "created"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
        case warnings = "warnings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let warningsContainer = try containerValues.decodeIfPresent([MqClientTypes.SanitizationWarning?].self, forKey: .warnings)
        var warningsDecoded0:[MqClientTypes.SanitizationWarning]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [MqClientTypes.SanitizationWarning]()
            for structure0 in warningsContainer {
                if let structure0 = structure0 {
                    warningsDecoded0?.append(structure0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleAccess = consoleAccess {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __listof__string0 in groups {
                try groupsContainer.encode(__listof__string0)
            }
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        guard let username = username else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
    }
}

/// Updates the information for an ActiveMQ user.
public struct UpdateUserInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
    public var consoleAccess: Swift.Bool?
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var groups: [Swift.String]?
    /// The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
    public var password: Swift.String?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init (
        brokerId: Swift.String? = nil,
        consoleAccess: Swift.Bool? = nil,
        groups: [Swift.String]? = nil,
        password: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.password = password
        self.username = username
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let consoleAccess: Swift.Bool?
    let groups: [Swift.String]?
    let password: Swift.String?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension UpdateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserOutputResponse: Swift.Equatable {

}

extension MqClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
        case username = "username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleAccess = consoleAccess {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __listof__string0 in groups {
                try groupsContainer.encode(__listof__string0)
            }
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension MqClientTypes {
    /// A user associated with the broker. For RabbitMQ brokers, one and only one administrative user is accepted and created when a broker is first provisioned. All subsequent broker users are created by making RabbitMQ API calls directly to brokers or via the RabbitMQ web console.
    public struct User: Swift.Equatable {
        /// Enables access to the ActiveMQ Web Console for the ActiveMQ user. Does not apply to RabbitMQ brokers.
        public var consoleAccess: Swift.Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long. Does not apply to RabbitMQ brokers.
        public var groups: [Swift.String]?
        /// Required. The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
        /// This member is required.
        public var password: Swift.String?
        /// important>Amazon MQ for ActiveMQ For ActiveMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long./important> Amazon MQ for RabbitMQ For RabbitMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores (- . _). This value must not contain a tilde (~) character. Amazon MQ prohibts using guest as a valid usename. This value must be 2-100 characters long.
        /// This member is required.
        public var username: Swift.String?

        public init (
            consoleAccess: Swift.Bool? = nil,
            groups: [Swift.String]? = nil,
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.password = password
            self.username = username
        }
    }

}

extension MqClientTypes.UserPendingChanges: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case pendingChange = "pendingChange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleAccess = consoleAccess {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __listof__string0 in groups {
                try groupsContainer.encode(__listof__string0)
            }
        }
        if let pendingChange = pendingChange {
            try encodeContainer.encode(pendingChange.rawValue, forKey: .pendingChange)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let pendingChangeDecoded = try containerValues.decodeIfPresent(MqClientTypes.ChangeType.self, forKey: .pendingChange)
        pendingChange = pendingChangeDecoded
    }
}

extension MqClientTypes {
    /// Returns information about the status of the changes pending for the ActiveMQ user.
    public struct UserPendingChanges: Swift.Equatable {
        /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
        public var consoleAccess: Swift.Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public var groups: [Swift.String]?
        /// Required. The type of change pending for the ActiveMQ user.
        /// This member is required.
        public var pendingChange: MqClientTypes.ChangeType?

        public init (
            consoleAccess: Swift.Bool? = nil,
            groups: [Swift.String]? = nil,
            pendingChange: MqClientTypes.ChangeType? = nil
        )
        {
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.pendingChange = pendingChange
        }
    }

}

extension MqClientTypes.UserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pendingChange = "pendingChange"
        case username = "username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pendingChange = pendingChange {
            try encodeContainer.encode(pendingChange.rawValue, forKey: .pendingChange)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pendingChangeDecoded = try containerValues.decodeIfPresent(MqClientTypes.ChangeType.self, forKey: .pendingChange)
        pendingChange = pendingChangeDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension MqClientTypes {
    /// Returns a list of all broker users. Does not apply to RabbitMQ brokers.
    public struct UserSummary: Swift.Equatable {
        /// The type of change pending for the broker user.
        public var pendingChange: MqClientTypes.ChangeType?
        /// Required. The username of the broker user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        /// This member is required.
        public var username: Swift.String?

        public init (
            pendingChange: MqClientTypes.ChangeType? = nil,
            username: Swift.String? = nil
        )
        {
            self.pendingChange = pendingChange
            self.username = username
        }
    }

}

extension MqClientTypes.WeeklyStartTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfWeek = "dayOfWeek"
        case timeOfDay = "timeOfDay"
        case timeZone = "timeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfWeek = dayOfWeek {
            try encodeContainer.encode(dayOfWeek.rawValue, forKey: .dayOfWeek)
        }
        if let timeOfDay = timeOfDay {
            try encodeContainer.encode(timeOfDay, forKey: .timeOfDay)
        }
        if let timeZone = timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(MqClientTypes.DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let timeOfDayDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeOfDay)
        timeOfDay = timeOfDayDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
    }
}

extension MqClientTypes {
    /// The scheduled time period relative to UTC during which Amazon MQ begins to apply pending updates or patches to the broker.
    public struct WeeklyStartTime: Swift.Equatable {
        /// Required. The day of the week.
        /// This member is required.
        public var dayOfWeek: MqClientTypes.DayOfWeek?
        /// Required. The time, in 24-hour format.
        /// This member is required.
        public var timeOfDay: Swift.String?
        /// The time zone, UTC by default, in either the Country/City format, or the UTC offset format.
        public var timeZone: Swift.String?

        public init (
            dayOfWeek: MqClientTypes.DayOfWeek? = nil,
            timeOfDay: Swift.String? = nil,
            timeZone: Swift.String? = nil
        )
        {
            self.dayOfWeek = dayOfWeek
            self.timeOfDay = timeOfDay
            self.timeZone = timeZone
        }
    }

}
