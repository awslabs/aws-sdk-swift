// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Access is denied.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CancelChangeSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelChangeSetInput(catalog: \(String(describing: catalog)), changeSetId: \(String(describing: changeSetId)))"}
}

extension CancelChangeSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CancelChangeSetInputHeadersMiddleware: Middleware {
    public let id: String = "CancelChangeSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelChangeSetInput>
    public typealias MOutput = OperationOutput<CancelChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelChangeSetOutputError>
}

public struct CancelChangeSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelChangeSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let changeSetId = input.operationInput.changeSetId {
            let changeSetIdQueryItem = URLQueryItem(name: "changeSetId".urlPercentEncoding(), value: String(changeSetId).urlPercentEncoding())
            input.builder.withQueryItem(changeSetIdQueryItem)
        }
        if let catalog = input.operationInput.catalog {
            let catalogQueryItem = URLQueryItem(name: "catalog".urlPercentEncoding(), value: String(catalog).urlPercentEncoding())
            input.builder.withQueryItem(catalogQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelChangeSetInput>
    public typealias MOutput = OperationOutput<CancelChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelChangeSetOutputError>
}

public struct CancelChangeSetInput: Equatable {
    /// <p>Required. The catalog related to the request. Fixed value:
    ///             <code>AWSMarketplace</code>.</p>
    public let catalog: String?
    /// <p>Required. The unique identifier of the <code>StartChangeSet</code> request that you
    ///             want to cancel.</p>
    public let changeSetId: String?

    public init (
        catalog: String? = nil,
        changeSetId: String? = nil
    )
    {
        self.catalog = catalog
        self.changeSetId = changeSetId
    }
}

struct CancelChangeSetInputBody: Equatable {
}

extension CancelChangeSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelChangeSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelChangeSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelChangeSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelChangeSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelChangeSetOutputResponse(changeSetArn: \(String(describing: changeSetArn)), changeSetId: \(String(describing: changeSetId)))"}
}

extension CancelChangeSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelChangeSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeSetArn = output.changeSetArn
            self.changeSetId = output.changeSetId
        } else {
            self.changeSetArn = nil
            self.changeSetId = nil
        }
    }
}

public struct CancelChangeSetOutputResponse: Equatable {
    /// <p>The ARN associated with the change set referenced in this request.</p>
    public let changeSetArn: String?
    /// <p>The unique identifier for the change set referenced in this request.</p>
    public let changeSetId: String?

    public init (
        changeSetArn: String? = nil,
        changeSetId: String? = nil
    )
    {
        self.changeSetArn = changeSetArn
        self.changeSetId = changeSetId
    }
}

struct CancelChangeSetOutputResponseBody: Equatable {
    public let changeSetId: String?
    public let changeSetArn: String?
}

extension CancelChangeSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeSetArn = "ChangeSetArn"
        case changeSetId = "ChangeSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let changeSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetArn)
        changeSetArn = changeSetArnDecoded
    }
}

extension Change: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeName = "ChangeName"
        case changeType = "ChangeType"
        case details = "Details"
        case entity = "Entity"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeName = changeName {
            try encodeContainer.encode(changeName, forKey: .changeName)
        }
        if let changeType = changeType {
            try encodeContainer.encode(changeType, forKey: .changeType)
        }
        if let details = details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let entity = entity {
            try encodeContainer.encode(entity, forKey: .entity)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let entityDecoded = try containerValues.decodeIfPresent(Entity.self, forKey: .entity)
        entity = entityDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .details)
        details = detailsDecoded
        let changeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeName)
        changeName = changeNameDecoded
    }
}

extension Change: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Change(changeName: \(String(describing: changeName)), changeType: \(String(describing: changeType)), details: \(String(describing: details)), entity: \(String(describing: entity)))"}
}

/// <p>An object that contains the <code>ChangeType</code>, <code>Details</code>, and
///                 <code>Entity</code>.</p>
public struct Change: Equatable {
    /// <p>Optional name for the change.</p>
    public let changeName: String?
    /// <p>Change types are single string values that describe your intention for the change.
    ///             Each change type is unique for each <code>EntityType</code> provided in the change's
    ///             scope.</p>
    public let changeType: String?
    /// <p>This object contains details specific to the change type of the requested
    ///             change.</p>
    public let details: String?
    /// <p>The entity to be changed.</p>
    public let entity: Entity?

    public init (
        changeName: String? = nil,
        changeType: String? = nil,
        details: String? = nil,
        entity: Entity? = nil
    )
    {
        self.changeName = changeName
        self.changeType = changeType
        self.details = details
        self.entity = entity
    }
}

extension ChangeSetSummaryListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeSetArn = "ChangeSetArn"
        case changeSetId = "ChangeSetId"
        case changeSetName = "ChangeSetName"
        case endTime = "EndTime"
        case entityIdList = "EntityIdList"
        case failureCode = "FailureCode"
        case startTime = "StartTime"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeSetArn = changeSetArn {
            try encodeContainer.encode(changeSetArn, forKey: .changeSetArn)
        }
        if let changeSetId = changeSetId {
            try encodeContainer.encode(changeSetId, forKey: .changeSetId)
        }
        if let changeSetName = changeSetName {
            try encodeContainer.encode(changeSetName, forKey: .changeSetName)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let entityIdList = entityIdList {
            var entityIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityIdList)
            for resourceidlist0 in entityIdList {
                try entityIdListContainer.encode(resourceidlist0)
            }
        }
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let changeSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetArn)
        changeSetArn = changeSetArnDecoded
        let changeSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetName)
        changeSetName = changeSetNameDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChangeStatus.self, forKey: .status)
        status = statusDecoded
        let entityIdListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .entityIdList)
        var entityIdListDecoded0:[String]? = nil
        if let entityIdListContainer = entityIdListContainer {
            entityIdListDecoded0 = [String]()
            for string0 in entityIdListContainer {
                if let string0 = string0 {
                    entityIdListDecoded0?.append(string0)
                }
            }
        }
        entityIdList = entityIdListDecoded0
        let failureCodeDecoded = try containerValues.decodeIfPresent(FailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
    }
}

extension ChangeSetSummaryListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChangeSetSummaryListItem(changeSetArn: \(String(describing: changeSetArn)), changeSetId: \(String(describing: changeSetId)), changeSetName: \(String(describing: changeSetName)), endTime: \(String(describing: endTime)), entityIdList: \(String(describing: entityIdList)), failureCode: \(String(describing: failureCode)), startTime: \(String(describing: startTime)), status: \(String(describing: status)))"}
}

/// <p>A summary of a change set returned in a list of change sets when the
///                 <code>ListChangeSets</code> action is called.</p>
public struct ChangeSetSummaryListItem: Equatable {
    /// <p>The ARN associated with the unique identifier for the change set referenced in this
    ///             request.</p>
    public let changeSetArn: String?
    /// <p>The unique identifier for a change set.</p>
    public let changeSetId: String?
    /// <p>The non-unique name for the change set.</p>
    public let changeSetName: String?
    /// <p>The time, in ISO 8601 format (2018-02-27T13:45:22Z), when the change set was
    ///             finished.</p>
    public let endTime: String?
    /// <p>This object is a list of entity IDs (string) that are a part of a change set. The
    ///             entity ID list is a maximum of 20 entities. It must contain at least one entity.</p>
    public let entityIdList: [String]?
    /// <p>Returned if the change set is in <code>FAILED</code> status. Can be either
    ///             <code>CLIENT_ERROR</code>, which means that there are issues with the request (see the
    ///             <code>ErrorDetailList</code> of <code>DescribeChangeSet</code>), or <code>SERVER_FAULT</code>,
    ///         which means that there is a problem in the system, and you should retry your request.</p>
    public let failureCode: FailureCode?
    /// <p>The time, in ISO 8601 format (2018-02-27T13:45:22Z), when the change set was
    ///             started.</p>
    public let startTime: String?
    /// <p>The current status of the change set.</p>
    public let status: ChangeStatus?

    public init (
        changeSetArn: String? = nil,
        changeSetId: String? = nil,
        changeSetName: String? = nil,
        endTime: String? = nil,
        entityIdList: [String]? = nil,
        failureCode: FailureCode? = nil,
        startTime: String? = nil,
        status: ChangeStatus? = nil
    )
    {
        self.changeSetArn = changeSetArn
        self.changeSetId = changeSetId
        self.changeSetName = changeSetName
        self.endTime = endTime
        self.entityIdList = entityIdList
        self.failureCode = failureCode
        self.startTime = startTime
        self.status = status
    }
}

public enum ChangeStatus {
    case applying
    case cancelled
    case failed
    case preparing
    case succeeded
    case sdkUnknown(String)
}

extension ChangeStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChangeStatus] {
        return [
            .applying,
            .cancelled,
            .failed,
            .preparing,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .applying: return "APPLYING"
        case .cancelled: return "CANCELLED"
        case .failed: return "FAILED"
        case .preparing: return "PREPARING"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChangeStatus(rawValue: rawValue) ?? ChangeStatus.sdkUnknown(rawValue)
    }
}

extension ChangeSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeName = "ChangeName"
        case changeType = "ChangeType"
        case details = "Details"
        case entity = "Entity"
        case errorDetailList = "ErrorDetailList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeName = changeName {
            try encodeContainer.encode(changeName, forKey: .changeName)
        }
        if let changeType = changeType {
            try encodeContainer.encode(changeType, forKey: .changeType)
        }
        if let details = details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let entity = entity {
            try encodeContainer.encode(entity, forKey: .entity)
        }
        if let errorDetailList = errorDetailList {
            var errorDetailListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorDetailList)
            for errordetaillist0 in errorDetailList {
                try errorDetailListContainer.encode(errordetaillist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let entityDecoded = try containerValues.decodeIfPresent(Entity.self, forKey: .entity)
        entity = entityDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .details)
        details = detailsDecoded
        let errorDetailListContainer = try containerValues.decodeIfPresent([ErrorDetail?].self, forKey: .errorDetailList)
        var errorDetailListDecoded0:[ErrorDetail]? = nil
        if let errorDetailListContainer = errorDetailListContainer {
            errorDetailListDecoded0 = [ErrorDetail]()
            for structure0 in errorDetailListContainer {
                if let structure0 = structure0 {
                    errorDetailListDecoded0?.append(structure0)
                }
            }
        }
        errorDetailList = errorDetailListDecoded0
        let changeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeName)
        changeName = changeNameDecoded
    }
}

extension ChangeSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChangeSummary(changeName: \(String(describing: changeName)), changeType: \(String(describing: changeType)), details: \(String(describing: details)), entity: \(String(describing: entity)), errorDetailList: \(String(describing: errorDetailList)))"}
}

/// <p>This object is a container for common summary information about the change. The
///             summary doesn't contain the whole change structure.</p>
public struct ChangeSummary: Equatable {
    /// <p>Optional name for the change.</p>
    public let changeName: String?
    /// <p>The type of the change.</p>
    public let changeType: String?
    /// <p>This object contains details specific to the change type of the requested
    ///             change.</p>
    public let details: String?
    /// <p>The entity to be changed.</p>
    public let entity: Entity?
    /// <p>An array of <code>ErrorDetail</code> objects associated with the change.</p>
    public let errorDetailList: [ErrorDetail]?

    public init (
        changeName: String? = nil,
        changeType: String? = nil,
        details: String? = nil,
        entity: Entity? = nil,
        errorDetailList: [ErrorDetail]? = nil
    )
    {
        self.changeName = changeName
        self.changeType = changeType
        self.details = details
        self.entity = entity
        self.errorDetailList = errorDetailList
    }
}

extension DescribeChangeSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeChangeSetInput(catalog: \(String(describing: catalog)), changeSetId: \(String(describing: changeSetId)))"}
}

extension DescribeChangeSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeChangeSetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeChangeSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeChangeSetInput>
    public typealias MOutput = OperationOutput<DescribeChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeChangeSetOutputError>
}

public struct DescribeChangeSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeChangeSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let changeSetId = input.operationInput.changeSetId {
            let changeSetIdQueryItem = URLQueryItem(name: "changeSetId".urlPercentEncoding(), value: String(changeSetId).urlPercentEncoding())
            input.builder.withQueryItem(changeSetIdQueryItem)
        }
        if let catalog = input.operationInput.catalog {
            let catalogQueryItem = URLQueryItem(name: "catalog".urlPercentEncoding(), value: String(catalog).urlPercentEncoding())
            input.builder.withQueryItem(catalogQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeChangeSetInput>
    public typealias MOutput = OperationOutput<DescribeChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeChangeSetOutputError>
}

public struct DescribeChangeSetInput: Equatable {
    /// <p>Required. The catalog related to the request. Fixed value:
    ///             <code>AWSMarketplace</code>
    ///          </p>
    public let catalog: String?
    /// <p>Required. The unique identifier for the <code>StartChangeSet</code> request that you
    ///             want to describe the details for.</p>
    public let changeSetId: String?

    public init (
        catalog: String? = nil,
        changeSetId: String? = nil
    )
    {
        self.catalog = catalog
        self.changeSetId = changeSetId
    }
}

struct DescribeChangeSetInputBody: Equatable {
}

extension DescribeChangeSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeChangeSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChangeSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChangeSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChangeSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeChangeSetOutputResponse(changeSet: \(String(describing: changeSet)), changeSetArn: \(String(describing: changeSetArn)), changeSetId: \(String(describing: changeSetId)), changeSetName: \(String(describing: changeSetName)), endTime: \(String(describing: endTime)), failureCode: \(String(describing: failureCode)), failureDescription: \(String(describing: failureDescription)), startTime: \(String(describing: startTime)), status: \(String(describing: status)))"}
}

extension DescribeChangeSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeChangeSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeSet = output.changeSet
            self.changeSetArn = output.changeSetArn
            self.changeSetId = output.changeSetId
            self.changeSetName = output.changeSetName
            self.endTime = output.endTime
            self.failureCode = output.failureCode
            self.failureDescription = output.failureDescription
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.changeSet = nil
            self.changeSetArn = nil
            self.changeSetId = nil
            self.changeSetName = nil
            self.endTime = nil
            self.failureCode = nil
            self.failureDescription = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct DescribeChangeSetOutputResponse: Equatable {
    /// <p>An array of <code>ChangeSummary</code> objects.</p>
    public let changeSet: [ChangeSummary]?
    /// <p>The ARN associated with the unique identifier for the change set referenced in this
    ///             request.</p>
    public let changeSetArn: String?
    /// <p>Required. The unique identifier for the change set referenced in this request.</p>
    public let changeSetId: String?
    /// <p>The optional name provided in the <code>StartChangeSet</code> request. If you do not
    ///             provide a name, one is set by default.</p>
    public let changeSetName: String?
    /// <p>The date and time, in ISO 8601 format (2018-02-27T13:45:22Z), the request transitioned
    ///             to a terminal state. The change cannot transition to a different state. Null if the
    ///             request is not in a terminal state. </p>
    public let endTime: String?
    /// <p>Returned if the change set is in <code>FAILED</code> status. Can be either
    ///             <code>CLIENT_ERROR</code>, which means that there are issues with the request (see the
    ///             <code>ErrorDetailList</code>), or <code>SERVER_FAULT</code>, which means that there is a
    ///             problem in the system, and you should retry your request.</p>
    public let failureCode: FailureCode?
    /// <p>Returned if there is a failure on the change set, but that failure is not related to
    ///             any of the changes in the request.</p>
    public let failureDescription: String?
    /// <p>The date and time, in ISO 8601 format (2018-02-27T13:45:22Z), the request started.
    ///         </p>
    public let startTime: String?
    /// <p>The status of the change request.</p>
    public let status: ChangeStatus?

    public init (
        changeSet: [ChangeSummary]? = nil,
        changeSetArn: String? = nil,
        changeSetId: String? = nil,
        changeSetName: String? = nil,
        endTime: String? = nil,
        failureCode: FailureCode? = nil,
        failureDescription: String? = nil,
        startTime: String? = nil,
        status: ChangeStatus? = nil
    )
    {
        self.changeSet = changeSet
        self.changeSetArn = changeSetArn
        self.changeSetId = changeSetId
        self.changeSetName = changeSetName
        self.endTime = endTime
        self.failureCode = failureCode
        self.failureDescription = failureDescription
        self.startTime = startTime
        self.status = status
    }
}

struct DescribeChangeSetOutputResponseBody: Equatable {
    public let changeSetId: String?
    public let changeSetArn: String?
    public let changeSetName: String?
    public let startTime: String?
    public let endTime: String?
    public let status: ChangeStatus?
    public let failureCode: FailureCode?
    public let failureDescription: String?
    public let changeSet: [ChangeSummary]?
}

extension DescribeChangeSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeSet = "ChangeSet"
        case changeSetArn = "ChangeSetArn"
        case changeSetId = "ChangeSetId"
        case changeSetName = "ChangeSetName"
        case endTime = "EndTime"
        case failureCode = "FailureCode"
        case failureDescription = "FailureDescription"
        case startTime = "StartTime"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let changeSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetArn)
        changeSetArn = changeSetArnDecoded
        let changeSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetName)
        changeSetName = changeSetNameDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChangeStatus.self, forKey: .status)
        status = statusDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(FailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureDescription)
        failureDescription = failureDescriptionDecoded
        let changeSetContainer = try containerValues.decodeIfPresent([ChangeSummary?].self, forKey: .changeSet)
        var changeSetDecoded0:[ChangeSummary]? = nil
        if let changeSetContainer = changeSetContainer {
            changeSetDecoded0 = [ChangeSummary]()
            for structure0 in changeSetContainer {
                if let structure0 = structure0 {
                    changeSetDecoded0?.append(structure0)
                }
            }
        }
        changeSet = changeSetDecoded0
    }
}

extension DescribeEntityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEntityInput(catalog: \(String(describing: catalog)), entityId: \(String(describing: entityId)))"}
}

extension DescribeEntityInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeEntityInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEntityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEntityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEntityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEntityInput>
    public typealias MOutput = OperationOutput<DescribeEntityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEntityOutputError>
}

public struct DescribeEntityInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEntityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEntityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEntityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let entityId = input.operationInput.entityId {
            let entityIdQueryItem = URLQueryItem(name: "entityId".urlPercentEncoding(), value: String(entityId).urlPercentEncoding())
            input.builder.withQueryItem(entityIdQueryItem)
        }
        if let catalog = input.operationInput.catalog {
            let catalogQueryItem = URLQueryItem(name: "catalog".urlPercentEncoding(), value: String(catalog).urlPercentEncoding())
            input.builder.withQueryItem(catalogQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEntityInput>
    public typealias MOutput = OperationOutput<DescribeEntityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEntityOutputError>
}

public struct DescribeEntityInput: Equatable {
    /// <p>Required. The catalog related to the request. Fixed value:
    ///             <code>AWSMarketplace</code>
    ///          </p>
    public let catalog: String?
    /// <p>Required. The unique ID of the entity to describe.</p>
    public let entityId: String?

    public init (
        catalog: String? = nil,
        entityId: String? = nil
    )
    {
        self.catalog = catalog
        self.entityId = entityId
    }
}

struct DescribeEntityInputBody: Equatable {
}

extension DescribeEntityInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeEntityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEntityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotSupportedException" : self = .resourceNotSupportedException(try ResourceNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEntityOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceNotSupportedException(ResourceNotSupportedException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEntityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEntityOutputResponse(details: \(String(describing: details)), entityArn: \(String(describing: entityArn)), entityIdentifier: \(String(describing: entityIdentifier)), entityType: \(String(describing: entityType)), lastModifiedDate: \(String(describing: lastModifiedDate)))"}
}

extension DescribeEntityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEntityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.details = output.details
            self.entityArn = output.entityArn
            self.entityIdentifier = output.entityIdentifier
            self.entityType = output.entityType
            self.lastModifiedDate = output.lastModifiedDate
        } else {
            self.details = nil
            self.entityArn = nil
            self.entityIdentifier = nil
            self.entityType = nil
            self.lastModifiedDate = nil
        }
    }
}

public struct DescribeEntityOutputResponse: Equatable {
    /// <p>This stringified JSON object includes the details of the entity.</p>
    public let details: String?
    /// <p>The ARN associated to the unique identifier for the change set referenced in this
    ///             request.</p>
    public let entityArn: String?
    /// <p>The identifier of the entity, in the format of
    ///             <code>EntityId@RevisionId</code>.</p>
    public let entityIdentifier: String?
    /// <p>The named type of the entity, in the format of <code>EntityType@Version</code>.</p>
    public let entityType: String?
    /// <p>The last modified date of the entity, in ISO 8601 format
    ///             (2018-02-27T13:45:22Z).</p>
    public let lastModifiedDate: String?

    public init (
        details: String? = nil,
        entityArn: String? = nil,
        entityIdentifier: String? = nil,
        entityType: String? = nil,
        lastModifiedDate: String? = nil
    )
    {
        self.details = details
        self.entityArn = entityArn
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.lastModifiedDate = lastModifiedDate
    }
}

struct DescribeEntityOutputResponseBody: Equatable {
    public let entityType: String?
    public let entityIdentifier: String?
    public let entityArn: String?
    public let lastModifiedDate: String?
    public let details: String?
}

extension DescribeEntityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case details = "Details"
        case entityArn = "EntityArn"
        case entityIdentifier = "EntityIdentifier"
        case entityType = "EntityType"
        case lastModifiedDate = "LastModifiedDate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let entityIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityIdentifier)
        entityIdentifier = entityIdentifierDecoded
        let entityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityArn)
        entityArn = entityArnDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .details)
        details = detailsDecoded
    }
}

extension Entity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identifier = "Identifier"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension Entity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Entity(identifier: \(String(describing: identifier)), type: \(String(describing: type)))"}
}

/// <p>An entity contains data that describes your product, its supported features,
///             and how it can be used or launched by your customer. </p>
public struct Entity: Equatable {
    /// <p>The identifier for the entity.</p>
    public let identifier: String?
    /// <p>The type of entity.</p>
    public let type: String?

    public init (
        identifier: String? = nil,
        type: String? = nil
    )
    {
        self.identifier = identifier
        self.type = type
    }
}

extension EntitySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityArn = "EntityArn"
        case entityId = "EntityId"
        case entityType = "EntityType"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityArn = entityArn {
            try encodeContainer.encode(entityArn, forKey: .entityArn)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityType = entityType {
            try encodeContainer.encode(entityType, forKey: .entityType)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let visibility = visibility {
            try encodeContainer.encode(visibility, forKey: .visibility)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityArn)
        entityArn = entityArnDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension EntitySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntitySummary(entityArn: \(String(describing: entityArn)), entityId: \(String(describing: entityId)), entityType: \(String(describing: entityType)), lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)), visibility: \(String(describing: visibility)))"}
}

/// <p>This object is a container for common summary information about the entity. The
///             summary doesn't contain the whole entity structure, but it does contain information
///             common across all entities.</p>
public struct EntitySummary: Equatable {
    /// <p>The ARN associated with the unique identifier for the entity.</p>
    public let entityArn: String?
    /// <p>The unique identifier for the entity.</p>
    public let entityId: String?
    /// <p>The type of the entity.</p>
    public let entityType: String?
    /// <p>The last time the entity was published, using ISO 8601 format
    ///             (2018-02-27T13:45:22Z).</p>
    public let lastModifiedDate: String?
    /// <p>The name for the entity. This value is not unique. It is defined by the
    ///             seller.</p>
    public let name: String?
    /// <p>The visibility status of the entity to
    ///             buyers.
    ///             This value can be <code>Public</code> (everyone can view the entity),
    ///                 <code>Limited</code> (the entity is visible to limited accounts only), or
    ///                 <code>Restricted</code> (the entity was published and then unpublished and only
    ///             existing
    ///             buyers
    ///             can view it). </p>
    public let visibility: String?

    public init (
        entityArn: String? = nil,
        entityId: String? = nil,
        entityType: String? = nil,
        lastModifiedDate: String? = nil,
        name: String? = nil,
        visibility: String? = nil
    )
    {
        self.entityArn = entityArn
        self.entityId = entityId
        self.entityType = entityType
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.visibility = visibility
    }
}

extension ErrorDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ErrorDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorDetail(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>Details about the error.</p>
public struct ErrorDetail: Equatable {
    /// <p>The error code that identifies the type of error.</p>
    public let errorCode: String?
    /// <p>The message for the error.</p>
    public let errorMessage: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }
}

public enum FailureCode {
    case clienterror
    case serverfault
    case sdkUnknown(String)
}

extension FailureCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FailureCode] {
        return [
            .clienterror,
            .serverfault,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .clienterror: return "CLIENT_ERROR"
        case .serverfault: return "SERVER_FAULT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FailureCode(rawValue: rawValue) ?? FailureCode.sdkUnknown(rawValue)
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case valueList = "ValueList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for valuelist0 in valueList {
                try valueListContainer.encode(valuelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .valueList)
        var valueListDecoded0:[String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(name: \(String(describing: name)), valueList: \(String(describing: valueList)))"}
}

/// <p>A filter object, used to optionally filter results from calls to the
///                 <code>ListEntities</code> and <code>ListChangeSets</code> actions.</p>
public struct Filter: Equatable {
    /// <p>For <code>ListEntities</code>, the supported value for this is an
    ///                 <code>EntityId</code>.</p>
    ///         <p>For <code>ListChangeSets</code>, the supported values are as follows:</p>
    public let name: String?
    /// <p>
    ///             <code>ListEntities</code> - This is a list of unique <code>EntityId</code>s.</p>
    ///
    ///         <p>
    ///             <code>ListChangeSets</code> - The supported filter names and associated
    ///                 <code>ValueList</code>s is as follows:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ChangeSetName</code> - The supported <code>ValueList</code> is a list of
    ///                     non-unique <code>ChangeSetName</code>s. These are defined when you call the
    ///                         <code>StartChangeSet</code> action.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Status</code> - The supported <code>ValueList</code> is a list of
    ///                     statuses for all change set requests.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>EntityId</code> - The supported <code>ValueList</code> is a list of
    ///                     unique <code>EntityId</code>s.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>BeforeStartTime</code> - The supported <code>ValueList</code> is a list
    ///                     of all change sets that started before the filter value.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>AfterStartTime</code> - The supported <code>ValueList</code> is a list
    ///                     of all change sets that started after the filter value.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>BeforeEndTime</code> - The supported <code>ValueList</code> is a list of
    ///                     all change sets that ended before the filter value.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>AfterEndTime</code> - The supported <code>ValueList</code> is a list of
    ///                     all change sets that ended after the filter value.</p>
    ///             </li>
    ///          </ul>
    public let valueList: [String]?

    public init (
        name: String? = nil,
        valueList: [String]? = nil
    )
    {
        self.name = name
        self.valueList = valueList
    }
}

extension InternalServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceException(message: \(String(describing: message)))"}
}

extension InternalServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was an internal service exception.</p>
public struct InternalServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListChangeSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListChangeSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChangeSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChangeSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChangeSetsInput>
    public typealias MOutput = OperationOutput<ListChangeSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChangeSetsOutputError>
}

extension ListChangeSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListChangeSetsInput(catalog: \(String(describing: catalog)), filterList: \(String(describing: filterList)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sort: \(String(describing: sort)))"}
}

extension ListChangeSetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalog = "Catalog"
        case filterList = "FilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let filterList = filterList {
            var filterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterList)
            for filterlist0 in filterList {
                try filterListContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sort = sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
    }
}

public struct ListChangeSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListChangeSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChangeSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChangeSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChangeSetsInput>
    public typealias MOutput = OperationOutput<ListChangeSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChangeSetsOutputError>
}

public struct ListChangeSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListChangeSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChangeSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChangeSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChangeSetsInput>
    public typealias MOutput = OperationOutput<ListChangeSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChangeSetsOutputError>
}

public struct ListChangeSetsInput: Equatable {
    /// <p>The catalog related to the request. Fixed value: <code>AWSMarketplace</code>
    ///          </p>
    public let catalog: String?
    /// <p>An array of filter objects.</p>
    public let filterList: [Filter]?
    /// <p>The maximum number of results returned by a single call. This value must be provided
    ///             in the next call to retrieve the next set of results. By default, this value is
    ///             20.</p>
    public let maxResults: Int?
    /// <p>The token value retrieved from a previous call to access the next page of
    ///             results.</p>
    public let nextToken: String?
    /// <p>An object that contains two attributes, <code>SortBy</code> and
    ///             <code>SortOrder</code>.</p>
    public let sort: Sort?

    public init (
        catalog: String? = nil,
        filterList: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sort: Sort? = nil
    )
    {
        self.catalog = catalog
        self.filterList = filterList
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

struct ListChangeSetsInputBody: Equatable {
    public let catalog: String?
    public let filterList: [Filter]?
    public let sort: Sort?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListChangeSetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalog = "Catalog"
        case filterList = "FilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalog)
        catalog = catalogDecoded
        let filterListContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filterList)
        var filterListDecoded0:[Filter]? = nil
        if let filterListContainer = filterListContainer {
            filterListDecoded0 = [Filter]()
            for structure0 in filterListContainer {
                if let structure0 = structure0 {
                    filterListDecoded0?.append(structure0)
                }
            }
        }
        filterList = filterListDecoded0
        let sortDecoded = try containerValues.decodeIfPresent(Sort.self, forKey: .sort)
        sort = sortDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChangeSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChangeSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChangeSetsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChangeSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListChangeSetsOutputResponse(changeSetSummaryList: \(String(describing: changeSetSummaryList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListChangeSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListChangeSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeSetSummaryList = output.changeSetSummaryList
            self.nextToken = output.nextToken
        } else {
            self.changeSetSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListChangeSetsOutputResponse: Equatable {
    /// <p> Array of <code>ChangeSetSummaryListItem</code> objects.</p>
    public let changeSetSummaryList: [ChangeSetSummaryListItem]?
    /// <p>The value of the next token, if it exists. Null if there are no more results.</p>
    public let nextToken: String?

    public init (
        changeSetSummaryList: [ChangeSetSummaryListItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.changeSetSummaryList = changeSetSummaryList
        self.nextToken = nextToken
    }
}

struct ListChangeSetsOutputResponseBody: Equatable {
    public let changeSetSummaryList: [ChangeSetSummaryListItem]?
    public let nextToken: String?
}

extension ListChangeSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeSetSummaryList = "ChangeSetSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeSetSummaryListContainer = try containerValues.decodeIfPresent([ChangeSetSummaryListItem?].self, forKey: .changeSetSummaryList)
        var changeSetSummaryListDecoded0:[ChangeSetSummaryListItem]? = nil
        if let changeSetSummaryListContainer = changeSetSummaryListContainer {
            changeSetSummaryListDecoded0 = [ChangeSetSummaryListItem]()
            for structure0 in changeSetSummaryListContainer {
                if let structure0 = structure0 {
                    changeSetSummaryListDecoded0?.append(structure0)
                }
            }
        }
        changeSetSummaryList = changeSetSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEntitiesInputBodyMiddleware: Middleware {
    public let id: String = "ListEntitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntitiesInput>
    public typealias MOutput = OperationOutput<ListEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntitiesOutputError>
}

extension ListEntitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEntitiesInput(catalog: \(String(describing: catalog)), entityType: \(String(describing: entityType)), filterList: \(String(describing: filterList)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sort: \(String(describing: sort)))"}
}

extension ListEntitiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalog = "Catalog"
        case entityType = "EntityType"
        case filterList = "FilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let entityType = entityType {
            try encodeContainer.encode(entityType, forKey: .entityType)
        }
        if let filterList = filterList {
            var filterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterList)
            for filterlist0 in filterList {
                try filterListContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sort = sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
    }
}

public struct ListEntitiesInputHeadersMiddleware: Middleware {
    public let id: String = "ListEntitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntitiesInput>
    public typealias MOutput = OperationOutput<ListEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntitiesOutputError>
}

public struct ListEntitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEntitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntitiesInput>
    public typealias MOutput = OperationOutput<ListEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntitiesOutputError>
}

public struct ListEntitiesInput: Equatable {
    /// <p>The catalog related to the request. Fixed value: <code>AWSMarketplace</code>
    ///          </p>
    public let catalog: String?
    /// <p>The type of entities to retrieve.</p>
    public let entityType: String?
    /// <p>An array of filter objects. Each filter object contains two attributes,
    ///                 <code>filterName</code> and <code>filterValues</code>.</p>
    public let filterList: [Filter]?
    /// <p>Specifies the upper limit of the elements on a single page. If a value isn't provided,
    ///             the default value is 20.</p>
    public let maxResults: Int?
    /// <p>The value of the next token, if it exists. Null if there are no more results.</p>
    public let nextToken: String?
    /// <p>An object that contains two attributes, <code>SortBy</code> and
    ///             <code>SortOrder</code>.</p>
    public let sort: Sort?

    public init (
        catalog: String? = nil,
        entityType: String? = nil,
        filterList: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sort: Sort? = nil
    )
    {
        self.catalog = catalog
        self.entityType = entityType
        self.filterList = filterList
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

struct ListEntitiesInputBody: Equatable {
    public let catalog: String?
    public let entityType: String?
    public let filterList: [Filter]?
    public let sort: Sort?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListEntitiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalog = "Catalog"
        case entityType = "EntityType"
        case filterList = "FilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalog)
        catalog = catalogDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let filterListContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filterList)
        var filterListDecoded0:[Filter]? = nil
        if let filterListContainer = filterListContainer {
            filterListDecoded0 = [Filter]()
            for structure0 in filterListContainer {
                if let structure0 = structure0 {
                    filterListDecoded0?.append(structure0)
                }
            }
        }
        filterList = filterListDecoded0
        let sortDecoded = try containerValues.decodeIfPresent(Sort.self, forKey: .sort)
        sort = sortDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEntitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEntitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEntitiesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEntitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEntitiesOutputResponse(entitySummaryList: \(String(describing: entitySummaryList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEntitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entitySummaryList = output.entitySummaryList
            self.nextToken = output.nextToken
        } else {
            self.entitySummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntitiesOutputResponse: Equatable {
    /// <p> Array of <code>EntitySummary</code> object.</p>
    public let entitySummaryList: [EntitySummary]?
    /// <p>The value of the next token if it exists. Null if there is no more result.</p>
    public let nextToken: String?

    public init (
        entitySummaryList: [EntitySummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.entitySummaryList = entitySummaryList
        self.nextToken = nextToken
    }
}

struct ListEntitiesOutputResponseBody: Equatable {
    public let entitySummaryList: [EntitySummary]?
    public let nextToken: String?
}

extension ListEntitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entitySummaryList = "EntitySummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitySummaryListContainer = try containerValues.decodeIfPresent([EntitySummary?].self, forKey: .entitySummaryList)
        var entitySummaryListDecoded0:[EntitySummary]? = nil
        if let entitySummaryListContainer = entitySummaryListContainer {
            entitySummaryListDecoded0 = [EntitySummary]()
            for structure0 in entitySummaryListContainer {
                if let structure0 = structure0 {
                    entitySummaryListDecoded0?.append(structure0)
                }
            }
        }
        entitySummaryList = entitySummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is currently in use.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource wasn't found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotSupportedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotSupportedException(message: \(String(describing: message)))"}
}

extension ResourceNotSupportedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotSupportedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Currently, the specified resource is not supported.</p>
public struct ResourceNotSupportedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotSupportedExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotSupportedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of open requests per account has been exceeded.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Sort: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension Sort: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Sort(sortBy: \(String(describing: sortBy)), sortOrder: \(String(describing: sortOrder)))"}
}

/// <p>An object that contains two attributes, <code>SortBy</code> and
///             <code>SortOrder</code>.</p>
public struct Sort: Equatable {
    /// <p>For <code>ListEntities</code>, supported attributes include
    ///                 <code>LastModifiedDate</code> (default), <code>Visibility</code>,
    ///                 <code>EntityId</code>, and <code>Name</code>.</p>
    ///
    ///         <p>For <code>ListChangeSets</code>, supported attributes include <code>StartTime</code>
    ///             and <code>EndTime</code>.</p>
    public let sortBy: String?
    /// <p>The sorting order. Can be <code>ASCENDING</code> or <code>DESCENDING</code>. The
    ///             default value is <code>DESCENDING</code>.</p>
    public let sortOrder: SortOrder?

    public init (
        sortBy: String? = nil,
        sortOrder: SortOrder? = nil
    )
    {
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

public enum SortOrder {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension SortOrder : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortOrder] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "ASCENDING"
        case .descending: return "DESCENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
    }
}

public struct StartChangeSetInputBodyMiddleware: Middleware {
    public let id: String = "StartChangeSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<StartChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartChangeSetInput>
    public typealias MOutput = OperationOutput<StartChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartChangeSetOutputError>
}

extension StartChangeSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartChangeSetInput(catalog: \(String(describing: catalog)), changeSet: \(String(describing: changeSet)), changeSetName: \(String(describing: changeSetName)), clientRequestToken: \(String(describing: clientRequestToken)))"}
}

extension StartChangeSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalog = "Catalog"
        case changeSet = "ChangeSet"
        case changeSetName = "ChangeSetName"
        case clientRequestToken = "ClientRequestToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let changeSet = changeSet {
            var changeSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .changeSet)
            for requestedchangelist0 in changeSet {
                try changeSetContainer.encode(requestedchangelist0)
            }
        }
        if let changeSetName = changeSetName {
            try encodeContainer.encode(changeSetName, forKey: .changeSetName)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
    }
}

public struct StartChangeSetInputHeadersMiddleware: Middleware {
    public let id: String = "StartChangeSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<StartChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartChangeSetInput>
    public typealias MOutput = OperationOutput<StartChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartChangeSetOutputError>
}

public struct StartChangeSetInputQueryItemMiddleware: Middleware {
    public let id: String = "StartChangeSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<StartChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartChangeSetInput>
    public typealias MOutput = OperationOutput<StartChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartChangeSetOutputError>
}

public struct StartChangeSetInput: Equatable {
    /// <p>The catalog related to the request. Fixed value: <code>AWSMarketplace</code>
    ///          </p>
    public let catalog: String?
    /// <p>Array of <code>change</code> object.</p>
    public let changeSet: [Change]?
    /// <p>Optional case sensitive string of up to 100 ASCII characters. The change set name can
    ///             be used to filter the list of change sets. </p>
    public let changeSetName: String?
    /// <p>A unique token to identify the request to ensure idempotency.</p>
    public let clientRequestToken: String?

    public init (
        catalog: String? = nil,
        changeSet: [Change]? = nil,
        changeSetName: String? = nil,
        clientRequestToken: String? = nil
    )
    {
        self.catalog = catalog
        self.changeSet = changeSet
        self.changeSetName = changeSetName
        self.clientRequestToken = clientRequestToken
    }
}

struct StartChangeSetInputBody: Equatable {
    public let catalog: String?
    public let changeSet: [Change]?
    public let changeSetName: String?
    public let clientRequestToken: String?
}

extension StartChangeSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalog = "Catalog"
        case changeSet = "ChangeSet"
        case changeSetName = "ChangeSetName"
        case clientRequestToken = "ClientRequestToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalog)
        catalog = catalogDecoded
        let changeSetContainer = try containerValues.decodeIfPresent([Change?].self, forKey: .changeSet)
        var changeSetDecoded0:[Change]? = nil
        if let changeSetContainer = changeSetContainer {
            changeSetDecoded0 = [Change]()
            for structure0 in changeSetContainer {
                if let structure0 = structure0 {
                    changeSetDecoded0?.append(structure0)
                }
            }
        }
        changeSet = changeSetDecoded0
        let changeSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetName)
        changeSetName = changeSetNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartChangeSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartChangeSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartChangeSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartChangeSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartChangeSetOutputResponse(changeSetArn: \(String(describing: changeSetArn)), changeSetId: \(String(describing: changeSetId)))"}
}

extension StartChangeSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartChangeSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeSetArn = output.changeSetArn
            self.changeSetId = output.changeSetId
        } else {
            self.changeSetArn = nil
            self.changeSetId = nil
        }
    }
}

public struct StartChangeSetOutputResponse: Equatable {
    /// <p>The ARN associated to the unique identifier generated for the request.</p>
    public let changeSetArn: String?
    /// <p>Unique identifier generated for the request.</p>
    public let changeSetId: String?

    public init (
        changeSetArn: String? = nil,
        changeSetId: String? = nil
    )
    {
        self.changeSetArn = changeSetArn
        self.changeSetId = changeSetId
    }
}

struct StartChangeSetOutputResponseBody: Equatable {
    public let changeSetId: String?
    public let changeSetArn: String?
}

extension StartChangeSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeSetArn = "ChangeSetArn"
        case changeSetId = "ChangeSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let changeSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetArn)
        changeSetArn = changeSetArnDecoded
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Too many requests.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error occurred during validation.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
