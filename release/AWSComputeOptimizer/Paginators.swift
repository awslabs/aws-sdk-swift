// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[DescribeRecommendationExportJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeRecommendationExportJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeRecommendationExportJobsOutputResponse`
extension ComputeOptimizerClient {
    public func describeRecommendationExportJobsPaginated(input: DescribeRecommendationExportJobsInput) -> ClientRuntime.PaginatorSequence<DescribeRecommendationExportJobsInput, DescribeRecommendationExportJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeRecommendationExportJobsInput, DescribeRecommendationExportJobsOutputResponse>(input: input, inputKey: \DescribeRecommendationExportJobsInput.nextToken, outputKey: \DescribeRecommendationExportJobsOutputResponse.nextToken, paginationFunction: self.describeRecommendationExportJobs(input:))
    }
}

extension DescribeRecommendationExportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRecommendationExportJobsInput {
        return DescribeRecommendationExportJobsInput(
            filters: self.filters,
            jobIds: self.jobIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeRecommendationExportJobsPaginated`
/// to access the nested member `[ComputeOptimizerClientTypes.RecommendationExportJob]`
/// - Returns: `[ComputeOptimizerClientTypes.RecommendationExportJob]`
extension PaginatorSequence where Input == DescribeRecommendationExportJobsInput, Output == DescribeRecommendationExportJobsOutputResponse {
    public func recommendationExportJobs() async throws -> [ComputeOptimizerClientTypes.RecommendationExportJob] {
        return try await self.asyncCompactMap { item in item.recommendationExportJobs }
    }
}

/// Paginate over `[GetEnrollmentStatusesForOrganizationOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetEnrollmentStatusesForOrganizationInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetEnrollmentStatusesForOrganizationOutputResponse`
extension ComputeOptimizerClient {
    public func getEnrollmentStatusesForOrganizationPaginated(input: GetEnrollmentStatusesForOrganizationInput) -> ClientRuntime.PaginatorSequence<GetEnrollmentStatusesForOrganizationInput, GetEnrollmentStatusesForOrganizationOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetEnrollmentStatusesForOrganizationInput, GetEnrollmentStatusesForOrganizationOutputResponse>(input: input, inputKey: \GetEnrollmentStatusesForOrganizationInput.nextToken, outputKey: \GetEnrollmentStatusesForOrganizationOutputResponse.nextToken, paginationFunction: self.getEnrollmentStatusesForOrganization(input:))
    }
}

extension GetEnrollmentStatusesForOrganizationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetEnrollmentStatusesForOrganizationInput {
        return GetEnrollmentStatusesForOrganizationInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getEnrollmentStatusesForOrganizationPaginated`
/// to access the nested member `[ComputeOptimizerClientTypes.AccountEnrollmentStatus]`
/// - Returns: `[ComputeOptimizerClientTypes.AccountEnrollmentStatus]`
extension PaginatorSequence where Input == GetEnrollmentStatusesForOrganizationInput, Output == GetEnrollmentStatusesForOrganizationOutputResponse {
    public func accountEnrollmentStatuses() async throws -> [ComputeOptimizerClientTypes.AccountEnrollmentStatus] {
        return try await self.asyncCompactMap { item in item.accountEnrollmentStatuses }
    }
}

/// Paginate over `[GetLambdaFunctionRecommendationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetLambdaFunctionRecommendationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetLambdaFunctionRecommendationsOutputResponse`
extension ComputeOptimizerClient {
    public func getLambdaFunctionRecommendationsPaginated(input: GetLambdaFunctionRecommendationsInput) -> ClientRuntime.PaginatorSequence<GetLambdaFunctionRecommendationsInput, GetLambdaFunctionRecommendationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetLambdaFunctionRecommendationsInput, GetLambdaFunctionRecommendationsOutputResponse>(input: input, inputKey: \GetLambdaFunctionRecommendationsInput.nextToken, outputKey: \GetLambdaFunctionRecommendationsOutputResponse.nextToken, paginationFunction: self.getLambdaFunctionRecommendations(input:))
    }
}

extension GetLambdaFunctionRecommendationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetLambdaFunctionRecommendationsInput {
        return GetLambdaFunctionRecommendationsInput(
            accountIds: self.accountIds,
            filters: self.filters,
            functionArns: self.functionArns,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getLambdaFunctionRecommendationsPaginated`
/// to access the nested member `[ComputeOptimizerClientTypes.LambdaFunctionRecommendation]`
/// - Returns: `[ComputeOptimizerClientTypes.LambdaFunctionRecommendation]`
extension PaginatorSequence where Input == GetLambdaFunctionRecommendationsInput, Output == GetLambdaFunctionRecommendationsOutputResponse {
    public func lambdaFunctionRecommendations() async throws -> [ComputeOptimizerClientTypes.LambdaFunctionRecommendation] {
        return try await self.asyncCompactMap { item in item.lambdaFunctionRecommendations }
    }
}

/// Paginate over `[GetRecommendationPreferencesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetRecommendationPreferencesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetRecommendationPreferencesOutputResponse`
extension ComputeOptimizerClient {
    public func getRecommendationPreferencesPaginated(input: GetRecommendationPreferencesInput) -> ClientRuntime.PaginatorSequence<GetRecommendationPreferencesInput, GetRecommendationPreferencesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetRecommendationPreferencesInput, GetRecommendationPreferencesOutputResponse>(input: input, inputKey: \GetRecommendationPreferencesInput.nextToken, outputKey: \GetRecommendationPreferencesOutputResponse.nextToken, paginationFunction: self.getRecommendationPreferences(input:))
    }
}

extension GetRecommendationPreferencesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetRecommendationPreferencesInput {
        return GetRecommendationPreferencesInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType,
            scope: self.scope
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getRecommendationPreferencesPaginated`
/// to access the nested member `[ComputeOptimizerClientTypes.RecommendationPreferencesDetail]`
/// - Returns: `[ComputeOptimizerClientTypes.RecommendationPreferencesDetail]`
extension PaginatorSequence where Input == GetRecommendationPreferencesInput, Output == GetRecommendationPreferencesOutputResponse {
    public func recommendationPreferencesDetails() async throws -> [ComputeOptimizerClientTypes.RecommendationPreferencesDetail] {
        return try await self.asyncCompactMap { item in item.recommendationPreferencesDetails }
    }
}

/// Paginate over `[GetRecommendationSummariesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetRecommendationSummariesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetRecommendationSummariesOutputResponse`
extension ComputeOptimizerClient {
    public func getRecommendationSummariesPaginated(input: GetRecommendationSummariesInput) -> ClientRuntime.PaginatorSequence<GetRecommendationSummariesInput, GetRecommendationSummariesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetRecommendationSummariesInput, GetRecommendationSummariesOutputResponse>(input: input, inputKey: \GetRecommendationSummariesInput.nextToken, outputKey: \GetRecommendationSummariesOutputResponse.nextToken, paginationFunction: self.getRecommendationSummaries(input:))
    }
}

extension GetRecommendationSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetRecommendationSummariesInput {
        return GetRecommendationSummariesInput(
            accountIds: self.accountIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getRecommendationSummariesPaginated`
/// to access the nested member `[ComputeOptimizerClientTypes.RecommendationSummary]`
/// - Returns: `[ComputeOptimizerClientTypes.RecommendationSummary]`
extension PaginatorSequence where Input == GetRecommendationSummariesInput, Output == GetRecommendationSummariesOutputResponse {
    public func recommendationSummaries() async throws -> [ComputeOptimizerClientTypes.RecommendationSummary] {
        return try await self.asyncCompactMap { item in item.recommendationSummaries }
    }
}
