// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDenied {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<AccessDeniedBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Access denied.
public struct AccessDenied: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.ActiveTrustedKeyGroups: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for kgkeypairids0 in items {
                try itemsContainer.encode(kgkeypairids0, forKey: ClientRuntime.Key("KeyGroup"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyGroup{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyGroup>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.KGKeyPairIds].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.KGKeyPairIds]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.KGKeyPairIds]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ActiveTrustedKeyGroups: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of key groups, and the public keys in each key group, that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct ActiveTrustedKeyGroups: Swift.Equatable {
        /// This field is true if any of the key groups have public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of key groups, including the identifiers of the public keys in each key group that CloudFront can use to verify the signatures of signed URLs and signed cookies.
        public var items: [CloudFrontClientTypes.KGKeyPairIds]?
        /// The number of key groups in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.KGKeyPairIds]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ActiveTrustedSigners: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for signer0 in items {
                try itemsContainer.encode(signer0, forKey: ClientRuntime.Key("Signer"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Signer{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Signer>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Signer].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Signer]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Signer]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ActiveTrustedSigners: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of Amazon Web Services accounts and the active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct ActiveTrustedSigners: Swift.Equatable {
        /// This field is true if any of the Amazon Web Services accounts in the list have active CloudFront key pairs that CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of Amazon Web Services accounts and the identifiers of active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.
        public var items: [CloudFrontClientTypes.Signer]?
        /// The number of Amazon Web Services accounts in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.Signer]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.AliasICPRecordal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cNAME = "CNAME"
        case iCPRecordalStatus = "ICPRecordalStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cNAME = cNAME {
            try container.encode(cNAME, forKey: ClientRuntime.Key("CNAME"))
        }
        if let iCPRecordalStatus = iCPRecordalStatus {
            try container.encode(iCPRecordalStatus, forKey: ClientRuntime.Key("ICPRecordalStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cNAMEDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cNAME)
        cNAME = cNAMEDecoded
        let iCPRecordalStatusDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ICPRecordalStatus.self, forKey: .iCPRecordalStatus)
        iCPRecordalStatus = iCPRecordalStatusDecoded
    }
}

extension CloudFrontClientTypes.AliasICPRecordal: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions. The status is returned in the CloudFront response; you can't configure it yourself. For more information about ICP recordals, see [ Signup, Accounts, and Credentials](https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html) in Getting Started with Amazon Web Services services in China.
    public struct AliasICPRecordal: Swift.Equatable {
        /// A domain name associated with a distribution.
        public var cNAME: Swift.String?
        /// The Internet Content Provider (ICP) recordal status for a CNAME. The ICPRecordalStatus is set to APPROVED for all CNAMEs (aliases) in regions outside of China. The status values returned are the following:
        ///
        /// * APPROVED indicates that the associated CNAME has a valid ICP recordal number. Multiple CNAMEs can be associated with a distribution, and CNAMEs can correspond to different ICP recordals. To be marked as APPROVED, that is, valid to use with China region, a CNAME must have one ICP recordal number associated with it.
        ///
        /// * SUSPENDED indicates that the associated CNAME does not have a valid ICP recordal number.
        ///
        /// * PENDING indicates that CloudFront can't determine the ICP recordal status of the CNAME associated with the distribution because there was an error in trying to determine the status. You can try again to see if the error is resolved in which case CloudFront returns an APPROVED or SUSPENDED status.
        public var iCPRecordalStatus: CloudFrontClientTypes.ICPRecordalStatus?

        public init (
            cNAME: Swift.String? = nil,
            iCPRecordalStatus: CloudFrontClientTypes.ICPRecordalStatus? = nil
        )
        {
            self.cNAME = cNAME
            self.iCPRecordalStatus = iCPRecordalStatus
        }
    }

}

extension CloudFrontClientTypes.Aliases: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("CNAME"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CNAME{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CNAME>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Aliases: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
    public struct Aliases: Swift.Equatable {
        /// A complex type that contains the CNAME aliases, if any, that you want to associate with this distribution.
        public var items: [Swift.String]?
        /// The number of CNAME aliases, if any, that you want to associate with this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.AllowedMethods: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachedMethods = "CachedMethods"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachedMethods = cachedMethods {
            try container.encode(cachedMethods, forKey: ClientRuntime.Key("CachedMethods"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for method0 in items {
                try itemsContainer.encode(method0, forKey: ClientRuntime.Key("Method"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Method{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Method>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Method].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Method]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Method]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
        let cachedMethodsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachedMethods.self, forKey: .cachedMethods)
        cachedMethods = cachedMethodsDecoded
    }
}

extension CloudFrontClientTypes.AllowedMethods: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:
    ///
    /// * CloudFront forwards only GET and HEAD requests.
    ///
    /// * CloudFront forwards only GET, HEAD, and OPTIONS requests.
    ///
    /// * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests.
    ///
    ///
    /// If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
    public struct AllowedMethods: Swift.Equatable {
        /// A complex type that controls whether CloudFront caches the response to requests using the specified HTTP methods. There are two choices:
        ///
        /// * CloudFront caches responses to GET and HEAD requests.
        ///
        /// * CloudFront caches responses to GET, HEAD, and OPTIONS requests.
        ///
        ///
        /// If you pick the second choice for your Amazon S3 Origin, you may need to forward Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the responses to be cached correctly.
        public var cachedMethods: CloudFrontClientTypes.CachedMethods?
        /// A complex type that contains the HTTP methods that you want CloudFront to process and forward to your origin.
        /// This member is required.
        public var items: [CloudFrontClientTypes.Method]?
        /// The number of HTTP methods that you want CloudFront to forward to your origin. Valid values are 2 (for GET and HEAD requests), 3 (for GET, HEAD, and OPTIONS requests) and 7 (for GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests).
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            cachedMethods: CloudFrontClientTypes.CachedMethods? = nil,
            items: [CloudFrontClientTypes.Method]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.cachedMethods = cachedMethods
            self.items = items
            self.quantity = quantity
        }
    }

}

extension AssociateAliasInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let alias = alias {
            let aliasQueryItem = ClientRuntime.URLQueryItem(name: "Alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
            items.append(aliasQueryItem)
        }
        return items
    }
}

extension AssociateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let targetDistributionId = targetDistributionId else {
            return nil
        }
        return "/2020-05-31/distribution/\(targetDistributionId.urlPercentEncoding())/associate-alias"
    }
}

public struct AssociateAliasInput: Swift.Equatable {
    /// The alias (also known as a CNAME) to add to the target distribution.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of the distribution that you’re associating the alias with.
    /// This member is required.
    public var targetDistributionId: Swift.String?

    public init (
        alias: Swift.String? = nil,
        targetDistributionId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.targetDistributionId = targetDistributionId
    }
}

struct AssociateAliasInputBody: Swift.Equatable {
}

extension AssociateAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AssociateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionCNAMEs" : self = .tooManyDistributionCNAMEs(try TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateAliasOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalUpdate(IllegalUpdate)
    case invalidArgument(InvalidArgument)
    case noSuchDistribution(NoSuchDistribution)
    case tooManyDistributionCNAMEs(TooManyDistributionCNAMEs)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateAliasOutputResponse: Swift.Equatable {

}

extension BatchTooLarge {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<BatchTooLargeBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Invalidation batch specified is too large.
public struct BatchTooLarge: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BatchTooLargeBody: Swift.Equatable {
    let message: Swift.String?
}

extension BatchTooLargeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CNAMEAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CNAMEAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The CNAME specified is already defined for CloudFront.
public struct CNAMEAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CNAMEAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension CNAMEAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CacheBehavior: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedMethods = "AllowedMethods"
        case cachePolicyId = "CachePolicyId"
        case compress = "Compress"
        case defaultTTL = "DefaultTTL"
        case fieldLevelEncryptionId = "FieldLevelEncryptionId"
        case forwardedValues = "ForwardedValues"
        case functionAssociations = "FunctionAssociations"
        case lambdaFunctionAssociations = "LambdaFunctionAssociations"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case originRequestPolicyId = "OriginRequestPolicyId"
        case pathPattern = "PathPattern"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case responseHeadersPolicyId = "ResponseHeadersPolicyId"
        case smoothStreaming = "SmoothStreaming"
        case targetOriginId = "TargetOriginId"
        case trustedKeyGroups = "TrustedKeyGroups"
        case trustedSigners = "TrustedSigners"
        case viewerProtocolPolicy = "ViewerProtocolPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let allowedMethods = allowedMethods {
            try container.encode(allowedMethods, forKey: ClientRuntime.Key("AllowedMethods"))
        }
        if let cachePolicyId = cachePolicyId {
            try container.encode(cachePolicyId, forKey: ClientRuntime.Key("CachePolicyId"))
        }
        if let compress = compress {
            try container.encode(compress, forKey: ClientRuntime.Key("Compress"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: ClientRuntime.Key("DefaultTTL"))
        }
        if let fieldLevelEncryptionId = fieldLevelEncryptionId {
            try container.encode(fieldLevelEncryptionId, forKey: ClientRuntime.Key("FieldLevelEncryptionId"))
        }
        if let forwardedValues = forwardedValues {
            try container.encode(forwardedValues, forKey: ClientRuntime.Key("ForwardedValues"))
        }
        if let functionAssociations = functionAssociations {
            try container.encode(functionAssociations, forKey: ClientRuntime.Key("FunctionAssociations"))
        }
        if let lambdaFunctionAssociations = lambdaFunctionAssociations {
            try container.encode(lambdaFunctionAssociations, forKey: ClientRuntime.Key("LambdaFunctionAssociations"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: ClientRuntime.Key("MaxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: ClientRuntime.Key("MinTTL"))
        }
        if let originRequestPolicyId = originRequestPolicyId {
            try container.encode(originRequestPolicyId, forKey: ClientRuntime.Key("OriginRequestPolicyId"))
        }
        if let pathPattern = pathPattern {
            try container.encode(pathPattern, forKey: ClientRuntime.Key("PathPattern"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: ClientRuntime.Key("RealtimeLogConfigArn"))
        }
        if let responseHeadersPolicyId = responseHeadersPolicyId {
            try container.encode(responseHeadersPolicyId, forKey: ClientRuntime.Key("ResponseHeadersPolicyId"))
        }
        if let smoothStreaming = smoothStreaming {
            try container.encode(smoothStreaming, forKey: ClientRuntime.Key("SmoothStreaming"))
        }
        if let targetOriginId = targetOriginId {
            try container.encode(targetOriginId, forKey: ClientRuntime.Key("TargetOriginId"))
        }
        if let trustedKeyGroups = trustedKeyGroups {
            try container.encode(trustedKeyGroups, forKey: ClientRuntime.Key("TrustedKeyGroups"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
        if let viewerProtocolPolicy = viewerProtocolPolicy {
            try container.encode(viewerProtocolPolicy, forKey: ClientRuntime.Key("ViewerProtocolPolicy"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPattern)
        pathPattern = pathPatternDecoded
        let targetOriginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetOriginId)
        targetOriginId = targetOriginIdDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let trustedKeyGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedKeyGroups.self, forKey: .trustedKeyGroups)
        trustedKeyGroups = trustedKeyGroupsDecoded
        let viewerProtocolPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerProtocolPolicy.self, forKey: .viewerProtocolPolicy)
        viewerProtocolPolicy = viewerProtocolPolicyDecoded
        let allowedMethodsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.AllowedMethods.self, forKey: .allowedMethods)
        allowedMethods = allowedMethodsDecoded
        let smoothStreamingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .smoothStreaming)
        smoothStreaming = smoothStreamingDecoded
        let compressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .compress)
        compress = compressDecoded
        let lambdaFunctionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.LambdaFunctionAssociations.self, forKey: .lambdaFunctionAssociations)
        lambdaFunctionAssociations = lambdaFunctionAssociationsDecoded
        let functionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionAssociations.self, forKey: .functionAssociations)
        functionAssociations = functionAssociationsDecoded
        let fieldLevelEncryptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldLevelEncryptionId)
        fieldLevelEncryptionId = fieldLevelEncryptionIdDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
        let cachePolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cachePolicyId)
        cachePolicyId = cachePolicyIdDecoded
        let originRequestPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originRequestPolicyId)
        originRequestPolicyId = originRequestPolicyIdDecoded
        let responseHeadersPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseHeadersPolicyId)
        responseHeadersPolicyId = responseHeadersPolicyIdDecoded
        let forwardedValuesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ForwardedValues.self, forKey: .forwardedValues)
        forwardedValues = forwardedValuesDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
    }
}

extension CloudFrontClientTypes.CacheBehavior: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that describes how CloudFront processes requests. You must create at least as many cache behaviors (including the default cache behavior) as you have origins if you want CloudFront to serve objects from all of the origins. Each cache behavior specifies the one origin from which you want CloudFront to get objects. If you have two origins and only the default cache behavior, the default cache behavior will cause CloudFront to get objects from one of the origins, but the other origin is never used. For the current quota (formerly known as limit) on the number of cache behaviors that you can add to a distribution, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) in the Amazon CloudFront Developer Guide. If you don’t want to specify any cache behaviors, include only an empty CacheBehaviors element. Don’t include an empty CacheBehavior element because this is invalid. To delete all cache behaviors in an existing distribution, update the distribution configuration and include only an empty CacheBehaviors element. To add, change, or remove one or more cache behaviors, update the distribution configuration and specify all of the cache behaviors that you want to include in the updated distribution. For more information about cache behaviors, see [Cache Behavior Settings](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesCacheBehavior) in the Amazon CloudFront Developer Guide.
    public struct CacheBehavior: Swift.Equatable {
        /// A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:
        ///
        /// * CloudFront forwards only GET and HEAD requests.
        ///
        /// * CloudFront forwards only GET, HEAD, and OPTIONS requests.
        ///
        /// * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests.
        ///
        ///
        /// If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
        public var allowedMethods: CloudFrontClientTypes.AllowedMethods?
        /// The unique identifier of the cache policy that is attached to this cache behavior. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. A CacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId.
        public var cachePolicyId: Swift.String?
        /// Whether you want CloudFront to automatically compress certain files for this cache behavior. If so, specify true; if not, specify false. For more information, see [Serving Compressed Files](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html) in the Amazon CloudFront Developer Guide.
        public var compress: Swift.Bool?
        /// This field is deprecated. We recommend that you use the DefaultTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The default amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin does not add HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var defaultTTL: Swift.Int?
        /// The value of ID for the field-level encryption configuration that you want CloudFront to use for encrypting specific fields of data for this cache behavior.
        public var fieldLevelEncryptionId: Swift.String?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. For more information, see [Working with policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html) in the Amazon CloudFront Developer Guide. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide. A CacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
        @available(*, deprecated)
        public var forwardedValues: CloudFrontClientTypes.ForwardedValues?
        /// A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
        public var functionAssociations: CloudFrontClientTypes.FunctionAssociations?
        /// A complex type that contains zero or more Lambda@Edge function associations for a cache behavior.
        public var lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations?
        /// This field is deprecated. We recommend that you use the MaxTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin adds HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var maxTTL: Swift.Int?
        /// This field is deprecated. We recommend that you use the MinTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. For more information, see [ Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. You must specify 0 for MinTTL if you configure CloudFront to forward all headers to your origin (under Headers, if you specify 1 for Quantity and * for Name).
        @available(*, deprecated)
        public var minTTL: Swift.Int?
        /// The unique identifier of the origin request policy that is attached to this cache behavior. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide.
        public var originRequestPolicyId: Swift.String?
        /// The pattern (for example, images/*.jpg) that specifies which requests to apply the behavior to. When CloudFront receives a viewer request, the requested path is compared with path patterns in the order in which cache behaviors are listed in the distribution. You can optionally include a slash (/) at the beginning of the path pattern. For example, /images/*.jpg. CloudFront behavior is the same with or without the leading /. The path pattern for the default cache behavior is * and cannot be changed. If the request for an object does not match the path pattern for any cache behaviors, CloudFront applies the behavior in the default cache behavior. For more information, see [Path Pattern](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesPathPattern) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var pathPattern: Swift.String?
        /// The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this cache behavior. For more information, see [Real-time logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html) in the Amazon CloudFront Developer Guide.
        public var realtimeLogConfigArn: Swift.String?
        /// The identifier for a response headers policy.
        public var responseHeadersPolicyId: Swift.String?
        /// Indicates whether you want to distribute media files in the Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify true; if not, specify false. If you specify true for SmoothStreaming, you can still distribute other content using this cache behavior if the content matches the value of PathPattern.
        public var smoothStreaming: Swift.Bool?
        /// The value of ID for the origin that you want CloudFront to route requests to when they match this cache behavior.
        /// This member is required.
        public var targetOriginId: Swift.String?
        /// A list of key groups that CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with a private key whose corresponding public key is in the key group. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups?
        /// We recommend using TrustedKeyGroups instead of TrustedSigners. A list of Amazon Web Services account IDs whose public keys CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with the private key of a CloudFront key pair in the trusted signer’s Amazon Web Services account. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?
        /// The protocol that viewers can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. You can specify the following options:
        ///
        /// * allow-all: Viewers can use HTTP or HTTPS.
        ///
        /// * redirect-to-https: If a viewer submits an HTTP request, CloudFront returns an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The viewer then resubmits the request using the new URL.
        ///
        /// * https-only: If a viewer sends an HTTP request, CloudFront returns an HTTP status code of 403 (Forbidden).
        ///
        ///
        /// For more information about requiring the HTTPS protocol, see [Requiring HTTPS Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html) in the Amazon CloudFront Developer Guide. The only way to guarantee that viewers retrieve an object that was fetched from the origin using HTTPS is never to use any other protocol to fetch the object. If you have recently changed from HTTP to HTTPS, we recommend that you clear your objects’ cache because cached objects are protocol agnostic. That means that an edge location will return an object from the cache regardless of whether the current request protocol matches the protocol used previously. For more information, see [Managing Cache Expiration](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy?

        public init (
            allowedMethods: CloudFrontClientTypes.AllowedMethods? = nil,
            cachePolicyId: Swift.String? = nil,
            compress: Swift.Bool? = nil,
            defaultTTL: Swift.Int? = nil,
            fieldLevelEncryptionId: Swift.String? = nil,
            forwardedValues: CloudFrontClientTypes.ForwardedValues? = nil,
            functionAssociations: CloudFrontClientTypes.FunctionAssociations? = nil,
            lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            originRequestPolicyId: Swift.String? = nil,
            pathPattern: Swift.String? = nil,
            realtimeLogConfigArn: Swift.String? = nil,
            responseHeadersPolicyId: Swift.String? = nil,
            smoothStreaming: Swift.Bool? = nil,
            targetOriginId: Swift.String? = nil,
            trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil,
            viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy? = nil
        )
        {
            self.allowedMethods = allowedMethods
            self.cachePolicyId = cachePolicyId
            self.compress = compress
            self.defaultTTL = defaultTTL
            self.fieldLevelEncryptionId = fieldLevelEncryptionId
            self.forwardedValues = forwardedValues
            self.functionAssociations = functionAssociations
            self.lambdaFunctionAssociations = lambdaFunctionAssociations
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.originRequestPolicyId = originRequestPolicyId
            self.pathPattern = pathPattern
            self.realtimeLogConfigArn = realtimeLogConfigArn
            self.responseHeadersPolicyId = responseHeadersPolicyId
            self.smoothStreaming = smoothStreaming
            self.targetOriginId = targetOriginId
            self.trustedKeyGroups = trustedKeyGroups
            self.trustedSigners = trustedSigners
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }

}

extension CloudFrontClientTypes.CacheBehaviors: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for cachebehavior0 in items {
                try itemsContainer.encode(cachebehavior0, forKey: ClientRuntime.Key("CacheBehavior"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CacheBehavior{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CacheBehavior>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CacheBehavior].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CacheBehavior]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CacheBehavior]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CacheBehaviors: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains zero or more CacheBehavior elements.
    public struct CacheBehaviors: Swift.Equatable {
        /// Optional: A complex type that contains cache behaviors for this distribution. If Quantity is 0, you can omit Items.
        public var items: [CloudFrontClientTypes.CacheBehavior]?
        /// The number of cache behaviors for this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.CacheBehavior]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CachePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicyConfig = cachePolicyConfig {
            try container.encode(cachePolicyConfig, forKey: ClientRuntime.Key("CachePolicyConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension CloudFrontClientTypes.CachePolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A cache policy. When it’s attached to a cache behavior, the cache policy determines the following:
    ///
    /// * The values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer.
    ///
    /// * The default, minimum, and maximum time to live (TTL) values that you want objects to stay in the CloudFront cache.
    ///
    ///
    /// The headers, cookies, and query strings that are included in the cache key are automatically included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t find a valid object in its cache that matches the request’s cache key. If you want to send values to the origin but not include them in the cache key, use OriginRequestPolicy.
    public struct CachePolicy: Swift.Equatable {
        /// The cache policy configuration.
        /// This member is required.
        public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
        /// The unique identifier for the cache policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time when the cache policy was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init (
            cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.cachePolicyConfig = cachePolicyConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension CachePolicyAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CachePolicyAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A cache policy with this name already exists. You must provide a unique name. To modify an existing cache policy, use UpdateCachePolicy.
public struct CachePolicyAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CachePolicyAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension CachePolicyAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case defaultTTL = "DefaultTTL"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case name = "Name"
        case parametersInCacheKeyAndForwardedToOrigin = "ParametersInCacheKeyAndForwardedToOrigin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: ClientRuntime.Key("DefaultTTL"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: ClientRuntime.Key("MaxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: ClientRuntime.Key("MinTTL"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin {
            try container.encode(parametersInCacheKeyAndForwardedToOrigin, forKey: ClientRuntime.Key("ParametersInCacheKeyAndForwardedToOrigin"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let parametersInCacheKeyAndForwardedToOriginDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin.self, forKey: .parametersInCacheKeyAndForwardedToOrigin)
        parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOriginDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A cache policy configuration. This configuration determines the following:
    ///
    /// * The values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer.
    ///
    /// * The default, minimum, and maximum time to live (TTL) values that you want objects to stay in the CloudFront cache.
    ///
    ///
    /// The headers, cookies, and query strings that are included in the cache key are automatically included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t find a valid object in its cache that matches the request’s cache key. If you want to send values to the origin but not include them in the cache key, use OriginRequestPolicy.
    public struct CachePolicyConfig: Swift.Equatable {
        /// A comment to describe the cache policy. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The default amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated. CloudFront uses this value as the object’s time to live (TTL) only when the origin does not send Cache-Control or Expires headers with the object. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. The default value for this field is 86400 seconds (one day). If the value of MinTTL is more than 86400 seconds, then the default value for this field is the same as the value of MinTTL.
        public var defaultTTL: Swift.Int?
        /// The maximum amount of time, in seconds, that objects stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated. CloudFront uses this value only when the origin sends Cache-Control or Expires headers with the object. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. The default value for this field is 31536000 seconds (one year). If the value of MinTTL or DefaultTTL is more than 31536000 seconds, then the default value for this field is the same as the value of DefaultTTL.
        public var maxTTL: Swift.Int?
        /// The minimum amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var minTTL: Swift.Int?
        /// A unique name to identify the cache policy.
        /// This member is required.
        public var name: Swift.String?
        /// The HTTP headers, cookies, and URL query strings to include in the cache key. The values included in the cache key are automatically included in requests that CloudFront sends to the origin.
        public var parametersInCacheKeyAndForwardedToOrigin: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin?

        public init (
            comment: Swift.String? = nil,
            defaultTTL: Swift.Int? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            name: Swift.String? = nil,
            parametersInCacheKeyAndForwardedToOrigin: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin? = nil
        )
        {
            self.comment = comment
            self.defaultTTL = defaultTTL
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.name = name
            self.parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyCookieBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyCookieBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyCookieBehavior(rawValue: rawValue) ?? CachePolicyCookieBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachePolicyCookiesConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieBehavior = "CookieBehavior"
        case cookies = "Cookies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookieBehavior = cookieBehavior {
            try container.encode(cookieBehavior, forKey: ClientRuntime.Key("CookieBehavior"))
        }
        if let cookies = cookies {
            try container.encode(cookies, forKey: ClientRuntime.Key("Cookies"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cookieBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyCookieBehavior.self, forKey: .cookieBehavior)
        cookieBehavior = cookieBehaviorDecoded
        let cookiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookieNames.self, forKey: .cookies)
        cookies = cookiesDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyCookiesConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the cache key and automatically included in requests that CloudFront sends to the origin.
    public struct CachePolicyCookiesConfig: Swift.Equatable {
        /// Determines whether any cookies in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – Cookies in viewer requests are not included in the cache key and are not automatically included in requests that CloudFront sends to the origin. Even when this field is set to none, any cookies that are listed in an OriginRequestPolicy are included in origin requests.
        ///
        /// * whitelist – The cookies in viewer requests that are listed in the CookieNames type are included in the cache key and automatically included in requests that CloudFront sends to the origin.
        ///
        /// * allExcept – All cookies in viewer requests that are not listed in the CookieNames type are included in the cache key and automatically included in requests that CloudFront sends to the origin.
        ///
        /// * all – All cookies in viewer requests are included in the cache key and are automatically included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var cookieBehavior: CloudFrontClientTypes.CachePolicyCookieBehavior?
        /// Contains a list of cookie names.
        public var cookies: CloudFrontClientTypes.CookieNames?

        public init (
            cookieBehavior: CloudFrontClientTypes.CachePolicyCookieBehavior? = nil,
            cookies: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.cookieBehavior = cookieBehavior
            self.cookies = cookies
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyHeaderBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyHeaderBehavior] {
            return [
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyHeaderBehavior(rawValue: rawValue) ?? CachePolicyHeaderBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachePolicyHeadersConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerBehavior = "HeaderBehavior"
        case headers = "Headers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let headerBehavior = headerBehavior {
            try container.encode(headerBehavior, forKey: ClientRuntime.Key("HeaderBehavior"))
        }
        if let headers = headers {
            try container.encode(headers, forKey: ClientRuntime.Key("Headers"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyHeaderBehavior.self, forKey: .headerBehavior)
        headerBehavior = headerBehaviorDecoded
        let headersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Headers.self, forKey: .headers)
        headers = headersDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyHeadersConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any HTTP headers (and if so, which headers) are included in the cache key and automatically included in requests that CloudFront sends to the origin.
    public struct CachePolicyHeadersConfig: Swift.Equatable {
        /// Determines whether any HTTP headers are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – HTTP headers are not included in the cache key and are not automatically included in requests that CloudFront sends to the origin. Even when this field is set to none, any headers that are listed in an OriginRequestPolicy are included in origin requests.
        ///
        /// * whitelist – The HTTP headers that are listed in the Headers type are included in the cache key and are automatically included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var headerBehavior: CloudFrontClientTypes.CachePolicyHeaderBehavior?
        /// Contains a list of HTTP header names.
        public var headers: CloudFrontClientTypes.Headers?

        public init (
            headerBehavior: CloudFrontClientTypes.CachePolicyHeaderBehavior? = nil,
            headers: CloudFrontClientTypes.Headers? = nil
        )
        {
            self.headerBehavior = headerBehavior
            self.headers = headers
        }
    }

}

extension CachePolicyInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CachePolicyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot delete the cache policy because it is attached to one or more cache behaviors.
public struct CachePolicyInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CachePolicyInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension CachePolicyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for cachepolicysummary0 in items {
                try itemsContainer.encode(cachepolicysummary0, forKey: ClientRuntime.Key("CachePolicySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CachePolicySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CachePolicySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CachePolicySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CachePolicySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CachePolicySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CachePolicyList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of cache policies.
    public struct CachePolicyList: Swift.Equatable {
        /// Contains the cache policies in the list.
        public var items: [CloudFrontClientTypes.CachePolicySummary]?
        /// The maximum number of cache policies requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing cache policies where you left off.
        public var nextMarker: Swift.String?
        /// The total number of cache policies returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.CachePolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyQueryStringBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyQueryStringBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyQueryStringBehavior(rawValue: rawValue) ?? CachePolicyQueryStringBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachePolicyQueryStringsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryStringBehavior = "QueryStringBehavior"
        case queryStrings = "QueryStrings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let queryStringBehavior = queryStringBehavior {
            try container.encode(queryStringBehavior, forKey: ClientRuntime.Key("QueryStringBehavior"))
        }
        if let queryStrings = queryStrings {
            try container.encode(queryStrings, forKey: ClientRuntime.Key("QueryStrings"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyQueryStringBehavior.self, forKey: .queryStringBehavior)
        queryStringBehavior = queryStringBehaviorDecoded
        let queryStringsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryStringNames.self, forKey: .queryStrings)
        queryStrings = queryStringsDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyQueryStringsConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the cache key and automatically included in requests that CloudFront sends to the origin.
    public struct CachePolicyQueryStringsConfig: Swift.Equatable {
        /// Determines whether any URL query strings in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – Query strings in viewer requests are not included in the cache key and are not automatically included in requests that CloudFront sends to the origin. Even when this field is set to none, any query strings that are listed in an OriginRequestPolicy are included in origin requests.
        ///
        /// * whitelist – The query strings in viewer requests that are listed in the QueryStringNames type are included in the cache key and automatically included in requests that CloudFront sends to the origin.
        ///
        /// * allExcept – All query strings in viewer requests that are not listed in the QueryStringNames type are included in the cache key and automatically included in requests that CloudFront sends to the origin.
        ///
        /// * all – All query strings in viewer requests are included in the cache key and are automatically included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var queryStringBehavior: CloudFrontClientTypes.CachePolicyQueryStringBehavior?
        /// Contains the specific query strings in viewer requests that either are or are not included in the cache key and automatically included in requests that CloudFront sends to the origin. The behavior depends on whether the QueryStringBehavior field in the CachePolicyQueryStringsConfig type is set to whitelist (the listed query strings are included) or allExcept (the listed query strings are not included, but all other query strings are).
        public var queryStrings: CloudFrontClientTypes.QueryStringNames?

        public init (
            queryStringBehavior: CloudFrontClientTypes.CachePolicyQueryStringBehavior? = nil,
            queryStrings: CloudFrontClientTypes.QueryStringNames? = nil
        )
        {
            self.queryStringBehavior = queryStringBehavior
            self.queryStrings = queryStrings
        }
    }

}

extension CloudFrontClientTypes.CachePolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicy = cachePolicy {
            try container.encode(cachePolicy, forKey: ClientRuntime.Key("CachePolicy"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyType.self, forKey: .type)
        type = typeDecoded
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

extension CloudFrontClientTypes.CachePolicySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains a cache policy.
    public struct CachePolicySummary: Swift.Equatable {
        /// The cache policy.
        /// This member is required.
        public var cachePolicy: CloudFrontClientTypes.CachePolicy?
        /// The type of cache policy, either managed (created by Amazon Web Services) or custom (created in this Amazon Web Services account).
        /// This member is required.
        public var type: CloudFrontClientTypes.CachePolicyType?

        public init (
            cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
            type: CloudFrontClientTypes.CachePolicyType? = nil
        )
        {
            self.cachePolicy = cachePolicy
            self.type = type
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyType] {
            return [
                .custom,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyType(rawValue: rawValue) ?? CachePolicyType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachedMethods: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for method0 in items {
                try itemsContainer.encode(method0, forKey: ClientRuntime.Key("Method"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Method{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Method>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Method].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Method]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Method]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CachedMethods: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls whether CloudFront caches the response to requests using the specified HTTP methods. There are two choices:
    ///
    /// * CloudFront caches responses to GET and HEAD requests.
    ///
    /// * CloudFront caches responses to GET, HEAD, and OPTIONS requests.
    ///
    ///
    /// If you pick the second choice for your Amazon S3 Origin, you may need to forward Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the responses to be cached correctly.
    public struct CachedMethods: Swift.Equatable {
        /// A complex type that contains the HTTP methods that you want CloudFront to cache responses to.
        /// This member is required.
        public var items: [CloudFrontClientTypes.Method]?
        /// The number of HTTP methods for which you want CloudFront to cache responses. Valid values are 2 (for caching responses to GET and HEAD requests) and 3 (for caching responses to GET, HEAD, and OPTIONS requests).
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.Method]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CannotChangeImmutablePublicKeyFields {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CannotChangeImmutablePublicKeyFieldsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't change the value of a public key.
public struct CannotChangeImmutablePublicKeyFields: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CannotChangeImmutablePublicKeyFieldsBody: Swift.Equatable {
    let message: Swift.String?
}

extension CannotChangeImmutablePublicKeyFieldsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes {
    public enum CertificateSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acm
        case cloudfront
        case iam
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateSource] {
            return [
                .acm,
                .cloudfront,
                .iam,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acm: return "acm"
            case .cloudfront: return "cloudfront"
            case .iam: return "iam"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateSource(rawValue: rawValue) ?? CertificateSource.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
        case id = "Id"
        case s3CanonicalUserId = "S3CanonicalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig {
            try container.encode(cloudFrontOriginAccessIdentityConfig, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentityConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let s3CanonicalUserId = s3CanonicalUserId {
            try container.encode(s3CanonicalUserId, forKey: ClientRuntime.Key("S3CanonicalUserId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let s3CanonicalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3CanonicalUserId)
        s3CanonicalUserId = s3CanonicalUserIdDecoded
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentity: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// CloudFront origin access identity.
    public struct CloudFrontOriginAccessIdentity: Swift.Equatable {
        /// The current configuration information for the identity.
        public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
        /// The ID for the origin access identity, for example, E74FTE3AJFJ256A.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon S3 canonical user ID for the origin access identity, used when giving the origin access identity read permission to an object in Amazon S3.
        /// This member is required.
        public var s3CanonicalUserId: Swift.String?

        public init (
            cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
            id: Swift.String? = nil,
            s3CanonicalUserId: Swift.String? = nil
        )
        {
            self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
            self.id = id
            self.s3CanonicalUserId = s3CanonicalUserId
        }
    }

}

extension CloudFrontOriginAccessIdentityAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CloudFrontOriginAccessIdentityAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// If the CallerReference is a value you already sent in a previous request to create an identity but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error.
public struct CloudFrontOriginAccessIdentityAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CloudFrontOriginAccessIdentityAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudFrontOriginAccessIdentityAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Origin access identity configuration. Send a GET request to the /CloudFront API version/CloudFront/identity ID/config resource.
    public struct CloudFrontOriginAccessIdentityConfig: Swift.Equatable {
        /// A unique value (for example, a date-time stamp) that ensures that the request can't be replayed. If the value of CallerReference is new (regardless of the content of the CloudFrontOriginAccessIdentityConfig object), a new origin access identity is created. If the CallerReference is a value already sent in a previous identity request, and the content of the CloudFrontOriginAccessIdentityConfig is identical to the original request (ignoring white space), the response includes the same information returned to the original request. If the CallerReference is a value you already sent in a previous request to create an identity, but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A comment to describe the origin access identity. The comment cannot be longer than 128 characters.
        /// This member is required.
        public var comment: Swift.String?

        public init (
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
        }
    }

}

extension CloudFrontOriginAccessIdentityInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CloudFrontOriginAccessIdentityInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Origin Access Identity specified is already in use.
public struct CloudFrontOriginAccessIdentityInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CloudFrontOriginAccessIdentityInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudFrontOriginAccessIdentityInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for cloudfrontoriginaccessidentitysummary0 in items {
                try itemsContainer.encode(cloudfrontoriginaccessidentitysummary0, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentitySummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CloudFrontOriginAccessIdentitySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CloudFrontOriginAccessIdentitySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Lists the origin access identities for CloudFront.Send a GET request to the /CloudFront API version/origin-access-identity/cloudfront resource. The response includes a CloudFrontOriginAccessIdentityList element with zero or more CloudFrontOriginAccessIdentitySummary child elements. By default, your entire list of origin access identities is returned in one single page. If the list is long, you can paginate it using the MaxItems and Marker parameters.
    public struct CloudFrontOriginAccessIdentityList: Swift.Equatable {
        /// A flag that indicates whether more origin access identities remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more items in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one CloudFrontOriginAccessIdentitySummary element for each origin access identity that was created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]?
        /// Use this when paginating results to indicate where to begin in your list of origin access identities. The results include identities in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last identity on that page).
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of origin access identities you want in the response body.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your origin access identities where they left off.
        public var nextMarker: Swift.String?
        /// The number of CloudFront origin access identities that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case id = "Id"
        case s3CanonicalUserId = "S3CanonicalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let s3CanonicalUserId = s3CanonicalUserId {
            try container.encode(s3CanonicalUserId, forKey: ClientRuntime.Key("S3CanonicalUserId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let s3CanonicalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3CanonicalUserId)
        s3CanonicalUserId = s3CanonicalUserIdDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Summary of the information about a CloudFront origin access identity.
    public struct CloudFrontOriginAccessIdentitySummary: Swift.Equatable {
        /// The comment for this origin access identity, as originally specified when created.
        /// This member is required.
        public var comment: Swift.String?
        /// The ID for the origin access identity. For example: E74FTE3AJFJ256A.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon S3 canonical user ID for the origin access identity, which you use when giving the origin access identity read permission to an object in Amazon S3.
        /// This member is required.
        public var s3CanonicalUserId: Swift.String?

        public init (
            comment: Swift.String? = nil,
            id: Swift.String? = nil,
            s3CanonicalUserId: Swift.String? = nil
        )
        {
            self.comment = comment
            self.id = id
            self.s3CanonicalUserId = s3CanonicalUserId
        }
    }

}

extension CloudFrontClientTypes.ConflictingAlias: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alias = "Alias"
        case distributionId = "DistributionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accountId = accountId {
            try container.encode(accountId, forKey: ClientRuntime.Key("AccountId"))
        }
        if let alias = alias {
            try container.encode(alias, forKey: ClientRuntime.Key("Alias"))
        }
        if let distributionId = distributionId {
            try container.encode(distributionId, forKey: ClientRuntime.Key("DistributionId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let distributionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionId)
        distributionId = distributionIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension CloudFrontClientTypes.ConflictingAlias: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An alias (also called a CNAME) and the CloudFront distribution and Amazon Web Services account ID that it’s associated with. The distribution and account IDs are partially hidden, which allows you to identify the distributions and accounts that you own, but helps to protect the information of ones that you don’t own.
    public struct ConflictingAlias: Swift.Equatable {
        /// The (partially hidden) ID of the Amazon Web Services account that owns the distribution that’s associated with the alias.
        public var accountId: Swift.String?
        /// An alias (also called a CNAME).
        public var alias: Swift.String?
        /// The (partially hidden) ID of the CloudFront distribution associated with the alias.
        public var distributionId: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            alias: Swift.String? = nil,
            distributionId: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.alias = alias
            self.distributionId = distributionId
        }
    }

}

extension CloudFrontClientTypes.ConflictingAliasesList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for conflictingalias0 in items {
                try itemsContainer.encode(conflictingalias0, forKey: ClientRuntime.Key("ConflictingAlias"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct ConflictingAlias{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ConflictingAlias>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.ConflictingAlias].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.ConflictingAlias]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.ConflictingAlias]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ConflictingAliasesList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of aliases (also called CNAMEs) and the CloudFront distributions and Amazon Web Services accounts that they are associated with. In the list, the distribution and account IDs are partially hidden, which allows you to identify the distributions and accounts that you own, but helps to protect the information of ones that you don’t own.
    public struct ConflictingAliasesList: Swift.Equatable {
        /// Contains the conflicting aliases in the list.
        public var items: [CloudFrontClientTypes.ConflictingAlias]?
        /// The maximum number of conflicting aliases requested.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing conflicting aliases where you left off.
        public var nextMarker: Swift.String?
        /// The number of conflicting aliases returned in the response.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.ConflictingAlias]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ContentTypeProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "ContentType"
        case format = "Format"
        case profileId = "ProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let contentType = contentType {
            try container.encode(contentType, forKey: ClientRuntime.Key("ContentType"))
        }
        if let format = format {
            try container.encode(format, forKey: ClientRuntime.Key("Format"))
        }
        if let profileId = profileId {
            try container.encode(profileId, forKey: ClientRuntime.Key("ProfileId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension CloudFrontClientTypes.ContentTypeProfile: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A field-level encryption content type profile.
    public struct ContentTypeProfile: Swift.Equatable {
        /// The content type for a field-level encryption content type-profile mapping.
        /// This member is required.
        public var contentType: Swift.String?
        /// The format for a field-level encryption content type-profile mapping.
        /// This member is required.
        public var format: CloudFrontClientTypes.Format?
        /// The profile ID for a field-level encryption content type-profile mapping.
        public var profileId: Swift.String?

        public init (
            contentType: Swift.String? = nil,
            format: CloudFrontClientTypes.Format? = nil,
            profileId: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.format = format
            self.profileId = profileId
        }
    }

}

extension CloudFrontClientTypes.ContentTypeProfileConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentTypeProfiles = "ContentTypeProfiles"
        case forwardWhenContentTypeIsUnknown = "ForwardWhenContentTypeIsUnknown"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let contentTypeProfiles = contentTypeProfiles {
            try container.encode(contentTypeProfiles, forKey: ClientRuntime.Key("ContentTypeProfiles"))
        }
        if let forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknown {
            try container.encode(forwardWhenContentTypeIsUnknown, forKey: ClientRuntime.Key("ForwardWhenContentTypeIsUnknown"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardWhenContentTypeIsUnknownDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forwardWhenContentTypeIsUnknown)
        forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknownDecoded
        let contentTypeProfilesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContentTypeProfiles.self, forKey: .contentTypeProfiles)
        contentTypeProfiles = contentTypeProfilesDecoded
    }
}

extension CloudFrontClientTypes.ContentTypeProfileConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The configuration for a field-level encryption content type-profile mapping.
    public struct ContentTypeProfileConfig: Swift.Equatable {
        /// The configuration for a field-level encryption content type-profile.
        public var contentTypeProfiles: CloudFrontClientTypes.ContentTypeProfiles?
        /// The setting in a field-level encryption content type-profile mapping that specifies what to do when an unknown content type is provided for the profile. If true, content is forwarded without being encrypted when the content type is unknown. If false (the default), an error is returned when the content type is unknown.
        /// This member is required.
        public var forwardWhenContentTypeIsUnknown: Swift.Bool?

        public init (
            contentTypeProfiles: CloudFrontClientTypes.ContentTypeProfiles? = nil,
            forwardWhenContentTypeIsUnknown: Swift.Bool? = nil
        )
        {
            self.contentTypeProfiles = contentTypeProfiles
            self.forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknown
        }
    }

}

extension CloudFrontClientTypes.ContentTypeProfiles: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for contenttypeprofile0 in items {
                try itemsContainer.encode(contenttypeprofile0, forKey: ClientRuntime.Key("ContentTypeProfile"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct ContentTypeProfile{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ContentTypeProfile>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.ContentTypeProfile].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.ContentTypeProfile]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.ContentTypeProfile]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ContentTypeProfiles: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Field-level encryption content type-profile.
    public struct ContentTypeProfiles: Swift.Equatable {
        /// Items in a field-level encryption content type-profile mapping.
        public var items: [CloudFrontClientTypes.ContentTypeProfile]?
        /// The number of field-level encryption content type-profile mappings.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.ContentTypeProfile]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CookieNames: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CookieNames: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains a list of cookie names.
    public struct CookieNames: Swift.Equatable {
        /// A list of cookie names.
        public var items: [Swift.String]?
        /// The number of cookie names in the Items list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CookiePreference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forward = "Forward"
        case whitelistedNames = "WhitelistedNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let forward = forward {
            try container.encode(forward, forKey: ClientRuntime.Key("Forward"))
        }
        if let whitelistedNames = whitelistedNames {
            try container.encode(whitelistedNames, forKey: ClientRuntime.Key("WhitelistedNames"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ItemSelection.self, forKey: .forward)
        forward = forwardDecoded
        let whitelistedNamesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookieNames.self, forKey: .whitelistedNames)
        whitelistedNames = whitelistedNamesDecoded
    }
}

extension CloudFrontClientTypes.CookiePreference: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use CookiesConfig in a cache policy. See CachePolicy. If you want to send cookies to the origin but not include them in the cache key, use CookiesConfig in an origin request policy. See OriginRequestPolicy. A complex type that specifies whether you want CloudFront to forward cookies to the origin and, if so, which ones. For more information about forwarding cookies to the origin, see [Caching Content Based on Cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html) in the Amazon CloudFront Developer Guide.
    public struct CookiePreference: Swift.Equatable {
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send cookies to the origin but not include them in the cache key, use origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. Specifies which cookies to forward to the origin for this cache behavior: all, none, or the list of cookies specified in the WhitelistedNames complex type. Amazon S3 doesn't process cookies. When the cache behavior is forwarding requests to an Amazon S3 origin, specify none for the Forward element.
        /// This member is required.
        public var forward: CloudFrontClientTypes.ItemSelection?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. Required if you specify whitelist for the value of Forward. A complex type that specifies how many different cookies you want CloudFront to forward to the origin for this cache behavior and, if you want to forward selected cookies, the names of those cookies. If you specify all or none for the value of Forward, omit WhitelistedNames. If you change the value of Forward from whitelist to all or none and you don't delete the WhitelistedNames element and its child elements, CloudFront deletes them automatically. For the current limit on the number of cookie names that you can whitelist for each cache behavior, see [ CloudFront Limits](https://docs.aws.amazon.com/general/latest/gr/xrefaws_service_limits.html#limits_cloudfront) in the Amazon Web Services General Reference.
        public var whitelistedNames: CloudFrontClientTypes.CookieNames?

        public init (
            forward: CloudFrontClientTypes.ItemSelection? = nil,
            whitelistedNames: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.forward = forward
            self.whitelistedNames = whitelistedNames
        }
    }

}

public struct CreateCachePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCachePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCachePolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let cachePolicyConfig = input.operationInput.cachePolicyConfig {
                let cachePolicyConfigdata = try encoder.encode(cachePolicyConfig)
                let cachePolicyConfigbody = ClientRuntime.HttpBody.data(cachePolicyConfigdata)
                input.builder.withBody(cachePolicyConfigbody)
            } else {
                let cachePolicyConfigdata = try encoder.encode(input.operationInput)
                let cachePolicyConfigbody = ClientRuntime.HttpBody.data(cachePolicyConfigdata)
                input.builder.withBody(cachePolicyConfigbody)
            }
        } catch let err {
            throw SdkError<CreateCachePolicyOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateCachePolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateCachePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicyConfig = cachePolicyConfig {
            try container.encode(cachePolicyConfig, forKey: ClientRuntime.Key("CachePolicyConfig"))
        }
    }
}

extension CreateCachePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/cache-policy"
    }
}

public struct CreateCachePolicyInput: Swift.Equatable {
    /// A cache policy configuration.
    /// This member is required.
    public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?

    public init (
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
    }
}

struct CreateCachePolicyInputBody: Swift.Equatable {
    let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
}

extension CreateCachePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension CreateCachePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateCachePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CachePolicyAlreadyExists" : self = .cachePolicyAlreadyExists(try CachePolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCachePolicies" : self = .tooManyCachePolicies(try TooManyCachePolicies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInCachePolicy" : self = .tooManyCookiesInCachePolicy(try TooManyCookiesInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInCachePolicy" : self = .tooManyHeadersInCachePolicy(try TooManyHeadersInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInCachePolicy" : self = .tooManyQueryStringsInCachePolicy(try TooManyQueryStringsInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCachePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cachePolicyAlreadyExists(CachePolicyAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case tooManyCachePolicies(TooManyCachePolicies)
    case tooManyCookiesInCachePolicy(TooManyCookiesInCachePolicy)
    case tooManyHeadersInCachePolicy(TooManyHeadersInCachePolicy)
    case tooManyQueryStringsInCachePolicy(TooManyQueryStringsInCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCachePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CachePolicy = try responseDecoder.decode(responseBody: data)
                self.cachePolicy = output
            } else {
                self.cachePolicy = nil
            }
        } else {
            self.cachePolicy = nil
        }
    }
}

public struct CreateCachePolicyOutputResponse: Swift.Equatable {
    /// A cache policy.
    public var cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// The current version of the cache policy.
    public var eTag: Swift.String?
    /// The fully qualified URI of the cache policy just created.
    public var location: Swift.String?

    public init (
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
        self.location = location
    }
}

struct CreateCachePolicyOutputResponseBody: Swift.Equatable {
    let cachePolicy: CloudFrontClientTypes.CachePolicy?
}

extension CreateCachePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

public struct CreateCloudFrontOriginAccessIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFrontOriginAccessIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let cloudFrontOriginAccessIdentityConfig = input.operationInput.cloudFrontOriginAccessIdentityConfig {
                let cloudFrontOriginAccessIdentityConfigdata = try encoder.encode(cloudFrontOriginAccessIdentityConfig)
                let cloudFrontOriginAccessIdentityConfigbody = ClientRuntime.HttpBody.data(cloudFrontOriginAccessIdentityConfigdata)
                input.builder.withBody(cloudFrontOriginAccessIdentityConfigbody)
            } else {
                let cloudFrontOriginAccessIdentityConfigdata = try encoder.encode(input.operationInput)
                let cloudFrontOriginAccessIdentityConfigbody = ClientRuntime.HttpBody.data(cloudFrontOriginAccessIdentityConfigdata)
                input.builder.withBody(cloudFrontOriginAccessIdentityConfigbody)
            }
        } catch let err {
            throw SdkError<CreateCloudFrontOriginAccessIdentityOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateCloudFrontOriginAccessIdentityInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateCloudFrontOriginAccessIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig {
            try container.encode(cloudFrontOriginAccessIdentityConfig, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentityConfig"))
        }
    }
}

extension CreateCloudFrontOriginAccessIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/origin-access-identity/cloudfront"
    }
}

/// The request to create a new origin access identity (OAI). An origin access identity is a special CloudFront user that you can associate with Amazon S3 origins, so that you can secure all or just some of your Amazon S3 content. For more information, see [ Restricting Access to Amazon S3 Content by Using an Origin Access Identity](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) in the Amazon CloudFront Developer Guide.
public struct CreateCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The current configuration information for the identity.
    /// This member is required.
    public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?

    public init (
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
    }
}

struct CreateCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
    let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
}

extension CreateCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension CreateCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudFrontOriginAccessIdentityAlreadyExists" : self = .cloudFrontOriginAccessIdentityAlreadyExists(try CloudFrontOriginAccessIdentityAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCloudFrontOriginAccessIdentities" : self = .tooManyCloudFrontOriginAccessIdentities(try TooManyCloudFrontOriginAccessIdentities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCloudFrontOriginAccessIdentityOutputError: Swift.Error, Swift.Equatable {
    case cloudFrontOriginAccessIdentityAlreadyExists(CloudFrontOriginAccessIdentityAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case missingBody(MissingBody)
    case tooManyCloudFrontOriginAccessIdentities(TooManyCloudFrontOriginAccessIdentities)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCloudFrontOriginAccessIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentity = try responseDecoder.decode(responseBody: data)
                self.cloudFrontOriginAccessIdentity = output
            } else {
                self.cloudFrontOriginAccessIdentity = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentity = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateCloudFrontOriginAccessIdentityOutputResponse: Swift.Equatable {
    /// The origin access identity's information.
    public var cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// The current version of the origin access identity created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new origin access identity just created.
    public var location: Swift.String?

    public init (
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
        self.location = location
    }
}

struct CreateCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Equatable {
    let cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
}

extension CreateCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentity = "CloudFrontOriginAccessIdentity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentity.self, forKey: .cloudFrontOriginAccessIdentity)
        cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentityDecoded
    }
}

public struct CreateDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateDistributionOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let distributionConfig = input.operationInput.distributionConfig {
                let distributionConfigdata = try encoder.encode(distributionConfig)
                let distributionConfigbody = ClientRuntime.HttpBody.data(distributionConfigdata)
                input.builder.withBody(distributionConfigbody)
            } else {
                let distributionConfigdata = try encoder.encode(input.operationInput)
                let distributionConfigbody = ClientRuntime.HttpBody.data(distributionConfigdata)
                input.builder.withBody(distributionConfigbody)
            }
        } catch let err {
            throw SdkError<CreateDistributionOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateDistributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
    }
}

extension CreateDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/distribution"
    }
}

/// The request to create a new distribution.
public struct CreateDistributionInput: Swift.Equatable {
    /// The distribution's configuration information.
    /// This member is required.
    public var distributionConfig: CloudFrontClientTypes.DistributionConfig?

    public init (
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil
    )
    {
        self.distributionConfig = distributionConfig
    }
}

struct CreateDistributionInputBody: Swift.Equatable {
    let distributionConfig: CloudFrontClientTypes.DistributionConfig?
}

extension CreateDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
    }
}

extension CreateDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DistributionAlreadyExists" : self = .distributionAlreadyExists(try DistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" : self = .illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefaultRootObject" : self = .invalidDefaultRootObject(try InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidErrorCode" : self = .invalidErrorCode(try InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidForwardCookies" : self = .invalidForwardCookies(try InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFunctionAssociation" : self = .invalidFunctionAssociation(try InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGeoRestrictionParameter" : self = .invalidGeoRestrictionParameter(try InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHeadersForS3Origin" : self = .invalidHeadersForS3Origin(try InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaFunctionAssociation" : self = .invalidLambdaFunctionAssociation(try InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLocationCode" : self = .invalidLocationCode(try InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMinimumProtocolVersion" : self = .invalidMinimumProtocolVersion(try InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginKeepaliveTimeout" : self = .invalidOriginKeepaliveTimeout(try InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginReadTimeout" : self = .invalidOriginReadTimeout(try InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidProtocolSettings" : self = .invalidProtocolSettings(try InvalidProtocolSettings(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryStringParameters" : self = .invalidQueryStringParameters(try InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativePath" : self = .invalidRelativePath(try InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequiredProtocol" : self = .invalidRequiredProtocol(try InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResponseCode" : self = .invalidResponseCode(try InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTTLOrder" : self = .invalidTTLOrder(try InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidViewerCertificate" : self = .invalidViewerCertificate(try InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrigin" : self = .noSuchOrigin(try NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResponseHeadersPolicy" : self = .noSuchResponseHeadersPolicy(try NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigOwnerMismatch" : self = .realtimeLogConfigOwnerMismatch(try RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCacheBehaviors" : self = .tooManyCacheBehaviors(try TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificates" : self = .tooManyCertificates(try TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookieNamesInWhiteList" : self = .tooManyCookieNamesInWhiteList(try TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionCNAMEs" : self = .tooManyDistributionCNAMEs(try TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributions" : self = .tooManyDistributions(try TooManyDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToCachePolicy" : self = .tooManyDistributionsAssociatedToCachePolicy(try TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" : self = .tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToKeyGroup" : self = .tooManyDistributionsAssociatedToKeyGroup(try TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToOriginRequestPolicy" : self = .tooManyDistributionsAssociatedToOriginRequestPolicy(try TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy" : self = .tooManyDistributionsAssociatedToResponseHeadersPolicy(try TooManyDistributionsAssociatedToResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithFunctionAssociations" : self = .tooManyDistributionsWithFunctionAssociations(try TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithLambdaAssociations" : self = .tooManyDistributionsWithLambdaAssociations(try TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithSingleFunctionARN" : self = .tooManyDistributionsWithSingleFunctionARN(try TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctionAssociations" : self = .tooManyFunctionAssociations(try TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInForwardedValues" : self = .tooManyHeadersInForwardedValues(try TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroupsAssociatedToDistribution" : self = .tooManyKeyGroupsAssociatedToDistribution(try TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLambdaFunctionAssociations" : self = .tooManyLambdaFunctionAssociations(try TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginCustomHeaders" : self = .tooManyOriginCustomHeaders(try TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginGroupsPerDistribution" : self = .tooManyOriginGroupsPerDistribution(try TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOrigins" : self = .tooManyOrigins(try TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringParameters" : self = .tooManyQueryStringParameters(try TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedKeyGroupDoesNotExist" : self = .trustedKeyGroupDoesNotExist(try TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case distributionAlreadyExists(DistributionAlreadyExists)
    case illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidDefaultRootObject(InvalidDefaultRootObject)
    case invalidErrorCode(InvalidErrorCode)
    case invalidForwardCookies(InvalidForwardCookies)
    case invalidFunctionAssociation(InvalidFunctionAssociation)
    case invalidGeoRestrictionParameter(InvalidGeoRestrictionParameter)
    case invalidHeadersForS3Origin(InvalidHeadersForS3Origin)
    case invalidLambdaFunctionAssociation(InvalidLambdaFunctionAssociation)
    case invalidLocationCode(InvalidLocationCode)
    case invalidMinimumProtocolVersion(InvalidMinimumProtocolVersion)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidOriginKeepaliveTimeout(InvalidOriginKeepaliveTimeout)
    case invalidOriginReadTimeout(InvalidOriginReadTimeout)
    case invalidProtocolSettings(InvalidProtocolSettings)
    case invalidQueryStringParameters(InvalidQueryStringParameters)
    case invalidRelativePath(InvalidRelativePath)
    case invalidRequiredProtocol(InvalidRequiredProtocol)
    case invalidResponseCode(InvalidResponseCode)
    case invalidTTLOrder(InvalidTTLOrder)
    case invalidViewerCertificate(InvalidViewerCertificate)
    case invalidWebACLId(InvalidWebACLId)
    case missingBody(MissingBody)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchOrigin(NoSuchOrigin)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case noSuchResponseHeadersPolicy(NoSuchResponseHeadersPolicy)
    case realtimeLogConfigOwnerMismatch(RealtimeLogConfigOwnerMismatch)
    case tooManyCacheBehaviors(TooManyCacheBehaviors)
    case tooManyCertificates(TooManyCertificates)
    case tooManyCookieNamesInWhiteList(TooManyCookieNamesInWhiteList)
    case tooManyDistributionCNAMEs(TooManyDistributionCNAMEs)
    case tooManyDistributions(TooManyDistributions)
    case tooManyDistributionsAssociatedToCachePolicy(TooManyDistributionsAssociatedToCachePolicy)
    case tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(TooManyDistributionsAssociatedToFieldLevelEncryptionConfig)
    case tooManyDistributionsAssociatedToKeyGroup(TooManyDistributionsAssociatedToKeyGroup)
    case tooManyDistributionsAssociatedToOriginRequestPolicy(TooManyDistributionsAssociatedToOriginRequestPolicy)
    case tooManyDistributionsAssociatedToResponseHeadersPolicy(TooManyDistributionsAssociatedToResponseHeadersPolicy)
    case tooManyDistributionsWithFunctionAssociations(TooManyDistributionsWithFunctionAssociations)
    case tooManyDistributionsWithLambdaAssociations(TooManyDistributionsWithLambdaAssociations)
    case tooManyDistributionsWithSingleFunctionARN(TooManyDistributionsWithSingleFunctionARN)
    case tooManyFunctionAssociations(TooManyFunctionAssociations)
    case tooManyHeadersInForwardedValues(TooManyHeadersInForwardedValues)
    case tooManyKeyGroupsAssociatedToDistribution(TooManyKeyGroupsAssociatedToDistribution)
    case tooManyLambdaFunctionAssociations(TooManyLambdaFunctionAssociations)
    case tooManyOriginCustomHeaders(TooManyOriginCustomHeaders)
    case tooManyOriginGroupsPerDistribution(TooManyOriginGroupsPerDistribution)
    case tooManyOrigins(TooManyOrigins)
    case tooManyQueryStringParameters(TooManyQueryStringParameters)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedKeyGroupDoesNotExist(TrustedKeyGroupDoesNotExist)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateDistributionOutputResponse: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new distribution resource just created.
    public var location: Swift.String?

    public init (
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

struct CreateDistributionOutputResponseBody: Swift.Equatable {
    let distribution: CloudFrontClientTypes.Distribution?
}

extension CreateDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

public struct CreateDistributionWithTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionWithTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let distributionConfigWithTags = input.operationInput.distributionConfigWithTags {
                let distributionConfigWithTagsdata = try encoder.encode(distributionConfigWithTags)
                let distributionConfigWithTagsbody = ClientRuntime.HttpBody.data(distributionConfigWithTagsdata)
                input.builder.withBody(distributionConfigWithTagsbody)
            } else {
                let distributionConfigWithTagsdata = try encoder.encode(input.operationInput)
                let distributionConfigWithTagsbody = ClientRuntime.HttpBody.data(distributionConfigWithTagsdata)
                input.builder.withBody(distributionConfigWithTagsbody)
            }
        } catch let err {
            throw SdkError<CreateDistributionWithTagsOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateDistributionWithTagsInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateDistributionWithTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfigWithTags = "DistributionConfigWithTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfigWithTags = distributionConfigWithTags {
            try container.encode(distributionConfigWithTags, forKey: ClientRuntime.Key("DistributionConfigWithTags"))
        }
    }
}

extension CreateDistributionWithTagsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "WithTags", value: nil))
        return items
    }
}

extension CreateDistributionWithTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/distribution"
    }
}

/// The request to create a new distribution with tags.
public struct CreateDistributionWithTagsInput: Swift.Equatable {
    /// The distribution's configuration information.
    /// This member is required.
    public var distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags?

    public init (
        distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags? = nil
    )
    {
        self.distributionConfigWithTags = distributionConfigWithTags
    }
}

struct CreateDistributionWithTagsInputBody: Swift.Equatable {
    let distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags?
}

extension CreateDistributionWithTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfigWithTags = "DistributionConfigWithTags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigWithTagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfigWithTags.self, forKey: .distributionConfigWithTags)
        distributionConfigWithTags = distributionConfigWithTagsDecoded
    }
}

extension CreateDistributionWithTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDistributionWithTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DistributionAlreadyExists" : self = .distributionAlreadyExists(try DistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" : self = .illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefaultRootObject" : self = .invalidDefaultRootObject(try InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidErrorCode" : self = .invalidErrorCode(try InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidForwardCookies" : self = .invalidForwardCookies(try InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFunctionAssociation" : self = .invalidFunctionAssociation(try InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGeoRestrictionParameter" : self = .invalidGeoRestrictionParameter(try InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHeadersForS3Origin" : self = .invalidHeadersForS3Origin(try InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaFunctionAssociation" : self = .invalidLambdaFunctionAssociation(try InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLocationCode" : self = .invalidLocationCode(try InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMinimumProtocolVersion" : self = .invalidMinimumProtocolVersion(try InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginKeepaliveTimeout" : self = .invalidOriginKeepaliveTimeout(try InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginReadTimeout" : self = .invalidOriginReadTimeout(try InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidProtocolSettings" : self = .invalidProtocolSettings(try InvalidProtocolSettings(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryStringParameters" : self = .invalidQueryStringParameters(try InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativePath" : self = .invalidRelativePath(try InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequiredProtocol" : self = .invalidRequiredProtocol(try InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResponseCode" : self = .invalidResponseCode(try InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTTLOrder" : self = .invalidTTLOrder(try InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidViewerCertificate" : self = .invalidViewerCertificate(try InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrigin" : self = .noSuchOrigin(try NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResponseHeadersPolicy" : self = .noSuchResponseHeadersPolicy(try NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigOwnerMismatch" : self = .realtimeLogConfigOwnerMismatch(try RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCacheBehaviors" : self = .tooManyCacheBehaviors(try TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificates" : self = .tooManyCertificates(try TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookieNamesInWhiteList" : self = .tooManyCookieNamesInWhiteList(try TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionCNAMEs" : self = .tooManyDistributionCNAMEs(try TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributions" : self = .tooManyDistributions(try TooManyDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToCachePolicy" : self = .tooManyDistributionsAssociatedToCachePolicy(try TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" : self = .tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToKeyGroup" : self = .tooManyDistributionsAssociatedToKeyGroup(try TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToOriginRequestPolicy" : self = .tooManyDistributionsAssociatedToOriginRequestPolicy(try TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy" : self = .tooManyDistributionsAssociatedToResponseHeadersPolicy(try TooManyDistributionsAssociatedToResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithFunctionAssociations" : self = .tooManyDistributionsWithFunctionAssociations(try TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithLambdaAssociations" : self = .tooManyDistributionsWithLambdaAssociations(try TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithSingleFunctionARN" : self = .tooManyDistributionsWithSingleFunctionARN(try TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctionAssociations" : self = .tooManyFunctionAssociations(try TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInForwardedValues" : self = .tooManyHeadersInForwardedValues(try TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroupsAssociatedToDistribution" : self = .tooManyKeyGroupsAssociatedToDistribution(try TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLambdaFunctionAssociations" : self = .tooManyLambdaFunctionAssociations(try TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginCustomHeaders" : self = .tooManyOriginCustomHeaders(try TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginGroupsPerDistribution" : self = .tooManyOriginGroupsPerDistribution(try TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOrigins" : self = .tooManyOrigins(try TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringParameters" : self = .tooManyQueryStringParameters(try TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedKeyGroupDoesNotExist" : self = .trustedKeyGroupDoesNotExist(try TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDistributionWithTagsOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case distributionAlreadyExists(DistributionAlreadyExists)
    case illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidDefaultRootObject(InvalidDefaultRootObject)
    case invalidErrorCode(InvalidErrorCode)
    case invalidForwardCookies(InvalidForwardCookies)
    case invalidFunctionAssociation(InvalidFunctionAssociation)
    case invalidGeoRestrictionParameter(InvalidGeoRestrictionParameter)
    case invalidHeadersForS3Origin(InvalidHeadersForS3Origin)
    case invalidLambdaFunctionAssociation(InvalidLambdaFunctionAssociation)
    case invalidLocationCode(InvalidLocationCode)
    case invalidMinimumProtocolVersion(InvalidMinimumProtocolVersion)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidOriginKeepaliveTimeout(InvalidOriginKeepaliveTimeout)
    case invalidOriginReadTimeout(InvalidOriginReadTimeout)
    case invalidProtocolSettings(InvalidProtocolSettings)
    case invalidQueryStringParameters(InvalidQueryStringParameters)
    case invalidRelativePath(InvalidRelativePath)
    case invalidRequiredProtocol(InvalidRequiredProtocol)
    case invalidResponseCode(InvalidResponseCode)
    case invalidTagging(InvalidTagging)
    case invalidTTLOrder(InvalidTTLOrder)
    case invalidViewerCertificate(InvalidViewerCertificate)
    case invalidWebACLId(InvalidWebACLId)
    case missingBody(MissingBody)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchOrigin(NoSuchOrigin)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case noSuchResponseHeadersPolicy(NoSuchResponseHeadersPolicy)
    case realtimeLogConfigOwnerMismatch(RealtimeLogConfigOwnerMismatch)
    case tooManyCacheBehaviors(TooManyCacheBehaviors)
    case tooManyCertificates(TooManyCertificates)
    case tooManyCookieNamesInWhiteList(TooManyCookieNamesInWhiteList)
    case tooManyDistributionCNAMEs(TooManyDistributionCNAMEs)
    case tooManyDistributions(TooManyDistributions)
    case tooManyDistributionsAssociatedToCachePolicy(TooManyDistributionsAssociatedToCachePolicy)
    case tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(TooManyDistributionsAssociatedToFieldLevelEncryptionConfig)
    case tooManyDistributionsAssociatedToKeyGroup(TooManyDistributionsAssociatedToKeyGroup)
    case tooManyDistributionsAssociatedToOriginRequestPolicy(TooManyDistributionsAssociatedToOriginRequestPolicy)
    case tooManyDistributionsAssociatedToResponseHeadersPolicy(TooManyDistributionsAssociatedToResponseHeadersPolicy)
    case tooManyDistributionsWithFunctionAssociations(TooManyDistributionsWithFunctionAssociations)
    case tooManyDistributionsWithLambdaAssociations(TooManyDistributionsWithLambdaAssociations)
    case tooManyDistributionsWithSingleFunctionARN(TooManyDistributionsWithSingleFunctionARN)
    case tooManyFunctionAssociations(TooManyFunctionAssociations)
    case tooManyHeadersInForwardedValues(TooManyHeadersInForwardedValues)
    case tooManyKeyGroupsAssociatedToDistribution(TooManyKeyGroupsAssociatedToDistribution)
    case tooManyLambdaFunctionAssociations(TooManyLambdaFunctionAssociations)
    case tooManyOriginCustomHeaders(TooManyOriginCustomHeaders)
    case tooManyOriginGroupsPerDistribution(TooManyOriginGroupsPerDistribution)
    case tooManyOrigins(TooManyOrigins)
    case tooManyQueryStringParameters(TooManyQueryStringParameters)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedKeyGroupDoesNotExist(TrustedKeyGroupDoesNotExist)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDistributionWithTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateDistributionWithTagsOutputResponse: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new distribution resource just created.
    public var location: Swift.String?

    public init (
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

struct CreateDistributionWithTagsOutputResponseBody: Swift.Equatable {
    let distribution: CloudFrontClientTypes.Distribution?
}

extension CreateDistributionWithTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

public struct CreateFieldLevelEncryptionConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let fieldLevelEncryptionConfig = input.operationInput.fieldLevelEncryptionConfig {
                let fieldLevelEncryptionConfigdata = try encoder.encode(fieldLevelEncryptionConfig)
                let fieldLevelEncryptionConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionConfigdata)
                input.builder.withBody(fieldLevelEncryptionConfigbody)
            } else {
                let fieldLevelEncryptionConfigdata = try encoder.encode(input.operationInput)
                let fieldLevelEncryptionConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionConfigdata)
                input.builder.withBody(fieldLevelEncryptionConfigbody)
            }
        } catch let err {
            throw SdkError<CreateFieldLevelEncryptionConfigOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateFieldLevelEncryptionConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateFieldLevelEncryptionConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionConfig = fieldLevelEncryptionConfig {
            try container.encode(fieldLevelEncryptionConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionConfig"))
        }
    }
}

extension CreateFieldLevelEncryptionConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/field-level-encryption"
    }
}

public struct CreateFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// The request to create a new field-level encryption configuration.
    /// This member is required.
    public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?

    public init (
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil
    )
    {
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
    }
}

struct CreateFieldLevelEncryptionConfigInputBody: Swift.Equatable {
    let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
}

extension CreateFieldLevelEncryptionConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension CreateFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateFieldLevelEncryptionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FieldLevelEncryptionConfigAlreadyExists" : self = .fieldLevelEncryptionConfigAlreadyExists(try FieldLevelEncryptionConfigAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QueryArgProfileEmpty" : self = .queryArgProfileEmpty(try QueryArgProfileEmpty(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionConfigs" : self = .tooManyFieldLevelEncryptionConfigs(try TooManyFieldLevelEncryptionConfigs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionContentTypeProfiles" : self = .tooManyFieldLevelEncryptionContentTypeProfiles(try TooManyFieldLevelEncryptionContentTypeProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionQueryArgProfiles" : self = .tooManyFieldLevelEncryptionQueryArgProfiles(try TooManyFieldLevelEncryptionQueryArgProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFieldLevelEncryptionConfigOutputError: Swift.Error, Swift.Equatable {
    case fieldLevelEncryptionConfigAlreadyExists(FieldLevelEncryptionConfigAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case queryArgProfileEmpty(QueryArgProfileEmpty)
    case tooManyFieldLevelEncryptionConfigs(TooManyFieldLevelEncryptionConfigs)
    case tooManyFieldLevelEncryptionContentTypeProfiles(TooManyFieldLevelEncryptionContentTypeProfiles)
    case tooManyFieldLevelEncryptionQueryArgProfiles(TooManyFieldLevelEncryptionQueryArgProfiles)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFieldLevelEncryptionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryption = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryption = output
            } else {
                self.fieldLevelEncryption = nil
            }
        } else {
            self.fieldLevelEncryption = nil
        }
    }
}

public struct CreateFieldLevelEncryptionConfigOutputResponse: Swift.Equatable {
    /// The current version of the field level encryption configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Returned when you create a new field-level encryption configuration.
    public var fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
    /// The fully qualified URI of the new configuration resource just created.
    public var location: Swift.String?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
        self.location = location
    }
}

struct CreateFieldLevelEncryptionConfigOutputResponseBody: Swift.Equatable {
    let fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
}

extension CreateFieldLevelEncryptionConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryption = "FieldLevelEncryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryption.self, forKey: .fieldLevelEncryption)
        fieldLevelEncryption = fieldLevelEncryptionDecoded
    }
}

public struct CreateFieldLevelEncryptionProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let fieldLevelEncryptionProfileConfig = input.operationInput.fieldLevelEncryptionProfileConfig {
                let fieldLevelEncryptionProfileConfigdata = try encoder.encode(fieldLevelEncryptionProfileConfig)
                let fieldLevelEncryptionProfileConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionProfileConfigdata)
                input.builder.withBody(fieldLevelEncryptionProfileConfigbody)
            } else {
                let fieldLevelEncryptionProfileConfigdata = try encoder.encode(input.operationInput)
                let fieldLevelEncryptionProfileConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionProfileConfigdata)
                input.builder.withBody(fieldLevelEncryptionProfileConfigbody)
            }
        } catch let err {
            throw SdkError<CreateFieldLevelEncryptionProfileOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateFieldLevelEncryptionProfileInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateFieldLevelEncryptionProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig {
            try container.encode(fieldLevelEncryptionProfileConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileConfig"))
        }
    }
}

extension CreateFieldLevelEncryptionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/field-level-encryption-profile"
    }
}

public struct CreateFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// The request to create a field-level encryption profile.
    /// This member is required.
    public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?

    public init (
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil
    )
    {
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
    }
}

struct CreateFieldLevelEncryptionProfileInputBody: Swift.Equatable {
    let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
}

extension CreateFieldLevelEncryptionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension CreateFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateFieldLevelEncryptionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FieldLevelEncryptionProfileAlreadyExists" : self = .fieldLevelEncryptionProfileAlreadyExists(try FieldLevelEncryptionProfileAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileSizeExceeded" : self = .fieldLevelEncryptionProfileSizeExceeded(try FieldLevelEncryptionProfileSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionEncryptionEntities" : self = .tooManyFieldLevelEncryptionEncryptionEntities(try TooManyFieldLevelEncryptionEncryptionEntities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionFieldPatterns" : self = .tooManyFieldLevelEncryptionFieldPatterns(try TooManyFieldLevelEncryptionFieldPatterns(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionProfiles" : self = .tooManyFieldLevelEncryptionProfiles(try TooManyFieldLevelEncryptionProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFieldLevelEncryptionProfileOutputError: Swift.Error, Swift.Equatable {
    case fieldLevelEncryptionProfileAlreadyExists(FieldLevelEncryptionProfileAlreadyExists)
    case fieldLevelEncryptionProfileSizeExceeded(FieldLevelEncryptionProfileSizeExceeded)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case noSuchPublicKey(NoSuchPublicKey)
    case tooManyFieldLevelEncryptionEncryptionEntities(TooManyFieldLevelEncryptionEncryptionEntities)
    case tooManyFieldLevelEncryptionFieldPatterns(TooManyFieldLevelEncryptionFieldPatterns)
    case tooManyFieldLevelEncryptionProfiles(TooManyFieldLevelEncryptionProfiles)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFieldLevelEncryptionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionProfile = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionProfile = output
            } else {
                self.fieldLevelEncryptionProfile = nil
            }
        } else {
            self.fieldLevelEncryptionProfile = nil
        }
    }
}

public struct CreateFieldLevelEncryptionProfileOutputResponse: Swift.Equatable {
    /// The current version of the field level encryption profile. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Returned when you create a new field-level encryption profile.
    public var fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
    /// The fully qualified URI of the new profile resource just created.
    public var location: Swift.String?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
        self.location = location
    }
}

struct CreateFieldLevelEncryptionProfileOutputResponseBody: Swift.Equatable {
    let fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
}

extension CreateFieldLevelEncryptionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfile = "FieldLevelEncryptionProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfile.self, forKey: .fieldLevelEncryptionProfile)
        fieldLevelEncryptionProfile = fieldLevelEncryptionProfileDecoded
    }
}

extension CreateFunctionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateFunctionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let functionCode = functionCode {
            try container.encode(functionCode, forKey: ClientRuntime.Key("FunctionCode"))
        }
        if let functionConfig = functionConfig {
            try container.encode(functionConfig, forKey: ClientRuntime.Key("FunctionConfig"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }
}

extension CreateFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/function"
    }
}

public struct CreateFunctionInput: Swift.Equatable {
    /// The function code. For more information about writing a CloudFront function, see [Writing function code for CloudFront Functions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var functionCode: ClientRuntime.Data?
    /// Configuration information about the function, including an optional comment and the function’s runtime.
    /// This member is required.
    public var functionConfig: CloudFrontClientTypes.FunctionConfig?
    /// A name to identify the function.
    /// This member is required.
    public var name: Swift.String?

    public init (
        functionCode: ClientRuntime.Data? = nil,
        functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionCode = functionCode
        self.functionConfig = functionConfig
        self.name = name
    }
}

struct CreateFunctionInputBody: Swift.Equatable {
    let name: Swift.String?
    let functionConfig: CloudFrontClientTypes.FunctionConfig?
    let functionCode: ClientRuntime.Data?
}

extension CreateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionConfig.self, forKey: .functionConfig)
        functionConfig = functionConfigDecoded
        if containerValues.contains(.functionCode) {
            do {
                let functionCodeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .functionCode)
                functionCode = functionCodeDecoded
            } catch {
                functionCode = "".data(using: .utf8)
            }
        } else {
            functionCode = nil
        }
    }
}

extension CreateFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FunctionAlreadyExists" : self = .functionAlreadyExists(try FunctionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FunctionSizeLimitExceeded" : self = .functionSizeLimitExceeded(try FunctionSizeLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctions" : self = .tooManyFunctions(try TooManyFunctions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFunctionOutputError: Swift.Error, Swift.Equatable {
    case functionAlreadyExists(FunctionAlreadyExists)
    case functionSizeLimitExceeded(FunctionSizeLimitExceeded)
    case invalidArgument(InvalidArgument)
    case tooManyFunctions(TooManyFunctions)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct CreateFunctionOutputResponse: Swift.Equatable {
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?
    /// The URL of the CloudFront function. Use the URL to manage the function with the CloudFront API.
    public var location: Swift.String?

    public init (
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
        self.location = location
    }
}

struct CreateFunctionOutputResponseBody: Swift.Equatable {
    let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension CreateFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

public struct CreateInvalidationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInvalidationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInvalidationInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let invalidationBatch = input.operationInput.invalidationBatch {
                let invalidationBatchdata = try encoder.encode(invalidationBatch)
                let invalidationBatchbody = ClientRuntime.HttpBody.data(invalidationBatchdata)
                input.builder.withBody(invalidationBatchbody)
            } else {
                let invalidationBatchdata = try encoder.encode(input.operationInput)
                let invalidationBatchbody = ClientRuntime.HttpBody.data(invalidationBatchdata)
                input.builder.withBody(invalidationBatchbody)
            }
        } catch let err {
            throw SdkError<CreateInvalidationOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInvalidationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateInvalidationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateInvalidationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidationBatch = "InvalidationBatch"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let invalidationBatch = invalidationBatch {
            try container.encode(invalidationBatch, forKey: ClientRuntime.Key("InvalidationBatch"))
        }
    }
}

extension CreateInvalidationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let distributionId = distributionId else {
            return nil
        }
        return "/2020-05-31/distribution/\(distributionId.urlPercentEncoding())/invalidation"
    }
}

/// The request to create an invalidation.
public struct CreateInvalidationInput: Swift.Equatable {
    /// The distribution's id.
    /// This member is required.
    public var distributionId: Swift.String?
    /// The batch information for the invalidation.
    /// This member is required.
    public var invalidationBatch: CloudFrontClientTypes.InvalidationBatch?

    public init (
        distributionId: Swift.String? = nil,
        invalidationBatch: CloudFrontClientTypes.InvalidationBatch? = nil
    )
    {
        self.distributionId = distributionId
        self.invalidationBatch = invalidationBatch
    }
}

struct CreateInvalidationInputBody: Swift.Equatable {
    let invalidationBatch: CloudFrontClientTypes.InvalidationBatch?
}

extension CreateInvalidationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidationBatch = "InvalidationBatch"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationBatchDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.InvalidationBatch.self, forKey: .invalidationBatch)
        invalidationBatch = invalidationBatchDecoded
    }
}

extension CreateInvalidationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateInvalidationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BatchTooLarge" : self = .batchTooLarge(try BatchTooLarge(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyInvalidationsInProgress" : self = .tooManyInvalidationsInProgress(try TooManyInvalidationsInProgress(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInvalidationOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case batchTooLarge(BatchTooLarge)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case missingBody(MissingBody)
    case noSuchDistribution(NoSuchDistribution)
    case tooManyInvalidationsInProgress(TooManyInvalidationsInProgress)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInvalidationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Invalidation = try responseDecoder.decode(responseBody: data)
                self.invalidation = output
            } else {
                self.invalidation = nil
            }
        } else {
            self.invalidation = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateInvalidationOutputResponse: Swift.Equatable {
    /// The invalidation's information.
    public var invalidation: CloudFrontClientTypes.Invalidation?
    /// The fully qualified URI of the distribution and invalidation batch request, including the Invalidation ID.
    public var location: Swift.String?

    public init (
        invalidation: CloudFrontClientTypes.Invalidation? = nil,
        location: Swift.String? = nil
    )
    {
        self.invalidation = invalidation
        self.location = location
    }
}

struct CreateInvalidationOutputResponseBody: Swift.Equatable {
    let invalidation: CloudFrontClientTypes.Invalidation?
}

extension CreateInvalidationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidation = "Invalidation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Invalidation.self, forKey: .invalidation)
        invalidation = invalidationDecoded
    }
}

public struct CreateKeyGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateKeyGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateKeyGroupInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let keyGroupConfig = input.operationInput.keyGroupConfig {
                let keyGroupConfigdata = try encoder.encode(keyGroupConfig)
                let keyGroupConfigbody = ClientRuntime.HttpBody.data(keyGroupConfigdata)
                input.builder.withBody(keyGroupConfigbody)
            } else {
                let keyGroupConfigdata = try encoder.encode(input.operationInput)
                let keyGroupConfigbody = ClientRuntime.HttpBody.data(keyGroupConfigdata)
                input.builder.withBody(keyGroupConfigbody)
            }
        } catch let err {
            throw SdkError<CreateKeyGroupOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateKeyGroupInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateKeyGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroupConfig = keyGroupConfig {
            try container.encode(keyGroupConfig, forKey: ClientRuntime.Key("KeyGroupConfig"))
        }
    }
}

extension CreateKeyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/key-group"
    }
}

public struct CreateKeyGroupInput: Swift.Equatable {
    /// A key group configuration.
    /// This member is required.
    public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init (
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.keyGroupConfig = keyGroupConfig
    }
}

struct CreateKeyGroupInputBody: Swift.Equatable {
    let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
}

extension CreateKeyGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension CreateKeyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateKeyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyGroupAlreadyExists" : self = .keyGroupAlreadyExists(try KeyGroupAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroups" : self = .tooManyKeyGroups(try TooManyKeyGroups(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPublicKeysInKeyGroup" : self = .tooManyPublicKeysInKeyGroup(try TooManyPublicKeysInKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateKeyGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case keyGroupAlreadyExists(KeyGroupAlreadyExists)
    case tooManyKeyGroups(TooManyKeyGroups)
    case tooManyPublicKeysInKeyGroup(TooManyPublicKeysInKeyGroup)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateKeyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.KeyGroup = try responseDecoder.decode(responseBody: data)
                self.keyGroup = output
            } else {
                self.keyGroup = nil
            }
        } else {
            self.keyGroup = nil
        }
    }
}

public struct CreateKeyGroupOutputResponse: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group that was just created.
    public var keyGroup: CloudFrontClientTypes.KeyGroup?
    /// The URL of the key group.
    public var location: Swift.String?

    public init (
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
        self.location = location
    }
}

struct CreateKeyGroupOutputResponseBody: Swift.Equatable {
    let keyGroup: CloudFrontClientTypes.KeyGroup?
}

extension CreateKeyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

public struct CreateMonitoringSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMonitoringSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let monitoringSubscription = input.operationInput.monitoringSubscription {
                let monitoringSubscriptiondata = try encoder.encode(monitoringSubscription)
                let monitoringSubscriptionbody = ClientRuntime.HttpBody.data(monitoringSubscriptiondata)
                input.builder.withBody(monitoringSubscriptionbody)
            } else {
                let monitoringSubscriptiondata = try encoder.encode(input.operationInput)
                let monitoringSubscriptionbody = ClientRuntime.HttpBody.data(monitoringSubscriptiondata)
                input.builder.withBody(monitoringSubscriptionbody)
            }
        } catch let err {
            throw SdkError<CreateMonitoringSubscriptionOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateMonitoringSubscriptionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateMonitoringSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let monitoringSubscription = monitoringSubscription {
            try container.encode(monitoringSubscription, forKey: ClientRuntime.Key("MonitoringSubscription"))
        }
    }
}

extension CreateMonitoringSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let distributionId = distributionId else {
            return nil
        }
        return "/2020-05-31/distributions/\(distributionId.urlPercentEncoding())/monitoring-subscription"
    }
}

public struct CreateMonitoringSubscriptionInput: Swift.Equatable {
    /// The ID of the distribution that you are enabling metrics for.
    /// This member is required.
    public var distributionId: Swift.String?
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    /// This member is required.
    public var monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init (
        distributionId: Swift.String? = nil,
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.distributionId = distributionId
        self.monitoringSubscription = monitoringSubscription
    }
}

struct CreateMonitoringSubscriptionInputBody: Swift.Equatable {
    let monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?
}

extension CreateMonitoringSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringSubscriptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MonitoringSubscription.self, forKey: .monitoringSubscription)
        monitoringSubscription = monitoringSubscriptionDecoded
    }
}

extension CreateMonitoringSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateMonitoringSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMonitoringSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMonitoringSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.MonitoringSubscription = try responseDecoder.decode(responseBody: data)
                self.monitoringSubscription = output
            } else {
                self.monitoringSubscription = nil
            }
        } else {
            self.monitoringSubscription = nil
        }
    }
}

public struct CreateMonitoringSubscriptionOutputResponse: Swift.Equatable {
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    public var monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init (
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.monitoringSubscription = monitoringSubscription
    }
}

struct CreateMonitoringSubscriptionOutputResponseBody: Swift.Equatable {
    let monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?
}

extension CreateMonitoringSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringSubscriptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MonitoringSubscription.self, forKey: .monitoringSubscription)
        monitoringSubscription = monitoringSubscriptionDecoded
    }
}

public struct CreateOriginRequestPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOriginRequestPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let originRequestPolicyConfig = input.operationInput.originRequestPolicyConfig {
                let originRequestPolicyConfigdata = try encoder.encode(originRequestPolicyConfig)
                let originRequestPolicyConfigbody = ClientRuntime.HttpBody.data(originRequestPolicyConfigdata)
                input.builder.withBody(originRequestPolicyConfigbody)
            } else {
                let originRequestPolicyConfigdata = try encoder.encode(input.operationInput)
                let originRequestPolicyConfigbody = ClientRuntime.HttpBody.data(originRequestPolicyConfigdata)
                input.builder.withBody(originRequestPolicyConfigbody)
            }
        } catch let err {
            throw SdkError<CreateOriginRequestPolicyOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateOriginRequestPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateOriginRequestPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originRequestPolicyConfig = originRequestPolicyConfig {
            try container.encode(originRequestPolicyConfig, forKey: ClientRuntime.Key("OriginRequestPolicyConfig"))
        }
    }
}

extension CreateOriginRequestPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/origin-request-policy"
    }
}

public struct CreateOriginRequestPolicyInput: Swift.Equatable {
    /// An origin request policy configuration.
    /// This member is required.
    public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init (
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

struct CreateOriginRequestPolicyInputBody: Swift.Equatable {
    let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?
}

extension CreateOriginRequestPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension CreateOriginRequestPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateOriginRequestPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OriginRequestPolicyAlreadyExists" : self = .originRequestPolicyAlreadyExists(try OriginRequestPolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInOriginRequestPolicy" : self = .tooManyCookiesInOriginRequestPolicy(try TooManyCookiesInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInOriginRequestPolicy" : self = .tooManyHeadersInOriginRequestPolicy(try TooManyHeadersInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginRequestPolicies" : self = .tooManyOriginRequestPolicies(try TooManyOriginRequestPolicies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInOriginRequestPolicy" : self = .tooManyQueryStringsInOriginRequestPolicy(try TooManyQueryStringsInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOriginRequestPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case originRequestPolicyAlreadyExists(OriginRequestPolicyAlreadyExists)
    case tooManyCookiesInOriginRequestPolicy(TooManyCookiesInOriginRequestPolicy)
    case tooManyHeadersInOriginRequestPolicy(TooManyHeadersInOriginRequestPolicy)
    case tooManyOriginRequestPolicies(TooManyOriginRequestPolicies)
    case tooManyQueryStringsInOriginRequestPolicy(TooManyQueryStringsInOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOriginRequestPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.OriginRequestPolicy = try responseDecoder.decode(responseBody: data)
                self.originRequestPolicy = output
            } else {
                self.originRequestPolicy = nil
            }
        } else {
            self.originRequestPolicy = nil
        }
    }
}

public struct CreateOriginRequestPolicyOutputResponse: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// The fully qualified URI of the origin request policy just created.
    public var location: Swift.String?
    /// An origin request policy.
    public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init (
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.originRequestPolicy = originRequestPolicy
    }
}

struct CreateOriginRequestPolicyOutputResponseBody: Swift.Equatable {
    let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
}

extension CreateOriginRequestPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

public struct CreatePublicKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePublicKeyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let publicKeyConfig = input.operationInput.publicKeyConfig {
                let publicKeyConfigdata = try encoder.encode(publicKeyConfig)
                let publicKeyConfigbody = ClientRuntime.HttpBody.data(publicKeyConfigdata)
                input.builder.withBody(publicKeyConfigbody)
            } else {
                let publicKeyConfigdata = try encoder.encode(input.operationInput)
                let publicKeyConfigbody = ClientRuntime.HttpBody.data(publicKeyConfigdata)
                input.builder.withBody(publicKeyConfigbody)
            }
        } catch let err {
            throw SdkError<CreatePublicKeyOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreatePublicKeyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreatePublicKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let publicKeyConfig = publicKeyConfig {
            try container.encode(publicKeyConfig, forKey: ClientRuntime.Key("PublicKeyConfig"))
        }
    }
}

extension CreatePublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/public-key"
    }
}

public struct CreatePublicKeyInput: Swift.Equatable {
    /// A CloudFront public key configuration.
    /// This member is required.
    public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init (
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.publicKeyConfig = publicKeyConfig
    }
}

struct CreatePublicKeyInputBody: Swift.Equatable {
    let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?
}

extension CreatePublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension CreatePublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreatePublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PublicKeyAlreadyExists" : self = .publicKeyAlreadyExists(try PublicKeyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPublicKeys" : self = .tooManyPublicKeys(try TooManyPublicKeys(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePublicKeyOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case publicKeyAlreadyExists(PublicKeyAlreadyExists)
    case tooManyPublicKeys(TooManyPublicKeys)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.PublicKey = try responseDecoder.decode(responseBody: data)
                self.publicKey = output
            } else {
                self.publicKey = nil
            }
        } else {
            self.publicKey = nil
        }
    }
}

public struct CreatePublicKeyOutputResponse: Swift.Equatable {
    /// The identifier for this version of the public key.
    public var eTag: Swift.String?
    /// The URL of the public key.
    public var location: Swift.String?
    /// The public key.
    public var publicKey: CloudFrontClientTypes.PublicKey?

    public init (
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.publicKey = publicKey
    }
}

struct CreatePublicKeyOutputResponseBody: Swift.Equatable {
    let publicKey: CloudFrontClientTypes.PublicKey?
}

extension CreatePublicKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKey = "PublicKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKey.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

extension CreateRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateRealtimeLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let endPoints = endPoints {
            var endPointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EndPoints"))
            for endpoint0 in endPoints {
                try endPointsContainer.encode(endpoint0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Fields"))
            for string0 in fields {
                try fieldsContainer.encode(string0, forKey: ClientRuntime.Key("Field"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: ClientRuntime.Key("SamplingRate"))
        }
    }
}

extension CreateRealtimeLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/realtime-log-config"
    }
}

public struct CreateRealtimeLogConfigInput: Swift.Equatable {
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
    /// This member is required.
    public var endPoints: [CloudFrontClientTypes.EndPoint]?
    /// A list of fields to include in each real-time log record. For more information about fields, see [Real-time log configuration fields](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var fields: [Swift.String]?
    /// A unique name to identify this real-time log configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. You must provide an integer between 1 and 100, inclusive.
    /// This member is required.
    public var samplingRate: Swift.Int?

    public init (
        endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
        fields: [Swift.String]? = nil,
        name: Swift.String? = nil,
        samplingRate: Swift.Int? = nil
    )
    {
        self.endPoints = endPoints
        self.fields = fields
        self.name = name
        self.samplingRate = samplingRate
    }
}

struct CreateRealtimeLogConfigInputBody: Swift.Equatable {
    let endPoints: [CloudFrontClientTypes.EndPoint]?
    let fields: [Swift.String]?
    let name: Swift.String?
    let samplingRate: Swift.Int?
}

extension CreateRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.endPoints) {
            struct KeyVal0{struct member{}}
            let endPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endPoints)
            if let endPointsWrappedContainer = endPointsWrappedContainer {
                let endPointsContainer = try endPointsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EndPoint].self, forKey: .member)
                var endPointsBuffer:[CloudFrontClientTypes.EndPoint]? = nil
                if let endPointsContainer = endPointsContainer {
                    endPointsBuffer = [CloudFrontClientTypes.EndPoint]()
                    for structureContainer0 in endPointsContainer {
                        endPointsBuffer?.append(structureContainer0)
                    }
                }
                endPoints = endPointsBuffer
            } else {
                endPoints = []
            }
        } else {
            endPoints = nil
        }
        if containerValues.contains(.fields) {
            struct KeyVal0{struct Field{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldsBuffer:[Swift.String]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [Swift.String]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
    }
}

extension CreateRealtimeLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateRealtimeLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigAlreadyExists" : self = .realtimeLogConfigAlreadyExists(try RealtimeLogConfigAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRealtimeLogConfigs" : self = .tooManyRealtimeLogConfigs(try TooManyRealtimeLogConfigs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRealtimeLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case realtimeLogConfigAlreadyExists(RealtimeLogConfigAlreadyExists)
    case tooManyRealtimeLogConfigs(TooManyRealtimeLogConfigs)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRealtimeLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRealtimeLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.realtimeLogConfig = output.realtimeLogConfig
        } else {
            self.realtimeLogConfig = nil
        }
    }
}

public struct CreateRealtimeLogConfigOutputResponse: Swift.Equatable {
    /// A real-time log configuration.
    public var realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init (
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

struct CreateRealtimeLogConfigOutputResponseBody: Swift.Equatable {
    let realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?
}

extension CreateRealtimeLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfig = "RealtimeLogConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfig.self, forKey: .realtimeLogConfig)
        realtimeLogConfig = realtimeLogConfigDecoded
    }
}

public struct CreateResponseHeadersPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResponseHeadersPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResponseHeadersPolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateResponseHeadersPolicyOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let responseHeadersPolicyConfig = input.operationInput.responseHeadersPolicyConfig {
                let responseHeadersPolicyConfigdata = try encoder.encode(responseHeadersPolicyConfig)
                let responseHeadersPolicyConfigbody = ClientRuntime.HttpBody.data(responseHeadersPolicyConfigdata)
                input.builder.withBody(responseHeadersPolicyConfigbody)
            } else {
                let responseHeadersPolicyConfigdata = try encoder.encode(input.operationInput)
                let responseHeadersPolicyConfigbody = ClientRuntime.HttpBody.data(responseHeadersPolicyConfigdata)
                input.builder.withBody(responseHeadersPolicyConfigbody)
            }
        } catch let err {
            throw SdkError<CreateResponseHeadersPolicyOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResponseHeadersPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResponseHeadersPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateResponseHeadersPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateResponseHeadersPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicyConfig = "ResponseHeadersPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let responseHeadersPolicyConfig = responseHeadersPolicyConfig {
            try container.encode(responseHeadersPolicyConfig, forKey: ClientRuntime.Key("ResponseHeadersPolicyConfig"))
        }
    }
}

extension CreateResponseHeadersPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/response-headers-policy"
    }
}

public struct CreateResponseHeadersPolicyInput: Swift.Equatable {
    /// Contains metadata about the response headers policy, and a set of configurations that specify the response headers.
    /// This member is required.
    public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

    public init (
        responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
    )
    {
        self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
    }
}

struct CreateResponseHeadersPolicyInputBody: Swift.Equatable {
    let responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?
}

extension CreateResponseHeadersPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicyConfig = "ResponseHeadersPolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseHeadersPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyConfig.self, forKey: .responseHeadersPolicyConfig)
        responseHeadersPolicyConfig = responseHeadersPolicyConfigDecoded
    }
}

extension CreateResponseHeadersPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateResponseHeadersPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResponseHeadersPolicyAlreadyExists" : self = .responseHeadersPolicyAlreadyExists(try ResponseHeadersPolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCustomHeadersInResponseHeadersPolicy" : self = .tooManyCustomHeadersInResponseHeadersPolicy(try TooManyCustomHeadersInResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyResponseHeadersPolicies" : self = .tooManyResponseHeadersPolicies(try TooManyResponseHeadersPolicies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResponseHeadersPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case responseHeadersPolicyAlreadyExists(ResponseHeadersPolicyAlreadyExists)
    case tooManyCustomHeadersInResponseHeadersPolicy(TooManyCustomHeadersInResponseHeadersPolicy)
    case tooManyResponseHeadersPolicies(TooManyResponseHeadersPolicies)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResponseHeadersPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.ResponseHeadersPolicy = try responseDecoder.decode(responseBody: data)
                self.responseHeadersPolicy = output
            } else {
                self.responseHeadersPolicy = nil
            }
        } else {
            self.responseHeadersPolicy = nil
        }
    }
}

public struct CreateResponseHeadersPolicyOutputResponse: Swift.Equatable {
    /// The version identifier for the current version of the response headers policy.
    public var eTag: Swift.String?
    /// The URL of the response headers policy.
    public var location: Swift.String?
    /// Contains a response headers policy.
    public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?

    public init (
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.responseHeadersPolicy = responseHeadersPolicy
    }
}

struct CreateResponseHeadersPolicyOutputResponseBody: Swift.Equatable {
    let responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?
}

extension CreateResponseHeadersPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicy = "ResponseHeadersPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseHeadersPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicy.self, forKey: .responseHeadersPolicy)
        responseHeadersPolicy = responseHeadersPolicyDecoded
    }
}

public struct CreateStreamingDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let streamingDistributionConfig = input.operationInput.streamingDistributionConfig {
                let streamingDistributionConfigdata = try encoder.encode(streamingDistributionConfig)
                let streamingDistributionConfigbody = ClientRuntime.HttpBody.data(streamingDistributionConfigdata)
                input.builder.withBody(streamingDistributionConfigbody)
            } else {
                let streamingDistributionConfigdata = try encoder.encode(input.operationInput)
                let streamingDistributionConfigbody = ClientRuntime.HttpBody.data(streamingDistributionConfigdata)
                input.builder.withBody(streamingDistributionConfigbody)
            }
        } catch let err {
            throw SdkError<CreateStreamingDistributionOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateStreamingDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateStreamingDistributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
    }
}

extension CreateStreamingDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/streaming-distribution"
    }
}

/// The request to create a new streaming distribution.
public struct CreateStreamingDistributionInput: Swift.Equatable {
    /// The streaming distribution's configuration information.
    /// This member is required.
    public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init (
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

struct CreateStreamingDistributionInputBody: Swift.Equatable {
    let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
}

extension CreateStreamingDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension CreateStreamingDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateStreamingDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamingDistributionAlreadyExists" : self = .streamingDistributionAlreadyExists(try StreamingDistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributionCNAMEs" : self = .tooManyStreamingDistributionCNAMEs(try TooManyStreamingDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributions" : self = .tooManyStreamingDistributions(try TooManyStreamingDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case missingBody(MissingBody)
    case streamingDistributionAlreadyExists(StreamingDistributionAlreadyExists)
    case tooManyStreamingDistributionCNAMEs(TooManyStreamingDistributionCNAMEs)
    case tooManyStreamingDistributions(TooManyStreamingDistributions)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateStreamingDistributionOutputResponse: Swift.Equatable {
    /// The current version of the streaming distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new streaming distribution resource just created.
    public var location: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init (
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.streamingDistribution = streamingDistribution
    }
}

struct CreateStreamingDistributionOutputResponseBody: Swift.Equatable {
    let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension CreateStreamingDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

public struct CreateStreamingDistributionWithTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionWithTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let streamingDistributionConfigWithTags = input.operationInput.streamingDistributionConfigWithTags {
                let streamingDistributionConfigWithTagsdata = try encoder.encode(streamingDistributionConfigWithTags)
                let streamingDistributionConfigWithTagsbody = ClientRuntime.HttpBody.data(streamingDistributionConfigWithTagsdata)
                input.builder.withBody(streamingDistributionConfigWithTagsbody)
            } else {
                let streamingDistributionConfigWithTagsdata = try encoder.encode(input.operationInput)
                let streamingDistributionConfigWithTagsbody = ClientRuntime.HttpBody.data(streamingDistributionConfigWithTagsdata)
                input.builder.withBody(streamingDistributionConfigWithTagsbody)
            }
        } catch let err {
            throw SdkError<CreateStreamingDistributionWithTagsOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateStreamingDistributionWithTagsInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateStreamingDistributionWithTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfigWithTags = "StreamingDistributionConfigWithTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfigWithTags = streamingDistributionConfigWithTags {
            try container.encode(streamingDistributionConfigWithTags, forKey: ClientRuntime.Key("StreamingDistributionConfigWithTags"))
        }
    }
}

extension CreateStreamingDistributionWithTagsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "WithTags", value: nil))
        return items
    }
}

extension CreateStreamingDistributionWithTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/streaming-distribution"
    }
}

/// The request to create a new streaming distribution with tags.
public struct CreateStreamingDistributionWithTagsInput: Swift.Equatable {
    /// The streaming distribution's configuration information.
    /// This member is required.
    public var streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags?

    public init (
        streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags? = nil
    )
    {
        self.streamingDistributionConfigWithTags = streamingDistributionConfigWithTags
    }
}

struct CreateStreamingDistributionWithTagsInputBody: Swift.Equatable {
    let streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags?
}

extension CreateStreamingDistributionWithTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfigWithTags = "StreamingDistributionConfigWithTags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigWithTagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfigWithTags.self, forKey: .streamingDistributionConfigWithTags)
        streamingDistributionConfigWithTags = streamingDistributionConfigWithTagsDecoded
    }
}

extension CreateStreamingDistributionWithTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateStreamingDistributionWithTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamingDistributionAlreadyExists" : self = .streamingDistributionAlreadyExists(try StreamingDistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributionCNAMEs" : self = .tooManyStreamingDistributionCNAMEs(try TooManyStreamingDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributions" : self = .tooManyStreamingDistributions(try TooManyStreamingDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingDistributionWithTagsOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidTagging(InvalidTagging)
    case missingBody(MissingBody)
    case streamingDistributionAlreadyExists(StreamingDistributionAlreadyExists)
    case tooManyStreamingDistributionCNAMEs(TooManyStreamingDistributionCNAMEs)
    case tooManyStreamingDistributions(TooManyStreamingDistributions)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingDistributionWithTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateStreamingDistributionWithTagsOutputResponse: Swift.Equatable {
    /// The current version of the distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new streaming distribution resource just created.
    public var location: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init (
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.streamingDistribution = streamingDistribution
    }
}

struct CreateStreamingDistributionWithTagsOutputResponseBody: Swift.Equatable {
    let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension CreateStreamingDistributionWithTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

extension CloudFrontClientTypes.CustomErrorResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCachingMinTTL = "ErrorCachingMinTTL"
        case errorCode = "ErrorCode"
        case responseCode = "ResponseCode"
        case responsePagePath = "ResponsePagePath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let errorCachingMinTTL = errorCachingMinTTL {
            try container.encode(errorCachingMinTTL, forKey: ClientRuntime.Key("ErrorCachingMinTTL"))
        }
        if let errorCode = errorCode {
            try container.encode(errorCode, forKey: ClientRuntime.Key("ErrorCode"))
        }
        if let responseCode = responseCode {
            try container.encode(responseCode, forKey: ClientRuntime.Key("ResponseCode"))
        }
        if let responsePagePath = responsePagePath {
            try container.encode(responsePagePath, forKey: ClientRuntime.Key("ResponsePagePath"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let responsePagePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responsePagePath)
        responsePagePath = responsePagePathDecoded
        let responseCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let errorCachingMinTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorCachingMinTTL)
        errorCachingMinTTL = errorCachingMinTTLDecoded
    }
}

extension CloudFrontClientTypes.CustomErrorResponse: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls:
    ///
    /// * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.
    ///
    /// * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
    ///
    ///
    /// For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
    public struct CustomErrorResponse: Swift.Equatable {
        /// The minimum amount of time, in seconds, that you want CloudFront to cache the HTTP status code specified in ErrorCode. When this time period has elapsed, CloudFront queries your origin to see whether the problem that caused the error has been resolved and the requested object is now available. For more information, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
        public var errorCachingMinTTL: Swift.Int?
        /// The HTTP status code for which you want to specify a custom error page and/or a caching duration.
        /// This member is required.
        public var errorCode: Swift.Int?
        /// The HTTP status code that you want CloudFront to return to the viewer along with the custom error page. There are a variety of reasons that you might want CloudFront to return a status code different from the status code that your origin returned to CloudFront, for example:
        ///
        /// * Some Internet devices (some firewalls and corporate proxies, for example) intercept HTTP 4xx and 5xx and prevent the response from being returned to the viewer. If you substitute 200, the response typically won't be intercepted.
        ///
        /// * If you don't care about distinguishing among different client errors or server errors, you can specify 400 or 500 as the ResponseCode for all 4xx or 5xx errors.
        ///
        /// * You might want to return a 200 status code (OK) and static website so your customers don't know that your website is down.
        ///
        ///
        /// If you specify a value for ResponseCode, you must also specify a value for ResponsePagePath.
        public var responseCode: Swift.String?
        /// The path to the custom error page that you want CloudFront to return to a viewer when your origin returns the HTTP status code specified by ErrorCode, for example, /4xx-errors/403-forbidden.html. If you want to store your objects and your custom error pages in different locations, your distribution must include a cache behavior for which the following is true:
        ///
        /// * The value of PathPattern matches the path to your custom error messages. For example, suppose you saved custom error pages for 4xx errors in an Amazon S3 bucket in a directory named /4xx-errors. Your distribution must include a cache behavior for which the path pattern routes requests for your custom error pages to that location, for example, /4xx-errors/*.
        ///
        /// * The value of TargetOriginId specifies the value of the ID element for the origin that contains your custom error pages.
        ///
        ///
        /// If you specify a value for ResponsePagePath, you must also specify a value for ResponseCode. We recommend that you store custom error pages in an Amazon S3 bucket. If you store custom error pages on an HTTP server and the server starts to return 5xx errors, CloudFront can't get the files that you want to return to viewers because the origin server is unavailable.
        public var responsePagePath: Swift.String?

        public init (
            errorCachingMinTTL: Swift.Int? = nil,
            errorCode: Swift.Int? = nil,
            responseCode: Swift.String? = nil,
            responsePagePath: Swift.String? = nil
        )
        {
            self.errorCachingMinTTL = errorCachingMinTTL
            self.errorCode = errorCode
            self.responseCode = responseCode
            self.responsePagePath = responsePagePath
        }
    }

}

extension CloudFrontClientTypes.CustomErrorResponses: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for customerrorresponse0 in items {
                try itemsContainer.encode(customerrorresponse0, forKey: ClientRuntime.Key("CustomErrorResponse"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CustomErrorResponse{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CustomErrorResponse>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CustomErrorResponse].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CustomErrorResponse]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CustomErrorResponse]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CustomErrorResponses: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls:
    ///
    /// * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.
    ///
    /// * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
    ///
    ///
    /// For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
    public struct CustomErrorResponses: Swift.Equatable {
        /// A complex type that contains a CustomErrorResponse element for each HTTP status code for which you want to specify a custom error page and/or a caching duration.
        public var items: [CloudFrontClientTypes.CustomErrorResponse]?
        /// The number of HTTP status codes for which you want to specify a custom error page and/or a caching duration. If Quantity is 0, you can omit Items.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.CustomErrorResponse]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CustomHeaders: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origincustomheader0 in items {
                try itemsContainer.encode(origincustomheader0, forKey: ClientRuntime.Key("OriginCustomHeader"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginCustomHeader{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginCustomHeader>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginCustomHeader].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginCustomHeader]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginCustomHeader]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CustomHeaders: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains the list of Custom Headers for each origin.
    public struct CustomHeaders: Swift.Equatable {
        /// Optional: A list that contains one OriginCustomHeader element for each custom header that you want CloudFront to forward to the origin. If Quantity is 0, omit Items.
        public var items: [CloudFrontClientTypes.OriginCustomHeader]?
        /// The number of custom headers, if any, for this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.OriginCustomHeader]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CustomOriginConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hTTPPort = "HTTPPort"
        case hTTPSPort = "HTTPSPort"
        case originKeepaliveTimeout = "OriginKeepaliveTimeout"
        case originProtocolPolicy = "OriginProtocolPolicy"
        case originReadTimeout = "OriginReadTimeout"
        case originSslProtocols = "OriginSslProtocols"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let hTTPPort = hTTPPort {
            try container.encode(hTTPPort, forKey: ClientRuntime.Key("HTTPPort"))
        }
        if let hTTPSPort = hTTPSPort {
            try container.encode(hTTPSPort, forKey: ClientRuntime.Key("HTTPSPort"))
        }
        if let originKeepaliveTimeout = originKeepaliveTimeout {
            try container.encode(originKeepaliveTimeout, forKey: ClientRuntime.Key("OriginKeepaliveTimeout"))
        }
        if let originProtocolPolicy = originProtocolPolicy {
            try container.encode(originProtocolPolicy, forKey: ClientRuntime.Key("OriginProtocolPolicy"))
        }
        if let originReadTimeout = originReadTimeout {
            try container.encode(originReadTimeout, forKey: ClientRuntime.Key("OriginReadTimeout"))
        }
        if let originSslProtocols = originSslProtocols {
            try container.encode(originSslProtocols, forKey: ClientRuntime.Key("OriginSslProtocols"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hTTPPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hTTPPort)
        hTTPPort = hTTPPortDecoded
        let hTTPSPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hTTPSPort)
        hTTPSPort = hTTPSPortDecoded
        let originProtocolPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginProtocolPolicy.self, forKey: .originProtocolPolicy)
        originProtocolPolicy = originProtocolPolicyDecoded
        let originSslProtocolsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginSslProtocols.self, forKey: .originSslProtocols)
        originSslProtocols = originSslProtocolsDecoded
        let originReadTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .originReadTimeout)
        originReadTimeout = originReadTimeoutDecoded
        let originKeepaliveTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .originKeepaliveTimeout)
        originKeepaliveTimeout = originKeepaliveTimeoutDecoded
    }
}

extension CloudFrontClientTypes.CustomOriginConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A custom origin. A custom origin is any origin that is not an Amazon S3 bucket, with one exception. An Amazon S3 bucket that is [configured with static website hosting](https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html) is a custom origin.
    public struct CustomOriginConfig: Swift.Equatable {
        /// The HTTP port that CloudFront uses to connect to the origin. Specify the HTTP port that the origin listens on.
        /// This member is required.
        public var hTTPPort: Swift.Int?
        /// The HTTPS port that CloudFront uses to connect to the origin. Specify the HTTPS port that the origin listens on.
        /// This member is required.
        public var hTTPSPort: Swift.Int?
        /// Specifies how long, in seconds, CloudFront persists its connection to the origin. The minimum timeout is 1 second, the maximum is 60 seconds, and the default (if you don’t specify otherwise) is 5 seconds. For more information, see [Origin Keep-alive Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginKeepaliveTimeout) in the Amazon CloudFront Developer Guide.
        public var originKeepaliveTimeout: Swift.Int?
        /// Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin. Valid values are:
        ///
        /// * http-only – CloudFront always uses HTTP to connect to the origin.
        ///
        /// * match-viewer – CloudFront connects to the origin using the same protocol that the viewer used to connect to CloudFront.
        ///
        /// * https-only – CloudFront always uses HTTPS to connect to the origin.
        /// This member is required.
        public var originProtocolPolicy: CloudFrontClientTypes.OriginProtocolPolicy?
        /// Specifies how long, in seconds, CloudFront waits for a response from the origin. This is also known as the origin response timeout. The minimum timeout is 1 second, the maximum is 60 seconds, and the default (if you don’t specify otherwise) is 30 seconds. For more information, see [Origin Response Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout) in the Amazon CloudFront Developer Guide.
        public var originReadTimeout: Swift.Int?
        /// Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over HTTPS. Valid values include SSLv3, TLSv1, TLSv1.1, and TLSv1.2. For more information, see [Minimum Origin SSL Protocol](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginSSLProtocols) in the Amazon CloudFront Developer Guide.
        public var originSslProtocols: CloudFrontClientTypes.OriginSslProtocols?

        public init (
            hTTPPort: Swift.Int? = nil,
            hTTPSPort: Swift.Int? = nil,
            originKeepaliveTimeout: Swift.Int? = nil,
            originProtocolPolicy: CloudFrontClientTypes.OriginProtocolPolicy? = nil,
            originReadTimeout: Swift.Int? = nil,
            originSslProtocols: CloudFrontClientTypes.OriginSslProtocols? = nil
        )
        {
            self.hTTPPort = hTTPPort
            self.hTTPSPort = hTTPSPort
            self.originKeepaliveTimeout = originKeepaliveTimeout
            self.originProtocolPolicy = originProtocolPolicy
            self.originReadTimeout = originReadTimeout
            self.originSslProtocols = originSslProtocols
        }
    }

}

extension CloudFrontClientTypes.DefaultCacheBehavior: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedMethods = "AllowedMethods"
        case cachePolicyId = "CachePolicyId"
        case compress = "Compress"
        case defaultTTL = "DefaultTTL"
        case fieldLevelEncryptionId = "FieldLevelEncryptionId"
        case forwardedValues = "ForwardedValues"
        case functionAssociations = "FunctionAssociations"
        case lambdaFunctionAssociations = "LambdaFunctionAssociations"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case originRequestPolicyId = "OriginRequestPolicyId"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case responseHeadersPolicyId = "ResponseHeadersPolicyId"
        case smoothStreaming = "SmoothStreaming"
        case targetOriginId = "TargetOriginId"
        case trustedKeyGroups = "TrustedKeyGroups"
        case trustedSigners = "TrustedSigners"
        case viewerProtocolPolicy = "ViewerProtocolPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let allowedMethods = allowedMethods {
            try container.encode(allowedMethods, forKey: ClientRuntime.Key("AllowedMethods"))
        }
        if let cachePolicyId = cachePolicyId {
            try container.encode(cachePolicyId, forKey: ClientRuntime.Key("CachePolicyId"))
        }
        if let compress = compress {
            try container.encode(compress, forKey: ClientRuntime.Key("Compress"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: ClientRuntime.Key("DefaultTTL"))
        }
        if let fieldLevelEncryptionId = fieldLevelEncryptionId {
            try container.encode(fieldLevelEncryptionId, forKey: ClientRuntime.Key("FieldLevelEncryptionId"))
        }
        if let forwardedValues = forwardedValues {
            try container.encode(forwardedValues, forKey: ClientRuntime.Key("ForwardedValues"))
        }
        if let functionAssociations = functionAssociations {
            try container.encode(functionAssociations, forKey: ClientRuntime.Key("FunctionAssociations"))
        }
        if let lambdaFunctionAssociations = lambdaFunctionAssociations {
            try container.encode(lambdaFunctionAssociations, forKey: ClientRuntime.Key("LambdaFunctionAssociations"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: ClientRuntime.Key("MaxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: ClientRuntime.Key("MinTTL"))
        }
        if let originRequestPolicyId = originRequestPolicyId {
            try container.encode(originRequestPolicyId, forKey: ClientRuntime.Key("OriginRequestPolicyId"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: ClientRuntime.Key("RealtimeLogConfigArn"))
        }
        if let responseHeadersPolicyId = responseHeadersPolicyId {
            try container.encode(responseHeadersPolicyId, forKey: ClientRuntime.Key("ResponseHeadersPolicyId"))
        }
        if let smoothStreaming = smoothStreaming {
            try container.encode(smoothStreaming, forKey: ClientRuntime.Key("SmoothStreaming"))
        }
        if let targetOriginId = targetOriginId {
            try container.encode(targetOriginId, forKey: ClientRuntime.Key("TargetOriginId"))
        }
        if let trustedKeyGroups = trustedKeyGroups {
            try container.encode(trustedKeyGroups, forKey: ClientRuntime.Key("TrustedKeyGroups"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
        if let viewerProtocolPolicy = viewerProtocolPolicy {
            try container.encode(viewerProtocolPolicy, forKey: ClientRuntime.Key("ViewerProtocolPolicy"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetOriginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetOriginId)
        targetOriginId = targetOriginIdDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let trustedKeyGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedKeyGroups.self, forKey: .trustedKeyGroups)
        trustedKeyGroups = trustedKeyGroupsDecoded
        let viewerProtocolPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerProtocolPolicy.self, forKey: .viewerProtocolPolicy)
        viewerProtocolPolicy = viewerProtocolPolicyDecoded
        let allowedMethodsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.AllowedMethods.self, forKey: .allowedMethods)
        allowedMethods = allowedMethodsDecoded
        let smoothStreamingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .smoothStreaming)
        smoothStreaming = smoothStreamingDecoded
        let compressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .compress)
        compress = compressDecoded
        let lambdaFunctionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.LambdaFunctionAssociations.self, forKey: .lambdaFunctionAssociations)
        lambdaFunctionAssociations = lambdaFunctionAssociationsDecoded
        let functionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionAssociations.self, forKey: .functionAssociations)
        functionAssociations = functionAssociationsDecoded
        let fieldLevelEncryptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldLevelEncryptionId)
        fieldLevelEncryptionId = fieldLevelEncryptionIdDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
        let cachePolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cachePolicyId)
        cachePolicyId = cachePolicyIdDecoded
        let originRequestPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originRequestPolicyId)
        originRequestPolicyId = originRequestPolicyIdDecoded
        let responseHeadersPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseHeadersPolicyId)
        responseHeadersPolicyId = responseHeadersPolicyIdDecoded
        let forwardedValuesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ForwardedValues.self, forKey: .forwardedValues)
        forwardedValues = forwardedValuesDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
    }
}

extension CloudFrontClientTypes.DefaultCacheBehavior: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that describes the default cache behavior if you don’t specify a CacheBehavior element or if request URLs don’t match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.
    public struct DefaultCacheBehavior: Swift.Equatable {
        /// A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:
        ///
        /// * CloudFront forwards only GET and HEAD requests.
        ///
        /// * CloudFront forwards only GET, HEAD, and OPTIONS requests.
        ///
        /// * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests.
        ///
        ///
        /// If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
        public var allowedMethods: CloudFrontClientTypes.AllowedMethods?
        /// The unique identifier of the cache policy that is attached to the default cache behavior. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. A DefaultCacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId.
        public var cachePolicyId: Swift.String?
        /// Whether you want CloudFront to automatically compress certain files for this cache behavior. If so, specify true; if not, specify false. For more information, see [Serving Compressed Files](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html) in the Amazon CloudFront Developer Guide.
        public var compress: Swift.Bool?
        /// This field is deprecated. We recommend that you use the DefaultTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The default amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin does not add HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var defaultTTL: Swift.Int?
        /// The value of ID for the field-level encryption configuration that you want CloudFront to use for encrypting specific fields of data for the default cache behavior.
        public var fieldLevelEncryptionId: Swift.String?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. For more information, see [Working with policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html) in the Amazon CloudFront Developer Guide. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide. A DefaultCacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
        @available(*, deprecated)
        public var forwardedValues: CloudFrontClientTypes.ForwardedValues?
        /// A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
        public var functionAssociations: CloudFrontClientTypes.FunctionAssociations?
        /// A complex type that contains zero or more Lambda@Edge function associations for a cache behavior.
        public var lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations?
        /// This field is deprecated. We recommend that you use the MaxTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin adds HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var maxTTL: Swift.Int?
        /// This field is deprecated. We recommend that you use the MinTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. You must specify 0 for MinTTL if you configure CloudFront to forward all headers to your origin (under Headers, if you specify 1 for Quantity and * for Name).
        @available(*, deprecated)
        public var minTTL: Swift.Int?
        /// The unique identifier of the origin request policy that is attached to the default cache behavior. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide.
        public var originRequestPolicyId: Swift.String?
        /// The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this cache behavior. For more information, see [Real-time logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html) in the Amazon CloudFront Developer Guide.
        public var realtimeLogConfigArn: Swift.String?
        /// The identifier for a response headers policy.
        public var responseHeadersPolicyId: Swift.String?
        /// Indicates whether you want to distribute media files in the Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify true; if not, specify false. If you specify true for SmoothStreaming, you can still distribute other content using this cache behavior if the content matches the value of PathPattern.
        public var smoothStreaming: Swift.Bool?
        /// The value of ID for the origin that you want CloudFront to route requests to when they use the default cache behavior.
        /// This member is required.
        public var targetOriginId: Swift.String?
        /// A list of key groups that CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with a private key whose corresponding public key is in the key group. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups?
        /// We recommend using TrustedKeyGroups instead of TrustedSigners. A list of Amazon Web Services account IDs whose public keys CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with the private key of a CloudFront key pair in a trusted signer’s Amazon Web Services account. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?
        /// The protocol that viewers can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. You can specify the following options:
        ///
        /// * allow-all: Viewers can use HTTP or HTTPS.
        ///
        /// * redirect-to-https: If a viewer submits an HTTP request, CloudFront returns an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The viewer then resubmits the request using the new URL.
        ///
        /// * https-only: If a viewer sends an HTTP request, CloudFront returns an HTTP status code of 403 (Forbidden).
        ///
        ///
        /// For more information about requiring the HTTPS protocol, see [Requiring HTTPS Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html) in the Amazon CloudFront Developer Guide. The only way to guarantee that viewers retrieve an object that was fetched from the origin using HTTPS is never to use any other protocol to fetch the object. If you have recently changed from HTTP to HTTPS, we recommend that you clear your objects’ cache because cached objects are protocol agnostic. That means that an edge location will return an object from the cache regardless of whether the current request protocol matches the protocol used previously. For more information, see [Managing Cache Expiration](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy?

        public init (
            allowedMethods: CloudFrontClientTypes.AllowedMethods? = nil,
            cachePolicyId: Swift.String? = nil,
            compress: Swift.Bool? = nil,
            defaultTTL: Swift.Int? = nil,
            fieldLevelEncryptionId: Swift.String? = nil,
            forwardedValues: CloudFrontClientTypes.ForwardedValues? = nil,
            functionAssociations: CloudFrontClientTypes.FunctionAssociations? = nil,
            lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            originRequestPolicyId: Swift.String? = nil,
            realtimeLogConfigArn: Swift.String? = nil,
            responseHeadersPolicyId: Swift.String? = nil,
            smoothStreaming: Swift.Bool? = nil,
            targetOriginId: Swift.String? = nil,
            trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil,
            viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy? = nil
        )
        {
            self.allowedMethods = allowedMethods
            self.cachePolicyId = cachePolicyId
            self.compress = compress
            self.defaultTTL = defaultTTL
            self.fieldLevelEncryptionId = fieldLevelEncryptionId
            self.forwardedValues = forwardedValues
            self.functionAssociations = functionAssociations
            self.lambdaFunctionAssociations = lambdaFunctionAssociations
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.originRequestPolicyId = originRequestPolicyId
            self.realtimeLogConfigArn = realtimeLogConfigArn
            self.responseHeadersPolicyId = responseHeadersPolicyId
            self.smoothStreaming = smoothStreaming
            self.targetOriginId = targetOriginId
            self.trustedKeyGroups = trustedKeyGroups
            self.trustedSigners = trustedSigners
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }

}

extension DeleteCachePolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteCachePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())"
    }
}

public struct DeleteCachePolicyInput: Swift.Equatable {
    /// The unique identifier for the cache policy that you are deleting. To get the identifier, you can use ListCachePolicies.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the cache policy that you are deleting. The version is the cache policy’s ETag value, which you can get using ListCachePolicies, GetCachePolicy, or GetCachePolicyConfig.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteCachePolicyInputBody: Swift.Equatable {
}

extension DeleteCachePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCachePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteCachePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CachePolicyInUse" : self = .cachePolicyInUse(try CachePolicyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalDelete" : self = .illegalDelete(try IllegalDelete(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCachePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cachePolicyInUse(CachePolicyInUse)
    case illegalDelete(IllegalDelete)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCachePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCachePolicyOutputResponse: Swift.Equatable {

}

extension DeleteCloudFrontOriginAccessIdentityInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteCloudFrontOriginAccessIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())"
    }
}

/// Deletes a origin access identity.
public struct DeleteCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The origin access identity's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header you received from a previous GET or PUT request. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
}

extension DeleteCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudFrontOriginAccessIdentityInUse" : self = .cloudFrontOriginAccessIdentityInUse(try CloudFrontOriginAccessIdentityInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCloudFrontOriginAccessIdentityOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cloudFrontOriginAccessIdentityInUse(CloudFrontOriginAccessIdentityInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCloudFrontOriginAccessIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCloudFrontOriginAccessIdentityOutputResponse: Swift.Equatable {

}

extension DeleteDistributionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())"
    }
}

/// This action deletes a web distribution. To delete a web distribution using the CloudFront API, perform the following steps. To delete a web distribution using the CloudFront API:
///
/// * Disable the web distribution
///
/// * Submit a GET Distribution Config request to get the current configuration and the Etag header for the distribution.
///
/// * Update the XML document that was returned in the response to your GET Distribution Config request to change the value of Enabled to false.
///
/// * Submit a PUT Distribution Config request to update the configuration for your distribution. In the request body, include the XML document that you updated in Step 3. Set the value of the HTTP If-Match header to the value of the ETag header that CloudFront returned when you submitted the GET Distribution Config request in Step 2.
///
/// * Review the response to the PUT Distribution Config request to confirm that the distribution was successfully disabled.
///
/// * Submit a GET Distribution request to confirm that your changes have propagated. When propagation is complete, the value of Status is Deployed.
///
/// * Submit a DELETE Distribution request. Set the value of the HTTP If-Match header to the value of the ETag header that CloudFront returned when you submitted the GET Distribution Config request in Step 6.
///
/// * Review the response to your DELETE Distribution request to confirm that the distribution was successfully deleted.
///
///
/// For information about deleting a distribution using the CloudFront console, see [Deleting a Distribution](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowToDeleteDistribution.html) in the Amazon CloudFront Developer Guide.
public struct DeleteDistributionInput: Swift.Equatable {
    /// The distribution ID.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when you disabled the distribution. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteDistributionInputBody: Swift.Equatable {
}

extension DeleteDistributionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DistributionNotDisabled" : self = .distributionNotDisabled(try DistributionNotDisabled(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case distributionNotDisabled(DistributionNotDisabled)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchDistribution(NoSuchDistribution)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDistributionOutputResponse: Swift.Equatable {

}

extension DeleteFieldLevelEncryptionConfigInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteFieldLevelEncryptionConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())"
    }
}

public struct DeleteFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// The ID of the configuration you want to delete from CloudFront.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the configuration identity to delete. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteFieldLevelEncryptionConfigInputBody: Swift.Equatable {
}

extension DeleteFieldLevelEncryptionConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteFieldLevelEncryptionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionConfigInUse" : self = .fieldLevelEncryptionConfigInUse(try FieldLevelEncryptionConfigInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFieldLevelEncryptionConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case fieldLevelEncryptionConfigInUse(FieldLevelEncryptionConfigInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFieldLevelEncryptionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFieldLevelEncryptionConfigOutputResponse: Swift.Equatable {

}

extension DeleteFieldLevelEncryptionProfileInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteFieldLevelEncryptionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())"
    }
}

public struct DeleteFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// Request the ID of the profile you want to delete from CloudFront.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the profile to delete. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteFieldLevelEncryptionProfileInputBody: Swift.Equatable {
}

extension DeleteFieldLevelEncryptionProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteFieldLevelEncryptionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileInUse" : self = .fieldLevelEncryptionProfileInUse(try FieldLevelEncryptionProfileInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFieldLevelEncryptionProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case fieldLevelEncryptionProfileInUse(FieldLevelEncryptionProfileInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFieldLevelEncryptionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFieldLevelEncryptionProfileOutputResponse: Swift.Equatable {

}

extension DeleteFunctionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())"
    }
}

public struct DeleteFunctionInput: Swift.Equatable {
    /// The current version (ETag value) of the function that you are deleting, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are deleting.
    /// This member is required.
    public var name: Swift.String?

    public init (
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

struct DeleteFunctionInputBody: Swift.Equatable {
}

extension DeleteFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FunctionInUse" : self = .functionInUse(try FunctionInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionOutputError: Swift.Error, Swift.Equatable {
    case functionInUse(FunctionInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case preconditionFailed(PreconditionFailed)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionOutputResponse: Swift.Equatable {

}

extension DeleteKeyGroupInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteKeyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())"
    }
}

public struct DeleteKeyGroupInput: Swift.Equatable {
    /// The identifier of the key group that you are deleting. To get the identifier, use ListKeyGroups.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the key group that you are deleting. The version is the key group’s ETag value. To get the ETag, use GetKeyGroup or GetKeyGroupConfig.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteKeyGroupInputBody: Swift.Equatable {
}

extension DeleteKeyGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKeyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteKeyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteKeyGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchResource(NoSuchResource)
    case preconditionFailed(PreconditionFailed)
    case resourceInUse(ResourceInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteKeyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteKeyGroupOutputResponse: Swift.Equatable {

}

extension DeleteMonitoringSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let distributionId = distributionId else {
            return nil
        }
        return "/2020-05-31/distributions/\(distributionId.urlPercentEncoding())/monitoring-subscription"
    }
}

public struct DeleteMonitoringSubscriptionInput: Swift.Equatable {
    /// The ID of the distribution that you are disabling metrics for.
    /// This member is required.
    public var distributionId: Swift.String?

    public init (
        distributionId: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
    }
}

struct DeleteMonitoringSubscriptionInputBody: Swift.Equatable {
}

extension DeleteMonitoringSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMonitoringSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteMonitoringSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMonitoringSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMonitoringSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMonitoringSubscriptionOutputResponse: Swift.Equatable {

}

extension DeleteOriginRequestPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteOriginRequestPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())"
    }
}

public struct DeleteOriginRequestPolicyInput: Swift.Equatable {
    /// The unique identifier for the origin request policy that you are deleting. To get the identifier, you can use ListOriginRequestPolicies.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the origin request policy that you are deleting. The version is the origin request policy’s ETag value, which you can get using ListOriginRequestPolicies, GetOriginRequestPolicy, or GetOriginRequestPolicyConfig.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteOriginRequestPolicyInputBody: Swift.Equatable {
}

extension DeleteOriginRequestPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOriginRequestPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteOriginRequestPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalDelete" : self = .illegalDelete(try IllegalDelete(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OriginRequestPolicyInUse" : self = .originRequestPolicyInUse(try OriginRequestPolicyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOriginRequestPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalDelete(IllegalDelete)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case originRequestPolicyInUse(OriginRequestPolicyInUse)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOriginRequestPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOriginRequestPolicyOutputResponse: Swift.Equatable {

}

extension DeletePublicKeyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeletePublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())"
    }
}

public struct DeletePublicKeyInput: Swift.Equatable {
    /// The ID of the public key you want to remove from CloudFront.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the public key identity to delete. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeletePublicKeyInputBody: Swift.Equatable {
}

extension DeletePublicKeyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PublicKeyInUse" : self = .publicKeyInUse(try PublicKeyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePublicKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchPublicKey(NoSuchPublicKey)
    case preconditionFailed(PreconditionFailed)
    case publicKeyInUse(PublicKeyInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePublicKeyOutputResponse: Swift.Equatable {

}

extension DeleteRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension DeleteRealtimeLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }
}

extension DeleteRealtimeLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/delete-realtime-log-config"
    }
}

public struct DeleteRealtimeLogConfigInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the real-time log configuration to delete.
    public var aRN: Swift.String?
    /// The name of the real-time log configuration to delete.
    public var name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct DeleteRealtimeLogConfigInputBody: Swift.Equatable {
    let name: Swift.String?
    let aRN: Swift.String?
}

extension DeleteRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension DeleteRealtimeLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteRealtimeLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigInUse" : self = .realtimeLogConfigInUse(try RealtimeLogConfigInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRealtimeLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case realtimeLogConfigInUse(RealtimeLogConfigInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRealtimeLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRealtimeLogConfigOutputResponse: Swift.Equatable {

}

extension DeleteResponseHeadersPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteResponseHeadersPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())"
    }
}

public struct DeleteResponseHeadersPolicyInput: Swift.Equatable {
    /// The identifier for the response headers policy that you are deleting. To get the identifier, you can use ListResponseHeadersPolicies.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the response headers policy that you are deleting. The version is the response headers policy’s ETag value, which you can get using ListResponseHeadersPolicies, GetResponseHeadersPolicy, or GetResponseHeadersPolicyConfig.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteResponseHeadersPolicyInputBody: Swift.Equatable {
}

extension DeleteResponseHeadersPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResponseHeadersPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteResponseHeadersPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalDelete" : self = .illegalDelete(try IllegalDelete(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResponseHeadersPolicy" : self = .noSuchResponseHeadersPolicy(try NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResponseHeadersPolicyInUse" : self = .responseHeadersPolicyInUse(try ResponseHeadersPolicyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResponseHeadersPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalDelete(IllegalDelete)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchResponseHeadersPolicy(NoSuchResponseHeadersPolicy)
    case preconditionFailed(PreconditionFailed)
    case responseHeadersPolicyInUse(ResponseHeadersPolicyInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResponseHeadersPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResponseHeadersPolicyOutputResponse: Swift.Equatable {

}

extension DeleteStreamingDistributionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteStreamingDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())"
    }
}

/// The request to delete a streaming distribution.
public struct DeleteStreamingDistributionInput: Swift.Equatable {
    /// The distribution ID.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when you disabled the streaming distribution. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteStreamingDistributionInputBody: Swift.Equatable {
}

extension DeleteStreamingDistributionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStreamingDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteStreamingDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamingDistributionNotDisabled" : self = .streamingDistributionNotDisabled(try StreamingDistributionNotDisabled(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamingDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case preconditionFailed(PreconditionFailed)
    case streamingDistributionNotDisabled(StreamingDistributionNotDisabled)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamingDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStreamingDistributionOutputResponse: Swift.Equatable {

}

extension DescribeFunctionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let stage = stage {
            let stageQueryItem = ClientRuntime.URLQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
            items.append(stageQueryItem)
        }
        return items
    }
}

extension DescribeFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())/describe"
    }
}

public struct DescribeFunctionInput: Swift.Equatable {
    /// The name of the function that you are getting information about.
    /// This member is required.
    public var name: Swift.String?
    /// The function’s stage, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init (
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.name = name
        self.stage = stage
    }
}

struct DescribeFunctionInputBody: Swift.Equatable {
}

extension DescribeFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFunctionOutputError: Swift.Error, Swift.Equatable {
    case noSuchFunctionExists(NoSuchFunctionExists)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct DescribeFunctionOutputResponse: Swift.Equatable {
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init (
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
    }
}

struct DescribeFunctionOutputResponseBody: Swift.Equatable {
    let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension DescribeFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

extension CloudFrontClientTypes.Distribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case activeTrustedKeyGroups = "ActiveTrustedKeyGroups"
        case activeTrustedSigners = "ActiveTrustedSigners"
        case aliasICPRecordals = "AliasICPRecordals"
        case distributionConfig = "DistributionConfig"
        case domainName = "DomainName"
        case id = "Id"
        case inProgressInvalidationBatches = "InProgressInvalidationBatches"
        case lastModifiedTime = "LastModifiedTime"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let activeTrustedKeyGroups = activeTrustedKeyGroups {
            try container.encode(activeTrustedKeyGroups, forKey: ClientRuntime.Key("ActiveTrustedKeyGroups"))
        }
        if let activeTrustedSigners = activeTrustedSigners {
            try container.encode(activeTrustedSigners, forKey: ClientRuntime.Key("ActiveTrustedSigners"))
        }
        if let aliasICPRecordals = aliasICPRecordals {
            var aliasICPRecordalsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AliasICPRecordals"))
            for aliasicprecordal0 in aliasICPRecordals {
                try aliasICPRecordalsContainer.encode(aliasicprecordal0, forKey: ClientRuntime.Key("AliasICPRecordal"))
            }
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let inProgressInvalidationBatches = inProgressInvalidationBatches {
            try container.encode(inProgressInvalidationBatches, forKey: ClientRuntime.Key("InProgressInvalidationBatches"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let inProgressInvalidationBatchesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inProgressInvalidationBatches)
        inProgressInvalidationBatches = inProgressInvalidationBatchesDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let activeTrustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ActiveTrustedSigners.self, forKey: .activeTrustedSigners)
        activeTrustedSigners = activeTrustedSignersDecoded
        let activeTrustedKeyGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ActiveTrustedKeyGroups.self, forKey: .activeTrustedKeyGroups)
        activeTrustedKeyGroups = activeTrustedKeyGroupsDecoded
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
        if containerValues.contains(.aliasICPRecordals) {
            struct KeyVal0{struct AliasICPRecordal{}}
            let aliasICPRecordalsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AliasICPRecordal>.CodingKeys.self, forKey: .aliasICPRecordals)
            if let aliasICPRecordalsWrappedContainer = aliasICPRecordalsWrappedContainer {
                let aliasICPRecordalsContainer = try aliasICPRecordalsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.AliasICPRecordal].self, forKey: .member)
                var aliasICPRecordalsBuffer:[CloudFrontClientTypes.AliasICPRecordal]? = nil
                if let aliasICPRecordalsContainer = aliasICPRecordalsContainer {
                    aliasICPRecordalsBuffer = [CloudFrontClientTypes.AliasICPRecordal]()
                    for structureContainer0 in aliasICPRecordalsContainer {
                        aliasICPRecordalsBuffer?.append(structureContainer0)
                    }
                }
                aliasICPRecordals = aliasICPRecordalsBuffer
            } else {
                aliasICPRecordals = []
            }
        } else {
            aliasICPRecordals = nil
        }
    }
}

extension CloudFrontClientTypes.Distribution: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A distribution tells CloudFront where you want content to be delivered from, and the details about how to track and manage content delivery.
    public struct Distribution: Swift.Equatable {
        /// The ARN (Amazon Resource Name) for the distribution. For example: arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5, where 123456789012 is your Amazon Web Services account ID.
        /// This member is required.
        public var aRN: Swift.String?
        /// CloudFront automatically adds this field to the response if you’ve configured a cache behavior in this distribution to serve private content using key groups. This field contains a list of key groups and the public keys in each key group that CloudFront can use to verify the signatures of signed URLs or signed cookies.
        public var activeTrustedKeyGroups: CloudFrontClientTypes.ActiveTrustedKeyGroups?
        /// We recommend using TrustedKeyGroups instead of TrustedSigners. CloudFront automatically adds this field to the response if you’ve configured a cache behavior in this distribution to serve private content using trusted signers. This field contains a list of Amazon Web Services account IDs and the active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs or signed cookies.
        public var activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners?
        /// Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions. For more information about ICP recordals, see [ Signup, Accounts, and Credentials](https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html) in Getting Started with Amazon Web Services services in China.
        public var aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]?
        /// The current configuration information for the distribution. Send a GET request to the /CloudFront API version/distribution ID/config resource.
        /// This member is required.
        public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
        /// The domain name corresponding to the distribution, for example, d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// The identifier for the distribution. For example: EDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// The number of invalidation batches currently in progress.
        /// This member is required.
        public var inProgressInvalidationBatches: Swift.Int?
        /// The date and time the distribution was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// This response element indicates the current status of the distribution. When the status is Deployed, the distribution's information is fully propagated to all CloudFront edge locations.
        /// This member is required.
        public var status: Swift.String?

        public init (
            aRN: Swift.String? = nil,
            activeTrustedKeyGroups: CloudFrontClientTypes.ActiveTrustedKeyGroups? = nil,
            activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners? = nil,
            aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]? = nil,
            distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            inProgressInvalidationBatches: Swift.Int? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.aRN = aRN
            self.activeTrustedKeyGroups = activeTrustedKeyGroups
            self.activeTrustedSigners = activeTrustedSigners
            self.aliasICPRecordals = aliasICPRecordals
            self.distributionConfig = distributionConfig
            self.domainName = domainName
            self.id = id
            self.inProgressInvalidationBatches = inProgressInvalidationBatches
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }

}

extension DistributionAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DistributionAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The caller reference you attempted to create the distribution with is associated with another distribution.
public struct DistributionAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DistributionAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension DistributionAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.DistributionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case cacheBehaviors = "CacheBehaviors"
        case callerReference = "CallerReference"
        case comment = "Comment"
        case customErrorResponses = "CustomErrorResponses"
        case defaultCacheBehavior = "DefaultCacheBehavior"
        case defaultRootObject = "DefaultRootObject"
        case enabled = "Enabled"
        case httpVersion = "HttpVersion"
        case isIPV6Enabled = "IsIPV6Enabled"
        case logging = "Logging"
        case originGroups = "OriginGroups"
        case origins = "Origins"
        case priceClass = "PriceClass"
        case restrictions = "Restrictions"
        case viewerCertificate = "ViewerCertificate"
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let cacheBehaviors = cacheBehaviors {
            try container.encode(cacheBehaviors, forKey: ClientRuntime.Key("CacheBehaviors"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let customErrorResponses = customErrorResponses {
            try container.encode(customErrorResponses, forKey: ClientRuntime.Key("CustomErrorResponses"))
        }
        if let defaultCacheBehavior = defaultCacheBehavior {
            try container.encode(defaultCacheBehavior, forKey: ClientRuntime.Key("DefaultCacheBehavior"))
        }
        if let defaultRootObject = defaultRootObject {
            try container.encode(defaultRootObject, forKey: ClientRuntime.Key("DefaultRootObject"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let httpVersion = httpVersion {
            try container.encode(httpVersion, forKey: ClientRuntime.Key("HttpVersion"))
        }
        if let isIPV6Enabled = isIPV6Enabled {
            try container.encode(isIPV6Enabled, forKey: ClientRuntime.Key("IsIPV6Enabled"))
        }
        if let logging = logging {
            try container.encode(logging, forKey: ClientRuntime.Key("Logging"))
        }
        if let originGroups = originGroups {
            try container.encode(originGroups, forKey: ClientRuntime.Key("OriginGroups"))
        }
        if let origins = origins {
            try container.encode(origins, forKey: ClientRuntime.Key("Origins"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let restrictions = restrictions {
            try container.encode(restrictions, forKey: ClientRuntime.Key("Restrictions"))
        }
        if let viewerCertificate = viewerCertificate {
            try container.encode(viewerCertificate, forKey: ClientRuntime.Key("ViewerCertificate"))
        }
        if let webACLId = webACLId {
            try container.encode(webACLId, forKey: ClientRuntime.Key("WebACLId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let defaultRootObjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRootObject)
        defaultRootObject = defaultRootObjectDecoded
        let originsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Origins.self, forKey: .origins)
        origins = originsDecoded
        let originGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroups.self, forKey: .originGroups)
        originGroups = originGroupsDecoded
        let defaultCacheBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DefaultCacheBehavior.self, forKey: .defaultCacheBehavior)
        defaultCacheBehavior = defaultCacheBehaviorDecoded
        let cacheBehaviorsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CacheBehaviors.self, forKey: .cacheBehaviors)
        cacheBehaviors = cacheBehaviorsDecoded
        let customErrorResponsesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomErrorResponses.self, forKey: .customErrorResponses)
        customErrorResponses = customErrorResponsesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.LoggingConfig.self, forKey: .logging)
        logging = loggingDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let viewerCertificateDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerCertificate.self, forKey: .viewerCertificate)
        viewerCertificate = viewerCertificateDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Restrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
        let webACLIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let httpVersionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.HttpVersion.self, forKey: .httpVersion)
        httpVersion = httpVersionDecoded
        let isIPV6EnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isIPV6Enabled)
        isIPV6Enabled = isIPV6EnabledDecoded
    }
}

extension CloudFrontClientTypes.DistributionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A distribution configuration.
    public struct DistributionConfig: Swift.Equatable {
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// A complex type that contains zero or more CacheBehavior elements.
        public var cacheBehaviors: CloudFrontClientTypes.CacheBehaviors?
        /// A unique value (for example, a date-time stamp) that ensures that the request can't be replayed. If the value of CallerReference is new (regardless of the content of the DistributionConfig object), CloudFront creates a new distribution. If CallerReference is a value that you already sent in a previous request to create a distribution, CloudFront returns a DistributionAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// An optional comment to describe the distribution. The comment cannot be longer than 128 characters.
        /// This member is required.
        public var comment: Swift.String?
        /// A complex type that controls the following:
        ///
        /// * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.
        ///
        /// * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
        ///
        ///
        /// For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
        public var customErrorResponses: CloudFrontClientTypes.CustomErrorResponses?
        /// A complex type that describes the default cache behavior if you don't specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.
        /// This member is required.
        public var defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior?
        /// The object that you want CloudFront to request from your origin (for example, index.html) when a viewer requests the root URL for your distribution (http://www.example.com) instead of an object in your distribution (http://www.example.com/product-description.html). Specifying a default root object avoids exposing the contents of your distribution. Specify only the object name, for example, index.html. Don't add a / before the object name. If you don't want to specify a default root object when you create a distribution, include an empty DefaultRootObject element. To delete the default root object from an existing distribution, update the distribution configuration and include an empty DefaultRootObject element. To replace the default root object, update the distribution configuration and specify the new object. For more information about the default root object, see [Creating a Default Root Object](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/DefaultRootObject.html) in the Amazon CloudFront Developer Guide.
        public var defaultRootObject: Swift.String?
        /// From this field, you can enable or disable the selected distribution.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// (Optional) Specify the maximum HTTP version that you want viewers to use to communicate with CloudFront. The default value for new web distributions is http2. Viewers that don't support HTTP/2 automatically use an earlier HTTP version. For viewers and CloudFront to use HTTP/2, viewers must support TLS 1.2 or later, and must support Server Name Identification (SNI). In general, configuring CloudFront to communicate with viewers using HTTP/2 reduces latency. You can improve performance by optimizing for HTTP/2. For more information, do an Internet search for "http/2 optimization."
        public var httpVersion: CloudFrontClientTypes.HttpVersion?
        /// If you want CloudFront to respond to IPv6 DNS requests with an IPv6 address for your distribution, specify true. If you specify false, CloudFront responds to IPv6 DNS requests with the DNS response code NOERROR and with no IP addresses. This allows viewers to submit a second request, for an IPv4 address for your distribution. In general, you should enable IPv6 if you have users on IPv6 networks who want to access your content. However, if you're using signed URLs or signed cookies to restrict access to your content, and if you're using a custom policy that includes the IpAddress parameter to restrict the IP addresses that can access your content, don't enable IPv6. If you want to restrict access to some content by IP address and not restrict access to other content (or restrict access but not by IP address), you can create two distributions. For more information, see [Creating a Signed URL Using a Custom Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html) in the Amazon CloudFront Developer Guide. If you're using an Route 53 Amazon Web Services Integration alias resource record set to route traffic to your CloudFront distribution, you need to create a second alias resource record set when both of the following are true:
        ///
        /// * You enable IPv6 for the distribution
        ///
        /// * You're using alternate domain names in the URLs for your objects
        ///
        ///
        /// For more information, see [Routing Traffic to an Amazon CloudFront Web Distribution by Using Your Domain Name](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-cloudfront-distribution.html) in the Route 53 Amazon Web Services Integration Developer Guide. If you created a CNAME resource record set, either with Route 53 Amazon Web Services Integration or with another DNS service, you don't need to make any changes. A CNAME record will route traffic to your distribution regardless of the IP address format of the viewer request.
        public var isIPV6Enabled: Swift.Bool?
        /// A complex type that controls whether access logs are written for the distribution. For more information about logging, see [Access Logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/AccessLogs.html) in the Amazon CloudFront Developer Guide.
        public var logging: CloudFrontClientTypes.LoggingConfig?
        /// A complex type that contains information about origin groups for this distribution.
        public var originGroups: CloudFrontClientTypes.OriginGroups?
        /// A complex type that contains information about origins for this distribution.
        /// This member is required.
        public var origins: CloudFrontClientTypes.Origins?
        /// The price class that corresponds with the maximum price that you want to pay for CloudFront service. If you specify PriceClass_All, CloudFront responds to requests for your objects from all CloudFront edge locations. If you specify a price class other than PriceClass_All, CloudFront serves your objects from the CloudFront edge location that has the lowest latency among the edge locations in your price class. Viewers who are in or near regions that are excluded from your specified price class may encounter slower performance. For more information about price classes, see [Choosing the Price Class for a CloudFront Distribution](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PriceClass.html) in the Amazon CloudFront Developer Guide. For information about CloudFront pricing, including how price classes (such as Price Class 100) map to CloudFront regions, see [Amazon CloudFront Pricing](http://aws.amazon.com/cloudfront/pricing/).
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that identifies ways in which you want to restrict distribution of your content.
        public var restrictions: CloudFrontClientTypes.Restrictions?
        /// A complex type that determines the distribution’s SSL/TLS configuration for communicating with viewers.
        public var viewerCertificate: CloudFrontClientTypes.ViewerCertificate?
        /// A unique identifier that specifies the WAF web ACL, if any, to associate with this distribution. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a. To specify a web ACL created using WAF Classic, use the ACL ID, for example 473e64fd-f30b-4765-81a0-62ad96dd167a. WAF is a web application firewall that lets you monitor the HTTP and HTTPS requests that are forwarded to CloudFront, and lets you control access to your content. Based on conditions that you specify, such as the IP addresses that requests originate from or the values of query strings, CloudFront responds to requests either with the requested content or with an HTTP 403 status code (Forbidden). You can also configure CloudFront to return a custom error page when a request is blocked. For more information about WAF, see the [WAF Developer Guide](https://docs.aws.amazon.com/waf/latest/developerguide/what-is-aws-waf.html).
        public var webACLId: Swift.String?

        public init (
            aliases: CloudFrontClientTypes.Aliases? = nil,
            cacheBehaviors: CloudFrontClientTypes.CacheBehaviors? = nil,
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            customErrorResponses: CloudFrontClientTypes.CustomErrorResponses? = nil,
            defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior? = nil,
            defaultRootObject: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            httpVersion: CloudFrontClientTypes.HttpVersion? = nil,
            isIPV6Enabled: Swift.Bool? = nil,
            logging: CloudFrontClientTypes.LoggingConfig? = nil,
            originGroups: CloudFrontClientTypes.OriginGroups? = nil,
            origins: CloudFrontClientTypes.Origins? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            restrictions: CloudFrontClientTypes.Restrictions? = nil,
            viewerCertificate: CloudFrontClientTypes.ViewerCertificate? = nil,
            webACLId: Swift.String? = nil
        )
        {
            self.aliases = aliases
            self.cacheBehaviors = cacheBehaviors
            self.callerReference = callerReference
            self.comment = comment
            self.customErrorResponses = customErrorResponses
            self.defaultCacheBehavior = defaultCacheBehavior
            self.defaultRootObject = defaultRootObject
            self.enabled = enabled
            self.httpVersion = httpVersion
            self.isIPV6Enabled = isIPV6Enabled
            self.logging = logging
            self.originGroups = originGroups
            self.origins = origins
            self.priceClass = priceClass
            self.restrictions = restrictions
            self.viewerCertificate = viewerCertificate
            self.webACLId = webACLId
        }
    }

}

extension CloudFrontClientTypes.DistributionConfigWithTags: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
        if let tags = tags {
            try container.encode(tags, forKey: ClientRuntime.Key("Tags"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension CloudFrontClientTypes.DistributionConfigWithTags: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A distribution Configuration and a list of tags to be associated with the distribution.
    public struct DistributionConfigWithTags: Swift.Equatable {
        /// A distribution configuration.
        /// This member is required.
        public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
        /// A complex type that contains zero or more Tag elements.
        /// This member is required.
        public var tags: CloudFrontClientTypes.Tags?

        public init (
            distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
            tags: CloudFrontClientTypes.Tags? = nil
        )
        {
            self.distributionConfig = distributionConfig
            self.tags = tags
        }
    }

}

extension CloudFrontClientTypes.DistributionIdList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("DistributionId"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct DistributionId{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DistributionId>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.DistributionIdList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of distribution IDs.
    public struct DistributionIdList: Swift.Equatable {
        /// A flag that indicates whether more distribution IDs remain to be listed. If your results were truncated, you can make a subsequent request using the Marker request field to retrieve more distribution IDs in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// Contains the distribution IDs in the list.
        public var items: [Swift.String]?
        /// The value provided in the Marker request field.
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of distribution IDs requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// Contains the value that you should use in the Marker field of a subsequent request to continue listing distribution IDs where you left off.
        public var nextMarker: Swift.String?
        /// The total number of distribution IDs returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.DistributionList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for distributionsummary0 in items {
                try itemsContainer.encode(distributionsummary0, forKey: ClientRuntime.Key("DistributionSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct DistributionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DistributionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.DistributionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.DistributionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.DistributionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.DistributionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A distribution list.
    public struct DistributionList: Swift.Equatable {
        /// A flag that indicates whether more distributions remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more distributions in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one DistributionSummary element for each distribution that was created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.DistributionSummary]?
        /// The value you provided for the Marker request parameter.
        /// This member is required.
        public var marker: Swift.String?
        /// The value you provided for the MaxItems request parameter.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your distributions where they left off.
        public var nextMarker: Swift.String?
        /// The number of distributions that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.DistributionSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension DistributionNotDisabled {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DistributionNotDisabledBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.
public struct DistributionNotDisabled: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DistributionNotDisabledBody: Swift.Equatable {
    let message: Swift.String?
}

extension DistributionNotDisabledBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.DistributionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case aliasICPRecordals = "AliasICPRecordals"
        case aliases = "Aliases"
        case cacheBehaviors = "CacheBehaviors"
        case comment = "Comment"
        case customErrorResponses = "CustomErrorResponses"
        case defaultCacheBehavior = "DefaultCacheBehavior"
        case domainName = "DomainName"
        case enabled = "Enabled"
        case httpVersion = "HttpVersion"
        case id = "Id"
        case isIPV6Enabled = "IsIPV6Enabled"
        case lastModifiedTime = "LastModifiedTime"
        case originGroups = "OriginGroups"
        case origins = "Origins"
        case priceClass = "PriceClass"
        case restrictions = "Restrictions"
        case status = "Status"
        case viewerCertificate = "ViewerCertificate"
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let aliasICPRecordals = aliasICPRecordals {
            var aliasICPRecordalsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AliasICPRecordals"))
            for aliasicprecordal0 in aliasICPRecordals {
                try aliasICPRecordalsContainer.encode(aliasicprecordal0, forKey: ClientRuntime.Key("AliasICPRecordal"))
            }
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let cacheBehaviors = cacheBehaviors {
            try container.encode(cacheBehaviors, forKey: ClientRuntime.Key("CacheBehaviors"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let customErrorResponses = customErrorResponses {
            try container.encode(customErrorResponses, forKey: ClientRuntime.Key("CustomErrorResponses"))
        }
        if let defaultCacheBehavior = defaultCacheBehavior {
            try container.encode(defaultCacheBehavior, forKey: ClientRuntime.Key("DefaultCacheBehavior"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let httpVersion = httpVersion {
            try container.encode(httpVersion, forKey: ClientRuntime.Key("HttpVersion"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let isIPV6Enabled = isIPV6Enabled {
            try container.encode(isIPV6Enabled, forKey: ClientRuntime.Key("IsIPV6Enabled"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let originGroups = originGroups {
            try container.encode(originGroups, forKey: ClientRuntime.Key("OriginGroups"))
        }
        if let origins = origins {
            try container.encode(origins, forKey: ClientRuntime.Key("Origins"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let restrictions = restrictions {
            try container.encode(restrictions, forKey: ClientRuntime.Key("Restrictions"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let viewerCertificate = viewerCertificate {
            try container.encode(viewerCertificate, forKey: ClientRuntime.Key("ViewerCertificate"))
        }
        if let webACLId = webACLId {
            try container.encode(webACLId, forKey: ClientRuntime.Key("WebACLId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let originsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Origins.self, forKey: .origins)
        origins = originsDecoded
        let originGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroups.self, forKey: .originGroups)
        originGroups = originGroupsDecoded
        let defaultCacheBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DefaultCacheBehavior.self, forKey: .defaultCacheBehavior)
        defaultCacheBehavior = defaultCacheBehaviorDecoded
        let cacheBehaviorsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CacheBehaviors.self, forKey: .cacheBehaviors)
        cacheBehaviors = cacheBehaviorsDecoded
        let customErrorResponsesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomErrorResponses.self, forKey: .customErrorResponses)
        customErrorResponses = customErrorResponsesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let viewerCertificateDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerCertificate.self, forKey: .viewerCertificate)
        viewerCertificate = viewerCertificateDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Restrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
        let webACLIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let httpVersionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.HttpVersion.self, forKey: .httpVersion)
        httpVersion = httpVersionDecoded
        let isIPV6EnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isIPV6Enabled)
        isIPV6Enabled = isIPV6EnabledDecoded
        if containerValues.contains(.aliasICPRecordals) {
            struct KeyVal0{struct AliasICPRecordal{}}
            let aliasICPRecordalsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AliasICPRecordal>.CodingKeys.self, forKey: .aliasICPRecordals)
            if let aliasICPRecordalsWrappedContainer = aliasICPRecordalsWrappedContainer {
                let aliasICPRecordalsContainer = try aliasICPRecordalsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.AliasICPRecordal].self, forKey: .member)
                var aliasICPRecordalsBuffer:[CloudFrontClientTypes.AliasICPRecordal]? = nil
                if let aliasICPRecordalsContainer = aliasICPRecordalsContainer {
                    aliasICPRecordalsBuffer = [CloudFrontClientTypes.AliasICPRecordal]()
                    for structureContainer0 in aliasICPRecordalsContainer {
                        aliasICPRecordalsBuffer?.append(structureContainer0)
                    }
                }
                aliasICPRecordals = aliasICPRecordalsBuffer
            } else {
                aliasICPRecordals = []
            }
        } else {
            aliasICPRecordals = nil
        }
    }
}

extension CloudFrontClientTypes.DistributionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A summary of the information about a CloudFront distribution.
    public struct DistributionSummary: Swift.Equatable {
        /// The ARN (Amazon Resource Name) for the distribution. For example: arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5, where 123456789012 is your Amazon Web Services account ID.
        /// This member is required.
        public var aRN: Swift.String?
        /// Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions. For more information about ICP recordals, see [ Signup, Accounts, and Credentials](https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html) in Getting Started with Amazon Web Services services in China.
        public var aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]?
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
        /// This member is required.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// A complex type that contains zero or more CacheBehavior elements.
        /// This member is required.
        public var cacheBehaviors: CloudFrontClientTypes.CacheBehaviors?
        /// The comment originally specified when this distribution was created.
        /// This member is required.
        public var comment: Swift.String?
        /// A complex type that contains zero or more CustomErrorResponses elements.
        /// This member is required.
        public var customErrorResponses: CloudFrontClientTypes.CustomErrorResponses?
        /// A complex type that describes the default cache behavior if you don't specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.
        /// This member is required.
        public var defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior?
        /// The domain name that corresponds to the distribution, for example, d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// Whether the distribution is enabled to accept user requests for content.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Specify the maximum HTTP version that you want viewers to use to communicate with CloudFront. The default value for new web distributions is http2. Viewers that don't support HTTP/2 will automatically use an earlier version.
        /// This member is required.
        public var httpVersion: CloudFrontClientTypes.HttpVersion?
        /// The identifier for the distribution. For example: EDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// Whether CloudFront responds to IPv6 DNS requests with an IPv6 address for your distribution.
        /// This member is required.
        public var isIPV6Enabled: Swift.Bool?
        /// The date and time the distribution was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A complex type that contains information about origin groups for this distribution.
        public var originGroups: CloudFrontClientTypes.OriginGroups?
        /// A complex type that contains information about origins for this distribution.
        /// This member is required.
        public var origins: CloudFrontClientTypes.Origins?
        /// A complex type that contains information about price class for this streaming distribution.
        /// This member is required.
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that identifies ways in which you want to restrict distribution of your content.
        /// This member is required.
        public var restrictions: CloudFrontClientTypes.Restrictions?
        /// The current status of the distribution. When the status is Deployed, the distribution's information is propagated to all CloudFront edge locations.
        /// This member is required.
        public var status: Swift.String?
        /// A complex type that determines the distribution’s SSL/TLS configuration for communicating with viewers.
        /// This member is required.
        public var viewerCertificate: CloudFrontClientTypes.ViewerCertificate?
        /// The Web ACL Id (if any) associated with the distribution.
        /// This member is required.
        public var webACLId: Swift.String?

        public init (
            aRN: Swift.String? = nil,
            aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]? = nil,
            aliases: CloudFrontClientTypes.Aliases? = nil,
            cacheBehaviors: CloudFrontClientTypes.CacheBehaviors? = nil,
            comment: Swift.String? = nil,
            customErrorResponses: CloudFrontClientTypes.CustomErrorResponses? = nil,
            defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior? = nil,
            domainName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            httpVersion: CloudFrontClientTypes.HttpVersion? = nil,
            id: Swift.String? = nil,
            isIPV6Enabled: Swift.Bool? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            originGroups: CloudFrontClientTypes.OriginGroups? = nil,
            origins: CloudFrontClientTypes.Origins? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            restrictions: CloudFrontClientTypes.Restrictions? = nil,
            status: Swift.String? = nil,
            viewerCertificate: CloudFrontClientTypes.ViewerCertificate? = nil,
            webACLId: Swift.String? = nil
        )
        {
            self.aRN = aRN
            self.aliasICPRecordals = aliasICPRecordals
            self.aliases = aliases
            self.cacheBehaviors = cacheBehaviors
            self.comment = comment
            self.customErrorResponses = customErrorResponses
            self.defaultCacheBehavior = defaultCacheBehavior
            self.domainName = domainName
            self.enabled = enabled
            self.httpVersion = httpVersion
            self.id = id
            self.isIPV6Enabled = isIPV6Enabled
            self.lastModifiedTime = lastModifiedTime
            self.originGroups = originGroups
            self.origins = origins
            self.priceClass = priceClass
            self.restrictions = restrictions
            self.status = status
            self.viewerCertificate = viewerCertificate
            self.webACLId = webACLId
        }
    }

}

extension CloudFrontClientTypes.EncryptionEntities: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for encryptionentity0 in items {
                try itemsContainer.encode(encryptionentity0, forKey: ClientRuntime.Key("EncryptionEntity"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct EncryptionEntity{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EncryptionEntity>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EncryptionEntity].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.EncryptionEntity]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.EncryptionEntity]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.EncryptionEntities: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Complex data type for field-level encryption profiles that includes all of the encryption entities.
    public struct EncryptionEntities: Swift.Equatable {
        /// An array of field patterns in a field-level encryption content type-profile mapping.
        public var items: [CloudFrontClientTypes.EncryptionEntity]?
        /// Number of field pattern items in a field-level encryption content type-profile mapping.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.EncryptionEntity]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.EncryptionEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldPatterns = "FieldPatterns"
        case providerId = "ProviderId"
        case publicKeyId = "PublicKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldPatterns = fieldPatterns {
            try container.encode(fieldPatterns, forKey: ClientRuntime.Key("FieldPatterns"))
        }
        if let providerId = providerId {
            try container.encode(providerId, forKey: ClientRuntime.Key("ProviderId"))
        }
        if let publicKeyId = publicKeyId {
            try container.encode(publicKeyId, forKey: ClientRuntime.Key("PublicKeyId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicKeyId)
        publicKeyId = publicKeyIdDecoded
        let providerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerId)
        providerId = providerIdDecoded
        let fieldPatternsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldPatterns.self, forKey: .fieldPatterns)
        fieldPatterns = fieldPatternsDecoded
    }
}

extension CloudFrontClientTypes.EncryptionEntity: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Complex data type for field-level encryption profiles that includes the encryption key and field pattern specifications.
    public struct EncryptionEntity: Swift.Equatable {
        /// Field patterns in a field-level encryption content type profile specify the fields that you want to be encrypted. You can provide the full field name, or any beginning characters followed by a wildcard (*). You can't overlap field patterns. For example, you can't have both ABC* and AB*. Note that field patterns are case-sensitive.
        /// This member is required.
        public var fieldPatterns: CloudFrontClientTypes.FieldPatterns?
        /// The provider associated with the public key being used for encryption. This value must also be provided with the private key for applications to be able to decrypt data.
        /// This member is required.
        public var providerId: Swift.String?
        /// The public key associated with a set of field-level encryption patterns, to be used when encrypting the fields that match the patterns.
        /// This member is required.
        public var publicKeyId: Swift.String?

        public init (
            fieldPatterns: CloudFrontClientTypes.FieldPatterns? = nil,
            providerId: Swift.String? = nil,
            publicKeyId: Swift.String? = nil
        )
        {
            self.fieldPatterns = fieldPatterns
            self.providerId = providerId
            self.publicKeyId = publicKeyId
        }
    }

}

extension CloudFrontClientTypes.EndPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kinesisStreamConfig = "KinesisStreamConfig"
        case streamType = "StreamType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let kinesisStreamConfig = kinesisStreamConfig {
            try container.encode(kinesisStreamConfig, forKey: ClientRuntime.Key("KinesisStreamConfig"))
        }
        if let streamType = streamType {
            try container.encode(streamType, forKey: ClientRuntime.Key("StreamType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamType)
        streamType = streamTypeDecoded
        let kinesisStreamConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KinesisStreamConfig.self, forKey: .kinesisStreamConfig)
        kinesisStreamConfig = kinesisStreamConfigDecoded
    }
}

extension CloudFrontClientTypes.EndPoint: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data in a real-time log configuration.
    public struct EndPoint: Swift.Equatable {
        /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
        public var kinesisStreamConfig: CloudFrontClientTypes.KinesisStreamConfig?
        /// The type of data stream where you are sending real-time log data. The only valid value is Kinesis.
        /// This member is required.
        public var streamType: Swift.String?

        public init (
            kinesisStreamConfig: CloudFrontClientTypes.KinesisStreamConfig? = nil,
            streamType: Swift.String? = nil
        )
        {
            self.kinesisStreamConfig = kinesisStreamConfig
            self.streamType = streamType
        }
    }

}

extension CloudFrontClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case originRequest
        case originResponse
        case viewerRequest
        case viewerResponse
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .originRequest,
                .originResponse,
                .viewerRequest,
                .viewerResponse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .originRequest: return "origin-request"
            case .originResponse: return "origin-response"
            case .viewerRequest: return "viewer-request"
            case .viewerResponse: return "viewer-response"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.FieldLevelEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionConfig = fieldLevelEncryptionConfig {
            try container.encode(fieldLevelEncryptionConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryption: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes the profile configurations and other options specified for field-level encryption.
    public struct FieldLevelEncryption: Swift.Equatable {
        /// A complex data type that includes the profile configurations specified for field-level encryption.
        /// This member is required.
        public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
        /// The configuration ID for a field-level encryption configuration which includes a set of profiles that specify certain selected data fields to be encrypted by specific public keys.
        /// This member is required.
        public var id: Swift.String?
        /// The last time the field-level encryption configuration was changed.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init (
            fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension CloudFrontClientTypes.FieldLevelEncryptionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
        case contentTypeProfileConfig = "ContentTypeProfileConfig"
        case queryArgProfileConfig = "QueryArgProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let contentTypeProfileConfig = contentTypeProfileConfig {
            try container.encode(contentTypeProfileConfig, forKey: ClientRuntime.Key("ContentTypeProfileConfig"))
        }
        if let queryArgProfileConfig = queryArgProfileConfig {
            try container.encode(queryArgProfileConfig, forKey: ClientRuntime.Key("QueryArgProfileConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let queryArgProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryArgProfileConfig.self, forKey: .queryArgProfileConfig)
        queryArgProfileConfig = queryArgProfileConfigDecoded
        let contentTypeProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContentTypeProfileConfig.self, forKey: .contentTypeProfileConfig)
        contentTypeProfileConfig = contentTypeProfileConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes the profile configurations specified for field-level encryption.
    public struct FieldLevelEncryptionConfig: Swift.Equatable {
        /// A unique number that ensures the request can't be replayed.
        /// This member is required.
        public var callerReference: Swift.String?
        /// An optional comment about the configuration. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A complex data type that specifies when to forward content if a content type isn't recognized and profiles to use as by default in a request if a query argument doesn't specify a profile to use.
        public var contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig?
        /// A complex data type that specifies when to forward content if a profile isn't found and the profile that can be provided as a query argument in a request.
        public var queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig?

        public init (
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig? = nil,
            queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.contentTypeProfileConfig = contentTypeProfileConfig
            self.queryArgProfileConfig = queryArgProfileConfig
        }
    }

}

extension FieldLevelEncryptionConfigAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FieldLevelEncryptionConfigAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified configuration for field-level encryption already exists.
public struct FieldLevelEncryptionConfigAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionConfigAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension FieldLevelEncryptionConfigAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FieldLevelEncryptionConfigInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FieldLevelEncryptionConfigInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified configuration for field-level encryption is in use.
public struct FieldLevelEncryptionConfigInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionConfigInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension FieldLevelEncryptionConfigInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for fieldlevelencryptionsummary0 in items {
                try itemsContainer.encode(fieldlevelencryptionsummary0, forKey: ClientRuntime.Key("FieldLevelEncryptionSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FieldLevelEncryptionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FieldLevelEncryptionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FieldLevelEncryptionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FieldLevelEncryptionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FieldLevelEncryptionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// List of field-level encrpytion configurations.
    public struct FieldLevelEncryptionList: Swift.Equatable {
        /// An array of field-level encryption items.
        public var items: [CloudFrontClientTypes.FieldLevelEncryptionSummary]?
        /// The maximum number of elements you want in the response body.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more elements to be listed, this element is present and contains the value that you can use for the Marker request parameter to continue listing your configurations where you left off.
        public var nextMarker: Swift.String?
        /// The number of field-level encryption items.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.FieldLevelEncryptionSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.FieldLevelEncryptionProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig {
            try container.encode(fieldLevelEncryptionProfileConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfile: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for field-level encryption profiles.
    public struct FieldLevelEncryptionProfile: Swift.Equatable {
        /// A complex data type that includes the profile name and the encryption entities for the field-level encryption profile.
        /// This member is required.
        public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
        /// The ID for a field-level encryption profile configuration which includes a set of profiles that specify certain selected data fields to be encrypted by specific public keys.
        /// This member is required.
        public var id: Swift.String?
        /// The last time the field-level encryption profile was updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init (
            fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension FieldLevelEncryptionProfileAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FieldLevelEncryptionProfileAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified profile for field-level encryption already exists.
public struct FieldLevelEncryptionProfileAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionProfileAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension FieldLevelEncryptionProfileAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
        case encryptionEntities = "EncryptionEntities"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let encryptionEntities = encryptionEntities {
            try container.encode(encryptionEntities, forKey: ClientRuntime.Key("EncryptionEntities"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let encryptionEntitiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EncryptionEntities.self, forKey: .encryptionEntities)
        encryptionEntities = encryptionEntitiesDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type of profiles for the field-level encryption.
    public struct FieldLevelEncryptionProfileConfig: Swift.Equatable {
        /// A unique number that ensures that the request can't be replayed.
        /// This member is required.
        public var callerReference: Swift.String?
        /// An optional comment for the field-level encryption profile. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and field patterns for specifying which fields to encrypt with this key.
        /// This member is required.
        public var encryptionEntities: CloudFrontClientTypes.EncryptionEntities?
        /// Profile name for the field-level encryption profile.
        /// This member is required.
        public var name: Swift.String?

        public init (
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            encryptionEntities: CloudFrontClientTypes.EncryptionEntities? = nil,
            name: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.encryptionEntities = encryptionEntities
            self.name = name
        }
    }

}

extension FieldLevelEncryptionProfileInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FieldLevelEncryptionProfileInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified profile for field-level encryption is in use.
public struct FieldLevelEncryptionProfileInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionProfileInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension FieldLevelEncryptionProfileInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for fieldlevelencryptionprofilesummary0 in items {
                try itemsContainer.encode(fieldlevelencryptionprofilesummary0, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FieldLevelEncryptionProfileSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FieldLevelEncryptionProfileSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FieldLevelEncryptionProfileSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// List of field-level encryption profiles.
    public struct FieldLevelEncryptionProfileList: Swift.Equatable {
        /// The field-level encryption profile items.
        public var items: [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]?
        /// The maximum number of field-level encryption profiles you want in the response body.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more elements to be listed, this element is present and contains the value that you can use for the Marker request parameter to continue listing your profiles where you left off.
        public var nextMarker: Swift.String?
        /// The number of field-level encryption profiles.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension FieldLevelEncryptionProfileSizeExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FieldLevelEncryptionProfileSizeExceededBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum size of a profile for field-level encryption was exceeded.
public struct FieldLevelEncryptionProfileSizeExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionProfileSizeExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension FieldLevelEncryptionProfileSizeExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case encryptionEntities = "EncryptionEntities"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let encryptionEntities = encryptionEntities {
            try container.encode(encryptionEntities, forKey: ClientRuntime.Key("EncryptionEntities"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let encryptionEntitiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EncryptionEntities.self, forKey: .encryptionEntities)
        encryptionEntities = encryptionEntitiesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The field-level encryption profile summary.
    public struct FieldLevelEncryptionProfileSummary: Swift.Equatable {
        /// An optional comment for the field-level encryption profile summary. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and field patterns for specifying which fields to encrypt with this key.
        /// This member is required.
        public var encryptionEntities: CloudFrontClientTypes.EncryptionEntities?
        /// ID for the field-level encryption profile summary.
        /// This member is required.
        public var id: Swift.String?
        /// The time when the the field-level encryption profile summary was last updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// Name for the field-level encryption profile summary.
        /// This member is required.
        public var name: Swift.String?

        public init (
            comment: Swift.String? = nil,
            encryptionEntities: CloudFrontClientTypes.EncryptionEntities? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.encryptionEntities = encryptionEntities
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

extension CloudFrontClientTypes.FieldLevelEncryptionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case contentTypeProfileConfig = "ContentTypeProfileConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case queryArgProfileConfig = "QueryArgProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let contentTypeProfileConfig = contentTypeProfileConfig {
            try container.encode(contentTypeProfileConfig, forKey: ClientRuntime.Key("ContentTypeProfileConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let queryArgProfileConfig = queryArgProfileConfig {
            try container.encode(queryArgProfileConfig, forKey: ClientRuntime.Key("QueryArgProfileConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let queryArgProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryArgProfileConfig.self, forKey: .queryArgProfileConfig)
        queryArgProfileConfig = queryArgProfileConfigDecoded
        let contentTypeProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContentTypeProfileConfig.self, forKey: .contentTypeProfileConfig)
        contentTypeProfileConfig = contentTypeProfileConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A summary of a field-level encryption item.
    public struct FieldLevelEncryptionSummary: Swift.Equatable {
        /// An optional comment about the field-level encryption item. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A summary of a content type-profile mapping.
        public var contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig?
        /// The unique ID of a field-level encryption item.
        /// This member is required.
        public var id: Swift.String?
        /// The last time that the summary of field-level encryption items was modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A summary of a query argument-profile mapping.
        public var queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig?

        public init (
            comment: Swift.String? = nil,
            contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig? = nil
        )
        {
            self.comment = comment
            self.contentTypeProfileConfig = contentTypeProfileConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.queryArgProfileConfig = queryArgProfileConfig
        }
    }

}

extension CloudFrontClientTypes.FieldPatterns: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("FieldPattern"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FieldPattern{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FieldPattern>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FieldPatterns: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes the field patterns to match for field-level encryption.
    public struct FieldPatterns: Swift.Equatable {
        /// An array of the field-level encryption field patterns.
        public var items: [Swift.String]?
        /// The number of field-level encryption field patterns.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case urlencoded
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .urlencoded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .urlencoded: return "URLEncoded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.ForwardedValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookies = "Cookies"
        case headers = "Headers"
        case queryString = "QueryString"
        case queryStringCacheKeys = "QueryStringCacheKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookies = cookies {
            try container.encode(cookies, forKey: ClientRuntime.Key("Cookies"))
        }
        if let headers = headers {
            try container.encode(headers, forKey: ClientRuntime.Key("Headers"))
        }
        if let queryString = queryString {
            try container.encode(queryString, forKey: ClientRuntime.Key("QueryString"))
        }
        if let queryStringCacheKeys = queryStringCacheKeys {
            try container.encode(queryStringCacheKeys, forKey: ClientRuntime.Key("QueryStringCacheKeys"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .queryString)
        queryString = queryStringDecoded
        let cookiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookiePreference.self, forKey: .cookies)
        cookies = cookiesDecoded
        let headersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Headers.self, forKey: .headers)
        headers = headersDecoded
        let queryStringCacheKeysDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryStringCacheKeys.self, forKey: .queryStringCacheKeys)
        queryStringCacheKeys = queryStringCacheKeysDecoded
    }
}

extension CloudFrontClientTypes.ForwardedValues: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
    public struct ForwardedValues: Swift.Equatable {
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that specifies whether you want CloudFront to forward cookies to the origin and, if so, which ones. For more information about forwarding cookies to the origin, see [How CloudFront Forwards, Caches, and Logs Cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var cookies: CloudFrontClientTypes.CookiePreference?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include headers in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send headers to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that specifies the Headers, if any, that you want CloudFront to forward to the origin for this cache behavior (whitelisted headers). For the headers that you specify, CloudFront also caches separate versions of a specified object that is based on the header values in viewer requests. For more information, see [ Caching Content Based on Request Headers](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html) in the Amazon CloudFront Developer Guide.
        public var headers: CloudFrontClientTypes.Headers?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send query strings to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior and cache based on the query string parameters. CloudFront behavior depends on the value of QueryString and on the values that you specify for QueryStringCacheKeys, if any: If you specify true for QueryString and you don't specify any values for QueryStringCacheKeys, CloudFront forwards all query string parameters to the origin and caches based on all query string parameters. Depending on how many query string parameters and values you have, this can adversely affect performance because CloudFront must forward more requests to the origin. If you specify true for QueryString and you specify one or more values for QueryStringCacheKeys, CloudFront forwards all query string parameters to the origin, but it only caches based on the query string parameters that you specify. If you specify false for QueryString, CloudFront doesn't forward any query string parameters to the origin, and doesn't cache based on query string parameters. For more information, see [Configuring CloudFront to Cache Based on Query String Parameters](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/QueryStringParameters.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var queryString: Swift.Bool?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send query strings to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that contains information about the query string parameters that you want CloudFront to use for caching for this cache behavior.
        public var queryStringCacheKeys: CloudFrontClientTypes.QueryStringCacheKeys?

        public init (
            cookies: CloudFrontClientTypes.CookiePreference? = nil,
            headers: CloudFrontClientTypes.Headers? = nil,
            queryString: Swift.Bool? = nil,
            queryStringCacheKeys: CloudFrontClientTypes.QueryStringCacheKeys? = nil
        )
        {
            self.cookies = cookies
            self.headers = headers
            self.queryString = queryString
            self.queryStringCacheKeys = queryStringCacheKeys
        }
    }

}

extension CloudFrontClientTypes {
    public enum FrameOptionsList: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deny
        case sameorigin
        case sdkUnknown(Swift.String)

        public static var allCases: [FrameOptionsList] {
            return [
                .deny,
                .sameorigin,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deny: return "DENY"
            case .sameorigin: return "SAMEORIGIN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FrameOptionsList(rawValue: rawValue) ?? FrameOptionsList.sdkUnknown(rawValue)
        }
    }
}

extension FunctionAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FunctionAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A function with the same name already exists in this Amazon Web Services account. To create a function, you must provide a unique name. To update an existing function, use UpdateFunction.
public struct FunctionAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FunctionAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension FunctionAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FunctionAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType = "EventType"
        case functionARN = "FunctionARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eventType = eventType {
            try container.encode(eventType, forKey: ClientRuntime.Key("EventType"))
        }
        if let functionARN = functionARN {
            try container.encode(functionARN, forKey: ClientRuntime.Key("FunctionARN"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionARN)
        functionARN = functionARNDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
    }
}

extension CloudFrontClientTypes.FunctionAssociation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A CloudFront function that is associated with a cache behavior in a CloudFront distribution.
    public struct FunctionAssociation: Swift.Equatable {
        /// The event type of the function, either viewer-request or viewer-response. You cannot use origin-facing event types (origin-request and origin-response) with a CloudFront function.
        /// This member is required.
        public var eventType: CloudFrontClientTypes.EventType?
        /// The Amazon Resource Name (ARN) of the function.
        /// This member is required.
        public var functionARN: Swift.String?

        public init (
            eventType: CloudFrontClientTypes.EventType? = nil,
            functionARN: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.functionARN = functionARN
        }
    }

}

extension CloudFrontClientTypes.FunctionAssociations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for functionassociation0 in items {
                try itemsContainer.encode(functionassociation0, forKey: ClientRuntime.Key("FunctionAssociation"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FunctionAssociation{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FunctionAssociation>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FunctionAssociation].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FunctionAssociation]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FunctionAssociation]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FunctionAssociations: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of CloudFront functions that are associated with a cache behavior in a CloudFront distribution. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
    public struct FunctionAssociations: Swift.Equatable {
        /// The CloudFront functions that are associated with a cache behavior in a CloudFront distribution. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
        public var items: [CloudFrontClientTypes.FunctionAssociation]?
        /// The number of CloudFront functions in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.FunctionAssociation]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.FunctionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case runtime = "Runtime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let runtime = runtime {
            try container.encode(runtime, forKey: ClientRuntime.Key("Runtime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionRuntime.self, forKey: .runtime)
        runtime = runtimeDecoded
    }
}

extension CloudFrontClientTypes.FunctionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains configuration information about a CloudFront function.
    public struct FunctionConfig: Swift.Equatable {
        /// A comment to describe the function.
        /// This member is required.
        public var comment: Swift.String?
        /// The function’s runtime environment. The only valid value is cloudfront-js-1.0.
        /// This member is required.
        public var runtime: CloudFrontClientTypes.FunctionRuntime?

        public init (
            comment: Swift.String? = nil,
            runtime: CloudFrontClientTypes.FunctionRuntime? = nil
        )
        {
            self.comment = comment
            self.runtime = runtime
        }
    }

}

extension FunctionInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FunctionInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot delete the function because it’s attached to one or more cache behaviors.
public struct FunctionInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FunctionInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension FunctionInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FunctionList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for functionsummary0 in items {
                try itemsContainer.encode(functionsummary0, forKey: ClientRuntime.Key("FunctionSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FunctionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FunctionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FunctionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FunctionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FunctionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FunctionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of CloudFront functions.
    public struct FunctionList: Swift.Equatable {
        /// Contains the functions in the list.
        public var items: [CloudFrontClientTypes.FunctionSummary]?
        /// The maximum number of functions requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing functions where you left off.
        public var nextMarker: Swift.String?
        /// The number of functions returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.FunctionSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.FunctionMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case functionARN = "FunctionARN"
        case lastModifiedTime = "LastModifiedTime"
        case stage = "Stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createdTime = createdTime {
            try container.encode(ClientRuntime.TimestampWrapper(createdTime, format: .dateTime), forKey: ClientRuntime.Key("CreatedTime"))
        }
        if let functionARN = functionARN {
            try container.encode(functionARN, forKey: ClientRuntime.Key("FunctionARN"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let stage = stage {
            try container.encode(stage, forKey: ClientRuntime.Key("Stage"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionARN)
        functionARN = functionARNDecoded
        let stageDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionStage.self, forKey: .stage)
        stage = stageDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        var createdTimeBuffer:ClientRuntime.Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
    }
}

extension CloudFrontClientTypes.FunctionMetadata: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains metadata about a CloudFront function.
    public struct FunctionMetadata: Swift.Equatable {
        /// The date and time when the function was created.
        public var createdTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the function. The ARN uniquely identifies the function.
        /// This member is required.
        public var functionARN: Swift.String?
        /// The date and time when the function was most recently updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The stage that the function is in, either DEVELOPMENT or LIVE. When a function is in the DEVELOPMENT stage, you can test the function with TestFunction, and update it with UpdateFunction. When a function is in the LIVE stage, you can attach the function to a distribution’s cache behavior, using the function’s ARN.
        public var stage: CloudFrontClientTypes.FunctionStage?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            functionARN: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            stage: CloudFrontClientTypes.FunctionStage? = nil
        )
        {
            self.createdTime = createdTime
            self.functionARN = functionARN
            self.lastModifiedTime = lastModifiedTime
            self.stage = stage
        }
    }

}

extension CloudFrontClientTypes {
    public enum FunctionRuntime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudfrontJs10
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionRuntime] {
            return [
                .cloudfrontJs10,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudfrontJs10: return "cloudfront-js-1.0"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionRuntime(rawValue: rawValue) ?? FunctionRuntime.sdkUnknown(rawValue)
        }
    }
}

extension FunctionSizeLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FunctionSizeLimitExceededBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The function is too large. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct FunctionSizeLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FunctionSizeLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension FunctionSizeLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes {
    public enum FunctionStage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionStage] {
            return [
                .development,
                .live,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionStage(rawValue: rawValue) ?? FunctionStage.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.FunctionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionConfig = "FunctionConfig"
        case functionMetadata = "FunctionMetadata"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let functionConfig = functionConfig {
            try container.encode(functionConfig, forKey: ClientRuntime.Key("FunctionConfig"))
        }
        if let functionMetadata = functionMetadata {
            try container.encode(functionMetadata, forKey: ClientRuntime.Key("FunctionMetadata"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let functionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionConfig.self, forKey: .functionConfig)
        functionConfig = functionConfigDecoded
        let functionMetadataDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionMetadata.self, forKey: .functionMetadata)
        functionMetadata = functionMetadataDecoded
    }
}

extension CloudFrontClientTypes.FunctionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains configuration information and metadata about a CloudFront function.
    public struct FunctionSummary: Swift.Equatable {
        /// Contains configuration information about a CloudFront function.
        /// This member is required.
        public var functionConfig: CloudFrontClientTypes.FunctionConfig?
        /// Contains metadata about a CloudFront function.
        /// This member is required.
        public var functionMetadata: CloudFrontClientTypes.FunctionMetadata?
        /// The name of the CloudFront function.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the CloudFront function.
        public var status: Swift.String?

        public init (
            functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
            functionMetadata: CloudFrontClientTypes.FunctionMetadata? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.functionConfig = functionConfig
            self.functionMetadata = functionMetadata
            self.name = name
            self.status = status
        }
    }

}

extension CloudFrontClientTypes.GeoRestriction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
        case restrictionType = "RestrictionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Location"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
        if let restrictionType = restrictionType {
            try container.encode(restrictionType, forKey: ClientRuntime.Key("RestrictionType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restrictionTypeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.GeoRestrictionType.self, forKey: .restrictionType)
        restrictionType = restrictionTypeDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Location{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Location>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.GeoRestriction: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls the countries in which your content is distributed. CloudFront determines the location of your users using MaxMind GeoIP databases.
    public struct GeoRestriction: Swift.Equatable {
        /// A complex type that contains a Location element for each country in which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). The Location element is a two-letter, uppercase country code for a country that you want to include in your blacklist or whitelist. Include one Location element for each country. CloudFront and MaxMind both use ISO 3166 country codes. For the current list of countries and the corresponding codes, see ISO 3166-1-alpha-2 code on the International Organization for Standardization website. You can also refer to the country list on the CloudFront console, which includes both country names and codes.
        public var items: [Swift.String]?
        /// When geo restriction is enabled, this is the number of countries in your whitelist or blacklist. Otherwise, when it is not enabled, Quantity is 0, and you can omit Items.
        /// This member is required.
        public var quantity: Swift.Int?
        /// The method that you want to use to restrict distribution of your content by country:
        ///
        /// * none: No geo restriction is enabled, meaning access to content is not restricted by client geo location.
        ///
        /// * blacklist: The Location elements specify the countries in which you don't want CloudFront to distribute your content.
        ///
        /// * whitelist: The Location elements specify the countries in which you want CloudFront to distribute your content.
        /// This member is required.
        public var restrictionType: CloudFrontClientTypes.GeoRestrictionType?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil,
            restrictionType: CloudFrontClientTypes.GeoRestrictionType? = nil
        )
        {
            self.items = items
            self.quantity = quantity
            self.restrictionType = restrictionType
        }
    }

}

extension CloudFrontClientTypes {
    public enum GeoRestrictionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case blacklist
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoRestrictionType] {
            return [
                .blacklist,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .blacklist: return "blacklist"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeoRestrictionType(rawValue: rawValue) ?? GeoRestrictionType.sdkUnknown(rawValue)
        }
    }
}

extension GetCachePolicyConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())/config"
    }
}

public struct GetCachePolicyConfigInput: Swift.Equatable {
    /// The unique identifier for the cache policy. If the cache policy is attached to a distribution’s cache behavior, you can get the policy’s identifier using ListDistributions or GetDistribution. If the cache policy is not attached to a cache behavior, you can get the identifier using ListCachePolicies.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCachePolicyConfigInputBody: Swift.Equatable {
}

extension GetCachePolicyConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCachePolicyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCachePolicyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCachePolicyConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCachePolicyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CachePolicyConfig = try responseDecoder.decode(responseBody: data)
                self.cachePolicyConfig = output
            } else {
                self.cachePolicyConfig = nil
            }
        } else {
            self.cachePolicyConfig = nil
        }
    }
}

public struct GetCachePolicyConfigOutputResponse: Swift.Equatable {
    /// The cache policy configuration.
    public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
    /// The current version of the cache policy.
    public var eTag: Swift.String?

    public init (
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
        self.eTag = eTag
    }
}

struct GetCachePolicyConfigOutputResponseBody: Swift.Equatable {
    let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
}

extension GetCachePolicyConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension GetCachePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())"
    }
}

public struct GetCachePolicyInput: Swift.Equatable {
    /// The unique identifier for the cache policy. If the cache policy is attached to a distribution’s cache behavior, you can get the policy’s identifier using ListDistributions or GetDistribution. If the cache policy is not attached to a cache behavior, you can get the identifier using ListCachePolicies.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCachePolicyInputBody: Swift.Equatable {
}

extension GetCachePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCachePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCachePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCachePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCachePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CachePolicy = try responseDecoder.decode(responseBody: data)
                self.cachePolicy = output
            } else {
                self.cachePolicy = nil
            }
        } else {
            self.cachePolicy = nil
        }
    }
}

public struct GetCachePolicyOutputResponse: Swift.Equatable {
    /// The cache policy.
    public var cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// The current version of the cache policy.
    public var eTag: Swift.String?

    public init (
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
    }
}

struct GetCachePolicyOutputResponseBody: Swift.Equatable {
    let cachePolicy: CloudFrontClientTypes.CachePolicy?
}

extension GetCachePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

extension GetCloudFrontOriginAccessIdentityConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())/config"
    }
}

/// The origin access identity's configuration information. For more information, see [CloudFrontOriginAccessIdentityConfig](https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_CloudFrontOriginAccessIdentityConfig.html).
public struct GetCloudFrontOriginAccessIdentityConfigInput: Swift.Equatable {
    /// The identity's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCloudFrontOriginAccessIdentityConfigInputBody: Swift.Equatable {
}

extension GetCloudFrontOriginAccessIdentityConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCloudFrontOriginAccessIdentityConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCloudFrontOriginAccessIdentityConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCloudFrontOriginAccessIdentityConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCloudFrontOriginAccessIdentityConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig = try responseDecoder.decode(responseBody: data)
                self.cloudFrontOriginAccessIdentityConfig = output
            } else {
                self.cloudFrontOriginAccessIdentityConfig = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentityConfig = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetCloudFrontOriginAccessIdentityConfigOutputResponse: Swift.Equatable {
    /// The origin access identity's configuration information.
    public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init (
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
        self.eTag = eTag
    }
}

struct GetCloudFrontOriginAccessIdentityConfigOutputResponseBody: Swift.Equatable {
    let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
}

extension GetCloudFrontOriginAccessIdentityConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension GetCloudFrontOriginAccessIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())"
    }
}

/// The request to get an origin access identity's information.
public struct GetCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The identity's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
}

extension GetCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCloudFrontOriginAccessIdentityOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCloudFrontOriginAccessIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentity = try responseDecoder.decode(responseBody: data)
                self.cloudFrontOriginAccessIdentity = output
            } else {
                self.cloudFrontOriginAccessIdentity = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentity = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetCloudFrontOriginAccessIdentityOutputResponse: Swift.Equatable {
    /// The origin access identity's information.
    public var cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// The current version of the origin access identity's information. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init (
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
    }
}

struct GetCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Equatable {
    let cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
}

extension GetCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentity = "CloudFrontOriginAccessIdentity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentity.self, forKey: .cloudFrontOriginAccessIdentity)
        cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentityDecoded
    }
}

extension GetDistributionConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())/config"
    }
}

/// The request to get a distribution configuration.
public struct GetDistributionConfigInput: Swift.Equatable {
    /// The distribution's ID. If the ID is empty, an empty distribution configuration is returned.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetDistributionConfigInputBody: Swift.Equatable {
}

extension GetDistributionConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDistributionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetDistributionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDistributionConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDistributionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionConfig = try responseDecoder.decode(responseBody: data)
                self.distributionConfig = output
            } else {
                self.distributionConfig = nil
            }
        } else {
            self.distributionConfig = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetDistributionConfigOutputResponse: Swift.Equatable {
    /// The distribution's configuration information.
    public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init (
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distributionConfig = distributionConfig
        self.eTag = eTag
    }
}

struct GetDistributionConfigOutputResponseBody: Swift.Equatable {
    let distributionConfig: CloudFrontClientTypes.DistributionConfig?
}

extension GetDistributionConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
    }
}

extension GetDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())"
    }
}

/// The request to get a distribution's information.
public struct GetDistributionInput: Swift.Equatable {
    /// The distribution's ID. If the ID is empty, an empty distribution configuration is returned.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetDistributionInputBody: Swift.Equatable {
}

extension GetDistributionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetDistributionOutputResponse: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the distribution's information. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init (
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

struct GetDistributionOutputResponseBody: Swift.Equatable {
    let distribution: CloudFrontClientTypes.Distribution?
}

extension GetDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

extension GetFieldLevelEncryptionConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())/config"
    }
}

public struct GetFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// Request the ID for the field-level encryption configuration information.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionConfigInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionConfig = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionConfig = output
            } else {
                self.fieldLevelEncryptionConfig = nil
            }
        } else {
            self.fieldLevelEncryptionConfig = nil
        }
    }
}

public struct GetFieldLevelEncryptionConfigOutputResponse: Swift.Equatable {
    /// The current version of the field level encryption configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption configuration information.
    public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
    }
}

struct GetFieldLevelEncryptionConfigOutputResponseBody: Swift.Equatable {
    let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
}

extension GetFieldLevelEncryptionConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension GetFieldLevelEncryptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())"
    }
}

public struct GetFieldLevelEncryptionInput: Swift.Equatable {
    /// Request the ID for the field-level encryption configuration information.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryption = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryption = output
            } else {
                self.fieldLevelEncryption = nil
            }
        } else {
            self.fieldLevelEncryption = nil
        }
    }
}

public struct GetFieldLevelEncryptionOutputResponse: Swift.Equatable {
    /// The current version of the field level encryption configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption configuration information.
    public var fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
    }
}

struct GetFieldLevelEncryptionOutputResponseBody: Swift.Equatable {
    let fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
}

extension GetFieldLevelEncryptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryption = "FieldLevelEncryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryption.self, forKey: .fieldLevelEncryption)
        fieldLevelEncryption = fieldLevelEncryptionDecoded
    }
}

extension GetFieldLevelEncryptionProfileConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())/config"
    }
}

public struct GetFieldLevelEncryptionProfileConfigInput: Swift.Equatable {
    /// Get the ID for the field-level encryption profile configuration information.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionProfileConfigInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionProfileConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionProfileConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionProfileConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionProfileConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionProfileConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionProfileConfig = output
            } else {
                self.fieldLevelEncryptionProfileConfig = nil
            }
        } else {
            self.fieldLevelEncryptionProfileConfig = nil
        }
    }
}

public struct GetFieldLevelEncryptionProfileConfigOutputResponse: Swift.Equatable {
    /// The current version of the field-level encryption profile configuration result. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption profile configuration information.
    public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
    }
}

struct GetFieldLevelEncryptionProfileConfigOutputResponseBody: Swift.Equatable {
    let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
}

extension GetFieldLevelEncryptionProfileConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension GetFieldLevelEncryptionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())"
    }
}

public struct GetFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// Get the ID for the field-level encryption profile information.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionProfileInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionProfile = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionProfile = output
            } else {
                self.fieldLevelEncryptionProfile = nil
            }
        } else {
            self.fieldLevelEncryptionProfile = nil
        }
    }
}

public struct GetFieldLevelEncryptionProfileOutputResponse: Swift.Equatable {
    /// The current version of the field level encryption profile. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption profile information.
    public var fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
    }
}

struct GetFieldLevelEncryptionProfileOutputResponseBody: Swift.Equatable {
    let fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
}

extension GetFieldLevelEncryptionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfile = "FieldLevelEncryptionProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfile.self, forKey: .fieldLevelEncryptionProfile)
        fieldLevelEncryptionProfile = fieldLevelEncryptionProfileDecoded
    }
}

extension GetFunctionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let stage = stage {
            let stageQueryItem = ClientRuntime.URLQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
            items.append(stageQueryItem)
        }
        return items
    }
}

extension GetFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())"
    }
}

public struct GetFunctionInput: Swift.Equatable {
    /// The name of the function whose code you are getting.
    /// This member is required.
    public var name: Swift.String?
    /// The function’s stage, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init (
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.name = name
        self.stage = stage
    }
}

struct GetFunctionInputBody: Swift.Equatable {
}

extension GetFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionOutputError: Swift.Error, Swift.Equatable {
    case noSuchFunctionExists(NoSuchFunctionExists)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.functionCode = data
        } else {
            self.functionCode = nil
        }
    }
}

public struct GetFunctionOutputResponse: Swift.Equatable {
    /// The content type (media type) of the response.
    public var contentType: Swift.String?
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// The function code of a CloudFront function.
    public var functionCode: ClientRuntime.Data?

    public init (
        contentType: Swift.String? = nil,
        eTag: Swift.String? = nil,
        functionCode: ClientRuntime.Data? = nil
    )
    {
        self.contentType = contentType
        self.eTag = eTag
        self.functionCode = functionCode
    }
}

struct GetFunctionOutputResponseBody: Swift.Equatable {
    let functionCode: ClientRuntime.Data?
}

extension GetFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.functionCode) {
            do {
                let functionCodeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .functionCode)
                functionCode = functionCodeDecoded
            } catch {
                functionCode = "".data(using: .utf8)
            }
        } else {
            functionCode = nil
        }
    }
}

extension GetInvalidationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let distributionId = distributionId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/distribution/\(distributionId.urlPercentEncoding())/invalidation/\(id.urlPercentEncoding())"
    }
}

/// The request to get an invalidation's information.
public struct GetInvalidationInput: Swift.Equatable {
    /// The distribution's ID.
    /// This member is required.
    public var distributionId: Swift.String?
    /// The identifier for the invalidation request, for example, IDFDVBD632BHDS5.
    /// This member is required.
    public var id: Swift.String?

    public init (
        distributionId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
        self.id = id
    }
}

struct GetInvalidationInputBody: Swift.Equatable {
}

extension GetInvalidationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetInvalidationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetInvalidationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchInvalidation" : self = .noSuchInvalidation(try NoSuchInvalidation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInvalidationOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case noSuchInvalidation(NoSuchInvalidation)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInvalidationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Invalidation = try responseDecoder.decode(responseBody: data)
                self.invalidation = output
            } else {
                self.invalidation = nil
            }
        } else {
            self.invalidation = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetInvalidationOutputResponse: Swift.Equatable {
    /// The invalidation's information. For more information, see [Invalidation Complex Type](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/InvalidationDatatype.html).
    public var invalidation: CloudFrontClientTypes.Invalidation?

    public init (
        invalidation: CloudFrontClientTypes.Invalidation? = nil
    )
    {
        self.invalidation = invalidation
    }
}

struct GetInvalidationOutputResponseBody: Swift.Equatable {
    let invalidation: CloudFrontClientTypes.Invalidation?
}

extension GetInvalidationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidation = "Invalidation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Invalidation.self, forKey: .invalidation)
        invalidation = invalidationDecoded
    }
}

extension GetKeyGroupConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())/config"
    }
}

public struct GetKeyGroupConfigInput: Swift.Equatable {
    /// The identifier of the key group whose configuration you are getting. To get the identifier, use ListKeyGroups.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetKeyGroupConfigInputBody: Swift.Equatable {
}

extension GetKeyGroupConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetKeyGroupConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetKeyGroupConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetKeyGroupConfigOutputError: Swift.Error, Swift.Equatable {
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetKeyGroupConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.KeyGroupConfig = try responseDecoder.decode(responseBody: data)
                self.keyGroupConfig = output
            } else {
                self.keyGroupConfig = nil
            }
        } else {
            self.keyGroupConfig = nil
        }
    }
}

public struct GetKeyGroupConfigOutputResponse: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group configuration.
    public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init (
        eTag: Swift.String? = nil,
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.eTag = eTag
        self.keyGroupConfig = keyGroupConfig
    }
}

struct GetKeyGroupConfigOutputResponseBody: Swift.Equatable {
    let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
}

extension GetKeyGroupConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension GetKeyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())"
    }
}

public struct GetKeyGroupInput: Swift.Equatable {
    /// The identifier of the key group that you are getting. To get the identifier, use ListKeyGroups.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetKeyGroupInputBody: Swift.Equatable {
}

extension GetKeyGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetKeyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetKeyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetKeyGroupOutputError: Swift.Error, Swift.Equatable {
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetKeyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.KeyGroup = try responseDecoder.decode(responseBody: data)
                self.keyGroup = output
            } else {
                self.keyGroup = nil
            }
        } else {
            self.keyGroup = nil
        }
    }
}

public struct GetKeyGroupOutputResponse: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group.
    public var keyGroup: CloudFrontClientTypes.KeyGroup?

    public init (
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
    }
}

struct GetKeyGroupOutputResponseBody: Swift.Equatable {
    let keyGroup: CloudFrontClientTypes.KeyGroup?
}

extension GetKeyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

extension GetMonitoringSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let distributionId = distributionId else {
            return nil
        }
        return "/2020-05-31/distributions/\(distributionId.urlPercentEncoding())/monitoring-subscription"
    }
}

public struct GetMonitoringSubscriptionInput: Swift.Equatable {
    /// The ID of the distribution that you are getting metrics information for.
    /// This member is required.
    public var distributionId: Swift.String?

    public init (
        distributionId: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
    }
}

struct GetMonitoringSubscriptionInputBody: Swift.Equatable {
}

extension GetMonitoringSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMonitoringSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetMonitoringSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMonitoringSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMonitoringSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.MonitoringSubscription = try responseDecoder.decode(responseBody: data)
                self.monitoringSubscription = output
            } else {
                self.monitoringSubscription = nil
            }
        } else {
            self.monitoringSubscription = nil
        }
    }
}

public struct GetMonitoringSubscriptionOutputResponse: Swift.Equatable {
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    public var monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init (
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.monitoringSubscription = monitoringSubscription
    }
}

struct GetMonitoringSubscriptionOutputResponseBody: Swift.Equatable {
    let monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?
}

extension GetMonitoringSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringSubscriptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MonitoringSubscription.self, forKey: .monitoringSubscription)
        monitoringSubscription = monitoringSubscriptionDecoded
    }
}

extension GetOriginRequestPolicyConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())/config"
    }
}

public struct GetOriginRequestPolicyConfigInput: Swift.Equatable {
    /// The unique identifier for the origin request policy. If the origin request policy is attached to a distribution’s cache behavior, you can get the policy’s identifier using ListDistributions or GetDistribution. If the origin request policy is not attached to a cache behavior, you can get the identifier using ListOriginRequestPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetOriginRequestPolicyConfigInputBody: Swift.Equatable {
}

extension GetOriginRequestPolicyConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOriginRequestPolicyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetOriginRequestPolicyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOriginRequestPolicyConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOriginRequestPolicyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.OriginRequestPolicyConfig = try responseDecoder.decode(responseBody: data)
                self.originRequestPolicyConfig = output
            } else {
                self.originRequestPolicyConfig = nil
            }
        } else {
            self.originRequestPolicyConfig = nil
        }
    }
}

public struct GetOriginRequestPolicyConfigOutputResponse: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// The origin request policy configuration.
    public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init (
        eTag: Swift.String? = nil,
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

struct GetOriginRequestPolicyConfigOutputResponseBody: Swift.Equatable {
    let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?
}

extension GetOriginRequestPolicyConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension GetOriginRequestPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())"
    }
}

public struct GetOriginRequestPolicyInput: Swift.Equatable {
    /// The unique identifier for the origin request policy. If the origin request policy is attached to a distribution’s cache behavior, you can get the policy’s identifier using ListDistributions or GetDistribution. If the origin request policy is not attached to a cache behavior, you can get the identifier using ListOriginRequestPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetOriginRequestPolicyInputBody: Swift.Equatable {
}

extension GetOriginRequestPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOriginRequestPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetOriginRequestPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOriginRequestPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOriginRequestPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.OriginRequestPolicy = try responseDecoder.decode(responseBody: data)
                self.originRequestPolicy = output
            } else {
                self.originRequestPolicy = nil
            }
        } else {
            self.originRequestPolicy = nil
        }
    }
}

public struct GetOriginRequestPolicyOutputResponse: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// The origin request policy.
    public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init (
        eTag: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicy = originRequestPolicy
    }
}

struct GetOriginRequestPolicyOutputResponseBody: Swift.Equatable {
    let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
}

extension GetOriginRequestPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

extension GetPublicKeyConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())/config"
    }
}

public struct GetPublicKeyConfigInput: Swift.Equatable {
    /// The identifier of the public key whose configuration you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetPublicKeyConfigInputBody: Swift.Equatable {
}

extension GetPublicKeyConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPublicKeyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPublicKeyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPublicKeyConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchPublicKey(NoSuchPublicKey)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPublicKeyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.PublicKeyConfig = try responseDecoder.decode(responseBody: data)
                self.publicKeyConfig = output
            } else {
                self.publicKeyConfig = nil
            }
        } else {
            self.publicKeyConfig = nil
        }
    }
}

public struct GetPublicKeyConfigOutputResponse: Swift.Equatable {
    /// The identifier for this version of the public key configuration.
    public var eTag: Swift.String?
    /// A public key configuration.
    public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init (
        eTag: Swift.String? = nil,
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.eTag = eTag
        self.publicKeyConfig = publicKeyConfig
    }
}

struct GetPublicKeyConfigOutputResponseBody: Swift.Equatable {
    let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?
}

extension GetPublicKeyConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension GetPublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())"
    }
}

public struct GetPublicKeyInput: Swift.Equatable {
    /// The identifier of the public key you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetPublicKeyInputBody: Swift.Equatable {
}

extension GetPublicKeyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPublicKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchPublicKey(NoSuchPublicKey)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.PublicKey = try responseDecoder.decode(responseBody: data)
                self.publicKey = output
            } else {
                self.publicKey = nil
            }
        } else {
            self.publicKey = nil
        }
    }
}

public struct GetPublicKeyOutputResponse: Swift.Equatable {
    /// The identifier for this version of the public key.
    public var eTag: Swift.String?
    /// The public key.
    public var publicKey: CloudFrontClientTypes.PublicKey?

    public init (
        eTag: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.publicKey = publicKey
    }
}

struct GetPublicKeyOutputResponseBody: Swift.Equatable {
    let publicKey: CloudFrontClientTypes.PublicKey?
}

extension GetPublicKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKey = "PublicKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKey.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

extension GetRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension GetRealtimeLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }
}

extension GetRealtimeLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/get-realtime-log-config"
    }
}

public struct GetRealtimeLogConfigInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the real-time log configuration to get.
    public var aRN: Swift.String?
    /// The name of the real-time log configuration to get.
    public var name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct GetRealtimeLogConfigInputBody: Swift.Equatable {
    let name: Swift.String?
    let aRN: Swift.String?
}

extension GetRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension GetRealtimeLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetRealtimeLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRealtimeLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRealtimeLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRealtimeLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.realtimeLogConfig = output.realtimeLogConfig
        } else {
            self.realtimeLogConfig = nil
        }
    }
}

public struct GetRealtimeLogConfigOutputResponse: Swift.Equatable {
    /// A real-time log configuration.
    public var realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init (
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

struct GetRealtimeLogConfigOutputResponseBody: Swift.Equatable {
    let realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?
}

extension GetRealtimeLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfig = "RealtimeLogConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfig.self, forKey: .realtimeLogConfig)
        realtimeLogConfig = realtimeLogConfigDecoded
    }
}

extension GetResponseHeadersPolicyConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())/config"
    }
}

public struct GetResponseHeadersPolicyConfigInput: Swift.Equatable {
    /// The identifier for the response headers policy. If the response headers policy is attached to a distribution’s cache behavior, you can get the policy’s identifier using ListDistributions or GetDistribution. If the response headers policy is not attached to a cache behavior, you can get the identifier using ListResponseHeadersPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetResponseHeadersPolicyConfigInputBody: Swift.Equatable {
}

extension GetResponseHeadersPolicyConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResponseHeadersPolicyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetResponseHeadersPolicyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResponseHeadersPolicy" : self = .noSuchResponseHeadersPolicy(try NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResponseHeadersPolicyConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchResponseHeadersPolicy(NoSuchResponseHeadersPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResponseHeadersPolicyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.ResponseHeadersPolicyConfig = try responseDecoder.decode(responseBody: data)
                self.responseHeadersPolicyConfig = output
            } else {
                self.responseHeadersPolicyConfig = nil
            }
        } else {
            self.responseHeadersPolicyConfig = nil
        }
    }
}

public struct GetResponseHeadersPolicyConfigOutputResponse: Swift.Equatable {
    /// The version identifier for the current version of the response headers policy.
    public var eTag: Swift.String?
    /// Contains a response headers policy.
    public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

    public init (
        eTag: Swift.String? = nil,
        responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
    )
    {
        self.eTag = eTag
        self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
    }
}

struct GetResponseHeadersPolicyConfigOutputResponseBody: Swift.Equatable {
    let responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?
}

extension GetResponseHeadersPolicyConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicyConfig = "ResponseHeadersPolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseHeadersPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyConfig.self, forKey: .responseHeadersPolicyConfig)
        responseHeadersPolicyConfig = responseHeadersPolicyConfigDecoded
    }
}

extension GetResponseHeadersPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())"
    }
}

public struct GetResponseHeadersPolicyInput: Swift.Equatable {
    /// The identifier for the response headers policy. If the response headers policy is attached to a distribution’s cache behavior, you can get the policy’s identifier using ListDistributions or GetDistribution. If the response headers policy is not attached to a cache behavior, you can get the identifier using ListResponseHeadersPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetResponseHeadersPolicyInputBody: Swift.Equatable {
}

extension GetResponseHeadersPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResponseHeadersPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetResponseHeadersPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResponseHeadersPolicy" : self = .noSuchResponseHeadersPolicy(try NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResponseHeadersPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchResponseHeadersPolicy(NoSuchResponseHeadersPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResponseHeadersPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.ResponseHeadersPolicy = try responseDecoder.decode(responseBody: data)
                self.responseHeadersPolicy = output
            } else {
                self.responseHeadersPolicy = nil
            }
        } else {
            self.responseHeadersPolicy = nil
        }
    }
}

public struct GetResponseHeadersPolicyOutputResponse: Swift.Equatable {
    /// The version identifier for the current version of the response headers policy.
    public var eTag: Swift.String?
    /// Contains a response headers policy.
    public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?

    public init (
        eTag: Swift.String? = nil,
        responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil
    )
    {
        self.eTag = eTag
        self.responseHeadersPolicy = responseHeadersPolicy
    }
}

struct GetResponseHeadersPolicyOutputResponseBody: Swift.Equatable {
    let responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?
}

extension GetResponseHeadersPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicy = "ResponseHeadersPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseHeadersPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicy.self, forKey: .responseHeadersPolicy)
        responseHeadersPolicy = responseHeadersPolicyDecoded
    }
}

extension GetStreamingDistributionConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())/config"
    }
}

/// To request to get a streaming distribution configuration.
public struct GetStreamingDistributionConfigInput: Swift.Equatable {
    /// The streaming distribution's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetStreamingDistributionConfigInputBody: Swift.Equatable {
}

extension GetStreamingDistributionConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingDistributionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetStreamingDistributionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingDistributionConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingDistributionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistributionConfig = try responseDecoder.decode(responseBody: data)
                self.streamingDistributionConfig = output
            } else {
                self.streamingDistributionConfig = nil
            }
        } else {
            self.streamingDistributionConfig = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetStreamingDistributionConfigOutputResponse: Swift.Equatable {
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// The streaming distribution's configuration information.
    public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init (
        eTag: Swift.String? = nil,
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

struct GetStreamingDistributionConfigOutputResponseBody: Swift.Equatable {
    let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
}

extension GetStreamingDistributionConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension GetStreamingDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())"
    }
}

/// The request to get a streaming distribution's information.
public struct GetStreamingDistributionInput: Swift.Equatable {
    /// The streaming distribution's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetStreamingDistributionInputBody: Swift.Equatable {
}

extension GetStreamingDistributionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetStreamingDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetStreamingDistributionOutputResponse: Swift.Equatable {
    /// The current version of the streaming distribution's information. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init (
        eTag: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistribution = streamingDistribution
    }
}

struct GetStreamingDistributionOutputResponseBody: Swift.Equatable {
    let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension GetStreamingDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

extension CloudFrontClientTypes.Headers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Headers: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains a list of HTTP header names.
    public struct Headers: Swift.Equatable {
        /// A list of HTTP header names.
        public var items: [Swift.String]?
        /// The number of header names in the Items list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum HttpVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http11
        case http2
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpVersion] {
            return [
                .http11,
                .http2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http11: return "http1.1"
            case .http2: return "http2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HttpVersion(rawValue: rawValue) ?? HttpVersion.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum ICPRecordalStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case pending
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [ICPRecordalStatus] {
            return [
                .approved,
                .pending,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .pending: return "PENDING"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICPRecordalStatus(rawValue: rawValue) ?? ICPRecordalStatus.sdkUnknown(rawValue)
        }
    }
}

extension IllegalDelete {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<IllegalDeleteBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot delete a managed policy.
public struct IllegalDelete: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalDeleteBody: Swift.Equatable {
    let message: Swift.String?
}

extension IllegalDeleteBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified configuration for field-level encryption can't be associated with the specified cache behavior.
public struct IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorBody: Swift.Equatable {
    let message: Swift.String?
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IllegalUpdate {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<IllegalUpdateBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The update contains modifications that are not allowed.
public struct IllegalUpdate: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalUpdateBody: Swift.Equatable {
    let message: Swift.String?
}

extension IllegalUpdateBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InconsistentQuantities {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InconsistentQuantitiesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value of Quantity and the size of Items don't match.
public struct InconsistentQuantities: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InconsistentQuantitiesBody: Swift.Equatable {
    let message: Swift.String?
}

extension InconsistentQuantitiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgument {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidArgumentBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An argument is invalid.
public struct InvalidArgument: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArgumentBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDefaultRootObject {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDefaultRootObjectBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The default root object file name is too big or contains an invalid character.
public struct InvalidDefaultRootObject: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDefaultRootObjectBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDefaultRootObjectBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidErrorCode {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidErrorCodeBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An invalid error code was specified.
public struct InvalidErrorCode: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidErrorCodeBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidErrorCodeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidForwardCookies {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidForwardCookiesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains forward cookies option which doesn't match with the expectation for the whitelisted list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.
public struct InvalidForwardCookies: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidForwardCookiesBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidForwardCookiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFunctionAssociation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidFunctionAssociationBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A CloudFront function association is invalid.
public struct InvalidFunctionAssociation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFunctionAssociationBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidFunctionAssociationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidGeoRestrictionParameter {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidGeoRestrictionParameterBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified geo restriction parameter is not valid.
public struct InvalidGeoRestrictionParameter: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidGeoRestrictionParameterBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidGeoRestrictionParameterBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidHeadersForS3Origin {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidHeadersForS3OriginBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The headers specified are not valid for an Amazon S3 origin.
public struct InvalidHeadersForS3Origin: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidHeadersForS3OriginBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidHeadersForS3OriginBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidIfMatchVersion {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidIfMatchVersionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The If-Match version is missing or not valid.
public struct InvalidIfMatchVersion: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidIfMatchVersionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidIfMatchVersionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLambdaFunctionAssociation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidLambdaFunctionAssociationBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified Lambda@Edge function association is invalid.
public struct InvalidLambdaFunctionAssociation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLambdaFunctionAssociationBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidLambdaFunctionAssociationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLocationCode {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidLocationCodeBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The location code specified is not valid.
public struct InvalidLocationCode: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLocationCodeBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidLocationCodeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMinimumProtocolVersion {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidMinimumProtocolVersionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The minimum protocol version specified is not valid.
public struct InvalidMinimumProtocolVersion: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMinimumProtocolVersionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidMinimumProtocolVersionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOrigin {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidOriginBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.
public struct InvalidOrigin: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension InvalidOriginAccessIdentity {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidOriginAccessIdentityBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The origin access identity is not valid or doesn't exist.
public struct InvalidOriginAccessIdentity: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOriginAccessIdentityBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOriginAccessIdentityBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

struct InvalidOriginBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOriginBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOriginKeepaliveTimeout {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidOriginKeepaliveTimeoutBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The keep alive timeout specified for the origin is not valid.
public struct InvalidOriginKeepaliveTimeout: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOriginKeepaliveTimeoutBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOriginKeepaliveTimeoutBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOriginReadTimeout {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidOriginReadTimeoutBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The read timeout specified for the origin is not valid.
public struct InvalidOriginReadTimeout: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOriginReadTimeoutBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOriginReadTimeoutBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidProtocolSettings {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidProtocolSettingsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that support Server Name Indication (SNI).
public struct InvalidProtocolSettings: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidProtocolSettingsBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidProtocolSettingsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidQueryStringParameters {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidQueryStringParametersBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The query string parameters specified are not valid.
public struct InvalidQueryStringParameters: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidQueryStringParametersBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidQueryStringParametersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRelativePath {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidRelativePathBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The relative path is too big, is not URL-encoded, or does not begin with a slash (/).
public struct InvalidRelativePath: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRelativePathBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRelativePathBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequiredProtocol {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidRequiredProtocolBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the RequiredProtocols element from your distribution configuration.
public struct InvalidRequiredProtocol: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequiredProtocolBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequiredProtocolBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResponseCode {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidResponseCodeBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A response code is not valid.
public struct InvalidResponseCode: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResponseCodeBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResponseCodeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTTLOrder {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidTTLOrderBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The TTL order specified is not valid.
public struct InvalidTTLOrder: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTTLOrderBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTTLOrderBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagging {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidTaggingBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The tagging specified is not valid.
public struct InvalidTagging: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTaggingBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTaggingBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidViewerCertificate {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidViewerCertificateBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A viewer certificate specified is not valid.
public struct InvalidViewerCertificate: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidViewerCertificateBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidViewerCertificateBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidWebACLId {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidWebACLIdBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A web ACL ID specified is not valid. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a. To specify a web ACL created using WAF Classic, use the ACL ID, for example 473e64fd-f30b-4765-81a0-62ad96dd167a.
public struct InvalidWebACLId: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidWebACLIdBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidWebACLIdBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.Invalidation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case id = "Id"
        case invalidationBatch = "InvalidationBatch"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createTime = createTime {
            try container.encode(ClientRuntime.TimestampWrapper(createTime, format: .dateTime), forKey: ClientRuntime.Key("CreateTime"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let invalidationBatch = invalidationBatch {
            try container.encode(invalidationBatch, forKey: ClientRuntime.Key("InvalidationBatch"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        var createTimeBuffer:ClientRuntime.Date? = nil
        if let createTimeDecoded = createTimeDecoded {
            createTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createTimeDecoded, format: .dateTime)
        }
        createTime = createTimeBuffer
        let invalidationBatchDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.InvalidationBatch.self, forKey: .invalidationBatch)
        invalidationBatch = invalidationBatchDecoded
    }
}

extension CloudFrontClientTypes.Invalidation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An invalidation.
    public struct Invalidation: Swift.Equatable {
        /// The date and time the invalidation request was first made.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The identifier for the invalidation request. For example: IDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// The current invalidation information for the batch request.
        /// This member is required.
        public var invalidationBatch: CloudFrontClientTypes.InvalidationBatch?
        /// The status of the invalidation request. When the invalidation batch is finished, the status is Completed.
        /// This member is required.
        public var status: Swift.String?

        public init (
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            invalidationBatch: CloudFrontClientTypes.InvalidationBatch? = nil,
            status: Swift.String? = nil
        )
        {
            self.createTime = createTime
            self.id = id
            self.invalidationBatch = invalidationBatch
            self.status = status
        }
    }

}

extension CloudFrontClientTypes.InvalidationBatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case paths = "Paths"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let paths = paths {
            try container.encode(paths, forKey: ClientRuntime.Key("Paths"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Paths.self, forKey: .paths)
        paths = pathsDecoded
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
    }
}

extension CloudFrontClientTypes.InvalidationBatch: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An invalidation batch.
    public struct InvalidationBatch: Swift.Equatable {
        /// A value that you specify to uniquely identify an invalidation request. CloudFront uses the value to prevent you from accidentally resubmitting an identical request. Whenever you create a new invalidation request, you must specify a new value for CallerReference and change other values in the request as applicable. One way to ensure that the value of CallerReference is unique is to use a timestamp, for example, 20120301090000. If you make a second invalidation request with the same value for CallerReference, and if the rest of the request is the same, CloudFront doesn't create a new invalidation request. Instead, CloudFront returns information about the invalidation request that you previously created with the same CallerReference. If CallerReference is a value you already sent in a previous invalidation batch request but the content of any Path is different from the original request, CloudFront returns an InvalidationBatchAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A complex type that contains information about the objects that you want to invalidate. For more information, see [Specifying the Objects to Invalidate](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var paths: CloudFrontClientTypes.Paths?

        public init (
            callerReference: Swift.String? = nil,
            paths: CloudFrontClientTypes.Paths? = nil
        )
        {
            self.callerReference = callerReference
            self.paths = paths
        }
    }

}

extension CloudFrontClientTypes.InvalidationList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for invalidationsummary0 in items {
                try itemsContainer.encode(invalidationsummary0, forKey: ClientRuntime.Key("InvalidationSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct InvalidationSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.InvalidationSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.InvalidationSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.InvalidationSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.InvalidationSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.InvalidationList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The InvalidationList complex type describes the list of invalidation objects. For more information about invalidation, see [Invalidating Objects (Web Distributions Only)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html) in the Amazon CloudFront Developer Guide.
    public struct InvalidationList: Swift.Equatable {
        /// A flag that indicates whether more invalidation batch requests remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more invalidation batches in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one InvalidationSummary element for each invalidation batch created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.InvalidationSummary]?
        /// The value that you provided for the Marker request parameter.
        /// This member is required.
        public var marker: Swift.String?
        /// The value that you provided for the MaxItems request parameter.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value that you can use for the Marker request parameter to continue listing your invalidation batches where they left off.
        public var nextMarker: Swift.String?
        /// The number of invalidation batches that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.InvalidationSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.InvalidationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case id = "Id"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createTime = createTime {
            try container.encode(ClientRuntime.TimestampWrapper(createTime, format: .dateTime), forKey: ClientRuntime.Key("CreateTime"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        var createTimeBuffer:ClientRuntime.Date? = nil
        if let createTimeDecoded = createTimeDecoded {
            createTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createTimeDecoded, format: .dateTime)
        }
        createTime = createTimeBuffer
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudFrontClientTypes.InvalidationSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A summary of an invalidation request.
    public struct InvalidationSummary: Swift.Equatable {
        /// The time that an invalidation request was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique ID for an invalidation request.
        /// This member is required.
        public var id: Swift.String?
        /// The status of an invalidation request.
        /// This member is required.
        public var status: Swift.String?

        public init (
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.createTime = createTime
            self.id = id
            self.status = status
        }
    }

}

extension CloudFrontClientTypes {
    public enum ItemSelection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [ItemSelection] {
            return [
                .all,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ItemSelection(rawValue: rawValue) ?? ItemSelection.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.KGKeyPairIds: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupId = "KeyGroupId"
        case keyPairIds = "KeyPairIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroupId = keyGroupId {
            try container.encode(keyGroupId, forKey: ClientRuntime.Key("KeyGroupId"))
        }
        if let keyPairIds = keyPairIds {
            try container.encode(keyPairIds, forKey: ClientRuntime.Key("KeyPairIds"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyGroupId)
        keyGroupId = keyGroupIdDecoded
        let keyPairIdsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyPairIds.self, forKey: .keyPairIds)
        keyPairIds = keyPairIdsDecoded
    }
}

extension CloudFrontClientTypes.KGKeyPairIds: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of identifiers for the public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct KGKeyPairIds: Swift.Equatable {
        /// The identifier of the key group that contains the public keys.
        public var keyGroupId: Swift.String?
        /// A list of CloudFront key pair identifiers.
        public var keyPairIds: CloudFrontClientTypes.KeyPairIds?

        public init (
            keyGroupId: Swift.String? = nil,
            keyPairIds: CloudFrontClientTypes.KeyPairIds? = nil
        )
        {
            self.keyGroupId = keyGroupId
            self.keyPairIds = keyPairIds
        }
    }

}

extension CloudFrontClientTypes.KeyGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case keyGroupConfig = "KeyGroupConfig"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let keyGroupConfig = keyGroupConfig {
            try container.encode(keyGroupConfig, forKey: ClientRuntime.Key("KeyGroupConfig"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension CloudFrontClientTypes.KeyGroup: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A key group. A key group contains a list of public keys that you can use with [CloudFront signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html).
    public struct KeyGroup: Swift.Equatable {
        /// The identifier for the key group.
        /// This member is required.
        public var id: Swift.String?
        /// The key group configuration.
        /// This member is required.
        public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
        /// The date and time when the key group was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init (
            id: Swift.String? = nil,
            keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.id = id
            self.keyGroupConfig = keyGroupConfig
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension KeyGroupAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<KeyGroupAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A key group with this name already exists. You must provide a unique name. To modify an existing key group, use UpdateKeyGroup.
public struct KeyGroupAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KeyGroupAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension KeyGroupAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.KeyGroupConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case items = "Items"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("PublicKey"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct PublicKey{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PublicKey>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.KeyGroupConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A key group configuration. A key group contains a list of public keys that you can use with [CloudFront signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html).
    public struct KeyGroupConfig: Swift.Equatable {
        /// A comment to describe the key group. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A list of the identifiers of the public keys in the key group.
        /// This member is required.
        public var items: [Swift.String]?
        /// A name to identify the key group.
        /// This member is required.
        public var name: Swift.String?

        public init (
            comment: Swift.String? = nil,
            items: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.items = items
            self.name = name
        }
    }

}

extension CloudFrontClientTypes.KeyGroupList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for keygroupsummary0 in items {
                try itemsContainer.encode(keygroupsummary0, forKey: ClientRuntime.Key("KeyGroupSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyGroupSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyGroupSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.KeyGroupSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.KeyGroupSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.KeyGroupSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.KeyGroupList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of key groups.
    public struct KeyGroupList: Swift.Equatable {
        /// A list of key groups.
        public var items: [CloudFrontClientTypes.KeyGroupSummary]?
        /// The maximum number of key groups requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing key groups.
        public var nextMarker: Swift.String?
        /// The number of key groups returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.KeyGroupSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.KeyGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroup = keyGroup {
            try container.encode(keyGroup, forKey: ClientRuntime.Key("KeyGroup"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

extension CloudFrontClientTypes.KeyGroupSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains information about a key group.
    public struct KeyGroupSummary: Swift.Equatable {
        /// A key group.
        /// This member is required.
        public var keyGroup: CloudFrontClientTypes.KeyGroup?

        public init (
            keyGroup: CloudFrontClientTypes.KeyGroup? = nil
        )
        {
            self.keyGroup = keyGroup
        }
    }

}

extension CloudFrontClientTypes.KeyPairIds: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("KeyPairId"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyPairId{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyPairId>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.KeyPairIds: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of CloudFront key pair identifiers.
    public struct KeyPairIds: Swift.Equatable {
        /// A list of CloudFront key pair identifiers.
        public var items: [Swift.String]?
        /// The number of key pair identifiers in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.KinesisStreamConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleARN = "RoleARN"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let roleARN = roleARN {
            try container.encode(roleARN, forKey: ClientRuntime.Key("RoleARN"))
        }
        if let streamARN = streamARN {
            try container.encode(streamARN, forKey: ClientRuntime.Key("StreamARN"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension CloudFrontClientTypes.KinesisStreamConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
    public struct KinesisStreamConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Identity and Access Management (IAM) role that CloudFront can use to send real-time log data to your Kinesis data stream. For more information the IAM role, see [Real-time log configuration IAM role](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-iam-role) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var roleARN: Swift.String?
        /// The Amazon Resource Name (ARN) of the Kinesis data stream where you are sending real-time log data.
        /// This member is required.
        public var streamARN: Swift.String?

        public init (
            roleARN: Swift.String? = nil,
            streamARN: Swift.String? = nil
        )
        {
            self.roleARN = roleARN
            self.streamARN = streamARN
        }
    }

}

extension CloudFrontClientTypes.LambdaFunctionAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType = "EventType"
        case includeBody = "IncludeBody"
        case lambdaFunctionARN = "LambdaFunctionARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eventType = eventType {
            try container.encode(eventType, forKey: ClientRuntime.Key("EventType"))
        }
        if let includeBody = includeBody {
            try container.encode(includeBody, forKey: ClientRuntime.Key("IncludeBody"))
        }
        if let lambdaFunctionARN = lambdaFunctionARN {
            try container.encode(lambdaFunctionARN, forKey: ClientRuntime.Key("LambdaFunctionARN"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionARN)
        lambdaFunctionARN = lambdaFunctionARNDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let includeBodyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeBody)
        includeBody = includeBodyDecoded
    }
}

extension CloudFrontClientTypes.LambdaFunctionAssociation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains a Lambda@Edge function association.
    public struct LambdaFunctionAssociation: Swift.Equatable {
        /// Specifies the event type that triggers a Lambda@Edge function invocation. You can specify the following values:
        ///
        /// * viewer-request: The function executes when CloudFront receives a request from a viewer and before it checks to see whether the requested object is in the edge cache.
        ///
        /// * origin-request: The function executes only when CloudFront sends a request to your origin. When the requested object is in the edge cache, the function doesn't execute.
        ///
        /// * origin-response: The function executes after CloudFront receives a response from the origin and before it caches the object in the response. When the requested object is in the edge cache, the function doesn't execute.
        ///
        /// * viewer-response: The function executes before CloudFront returns the requested object to the viewer. The function executes regardless of whether the object was already in the edge cache. If the origin returns an HTTP status code other than HTTP 200 (OK), the function doesn't execute.
        /// This member is required.
        public var eventType: CloudFrontClientTypes.EventType?
        /// A flag that allows a Lambda@Edge function to have read access to the body content. For more information, see [Accessing the Request Body by Choosing the Include Body Option](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-include-body-access.html) in the Amazon CloudFront Developer Guide.
        public var includeBody: Swift.Bool?
        /// The ARN of the Lambda@Edge function. You must specify the ARN of a function version; you can't specify an alias or $LATEST.
        /// This member is required.
        public var lambdaFunctionARN: Swift.String?

        public init (
            eventType: CloudFrontClientTypes.EventType? = nil,
            includeBody: Swift.Bool? = nil,
            lambdaFunctionARN: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.includeBody = includeBody
            self.lambdaFunctionARN = lambdaFunctionARN
        }
    }

}

extension CloudFrontClientTypes.LambdaFunctionAssociations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for lambdafunctionassociation0 in items {
                try itemsContainer.encode(lambdafunctionassociation0, forKey: ClientRuntime.Key("LambdaFunctionAssociation"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct LambdaFunctionAssociation{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.LambdaFunctionAssociation>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.LambdaFunctionAssociation].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.LambdaFunctionAssociation]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.LambdaFunctionAssociation]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.LambdaFunctionAssociations: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that specifies a list of Lambda@Edge functions associations for a cache behavior. If you want to invoke one or more Lambda@Edge functions triggered by requests that match the PathPattern of the cache behavior, specify the applicable values for Quantity and Items. Note that there can be up to 4 LambdaFunctionAssociation items in this list (one for each possible value of EventType) and each EventType can be associated with only one function. If you don't want to invoke any Lambda@Edge functions for the requests that match PathPattern, specify 0 for Quantity and omit Items.
    public struct LambdaFunctionAssociations: Swift.Equatable {
        /// Optional: A complex type that contains LambdaFunctionAssociation items for this cache behavior. If Quantity is 0, you can omit Items.
        public var items: [CloudFrontClientTypes.LambdaFunctionAssociation]?
        /// The number of Lambda@Edge function associations for this cache behavior.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.LambdaFunctionAssociation]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension ListCachePoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let type = type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListCachePoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/cache-policy"
    }
}

public struct ListCachePoliciesInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of cache policies. The response includes cache policies in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of cache policies that you want in the response.
    public var maxItems: Swift.Int?
    /// A filter to return only the specified kinds of cache policies. Valid values are:
    ///
    /// * managed – Returns only the managed policies created by Amazon Web Services.
    ///
    /// * custom – Returns only the custom policies created in your Amazon Web Services account.
    public var type: CloudFrontClientTypes.CachePolicyType?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.CachePolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

struct ListCachePoliciesInputBody: Swift.Equatable {
}

extension ListCachePoliciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCachePoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListCachePoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCachePoliciesOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCachePoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CachePolicyList = try responseDecoder.decode(responseBody: data)
                self.cachePolicyList = output
            } else {
                self.cachePolicyList = nil
            }
        } else {
            self.cachePolicyList = nil
        }
    }
}

public struct ListCachePoliciesOutputResponse: Swift.Equatable {
    /// A list of cache policies.
    public var cachePolicyList: CloudFrontClientTypes.CachePolicyList?

    public init (
        cachePolicyList: CloudFrontClientTypes.CachePolicyList? = nil
    )
    {
        self.cachePolicyList = cachePolicyList
    }
}

struct ListCachePoliciesOutputResponseBody: Swift.Equatable {
    let cachePolicyList: CloudFrontClientTypes.CachePolicyList?
}

extension ListCachePoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyList = "CachePolicyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyList.self, forKey: .cachePolicyList)
        cachePolicyList = cachePolicyListDecoded
    }
}

extension ListCloudFrontOriginAccessIdentitiesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListCloudFrontOriginAccessIdentitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/origin-access-identity/cloudfront"
    }
}

/// The request to list origin access identities.
public struct ListCloudFrontOriginAccessIdentitiesInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of origin access identities. The results include identities in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last identity on that page).
    public var marker: Swift.String?
    /// The maximum number of origin access identities you want in the response body.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListCloudFrontOriginAccessIdentitiesInputBody: Swift.Equatable {
}

extension ListCloudFrontOriginAccessIdentitiesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCloudFrontOriginAccessIdentitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListCloudFrontOriginAccessIdentitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCloudFrontOriginAccessIdentitiesOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCloudFrontOriginAccessIdentitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList = try responseDecoder.decode(responseBody: data)
                self.cloudFrontOriginAccessIdentityList = output
            } else {
                self.cloudFrontOriginAccessIdentityList = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentityList = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct ListCloudFrontOriginAccessIdentitiesOutputResponse: Swift.Equatable {
    /// The CloudFrontOriginAccessIdentityList type.
    public var cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList?

    public init (
        cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityList = cloudFrontOriginAccessIdentityList
    }
}

struct ListCloudFrontOriginAccessIdentitiesOutputResponseBody: Swift.Equatable {
    let cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList?
}

extension ListCloudFrontOriginAccessIdentitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityList = "CloudFrontOriginAccessIdentityList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityList.self, forKey: .cloudFrontOriginAccessIdentityList)
        cloudFrontOriginAccessIdentityList = cloudFrontOriginAccessIdentityListDecoded
    }
}

extension ListConflictingAliasesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let alias = alias {
            let aliasQueryItem = ClientRuntime.URLQueryItem(name: "Alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
            items.append(aliasQueryItem)
        }
        if let distributionId = distributionId {
            let distributionIdQueryItem = ClientRuntime.URLQueryItem(name: "DistributionId".urlPercentEncoding(), value: Swift.String(distributionId).urlPercentEncoding())
            items.append(distributionIdQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListConflictingAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/conflicting-alias"
    }
}

public struct ListConflictingAliasesInput: Swift.Equatable {
    /// The alias (also called a CNAME) to search for conflicting aliases.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of a distribution in your account that has an attached SSL/TLS certificate that includes the provided alias.
    /// This member is required.
    public var distributionId: Swift.String?
    /// Use this field when paginating results to indicate where to begin in the list of conflicting aliases. The response includes conflicting aliases in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of conflicting aliases that you want in the response.
    public var maxItems: Swift.Int?

    public init (
        alias: Swift.String? = nil,
        distributionId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.alias = alias
        self.distributionId = distributionId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListConflictingAliasesInputBody: Swift.Equatable {
}

extension ListConflictingAliasesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConflictingAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListConflictingAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConflictingAliasesOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case noSuchDistribution(NoSuchDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConflictingAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.ConflictingAliasesList = try responseDecoder.decode(responseBody: data)
                self.conflictingAliasesList = output
            } else {
                self.conflictingAliasesList = nil
            }
        } else {
            self.conflictingAliasesList = nil
        }
    }
}

public struct ListConflictingAliasesOutputResponse: Swift.Equatable {
    /// A list of conflicting aliases.
    public var conflictingAliasesList: CloudFrontClientTypes.ConflictingAliasesList?

    public init (
        conflictingAliasesList: CloudFrontClientTypes.ConflictingAliasesList? = nil
    )
    {
        self.conflictingAliasesList = conflictingAliasesList
    }
}

struct ListConflictingAliasesOutputResponseBody: Swift.Equatable {
    let conflictingAliasesList: CloudFrontClientTypes.ConflictingAliasesList?
}

extension ListConflictingAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictingAliasesList = "ConflictingAliasesList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictingAliasesListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ConflictingAliasesList.self, forKey: .conflictingAliasesList)
        conflictingAliasesList = conflictingAliasesListDecoded
    }
}

extension ListDistributionsByCachePolicyIdInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsByCachePolicyIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let cachePolicyId = cachePolicyId else {
            return nil
        }
        return "/2020-05-31/distributionsByCachePolicyId/\(cachePolicyId.urlPercentEncoding())"
    }
}

public struct ListDistributionsByCachePolicyIdInput: Swift.Equatable {
    /// The ID of the cache policy whose associated distribution IDs you want to list.
    /// This member is required.
    public var cachePolicyId: Swift.String?
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want in the response.
    public var maxItems: Swift.Int?

    public init (
        cachePolicyId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.cachePolicyId = cachePolicyId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDistributionsByCachePolicyIdInputBody: Swift.Equatable {
}

extension ListDistributionsByCachePolicyIdInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByCachePolicyIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByCachePolicyIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByCachePolicyIdOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByCachePolicyIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionIdList = try responseDecoder.decode(responseBody: data)
                self.distributionIdList = output
            } else {
                self.distributionIdList = nil
            }
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByCachePolicyIdOutputResponse: Swift.Equatable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init (
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByCachePolicyIdOutputResponseBody: Swift.Equatable {
    let distributionIdList: CloudFrontClientTypes.DistributionIdList?
}

extension ListDistributionsByCachePolicyIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

extension ListDistributionsByKeyGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsByKeyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let keyGroupId = keyGroupId else {
            return nil
        }
        return "/2020-05-31/distributionsByKeyGroupId/\(keyGroupId.urlPercentEncoding())"
    }
}

public struct ListDistributionsByKeyGroupInput: Swift.Equatable {
    /// The ID of the key group whose associated distribution IDs you are listing.
    /// This member is required.
    public var keyGroupId: Swift.String?
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want in the response.
    public var maxItems: Swift.Int?

    public init (
        keyGroupId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.keyGroupId = keyGroupId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDistributionsByKeyGroupInputBody: Swift.Equatable {
}

extension ListDistributionsByKeyGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByKeyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByKeyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByKeyGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByKeyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionIdList = try responseDecoder.decode(responseBody: data)
                self.distributionIdList = output
            } else {
                self.distributionIdList = nil
            }
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByKeyGroupOutputResponse: Swift.Equatable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init (
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByKeyGroupOutputResponseBody: Swift.Equatable {
    let distributionIdList: CloudFrontClientTypes.DistributionIdList?
}

extension ListDistributionsByKeyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

extension ListDistributionsByOriginRequestPolicyIdInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsByOriginRequestPolicyIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let originRequestPolicyId = originRequestPolicyId else {
            return nil
        }
        return "/2020-05-31/distributionsByOriginRequestPolicyId/\(originRequestPolicyId.urlPercentEncoding())"
    }
}

public struct ListDistributionsByOriginRequestPolicyIdInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want in the response.
    public var maxItems: Swift.Int?
    /// The ID of the origin request policy whose associated distribution IDs you want to list.
    /// This member is required.
    public var originRequestPolicyId: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        originRequestPolicyId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.originRequestPolicyId = originRequestPolicyId
    }
}

struct ListDistributionsByOriginRequestPolicyIdInputBody: Swift.Equatable {
}

extension ListDistributionsByOriginRequestPolicyIdInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByOriginRequestPolicyIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByOriginRequestPolicyIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByOriginRequestPolicyIdOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByOriginRequestPolicyIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionIdList = try responseDecoder.decode(responseBody: data)
                self.distributionIdList = output
            } else {
                self.distributionIdList = nil
            }
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByOriginRequestPolicyIdOutputResponse: Swift.Equatable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init (
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByOriginRequestPolicyIdOutputResponseBody: Swift.Equatable {
    let distributionIdList: CloudFrontClientTypes.DistributionIdList?
}

extension ListDistributionsByOriginRequestPolicyIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

extension ListDistributionsByRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension ListDistributionsByRealtimeLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case realtimeLogConfigName = "RealtimeLogConfigName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: ClientRuntime.Key("RealtimeLogConfigArn"))
        }
        if let realtimeLogConfigName = realtimeLogConfigName {
            try container.encode(realtimeLogConfigName, forKey: ClientRuntime.Key("RealtimeLogConfigName"))
        }
    }
}

extension ListDistributionsByRealtimeLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/distributionsByRealtimeLogConfig"
    }
}

public struct ListDistributionsByRealtimeLogConfigInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of distributions. The response includes distributions in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of distributions that you want in the response.
    public var maxItems: Swift.Int?
    /// The Amazon Resource Name (ARN) of the real-time log configuration whose associated distributions you want to list.
    public var realtimeLogConfigArn: Swift.String?
    /// The name of the real-time log configuration whose associated distributions you want to list.
    public var realtimeLogConfigName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        realtimeLogConfigArn: Swift.String? = nil,
        realtimeLogConfigName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.realtimeLogConfigArn = realtimeLogConfigArn
        self.realtimeLogConfigName = realtimeLogConfigName
    }
}

struct ListDistributionsByRealtimeLogConfigInputBody: Swift.Equatable {
    let marker: Swift.String?
    let maxItems: Swift.Int?
    let realtimeLogConfigName: Swift.String?
    let realtimeLogConfigArn: Swift.String?
}

extension ListDistributionsByRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case realtimeLogConfigName = "RealtimeLogConfigName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let realtimeLogConfigNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigName)
        realtimeLogConfigName = realtimeLogConfigNameDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
    }
}

extension ListDistributionsByRealtimeLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByRealtimeLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByRealtimeLogConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByRealtimeLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionList = try responseDecoder.decode(responseBody: data)
                self.distributionList = output
            } else {
                self.distributionList = nil
            }
        } else {
            self.distributionList = nil
        }
    }
}

public struct ListDistributionsByRealtimeLogConfigOutputResponse: Swift.Equatable {
    /// A distribution list.
    public var distributionList: CloudFrontClientTypes.DistributionList?

    public init (
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

struct ListDistributionsByRealtimeLogConfigOutputResponseBody: Swift.Equatable {
    let distributionList: CloudFrontClientTypes.DistributionList?
}

extension ListDistributionsByRealtimeLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionList = "DistributionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionList.self, forKey: .distributionList)
        distributionList = distributionListDecoded
    }
}

extension ListDistributionsByResponseHeadersPolicyIdInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsByResponseHeadersPolicyIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let responseHeadersPolicyId = responseHeadersPolicyId else {
            return nil
        }
        return "/2020-05-31/distributionsByResponseHeadersPolicyId/\(responseHeadersPolicyId.urlPercentEncoding())"
    }
}

public struct ListDistributionsByResponseHeadersPolicyIdInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want to get in the response.
    public var maxItems: Swift.Int?
    /// The ID of the response headers policy whose associated distribution IDs you want to list.
    /// This member is required.
    public var responseHeadersPolicyId: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        responseHeadersPolicyId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.responseHeadersPolicyId = responseHeadersPolicyId
    }
}

struct ListDistributionsByResponseHeadersPolicyIdInputBody: Swift.Equatable {
}

extension ListDistributionsByResponseHeadersPolicyIdInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByResponseHeadersPolicyIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByResponseHeadersPolicyIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResponseHeadersPolicy" : self = .noSuchResponseHeadersPolicy(try NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByResponseHeadersPolicyIdOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchResponseHeadersPolicy(NoSuchResponseHeadersPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByResponseHeadersPolicyIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionIdList = try responseDecoder.decode(responseBody: data)
                self.distributionIdList = output
            } else {
                self.distributionIdList = nil
            }
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByResponseHeadersPolicyIdOutputResponse: Swift.Equatable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init (
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByResponseHeadersPolicyIdOutputResponseBody: Swift.Equatable {
    let distributionIdList: CloudFrontClientTypes.DistributionIdList?
}

extension ListDistributionsByResponseHeadersPolicyIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

extension ListDistributionsByWebACLIdInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsByWebACLIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let webACLId = webACLId else {
            return nil
        }
        return "/2020-05-31/distributionsByWebACLId/\(webACLId.urlPercentEncoding())"
    }
}

/// The request to list distributions that are associated with a specified WAF web ACL.
public struct ListDistributionsByWebACLIdInput: Swift.Equatable {
    /// Use Marker and MaxItems to control pagination of results. If you have more than MaxItems distributions that satisfy the request, the response includes a NextMarker element. To get the next page of results, submit another request. For the value of Marker, specify the value of NextMarker from the last response. (For the first request, omit Marker.)
    public var marker: Swift.String?
    /// The maximum number of distributions that you want CloudFront to return in the response body. The maximum and default values are both 100.
    public var maxItems: Swift.Int?
    /// The ID of the WAF web ACL that you want to list the associated distributions. If you specify "null" for the ID, the request returns a list of the distributions that aren't associated with a web ACL.
    /// This member is required.
    public var webACLId: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        webACLId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.webACLId = webACLId
    }
}

struct ListDistributionsByWebACLIdInputBody: Swift.Equatable {
}

extension ListDistributionsByWebACLIdInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByWebACLIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByWebACLIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByWebACLIdOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case invalidWebACLId(InvalidWebACLId)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByWebACLIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionList = try responseDecoder.decode(responseBody: data)
                self.distributionList = output
            } else {
                self.distributionList = nil
            }
        } else {
            self.distributionList = nil
        }
    }
}

/// The response to a request to list the distributions that are associated with a specified WAF web ACL.
public struct ListDistributionsByWebACLIdOutputResponse: Swift.Equatable {
    /// The DistributionList type.
    public var distributionList: CloudFrontClientTypes.DistributionList?

    public init (
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

struct ListDistributionsByWebACLIdOutputResponseBody: Swift.Equatable {
    let distributionList: CloudFrontClientTypes.DistributionList?
}

extension ListDistributionsByWebACLIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionList = "DistributionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionList.self, forKey: .distributionList)
        distributionList = distributionListDecoded
    }
}

extension ListDistributionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/distribution"
    }
}

/// The request to list your distributions.
public struct ListDistributionsInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of distributions. The results include distributions in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last distribution on that page).
    public var marker: Swift.String?
    /// The maximum number of distributions you want in the response body.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDistributionsInputBody: Swift.Equatable {
}

extension ListDistributionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionList = try responseDecoder.decode(responseBody: data)
                self.distributionList = output
            } else {
                self.distributionList = nil
            }
        } else {
            self.distributionList = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct ListDistributionsOutputResponse: Swift.Equatable {
    /// The DistributionList type.
    public var distributionList: CloudFrontClientTypes.DistributionList?

    public init (
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

struct ListDistributionsOutputResponseBody: Swift.Equatable {
    let distributionList: CloudFrontClientTypes.DistributionList?
}

extension ListDistributionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionList = "DistributionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionList.self, forKey: .distributionList)
        distributionList = distributionListDecoded
    }
}

extension ListFieldLevelEncryptionConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFieldLevelEncryptionConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/field-level-encryption"
    }
}

public struct ListFieldLevelEncryptionConfigsInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of configurations. The results include configurations in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last configuration on that page).
    public var marker: Swift.String?
    /// The maximum number of field-level encryption configurations you want in the response body.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFieldLevelEncryptionConfigsInputBody: Swift.Equatable {
}

extension ListFieldLevelEncryptionConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFieldLevelEncryptionConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListFieldLevelEncryptionConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFieldLevelEncryptionConfigsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFieldLevelEncryptionConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionList = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionList = output
            } else {
                self.fieldLevelEncryptionList = nil
            }
        } else {
            self.fieldLevelEncryptionList = nil
        }
    }
}

public struct ListFieldLevelEncryptionConfigsOutputResponse: Swift.Equatable {
    /// Returns a list of all field-level encryption configurations that have been created in CloudFront for this account.
    public var fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList?

    public init (
        fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList? = nil
    )
    {
        self.fieldLevelEncryptionList = fieldLevelEncryptionList
    }
}

struct ListFieldLevelEncryptionConfigsOutputResponseBody: Swift.Equatable {
    let fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList?
}

extension ListFieldLevelEncryptionConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionList = "FieldLevelEncryptionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionList.self, forKey: .fieldLevelEncryptionList)
        fieldLevelEncryptionList = fieldLevelEncryptionListDecoded
    }
}

extension ListFieldLevelEncryptionProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFieldLevelEncryptionProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/field-level-encryption-profile"
    }
}

public struct ListFieldLevelEncryptionProfilesInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of profiles. The results include profiles in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last profile on that page).
    public var marker: Swift.String?
    /// The maximum number of field-level encryption profiles you want in the response body.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFieldLevelEncryptionProfilesInputBody: Swift.Equatable {
}

extension ListFieldLevelEncryptionProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFieldLevelEncryptionProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListFieldLevelEncryptionProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFieldLevelEncryptionProfilesOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFieldLevelEncryptionProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionProfileList = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionProfileList = output
            } else {
                self.fieldLevelEncryptionProfileList = nil
            }
        } else {
            self.fieldLevelEncryptionProfileList = nil
        }
    }
}

public struct ListFieldLevelEncryptionProfilesOutputResponse: Swift.Equatable {
    /// Returns a list of the field-level encryption profiles that have been created in CloudFront for this account.
    public var fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList?

    public init (
        fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList? = nil
    )
    {
        self.fieldLevelEncryptionProfileList = fieldLevelEncryptionProfileList
    }
}

struct ListFieldLevelEncryptionProfilesOutputResponseBody: Swift.Equatable {
    let fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList?
}

extension ListFieldLevelEncryptionProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileList = "FieldLevelEncryptionProfileList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileList.self, forKey: .fieldLevelEncryptionProfileList)
        fieldLevelEncryptionProfileList = fieldLevelEncryptionProfileListDecoded
    }
}

extension ListFunctionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let stage = stage {
            let stageQueryItem = ClientRuntime.URLQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
            items.append(stageQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFunctionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/function"
    }
}

public struct ListFunctionsInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of functions. The response includes functions in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of functions that you want in the response.
    public var maxItems: Swift.Int?
    /// An optional filter to return only the functions that are in the specified stage, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.stage = stage
    }
}

struct ListFunctionsInputBody: Swift.Equatable {
}

extension ListFunctionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListFunctionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FunctionList = try responseDecoder.decode(responseBody: data)
                self.functionList = output
            } else {
                self.functionList = nil
            }
        } else {
            self.functionList = nil
        }
    }
}

public struct ListFunctionsOutputResponse: Swift.Equatable {
    /// A list of CloudFront functions.
    public var functionList: CloudFrontClientTypes.FunctionList?

    public init (
        functionList: CloudFrontClientTypes.FunctionList? = nil
    )
    {
        self.functionList = functionList
    }
}

struct ListFunctionsOutputResponseBody: Swift.Equatable {
    let functionList: CloudFrontClientTypes.FunctionList?
}

extension ListFunctionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionList = "FunctionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionList.self, forKey: .functionList)
        functionList = functionListDecoded
    }
}

extension ListInvalidationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListInvalidationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let distributionId = distributionId else {
            return nil
        }
        return "/2020-05-31/distribution/\(distributionId.urlPercentEncoding())/invalidation"
    }
}

/// The request to list invalidations.
public struct ListInvalidationsInput: Swift.Equatable {
    /// The distribution's ID.
    /// This member is required.
    public var distributionId: Swift.String?
    /// Use this parameter when paginating results to indicate where to begin in your list of invalidation batches. Because the results are returned in decreasing order from most recent to oldest, the most recent results are on the first page, the second page will contain earlier results, and so on. To get the next page of results, set Marker to the value of the NextMarker from the current page's response. This value is the same as the ID of the last invalidation batch on that page.
    public var marker: Swift.String?
    /// The maximum number of invalidation batches that you want in the response body.
    public var maxItems: Swift.Int?

    public init (
        distributionId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.distributionId = distributionId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListInvalidationsInputBody: Swift.Equatable {
}

extension ListInvalidationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListInvalidationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListInvalidationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInvalidationsOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchDistribution(NoSuchDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInvalidationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.InvalidationList = try responseDecoder.decode(responseBody: data)
                self.invalidationList = output
            } else {
                self.invalidationList = nil
            }
        } else {
            self.invalidationList = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct ListInvalidationsOutputResponse: Swift.Equatable {
    /// Information about invalidation batches.
    public var invalidationList: CloudFrontClientTypes.InvalidationList?

    public init (
        invalidationList: CloudFrontClientTypes.InvalidationList? = nil
    )
    {
        self.invalidationList = invalidationList
    }
}

struct ListInvalidationsOutputResponseBody: Swift.Equatable {
    let invalidationList: CloudFrontClientTypes.InvalidationList?
}

extension ListInvalidationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidationList = "InvalidationList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.InvalidationList.self, forKey: .invalidationList)
        invalidationList = invalidationListDecoded
    }
}

extension ListKeyGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListKeyGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/key-group"
    }
}

public struct ListKeyGroupsInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of key groups. The response includes key groups in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of key groups that you want in the response.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListKeyGroupsInputBody: Swift.Equatable {
}

extension ListKeyGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListKeyGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListKeyGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListKeyGroupsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListKeyGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.KeyGroupList = try responseDecoder.decode(responseBody: data)
                self.keyGroupList = output
            } else {
                self.keyGroupList = nil
            }
        } else {
            self.keyGroupList = nil
        }
    }
}

public struct ListKeyGroupsOutputResponse: Swift.Equatable {
    /// A list of key groups.
    public var keyGroupList: CloudFrontClientTypes.KeyGroupList?

    public init (
        keyGroupList: CloudFrontClientTypes.KeyGroupList? = nil
    )
    {
        self.keyGroupList = keyGroupList
    }
}

struct ListKeyGroupsOutputResponseBody: Swift.Equatable {
    let keyGroupList: CloudFrontClientTypes.KeyGroupList?
}

extension ListKeyGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupList = "KeyGroupList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupList.self, forKey: .keyGroupList)
        keyGroupList = keyGroupListDecoded
    }
}

extension ListOriginRequestPoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let type = type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListOriginRequestPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/origin-request-policy"
    }
}

public struct ListOriginRequestPoliciesInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of origin request policies. The response includes origin request policies in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of origin request policies that you want in the response.
    public var maxItems: Swift.Int?
    /// A filter to return only the specified kinds of origin request policies. Valid values are:
    ///
    /// * managed – Returns only the managed policies created by Amazon Web Services.
    ///
    /// * custom – Returns only the custom policies created in your Amazon Web Services account.
    public var type: CloudFrontClientTypes.OriginRequestPolicyType?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.OriginRequestPolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

struct ListOriginRequestPoliciesInputBody: Swift.Equatable {
}

extension ListOriginRequestPoliciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListOriginRequestPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListOriginRequestPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOriginRequestPoliciesOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOriginRequestPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.OriginRequestPolicyList = try responseDecoder.decode(responseBody: data)
                self.originRequestPolicyList = output
            } else {
                self.originRequestPolicyList = nil
            }
        } else {
            self.originRequestPolicyList = nil
        }
    }
}

public struct ListOriginRequestPoliciesOutputResponse: Swift.Equatable {
    /// A list of origin request policies.
    public var originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList?

    public init (
        originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList? = nil
    )
    {
        self.originRequestPolicyList = originRequestPolicyList
    }
}

struct ListOriginRequestPoliciesOutputResponseBody: Swift.Equatable {
    let originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList?
}

extension ListOriginRequestPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyList = "OriginRequestPolicyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyList.self, forKey: .originRequestPolicyList)
        originRequestPolicyList = originRequestPolicyListDecoded
    }
}

extension ListPublicKeysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListPublicKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/public-key"
    }
}

public struct ListPublicKeysInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of public keys. The results include public keys in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last public key on that page).
    public var marker: Swift.String?
    /// The maximum number of public keys you want in the response body.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListPublicKeysInputBody: Swift.Equatable {
}

extension ListPublicKeysInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPublicKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPublicKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPublicKeysOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPublicKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.PublicKeyList = try responseDecoder.decode(responseBody: data)
                self.publicKeyList = output
            } else {
                self.publicKeyList = nil
            }
        } else {
            self.publicKeyList = nil
        }
    }
}

public struct ListPublicKeysOutputResponse: Swift.Equatable {
    /// Returns a list of all public keys that have been added to CloudFront for this account.
    public var publicKeyList: CloudFrontClientTypes.PublicKeyList?

    public init (
        publicKeyList: CloudFrontClientTypes.PublicKeyList? = nil
    )
    {
        self.publicKeyList = publicKeyList
    }
}

struct ListPublicKeysOutputResponseBody: Swift.Equatable {
    let publicKeyList: CloudFrontClientTypes.PublicKeyList?
}

extension ListPublicKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyList = "PublicKeyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyList.self, forKey: .publicKeyList)
        publicKeyList = publicKeyListDecoded
    }
}

extension ListRealtimeLogConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension ListRealtimeLogConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/realtime-log-config"
    }
}

public struct ListRealtimeLogConfigsInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of real-time log configurations. The response includes real-time log configurations in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of real-time log configurations that you want in the response.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListRealtimeLogConfigsInputBody: Swift.Equatable {
}

extension ListRealtimeLogConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRealtimeLogConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListRealtimeLogConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRealtimeLogConfigsOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRealtimeLogConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.RealtimeLogConfigs = try responseDecoder.decode(responseBody: data)
                self.realtimeLogConfigs = output
            } else {
                self.realtimeLogConfigs = nil
            }
        } else {
            self.realtimeLogConfigs = nil
        }
    }
}

public struct ListRealtimeLogConfigsOutputResponse: Swift.Equatable {
    /// A list of real-time log configurations.
    public var realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs?

    public init (
        realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs? = nil
    )
    {
        self.realtimeLogConfigs = realtimeLogConfigs
    }
}

struct ListRealtimeLogConfigsOutputResponseBody: Swift.Equatable {
    let realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs?
}

extension ListRealtimeLogConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfigs = "RealtimeLogConfigs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfigs.self, forKey: .realtimeLogConfigs)
        realtimeLogConfigs = realtimeLogConfigsDecoded
    }
}

extension ListResponseHeadersPoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let type = type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListResponseHeadersPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/response-headers-policy"
    }
}

public struct ListResponseHeadersPoliciesInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of response headers policies. The response includes response headers policies in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of response headers policies that you want to get in the response.
    public var maxItems: Swift.Int?
    /// A filter to get only the specified kind of response headers policies. Valid values are:
    ///
    /// * managed – Gets only the managed policies created by Amazon Web Services.
    ///
    /// * custom – Gets only the custom policies created in your Amazon Web Services account.
    public var type: CloudFrontClientTypes.ResponseHeadersPolicyType?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.ResponseHeadersPolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

struct ListResponseHeadersPoliciesInputBody: Swift.Equatable {
}

extension ListResponseHeadersPoliciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListResponseHeadersPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListResponseHeadersPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResponseHeadersPolicy" : self = .noSuchResponseHeadersPolicy(try NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResponseHeadersPoliciesOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchResponseHeadersPolicy(NoSuchResponseHeadersPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResponseHeadersPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.ResponseHeadersPolicyList = try responseDecoder.decode(responseBody: data)
                self.responseHeadersPolicyList = output
            } else {
                self.responseHeadersPolicyList = nil
            }
        } else {
            self.responseHeadersPolicyList = nil
        }
    }
}

public struct ListResponseHeadersPoliciesOutputResponse: Swift.Equatable {
    /// A list of response headers policies.
    public var responseHeadersPolicyList: CloudFrontClientTypes.ResponseHeadersPolicyList?

    public init (
        responseHeadersPolicyList: CloudFrontClientTypes.ResponseHeadersPolicyList? = nil
    )
    {
        self.responseHeadersPolicyList = responseHeadersPolicyList
    }
}

struct ListResponseHeadersPoliciesOutputResponseBody: Swift.Equatable {
    let responseHeadersPolicyList: CloudFrontClientTypes.ResponseHeadersPolicyList?
}

extension ListResponseHeadersPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicyList = "ResponseHeadersPolicyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseHeadersPolicyListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyList.self, forKey: .responseHeadersPolicyList)
        responseHeadersPolicyList = responseHeadersPolicyListDecoded
    }
}

extension ListStreamingDistributionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListStreamingDistributionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/streaming-distribution"
    }
}

/// The request to list your streaming distributions.
public struct ListStreamingDistributionsInput: Swift.Equatable {
    /// The value that you provided for the Marker request parameter.
    public var marker: Swift.String?
    /// The value that you provided for the MaxItems request parameter.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListStreamingDistributionsInputBody: Swift.Equatable {
}

extension ListStreamingDistributionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListStreamingDistributionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListStreamingDistributionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamingDistributionsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamingDistributionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistributionList = try responseDecoder.decode(responseBody: data)
                self.streamingDistributionList = output
            } else {
                self.streamingDistributionList = nil
            }
        } else {
            self.streamingDistributionList = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct ListStreamingDistributionsOutputResponse: Swift.Equatable {
    /// The StreamingDistributionList type.
    public var streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList?

    public init (
        streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList? = nil
    )
    {
        self.streamingDistributionList = streamingDistributionList
    }
}

struct ListStreamingDistributionsOutputResponseBody: Swift.Equatable {
    let streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList?
}

extension ListStreamingDistributionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionList = "StreamingDistributionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionList.self, forKey: .streamingDistributionList)
        streamingDistributionList = streamingDistributionListDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resource = resource {
            let resourceQueryItem = ClientRuntime.URLQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
            items.append(resourceQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/tagging"
    }
}

/// The request to list tags for a CloudFront resource.
public struct ListTagsForResourceInput: Swift.Equatable {
    /// An ARN of a CloudFront resource.
    /// This member is required.
    public var resource: Swift.String?

    public init (
        resource: Swift.String? = nil
    )
    {
        self.resource = resource
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case invalidTagging(InvalidTagging)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Tags = try responseDecoder.decode(responseBody: data)
                self.tags = output
            } else {
                self.tags = nil
            }
        } else {
            self.tags = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A complex type that contains zero or more Tag elements.
    /// This member is required.
    public var tags: CloudFrontClientTypes.Tags?

    public init (
        tags: CloudFrontClientTypes.Tags? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: CloudFrontClientTypes.Tags?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension CloudFrontClientTypes.LoggingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case enabled = "Enabled"
        case includeCookies = "IncludeCookies"
        case `prefix` = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let includeCookies = includeCookies {
            try container.encode(includeCookies, forKey: ClientRuntime.Key("IncludeCookies"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let includeCookiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeCookies)
        includeCookies = includeCookiesDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension CloudFrontClientTypes.LoggingConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls whether access logs are written for the distribution.
    public struct LoggingConfig: Swift.Equatable {
        /// The Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com.
        /// This member is required.
        public var bucket: Swift.String?
        /// Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't want to enable logging when you create a distribution or if you want to disable logging for an existing distribution, specify false for Enabled, and specify empty Bucket and Prefix elements. If you specify false for Enabled but you specify values for Bucket, prefix, and IncludeCookies, the values are automatically deleted.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Specifies whether you want CloudFront to include cookies in access logs, specify true for IncludeCookies. If you choose to include cookies in logs, CloudFront logs all cookies regardless of how you configure the cache behaviors for this distribution. If you don't want to include cookies when you create a distribution or if you want to disable include cookies for an existing distribution, specify false for IncludeCookies.
        /// This member is required.
        public var includeCookies: Swift.Bool?
        /// An optional string that you want CloudFront to prefix to the access log filenames for this distribution, for example, myprefix/. If you want to enable logging, but you don't want to specify a prefix, you still must include an empty Prefix element in the Logging element.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            includeCookies: Swift.Bool? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.includeCookies = includeCookies
            self.`prefix` = `prefix`
        }
    }

}

extension CloudFrontClientTypes {
    public enum Method: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [Method] {
            return [
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Method(rawValue: rawValue) ?? Method.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum MinimumProtocolVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sslv3
        case tlsv1
        case tlsv112016
        case tlsv12016
        case tlsv122018
        case tlsv122019
        case tlsv122021
        case sdkUnknown(Swift.String)

        public static var allCases: [MinimumProtocolVersion] {
            return [
                .sslv3,
                .tlsv1,
                .tlsv112016,
                .tlsv12016,
                .tlsv122018,
                .tlsv122019,
                .tlsv122021,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sslv3: return "SSLv3"
            case .tlsv1: return "TLSv1"
            case .tlsv112016: return "TLSv1.1_2016"
            case .tlsv12016: return "TLSv1_2016"
            case .tlsv122018: return "TLSv1.2_2018"
            case .tlsv122019: return "TLSv1.2_2019"
            case .tlsv122021: return "TLSv1.2_2021"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MinimumProtocolVersion(rawValue: rawValue) ?? MinimumProtocolVersion.sdkUnknown(rawValue)
        }
    }
}

extension MissingBody {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<MissingBodyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This operation requires a body. Ensure that the body is present and the Content-Type header is set.
public struct MissingBody: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MissingBodyBody: Swift.Equatable {
    let message: Swift.String?
}

extension MissingBodyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.MonitoringSubscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeMetricsSubscriptionConfig = "RealtimeMetricsSubscriptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfig {
            try container.encode(realtimeMetricsSubscriptionConfig, forKey: ClientRuntime.Key("RealtimeMetricsSubscriptionConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeMetricsSubscriptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig.self, forKey: .realtimeMetricsSubscriptionConfig)
        realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfigDecoded
    }
}

extension CloudFrontClientTypes.MonitoringSubscription: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    public struct MonitoringSubscription: Swift.Equatable {
        /// A subscription configuration for additional CloudWatch metrics.
        public var realtimeMetricsSubscriptionConfig: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig?

        public init (
            realtimeMetricsSubscriptionConfig: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig? = nil
        )
        {
            self.realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfig
        }
    }

}

extension NoSuchCachePolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The cache policy does not exist.
public struct NoSuchCachePolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchCachePolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchCloudFrontOriginAccessIdentity {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchCloudFrontOriginAccessIdentityBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified origin access identity does not exist.
public struct NoSuchCloudFrontOriginAccessIdentity: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchCloudFrontOriginAccessIdentityBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchCloudFrontOriginAccessIdentityBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchDistribution {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified distribution does not exist.
public struct NoSuchDistribution: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchDistributionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchFieldLevelEncryptionConfig {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchFieldLevelEncryptionConfigBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified configuration for field-level encryption doesn't exist.
public struct NoSuchFieldLevelEncryptionConfig: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchFieldLevelEncryptionConfigBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchFieldLevelEncryptionConfigBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchFieldLevelEncryptionProfile {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchFieldLevelEncryptionProfileBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified profile for field-level encryption doesn't exist.
public struct NoSuchFieldLevelEncryptionProfile: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchFieldLevelEncryptionProfileBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchFieldLevelEncryptionProfileBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchFunctionExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchFunctionExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The function does not exist.
public struct NoSuchFunctionExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchFunctionExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchFunctionExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchInvalidation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchInvalidationBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified invalidation does not exist.
public struct NoSuchInvalidation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchInvalidationBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchInvalidationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchOrigin {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchOriginBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No origin exists with the specified Origin Id.
public struct NoSuchOrigin: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchOriginBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchOriginBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchOriginRequestPolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The origin request policy does not exist.
public struct NoSuchOriginRequestPolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchOriginRequestPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchPublicKey {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchPublicKeyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified public key doesn't exist.
public struct NoSuchPublicKey: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchPublicKeyBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchPublicKeyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchRealtimeLogConfig {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchRealtimeLogConfigBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The real-time log configuration does not exist.
public struct NoSuchRealtimeLogConfig: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchRealtimeLogConfigBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchRealtimeLogConfigBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchResource {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchResourceBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource that was specified is not valid.
public struct NoSuchResource: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchResourceBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchResourceBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchResponseHeadersPolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchResponseHeadersPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The response headers policy does not exist.
public struct NoSuchResponseHeadersPolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchResponseHeadersPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchResponseHeadersPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchStreamingDistribution {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchStreamingDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified streaming distribution does not exist.
public struct NoSuchStreamingDistribution: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchStreamingDistributionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchStreamingDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.Origin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionAttempts = "ConnectionAttempts"
        case connectionTimeout = "ConnectionTimeout"
        case customHeaders = "CustomHeaders"
        case customOriginConfig = "CustomOriginConfig"
        case domainName = "DomainName"
        case id = "Id"
        case originPath = "OriginPath"
        case originShield = "OriginShield"
        case s3OriginConfig = "S3OriginConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let connectionAttempts = connectionAttempts {
            try container.encode(connectionAttempts, forKey: ClientRuntime.Key("ConnectionAttempts"))
        }
        if let connectionTimeout = connectionTimeout {
            try container.encode(connectionTimeout, forKey: ClientRuntime.Key("ConnectionTimeout"))
        }
        if let customHeaders = customHeaders {
            try container.encode(customHeaders, forKey: ClientRuntime.Key("CustomHeaders"))
        }
        if let customOriginConfig = customOriginConfig {
            try container.encode(customOriginConfig, forKey: ClientRuntime.Key("CustomOriginConfig"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let originPath = originPath {
            try container.encode(originPath, forKey: ClientRuntime.Key("OriginPath"))
        }
        if let originShield = originShield {
            try container.encode(originShield, forKey: ClientRuntime.Key("OriginShield"))
        }
        if let s3OriginConfig = s3OriginConfig {
            try container.encode(s3OriginConfig, forKey: ClientRuntime.Key("S3OriginConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let originPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originPath)
        originPath = originPathDecoded
        let customHeadersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomHeaders.self, forKey: .customHeaders)
        customHeaders = customHeadersDecoded
        let s3OriginConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.S3OriginConfig.self, forKey: .s3OriginConfig)
        s3OriginConfig = s3OriginConfigDecoded
        let customOriginConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomOriginConfig.self, forKey: .customOriginConfig)
        customOriginConfig = customOriginConfigDecoded
        let connectionAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionAttempts)
        connectionAttempts = connectionAttemptsDecoded
        let connectionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionTimeout)
        connectionTimeout = connectionTimeoutDecoded
        let originShieldDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginShield.self, forKey: .originShield)
        originShield = originShieldDecoded
    }
}

extension CloudFrontClientTypes.Origin: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An origin. An origin is the location where content is stored, and from which CloudFront gets content to serve to viewers. To specify an origin:
    ///
    /// * Use S3OriginConfig to specify an Amazon S3 bucket that is not configured with static website hosting.
    ///
    /// * Use CustomOriginConfig to specify all other kinds of origins, including:
    ///
    /// * An Amazon S3 bucket that is configured with static website hosting
    ///
    /// * An Elastic Load Balancing load balancer
    ///
    /// * An AWS Elemental MediaPackage endpoint
    ///
    /// * An AWS Elemental MediaStore container
    ///
    /// * Any other HTTP server, running on an Amazon EC2 instance or any other kind of host
    ///
    ///
    ///
    ///
    ///
    /// For the current maximum number of origins that you can specify per distribution, see [General Quotas on Web Distributions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html#limits-web-distributions) in the Amazon CloudFront Developer Guide (quotas were formerly referred to as limits).
    public struct Origin: Swift.Equatable {
        /// The number of times that CloudFront attempts to connect to the origin. The minimum number is 1, the maximum is 3, and the default (if you don’t specify otherwise) is 3. For a custom origin (including an Amazon S3 bucket that’s configured with static website hosting), this value also specifies the number of times that CloudFront attempts to get a response from the origin, in the case of an [Origin Response Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout). For more information, see [Origin Connection Attempts](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-attempts) in the Amazon CloudFront Developer Guide.
        public var connectionAttempts: Swift.Int?
        /// The number of seconds that CloudFront waits when trying to establish a connection to the origin. The minimum timeout is 1 second, the maximum is 10 seconds, and the default (if you don’t specify otherwise) is 10 seconds. For more information, see [Origin Connection Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-timeout) in the Amazon CloudFront Developer Guide.
        public var connectionTimeout: Swift.Int?
        /// A list of HTTP header names and values that CloudFront adds to the requests that it sends to the origin. For more information, see [Adding Custom Headers to Origin Requests](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/add-origin-custom-headers.html) in the Amazon CloudFront Developer Guide.
        public var customHeaders: CloudFrontClientTypes.CustomHeaders?
        /// Use this type to specify an origin that is not an Amazon S3 bucket, with one exception. If the Amazon S3 bucket is configured with static website hosting, use this type. If the Amazon S3 bucket is not configured with static website hosting, use the S3OriginConfig type instead.
        public var customOriginConfig: CloudFrontClientTypes.CustomOriginConfig?
        /// The domain name for the origin. For more information, see [Origin Domain Name](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesDomainName) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var domainName: Swift.String?
        /// A unique identifier for the origin. This value must be unique within the distribution. Use this value to specify the TargetOriginId in a CacheBehavior or DefaultCacheBehavior.
        /// This member is required.
        public var id: Swift.String?
        /// An optional path that CloudFront appends to the origin domain name when CloudFront requests content from the origin. For more information, see [Origin Path](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginPath) in the Amazon CloudFront Developer Guide.
        public var originPath: Swift.String?
        /// CloudFront Origin Shield. Using Origin Shield can help reduce the load on your origin. For more information, see [Using Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html) in the Amazon CloudFront Developer Guide.
        public var originShield: CloudFrontClientTypes.OriginShield?
        /// Use this type to specify an origin that is an Amazon S3 bucket that is not configured with static website hosting. To specify any other type of origin, including an Amazon S3 bucket that is configured with static website hosting, use the CustomOriginConfig type instead.
        public var s3OriginConfig: CloudFrontClientTypes.S3OriginConfig?

        public init (
            connectionAttempts: Swift.Int? = nil,
            connectionTimeout: Swift.Int? = nil,
            customHeaders: CloudFrontClientTypes.CustomHeaders? = nil,
            customOriginConfig: CloudFrontClientTypes.CustomOriginConfig? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            originPath: Swift.String? = nil,
            originShield: CloudFrontClientTypes.OriginShield? = nil,
            s3OriginConfig: CloudFrontClientTypes.S3OriginConfig? = nil
        )
        {
            self.connectionAttempts = connectionAttempts
            self.connectionTimeout = connectionTimeout
            self.customHeaders = customHeaders
            self.customOriginConfig = customOriginConfig
            self.domainName = domainName
            self.id = id
            self.originPath = originPath
            self.originShield = originShield
            self.s3OriginConfig = s3OriginConfig
        }
    }

}

extension CloudFrontClientTypes.OriginCustomHeader: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerName = "HeaderName"
        case headerValue = "HeaderValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let headerName = headerName {
            try container.encode(headerName, forKey: ClientRuntime.Key("HeaderName"))
        }
        if let headerValue = headerValue {
            try container.encode(headerValue, forKey: ClientRuntime.Key("HeaderValue"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headerName)
        headerName = headerNameDecoded
        let headerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headerValue)
        headerValue = headerValueDecoded
    }
}

extension CloudFrontClientTypes.OriginCustomHeader: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains HeaderName and HeaderValue elements, if any, for this distribution.
    public struct OriginCustomHeader: Swift.Equatable {
        /// The name of a header that you want CloudFront to send to your origin. For more information, see [Adding Custom Headers to Origin Requests](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/forward-custom-headers.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var headerName: Swift.String?
        /// The value for the header that you specified in the HeaderName field.
        /// This member is required.
        public var headerValue: Swift.String?

        public init (
            headerName: Swift.String? = nil,
            headerValue: Swift.String? = nil
        )
        {
            self.headerName = headerName
            self.headerValue = headerValue
        }
    }

}

extension CloudFrontClientTypes.OriginGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failoverCriteria = "FailoverCriteria"
        case id = "Id"
        case members = "Members"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let failoverCriteria = failoverCriteria {
            try container.encode(failoverCriteria, forKey: ClientRuntime.Key("FailoverCriteria"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let members = members {
            try container.encode(members, forKey: ClientRuntime.Key("Members"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let failoverCriteriaDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroupFailoverCriteria.self, forKey: .failoverCriteria)
        failoverCriteria = failoverCriteriaDecoded
        let membersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroupMembers.self, forKey: .members)
        members = membersDecoded
    }
}

extension CloudFrontClientTypes.OriginGroup: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An origin group includes two origins (a primary origin and a second origin to failover to) and a failover criteria that you specify. You create an origin group to support origin failover in CloudFront. When you create or update a distribution, you can specifiy the origin group instead of a single origin, and CloudFront will failover from the primary origin to the second origin under the failover conditions that you've chosen.
    public struct OriginGroup: Swift.Equatable {
        /// A complex type that contains information about the failover criteria for an origin group.
        /// This member is required.
        public var failoverCriteria: CloudFrontClientTypes.OriginGroupFailoverCriteria?
        /// The origin group's ID.
        /// This member is required.
        public var id: Swift.String?
        /// A complex type that contains information about the origins in an origin group.
        /// This member is required.
        public var members: CloudFrontClientTypes.OriginGroupMembers?

        public init (
            failoverCriteria: CloudFrontClientTypes.OriginGroupFailoverCriteria? = nil,
            id: Swift.String? = nil,
            members: CloudFrontClientTypes.OriginGroupMembers? = nil
        )
        {
            self.failoverCriteria = failoverCriteria
            self.id = id
            self.members = members
        }
    }

}

extension CloudFrontClientTypes.OriginGroupFailoverCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCodes = "StatusCodes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let statusCodes = statusCodes {
            try container.encode(statusCodes, forKey: ClientRuntime.Key("StatusCodes"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StatusCodes.self, forKey: .statusCodes)
        statusCodes = statusCodesDecoded
    }
}

extension CloudFrontClientTypes.OriginGroupFailoverCriteria: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes information about the failover criteria for an origin group, including the status codes for which CloudFront will failover from the primary origin to the second origin.
    public struct OriginGroupFailoverCriteria: Swift.Equatable {
        /// The status codes that, when returned from the primary origin, will trigger CloudFront to failover to the second origin.
        /// This member is required.
        public var statusCodes: CloudFrontClientTypes.StatusCodes?

        public init (
            statusCodes: CloudFrontClientTypes.StatusCodes? = nil
        )
        {
            self.statusCodes = statusCodes
        }
    }

}

extension CloudFrontClientTypes.OriginGroupMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originId = "OriginId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originId = originId {
            try container.encode(originId, forKey: ClientRuntime.Key("OriginId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originId)
        originId = originIdDecoded
    }
}

extension CloudFrontClientTypes.OriginGroupMember: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An origin in an origin group.
    public struct OriginGroupMember: Swift.Equatable {
        /// The ID for an origin in an origin group.
        /// This member is required.
        public var originId: Swift.String?

        public init (
            originId: Swift.String? = nil
        )
        {
            self.originId = originId
        }
    }

}

extension CloudFrontClientTypes.OriginGroupMembers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origingroupmember0 in items {
                try itemsContainer.encode(origingroupmember0, forKey: ClientRuntime.Key("OriginGroupMember"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginGroupMember{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginGroupMember>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginGroupMember].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginGroupMember]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginGroupMember]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginGroupMembers: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for the origins included in an origin group.
    public struct OriginGroupMembers: Swift.Equatable {
        /// Items (origins) in an origin group.
        /// This member is required.
        public var items: [CloudFrontClientTypes.OriginGroupMember]?
        /// The number of origins in an origin group.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.OriginGroupMember]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.OriginGroups: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origingroup0 in items {
                try itemsContainer.encode(origingroup0, forKey: ClientRuntime.Key("OriginGroup"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginGroup{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginGroup>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginGroup].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginGroup]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginGroup]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginGroups: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for the origin groups specified for a distribution.
    public struct OriginGroups: Swift.Equatable {
        /// The items (origin groups) in a distribution.
        public var items: [CloudFrontClientTypes.OriginGroup]?
        /// The number of origin groups.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.OriginGroup]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginProtocolPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case httpOnly
        case httpsOnly
        case matchViewer
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginProtocolPolicy] {
            return [
                .httpOnly,
                .httpsOnly,
                .matchViewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .httpOnly: return "http-only"
            case .httpsOnly: return "https-only"
            case .matchViewer: return "match-viewer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginProtocolPolicy(rawValue: rawValue) ?? OriginProtocolPolicy.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let originRequestPolicyConfig = originRequestPolicyConfig {
            try container.encode(originRequestPolicyConfig, forKey: ClientRuntime.Key("OriginRequestPolicyConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An origin request policy. When it’s attached to a cache behavior, the origin request policy determines the values that CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends to the origin includes the following:
    ///
    /// * The request body and the URL path (without the domain name) from the viewer request.
    ///
    /// * The headers that CloudFront automatically includes in every origin request, including Host, User-Agent, and X-Amz-Cf-Id.
    ///
    /// * All HTTP headers, cookies, and URL query strings that are specified in the cache policy or the origin request policy. These can include items from the viewer request and, in the case of headers, additional ones that are added by CloudFront.
    ///
    ///
    /// CloudFront sends a request when it can’t find an object in its cache that matches the request. If you want to send values to the origin and also include them in the cache key, use CachePolicy.
    public struct OriginRequestPolicy: Swift.Equatable {
        /// The unique identifier for the origin request policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time when the origin request policy was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The origin request policy configuration.
        /// This member is required.
        public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

        public init (
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
        )
        {
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.originRequestPolicyConfig = originRequestPolicyConfig
        }
    }

}

extension OriginRequestPolicyAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<OriginRequestPolicyAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An origin request policy with this name already exists. You must provide a unique name. To modify an existing origin request policy, use UpdateOriginRequestPolicy.
public struct OriginRequestPolicyAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OriginRequestPolicyAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension OriginRequestPolicyAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case cookiesConfig = "CookiesConfig"
        case headersConfig = "HeadersConfig"
        case name = "Name"
        case queryStringsConfig = "QueryStringsConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let cookiesConfig = cookiesConfig {
            try container.encode(cookiesConfig, forKey: ClientRuntime.Key("CookiesConfig"))
        }
        if let headersConfig = headersConfig {
            try container.encode(headersConfig, forKey: ClientRuntime.Key("HeadersConfig"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let queryStringsConfig = queryStringsConfig {
            try container.encode(queryStringsConfig, forKey: ClientRuntime.Key("QueryStringsConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let headersConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyHeadersConfig.self, forKey: .headersConfig)
        headersConfig = headersConfigDecoded
        let cookiesConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyCookiesConfig.self, forKey: .cookiesConfig)
        cookiesConfig = cookiesConfigDecoded
        let queryStringsConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig.self, forKey: .queryStringsConfig)
        queryStringsConfig = queryStringsConfigDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An origin request policy configuration. This configuration determines the values that CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends to the origin includes the following:
    ///
    /// * The request body and the URL path (without the domain name) from the viewer request.
    ///
    /// * The headers that CloudFront automatically includes in every origin request, including Host, User-Agent, and X-Amz-Cf-Id.
    ///
    /// * All HTTP headers, cookies, and URL query strings that are specified in the cache policy or the origin request policy. These can include items from the viewer request and, in the case of headers, additional ones that are added by CloudFront.
    ///
    ///
    /// CloudFront sends a request when it can’t find an object in its cache that matches the request. If you want to send values to the origin and also include them in the cache key, use CachePolicy.
    public struct OriginRequestPolicyConfig: Swift.Equatable {
        /// A comment to describe the origin request policy. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The cookies from viewer requests to include in origin requests.
        /// This member is required.
        public var cookiesConfig: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig?
        /// The HTTP headers to include in origin requests. These can include headers from viewer requests and additional headers added by CloudFront.
        /// This member is required.
        public var headersConfig: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig?
        /// A unique name to identify the origin request policy.
        /// This member is required.
        public var name: Swift.String?
        /// The URL query strings from viewer requests to include in origin requests.
        /// This member is required.
        public var queryStringsConfig: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig?

        public init (
            comment: Swift.String? = nil,
            cookiesConfig: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig? = nil,
            headersConfig: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig? = nil,
            name: Swift.String? = nil,
            queryStringsConfig: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig? = nil
        )
        {
            self.comment = comment
            self.cookiesConfig = cookiesConfig
            self.headersConfig = headersConfig
            self.name = name
            self.queryStringsConfig = queryStringsConfig
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyCookieBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyCookieBehavior] {
            return [
                .all,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyCookieBehavior(rawValue: rawValue) ?? OriginRequestPolicyCookieBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyCookiesConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieBehavior = "CookieBehavior"
        case cookies = "Cookies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookieBehavior = cookieBehavior {
            try container.encode(cookieBehavior, forKey: ClientRuntime.Key("CookieBehavior"))
        }
        if let cookies = cookies {
            try container.encode(cookies, forKey: ClientRuntime.Key("Cookies"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cookieBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyCookieBehavior.self, forKey: .cookieBehavior)
        cookieBehavior = cookieBehaviorDecoded
        let cookiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookieNames.self, forKey: .cookies)
        cookies = cookiesDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyCookiesConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any cookies in viewer requests (and if so, which cookies) are included in requests that CloudFront sends to the origin.
    public struct OriginRequestPolicyCookiesConfig: Swift.Equatable {
        /// Determines whether cookies in viewer requests are included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – Cookies in viewer requests are not included in requests that CloudFront sends to the origin. Even when this field is set to none, any cookies that are listed in a CachePolicy are included in origin requests.
        ///
        /// * whitelist – The cookies in viewer requests that are listed in the CookieNames type are included in requests that CloudFront sends to the origin.
        ///
        /// * all – All cookies in viewer requests are included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var cookieBehavior: CloudFrontClientTypes.OriginRequestPolicyCookieBehavior?
        /// Contains a list of cookie names.
        public var cookies: CloudFrontClientTypes.CookieNames?

        public init (
            cookieBehavior: CloudFrontClientTypes.OriginRequestPolicyCookieBehavior? = nil,
            cookies: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.cookieBehavior = cookieBehavior
            self.cookies = cookies
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyHeaderBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allviewer
        case allviewerandwhitelistcloudfront
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyHeaderBehavior] {
            return [
                .allviewer,
                .allviewerandwhitelistcloudfront,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allviewer: return "allViewer"
            case .allviewerandwhitelistcloudfront: return "allViewerAndWhitelistCloudFront"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyHeaderBehavior(rawValue: rawValue) ?? OriginRequestPolicyHeaderBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyHeadersConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerBehavior = "HeaderBehavior"
        case headers = "Headers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let headerBehavior = headerBehavior {
            try container.encode(headerBehavior, forKey: ClientRuntime.Key("HeaderBehavior"))
        }
        if let headers = headers {
            try container.encode(headers, forKey: ClientRuntime.Key("Headers"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior.self, forKey: .headerBehavior)
        headerBehavior = headerBehaviorDecoded
        let headersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Headers.self, forKey: .headers)
        headers = headersDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyHeadersConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any HTTP headers (and if so, which headers) are included in requests that CloudFront sends to the origin.
    public struct OriginRequestPolicyHeadersConfig: Swift.Equatable {
        /// Determines whether any HTTP headers are included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – HTTP headers are not included in requests that CloudFront sends to the origin. Even when this field is set to none, any headers that are listed in a CachePolicy are included in origin requests.
        ///
        /// * whitelist – The HTTP headers that are listed in the Headers type are included in requests that CloudFront sends to the origin.
        ///
        /// * allViewer – All HTTP headers in viewer requests are included in requests that CloudFront sends to the origin.
        ///
        /// * allViewerAndWhitelistCloudFront – All HTTP headers in viewer requests and the additional CloudFront headers that are listed in the Headers type are included in requests that CloudFront sends to the origin. The additional headers are added by CloudFront.
        /// This member is required.
        public var headerBehavior: CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior?
        /// Contains a list of HTTP header names.
        public var headers: CloudFrontClientTypes.Headers?

        public init (
            headerBehavior: CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior? = nil,
            headers: CloudFrontClientTypes.Headers? = nil
        )
        {
            self.headerBehavior = headerBehavior
            self.headers = headers
        }
    }

}

extension OriginRequestPolicyInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<OriginRequestPolicyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot delete the origin request policy because it is attached to one or more cache behaviors.
public struct OriginRequestPolicyInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OriginRequestPolicyInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension OriginRequestPolicyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for originrequestpolicysummary0 in items {
                try itemsContainer.encode(originrequestpolicysummary0, forKey: ClientRuntime.Key("OriginRequestPolicySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginRequestPolicySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginRequestPolicySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginRequestPolicySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginRequestPolicySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginRequestPolicySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of origin request policies.
    public struct OriginRequestPolicyList: Swift.Equatable {
        /// Contains the origin request policies in the list.
        public var items: [CloudFrontClientTypes.OriginRequestPolicySummary]?
        /// The maximum number of origin request policies requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing origin request policies where you left off.
        public var nextMarker: Swift.String?
        /// The total number of origin request policies returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.OriginRequestPolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyQueryStringBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyQueryStringBehavior] {
            return [
                .all,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyQueryStringBehavior(rawValue: rawValue) ?? OriginRequestPolicyQueryStringBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryStringBehavior = "QueryStringBehavior"
        case queryStrings = "QueryStrings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let queryStringBehavior = queryStringBehavior {
            try container.encode(queryStringBehavior, forKey: ClientRuntime.Key("QueryStringBehavior"))
        }
        if let queryStrings = queryStrings {
            try container.encode(queryStrings, forKey: ClientRuntime.Key("QueryStrings"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior.self, forKey: .queryStringBehavior)
        queryStringBehavior = queryStringBehaviorDecoded
        let queryStringsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryStringNames.self, forKey: .queryStrings)
        queryStrings = queryStringsDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in requests that CloudFront sends to the origin.
    public struct OriginRequestPolicyQueryStringsConfig: Swift.Equatable {
        /// Determines whether any URL query strings in viewer requests are included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – Query strings in viewer requests are not included in requests that CloudFront sends to the origin. Even when this field is set to none, any query strings that are listed in a CachePolicy are included in origin requests.
        ///
        /// * whitelist – The query strings in viewer requests that are listed in the QueryStringNames type are included in requests that CloudFront sends to the origin.
        ///
        /// * all – All query strings in viewer requests are included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var queryStringBehavior: CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior?
        /// Contains a list of the query strings in viewer requests that are included in requests that CloudFront sends to the origin.
        public var queryStrings: CloudFrontClientTypes.QueryStringNames?

        public init (
            queryStringBehavior: CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior? = nil,
            queryStrings: CloudFrontClientTypes.QueryStringNames? = nil
        )
        {
            self.queryStringBehavior = queryStringBehavior
            self.queryStrings = queryStrings
        }
    }

}

extension CloudFrontClientTypes.OriginRequestPolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originRequestPolicy = originRequestPolicy {
            try container.encode(originRequestPolicy, forKey: ClientRuntime.Key("OriginRequestPolicy"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyType.self, forKey: .type)
        type = typeDecoded
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains an origin request policy.
    public struct OriginRequestPolicySummary: Swift.Equatable {
        /// The origin request policy.
        /// This member is required.
        public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
        /// The type of origin request policy, either managed (created by Amazon Web Services) or custom (created in this Amazon Web Services account).
        /// This member is required.
        public var type: CloudFrontClientTypes.OriginRequestPolicyType?

        public init (
            originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil,
            type: CloudFrontClientTypes.OriginRequestPolicyType? = nil
        )
        {
            self.originRequestPolicy = originRequestPolicy
            self.type = type
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyType] {
            return [
                .custom,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyType(rawValue: rawValue) ?? OriginRequestPolicyType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginShield: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case originShieldRegion = "OriginShieldRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let originShieldRegion = originShieldRegion {
            try container.encode(originShieldRegion, forKey: ClientRuntime.Key("OriginShieldRegion"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let originShieldRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originShieldRegion)
        originShieldRegion = originShieldRegionDecoded
    }
}

extension CloudFrontClientTypes.OriginShield: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// CloudFront Origin Shield. Using Origin Shield can help reduce the load on your origin. For more information, see [Using Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html) in the Amazon CloudFront Developer Guide.
    public struct OriginShield: Swift.Equatable {
        /// A flag that specifies whether Origin Shield is enabled. When it’s enabled, CloudFront routes all requests through Origin Shield, which can help protect your origin. When it’s disabled, CloudFront might send requests directly to your origin from multiple edge locations or regional edge caches.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The Amazon Web Services Region for Origin Shield. Specify the Amazon Web Services Region that has the lowest latency to your origin. To specify a region, use the region code, not the region name. For example, specify the US East (Ohio) region as us-east-2. When you enable CloudFront Origin Shield, you must specify the Amazon Web Services Region for Origin Shield. For the list of Amazon Web Services Regions that you can specify, and for help choosing the best Region for your origin, see [Choosing the Amazon Web Services Region for Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html#choose-origin-shield-region) in the Amazon CloudFront Developer Guide.
        public var originShieldRegion: Swift.String?

        public init (
            enabled: Swift.Bool? = nil,
            originShieldRegion: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.originShieldRegion = originShieldRegion
        }
    }

}

extension CloudFrontClientTypes.OriginSslProtocols: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for sslprotocol0 in items {
                try itemsContainer.encode(sslprotocol0, forKey: ClientRuntime.Key("SslProtocol"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct SslProtocol{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SslProtocol>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.SslProtocol].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.SslProtocol]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.SslProtocol]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginSslProtocols: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the SSL/TLS protocols that CloudFront can use when establishing an HTTPS connection with your origin.
    public struct OriginSslProtocols: Swift.Equatable {
        /// A list that contains allowed SSL/TLS protocols for this distribution.
        /// This member is required.
        public var items: [CloudFrontClientTypes.SslProtocol]?
        /// The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing an HTTPS connection with this origin.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.SslProtocol]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.Origins: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origin0 in items {
                try itemsContainer.encode(origin0, forKey: ClientRuntime.Key("Origin"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Origin{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Origin>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Origin].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Origin]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Origin]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Origins: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains information about the origins for this distribution.
    public struct Origins: Swift.Equatable {
        /// A list of origins.
        /// This member is required.
        public var items: [CloudFrontClientTypes.Origin]?
        /// The number of origins for this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.Origin]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookiesConfig = "CookiesConfig"
        case enableAcceptEncodingBrotli = "EnableAcceptEncodingBrotli"
        case enableAcceptEncodingGzip = "EnableAcceptEncodingGzip"
        case headersConfig = "HeadersConfig"
        case queryStringsConfig = "QueryStringsConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookiesConfig = cookiesConfig {
            try container.encode(cookiesConfig, forKey: ClientRuntime.Key("CookiesConfig"))
        }
        if let enableAcceptEncodingBrotli = enableAcceptEncodingBrotli {
            try container.encode(enableAcceptEncodingBrotli, forKey: ClientRuntime.Key("EnableAcceptEncodingBrotli"))
        }
        if let enableAcceptEncodingGzip = enableAcceptEncodingGzip {
            try container.encode(enableAcceptEncodingGzip, forKey: ClientRuntime.Key("EnableAcceptEncodingGzip"))
        }
        if let headersConfig = headersConfig {
            try container.encode(headersConfig, forKey: ClientRuntime.Key("HeadersConfig"))
        }
        if let queryStringsConfig = queryStringsConfig {
            try container.encode(queryStringsConfig, forKey: ClientRuntime.Key("QueryStringsConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableAcceptEncodingGzipDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAcceptEncodingGzip)
        enableAcceptEncodingGzip = enableAcceptEncodingGzipDecoded
        let enableAcceptEncodingBrotliDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAcceptEncodingBrotli)
        enableAcceptEncodingBrotli = enableAcceptEncodingBrotliDecoded
        let headersConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyHeadersConfig.self, forKey: .headersConfig)
        headersConfig = headersConfigDecoded
        let cookiesConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyCookiesConfig.self, forKey: .cookiesConfig)
        cookiesConfig = cookiesConfigDecoded
        let queryStringsConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyQueryStringsConfig.self, forKey: .queryStringsConfig)
        queryStringsConfig = queryStringsConfigDecoded
    }
}

extension CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// This object determines the values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer. The headers, cookies, and query strings that are included in the cache key are automatically included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t find an object in its cache that matches the request’s cache key. If you want to send values to the origin but not include them in the cache key, use OriginRequestPolicy.
    public struct ParametersInCacheKeyAndForwardedToOrigin: Swift.Equatable {
        /// An object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the cache key and automatically included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var cookiesConfig: CloudFrontClientTypes.CachePolicyCookiesConfig?
        /// A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin. This field is related to the EnableAcceptEncodingGzip field. If one or both of these fields is true and the viewer request includes the Accept-Encoding header, then CloudFront does the following:
        ///
        /// * Normalizes the value of the viewer’s Accept-Encoding header
        ///
        /// * Includes the normalized header in the cache key
        ///
        /// * Includes the normalized header in the request to the origin, if a request is necessary
        ///
        ///
        /// For more information, see [Compression support](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects) in the Amazon CloudFront Developer Guide. If you set this value to true, and this cache behavior also has an origin request policy attached, do not include the Accept-Encoding header in the origin request policy. CloudFront always includes the Accept-Encoding header in origin requests when the value of this field is true, so including this header in an origin request policy has no effect. If both of these fields are false, then CloudFront treats the Accept-Encoding header the same as any other HTTP header in the viewer request. By default, it’s not included in the cache key and it’s not included in origin requests. In this case, you can manually add Accept-Encoding to the headers whitelist like any other HTTP header.
        public var enableAcceptEncodingBrotli: Swift.Bool?
        /// A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin. This field is related to the EnableAcceptEncodingBrotli field. If one or both of these fields is true and the viewer request includes the Accept-Encoding header, then CloudFront does the following:
        ///
        /// * Normalizes the value of the viewer’s Accept-Encoding header
        ///
        /// * Includes the normalized header in the cache key
        ///
        /// * Includes the normalized header in the request to the origin, if a request is necessary
        ///
        ///
        /// For more information, see [Compression support](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects) in the Amazon CloudFront Developer Guide. If you set this value to true, and this cache behavior also has an origin request policy attached, do not include the Accept-Encoding header in the origin request policy. CloudFront always includes the Accept-Encoding header in origin requests when the value of this field is true, so including this header in an origin request policy has no effect. If both of these fields are false, then CloudFront treats the Accept-Encoding header the same as any other HTTP header in the viewer request. By default, it’s not included in the cache key and it’s not included in origin requests. In this case, you can manually add Accept-Encoding to the headers whitelist like any other HTTP header.
        /// This member is required.
        public var enableAcceptEncodingGzip: Swift.Bool?
        /// An object that determines whether any HTTP headers (and if so, which headers) are included in the cache key and automatically included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var headersConfig: CloudFrontClientTypes.CachePolicyHeadersConfig?
        /// An object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the cache key and automatically included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var queryStringsConfig: CloudFrontClientTypes.CachePolicyQueryStringsConfig?

        public init (
            cookiesConfig: CloudFrontClientTypes.CachePolicyCookiesConfig? = nil,
            enableAcceptEncodingBrotli: Swift.Bool? = nil,
            enableAcceptEncodingGzip: Swift.Bool? = nil,
            headersConfig: CloudFrontClientTypes.CachePolicyHeadersConfig? = nil,
            queryStringsConfig: CloudFrontClientTypes.CachePolicyQueryStringsConfig? = nil
        )
        {
            self.cookiesConfig = cookiesConfig
            self.enableAcceptEncodingBrotli = enableAcceptEncodingBrotli
            self.enableAcceptEncodingGzip = enableAcceptEncodingGzip
            self.headersConfig = headersConfig
            self.queryStringsConfig = queryStringsConfig
        }
    }

}

extension CloudFrontClientTypes.Paths: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Path"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Path{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Path>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Paths: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the objects that you want to invalidate. For more information, see [Specifying the Objects to Invalidate](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects) in the Amazon CloudFront Developer Guide.
    public struct Paths: Swift.Equatable {
        /// A complex type that contains a list of the paths that you want to invalidate.
        public var items: [Swift.String]?
        /// The number of invalidation paths specified for the objects that you want to invalidate.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension PreconditionFailed {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<PreconditionFailedBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The precondition in one or more of the request fields evaluated to false.
public struct PreconditionFailed: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PreconditionFailedBody: Swift.Equatable {
    let message: Swift.String?
}

extension PreconditionFailedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes {
    public enum PriceClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case priceclass100
        case priceclass200
        case priceclassAll
        case sdkUnknown(Swift.String)

        public static var allCases: [PriceClass] {
            return [
                .priceclass100,
                .priceclass200,
                .priceclassAll,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .priceclass100: return "PriceClass_100"
            case .priceclass200: return "PriceClass_200"
            case .priceclassAll: return "PriceClass_All"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PriceClass(rawValue: rawValue) ?? PriceClass.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.PublicKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case id = "Id"
        case publicKeyConfig = "PublicKeyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createdTime = createdTime {
            try container.encode(ClientRuntime.TimestampWrapper(createdTime, format: .dateTime), forKey: ClientRuntime.Key("CreatedTime"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let publicKeyConfig = publicKeyConfig {
            try container.encode(publicKeyConfig, forKey: ClientRuntime.Key("PublicKeyConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        var createdTimeBuffer:ClientRuntime.Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension CloudFrontClientTypes.PublicKey: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
    public struct PublicKey: Swift.Equatable {
        /// The date and time when the public key was uploaded.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The identifier of the public key.
        /// This member is required.
        public var id: Swift.String?
        /// Configuration information about a public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
        /// This member is required.
        public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
        )
        {
            self.createdTime = createdTime
            self.id = id
            self.publicKeyConfig = publicKeyConfig
        }
    }

}

extension PublicKeyAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<PublicKeyAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified public key already exists.
public struct PublicKeyAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PublicKeyAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension PublicKeyAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.PublicKeyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
        case encodedKey = "EncodedKey"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let encodedKey = encodedKey {
            try container.encode(encodedKey, forKey: ClientRuntime.Key("EncodedKey"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let encodedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encodedKey)
        encodedKey = encodedKeyDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.PublicKeyConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Configuration information about a public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
    public struct PublicKeyConfig: Swift.Equatable {
        /// A string included in the request to help make sure that the request can’t be replayed.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A comment to describe the public key. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
        /// This member is required.
        public var encodedKey: Swift.String?
        /// A name to help identify the public key.
        /// This member is required.
        public var name: Swift.String?

        public init (
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            encodedKey: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.encodedKey = encodedKey
            self.name = name
        }
    }

}

extension PublicKeyInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<PublicKeyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified public key is in use.
public struct PublicKeyInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PublicKeyInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension PublicKeyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.PublicKeyList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for publickeysummary0 in items {
                try itemsContainer.encode(publickeysummary0, forKey: ClientRuntime.Key("PublicKeySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct PublicKeySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PublicKeySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.PublicKeySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.PublicKeySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.PublicKeySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.PublicKeyList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of public keys that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
    public struct PublicKeyList: Swift.Equatable {
        /// A list of public keys.
        public var items: [CloudFrontClientTypes.PublicKeySummary]?
        /// The maximum number of public keys you want in the response.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more elements to be listed, this element is present and contains the value that you can use for the Marker request parameter to continue listing your public keys where you left off.
        public var nextMarker: Swift.String?
        /// The number of public keys in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.PublicKeySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.PublicKeySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case createdTime = "CreatedTime"
        case encodedKey = "EncodedKey"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let createdTime = createdTime {
            try container.encode(ClientRuntime.TimestampWrapper(createdTime, format: .dateTime), forKey: ClientRuntime.Key("CreatedTime"))
        }
        if let encodedKey = encodedKey {
            try container.encode(encodedKey, forKey: ClientRuntime.Key("EncodedKey"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        var createdTimeBuffer:ClientRuntime.Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let encodedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encodedKey)
        encodedKey = encodedKeyDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.PublicKeySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains information about a public key.
    public struct PublicKeySummary: Swift.Equatable {
        /// A comment to describe the public key. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The date and time when the public key was uploaded.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The public key.
        /// This member is required.
        public var encodedKey: Swift.String?
        /// The identifier of the public key.
        /// This member is required.
        public var id: Swift.String?
        /// A name to help identify the public key.
        /// This member is required.
        public var name: Swift.String?

        public init (
            comment: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            encodedKey: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.createdTime = createdTime
            self.encodedKey = encodedKey
            self.id = id
            self.name = name
        }
    }

}

extension PublishFunctionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension PublishFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())/publish"
    }
}

public struct PublishFunctionInput: Swift.Equatable {
    /// The current version (ETag value) of the function that you are publishing, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are publishing.
    /// This member is required.
    public var name: Swift.String?

    public init (
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

struct PublishFunctionInputBody: Swift.Equatable {
}

extension PublishFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PublishFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PublishFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishFunctionOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case preconditionFailed(PreconditionFailed)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct PublishFunctionOutputResponse: Swift.Equatable {
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init (
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.functionSummary = functionSummary
    }
}

struct PublishFunctionOutputResponseBody: Swift.Equatable {
    let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension PublishFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

extension CloudFrontClientTypes.QueryArgProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
        case queryArg = "QueryArg"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let profileId = profileId {
            try container.encode(profileId, forKey: ClientRuntime.Key("ProfileId"))
        }
        if let queryArg = queryArg {
            try container.encode(queryArg, forKey: ClientRuntime.Key("QueryArg"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryArgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryArg)
        queryArg = queryArgDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

extension CloudFrontClientTypes.QueryArgProfile: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Query argument-profile mapping for field-level encryption.
    public struct QueryArgProfile: Swift.Equatable {
        /// ID of profile to use for field-level encryption query argument-profile mapping
        /// This member is required.
        public var profileId: Swift.String?
        /// Query argument for field-level encryption query argument-profile mapping.
        /// This member is required.
        public var queryArg: Swift.String?

        public init (
            profileId: Swift.String? = nil,
            queryArg: Swift.String? = nil
        )
        {
            self.profileId = profileId
            self.queryArg = queryArg
        }
    }

}

extension CloudFrontClientTypes.QueryArgProfileConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forwardWhenQueryArgProfileIsUnknown = "ForwardWhenQueryArgProfileIsUnknown"
        case queryArgProfiles = "QueryArgProfiles"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknown {
            try container.encode(forwardWhenQueryArgProfileIsUnknown, forKey: ClientRuntime.Key("ForwardWhenQueryArgProfileIsUnknown"))
        }
        if let queryArgProfiles = queryArgProfiles {
            try container.encode(queryArgProfiles, forKey: ClientRuntime.Key("QueryArgProfiles"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardWhenQueryArgProfileIsUnknownDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forwardWhenQueryArgProfileIsUnknown)
        forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknownDecoded
        let queryArgProfilesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryArgProfiles.self, forKey: .queryArgProfiles)
        queryArgProfiles = queryArgProfilesDecoded
    }
}

extension CloudFrontClientTypes.QueryArgProfileConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Configuration for query argument-profile mapping for field-level encryption.
    public struct QueryArgProfileConfig: Swift.Equatable {
        /// Flag to set if you want a request to be forwarded to the origin even if the profile specified by the field-level encryption query argument, fle-profile, is unknown.
        /// This member is required.
        public var forwardWhenQueryArgProfileIsUnknown: Swift.Bool?
        /// Profiles specified for query argument-profile mapping for field-level encryption.
        public var queryArgProfiles: CloudFrontClientTypes.QueryArgProfiles?

        public init (
            forwardWhenQueryArgProfileIsUnknown: Swift.Bool? = nil,
            queryArgProfiles: CloudFrontClientTypes.QueryArgProfiles? = nil
        )
        {
            self.forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknown
            self.queryArgProfiles = queryArgProfiles
        }
    }

}

extension QueryArgProfileEmpty {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<QueryArgProfileEmptyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No profile specified for the field-level encryption query argument.
public struct QueryArgProfileEmpty: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct QueryArgProfileEmptyBody: Swift.Equatable {
    let message: Swift.String?
}

extension QueryArgProfileEmptyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.QueryArgProfiles: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for queryargprofile0 in items {
                try itemsContainer.encode(queryargprofile0, forKey: ClientRuntime.Key("QueryArgProfile"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct QueryArgProfile{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.QueryArgProfile>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.QueryArgProfile].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.QueryArgProfile]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.QueryArgProfile]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.QueryArgProfiles: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Query argument-profile mapping for field-level encryption.
    public struct QueryArgProfiles: Swift.Equatable {
        /// Number of items for query argument-profile mapping for field-level encryption.
        public var items: [CloudFrontClientTypes.QueryArgProfile]?
        /// Number of profiles for query argument-profile mapping for field-level encryption.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.QueryArgProfile]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.QueryStringCacheKeys: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.QueryStringCacheKeys: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use QueryStringsConfig in a cache policy. See CachePolicy. If you want to send query strings to the origin but not include them in the cache key, use QueryStringsConfig in an origin request policy. See OriginRequestPolicy. A complex type that contains information about the query string parameters that you want CloudFront to use for caching for a cache behavior.
    public struct QueryStringCacheKeys: Swift.Equatable {
        /// A list that contains the query string parameters that you want CloudFront to use as a basis for caching for a cache behavior. If Quantity is 0, you can omit Items.
        public var items: [Swift.String]?
        /// The number of whitelisted query string parameters for a cache behavior.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.QueryStringNames: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.QueryStringNames: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains a list of query string names.
    public struct QueryStringNames: Swift.Equatable {
        /// A list of query string names.
        public var items: [Swift.String]?
        /// The number of query string names in the Items list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.RealtimeLogConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let endPoints = endPoints {
            var endPointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EndPoints"))
            for endpoint0 in endPoints {
                try endPointsContainer.encode(endpoint0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Fields"))
            for string0 in fields {
                try fieldsContainer.encode(string0, forKey: ClientRuntime.Key("Field"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: ClientRuntime.Key("SamplingRate"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
        if containerValues.contains(.endPoints) {
            struct KeyVal0{struct member{}}
            let endPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endPoints)
            if let endPointsWrappedContainer = endPointsWrappedContainer {
                let endPointsContainer = try endPointsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EndPoint].self, forKey: .member)
                var endPointsBuffer:[CloudFrontClientTypes.EndPoint]? = nil
                if let endPointsContainer = endPointsContainer {
                    endPointsBuffer = [CloudFrontClientTypes.EndPoint]()
                    for structureContainer0 in endPointsContainer {
                        endPointsBuffer?.append(structureContainer0)
                    }
                }
                endPoints = endPointsBuffer
            } else {
                endPoints = []
            }
        } else {
            endPoints = nil
        }
        if containerValues.contains(.fields) {
            struct KeyVal0{struct Field{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldsBuffer:[Swift.String]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [Swift.String]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
    }
}

extension CloudFrontClientTypes.RealtimeLogConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A real-time log configuration.
    public struct RealtimeLogConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this real-time log configuration.
        /// This member is required.
        public var aRN: Swift.String?
        /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data for this real-time log configuration.
        /// This member is required.
        public var endPoints: [CloudFrontClientTypes.EndPoint]?
        /// A list of fields that are included in each real-time log record. In an API response, the fields are provided in the same order in which they are sent to the Amazon Kinesis data stream. For more information about fields, see [Real-time log configuration fields](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var fields: [Swift.String]?
        /// The unique name of this real-time log configuration.
        /// This member is required.
        public var name: Swift.String?
        /// The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. The sampling rate is an integer between 1 and 100, inclusive.
        /// This member is required.
        public var samplingRate: Swift.Int?

        public init (
            aRN: Swift.String? = nil,
            endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
            fields: [Swift.String]? = nil,
            name: Swift.String? = nil,
            samplingRate: Swift.Int? = nil
        )
        {
            self.aRN = aRN
            self.endPoints = endPoints
            self.fields = fields
            self.name = name
            self.samplingRate = samplingRate
        }
    }

}

extension RealtimeLogConfigAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<RealtimeLogConfigAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A real-time log configuration with this name already exists. You must provide a unique name. To modify an existing real-time log configuration, use UpdateRealtimeLogConfig.
public struct RealtimeLogConfigAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RealtimeLogConfigAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension RealtimeLogConfigAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RealtimeLogConfigInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<RealtimeLogConfigInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot delete the real-time log configuration because it is attached to one or more cache behaviors.
public struct RealtimeLogConfigInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RealtimeLogConfigInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension RealtimeLogConfigInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RealtimeLogConfigOwnerMismatch {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<RealtimeLogConfigOwnerMismatchBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified real-time log configuration belongs to a different Amazon Web Services account.
public struct RealtimeLogConfigOwnerMismatch: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RealtimeLogConfigOwnerMismatchBody: Swift.Equatable {
    let message: Swift.String?
}

extension RealtimeLogConfigOwnerMismatchBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.RealtimeLogConfigs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for realtimelogconfig0 in items {
                try itemsContainer.encode(realtimelogconfig0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct member{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.RealtimeLogConfig].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.RealtimeLogConfig]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.RealtimeLogConfig]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension CloudFrontClientTypes.RealtimeLogConfigs: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of real-time log configurations.
    public struct RealtimeLogConfigs: Swift.Equatable {
        /// A flag that indicates whether there are more real-time log configurations than are contained in this list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// Contains the list of real-time log configurations.
        public var items: [CloudFrontClientTypes.RealtimeLogConfig]?
        /// This parameter indicates where this list of real-time log configurations begins. This list includes real-time log configurations that occur after the marker.
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of real-time log configurations requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing real-time log configurations where you left off.
        public var nextMarker: Swift.String?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.RealtimeLogConfig]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
        }
    }

}

extension CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeMetricsSubscriptionStatus = "RealtimeMetricsSubscriptionStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatus {
            try container.encode(realtimeMetricsSubscriptionStatus, forKey: ClientRuntime.Key("RealtimeMetricsSubscriptionStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeMetricsSubscriptionStatusDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus.self, forKey: .realtimeMetricsSubscriptionStatus)
        realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatusDecoded
    }
}

extension CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A subscription configuration for additional CloudWatch metrics.
    public struct RealtimeMetricsSubscriptionConfig: Swift.Equatable {
        /// A flag that indicates whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
        /// This member is required.
        public var realtimeMetricsSubscriptionStatus: CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus?

        public init (
            realtimeMetricsSubscriptionStatus: CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus? = nil
        )
        {
            self.realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatus
        }
    }

}

extension CloudFrontClientTypes {
    public enum RealtimeMetricsSubscriptionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [RealtimeMetricsSubscriptionStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RealtimeMetricsSubscriptionStatus(rawValue: rawValue) ?? RealtimeMetricsSubscriptionStatus.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum ReferrerPolicyList: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noReferrer
        case noReferrerWhenDowngrade
        case origin
        case originWhenCrossOrigin
        case sameOrigin
        case strictOrigin
        case strictOriginWhenCrossOrigin
        case unsafeUrl
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferrerPolicyList] {
            return [
                .noReferrer,
                .noReferrerWhenDowngrade,
                .origin,
                .originWhenCrossOrigin,
                .sameOrigin,
                .strictOrigin,
                .strictOriginWhenCrossOrigin,
                .unsafeUrl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noReferrer: return "no-referrer"
            case .noReferrerWhenDowngrade: return "no-referrer-when-downgrade"
            case .origin: return "origin"
            case .originWhenCrossOrigin: return "origin-when-cross-origin"
            case .sameOrigin: return "same-origin"
            case .strictOrigin: return "strict-origin"
            case .strictOriginWhenCrossOrigin: return "strict-origin-when-cross-origin"
            case .unsafeUrl: return "unsafe-url"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferrerPolicyList(rawValue: rawValue) ?? ReferrerPolicyList.sdkUnknown(rawValue)
        }
    }
}

extension ResourceInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ResourceInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot delete this resource because it is in use.
public struct ResourceInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case responseHeadersPolicyConfig = "ResponseHeadersPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let responseHeadersPolicyConfig = responseHeadersPolicyConfig {
            try container.encode(responseHeadersPolicyConfig, forKey: ClientRuntime.Key("ResponseHeadersPolicyConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let responseHeadersPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyConfig.self, forKey: .responseHeadersPolicyConfig)
        responseHeadersPolicyConfig = responseHeadersPolicyConfigDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A response headers policy. A response headers policy contains information about a set of HTTP response headers and their values. After you create a response headers policy, you can use its ID to attach it to one or more cache behaviors in a CloudFront distribution. When it’s attached to a cache behavior, CloudFront adds the headers in the policy to HTTP responses that it sends for requests that match the cache behavior. For more information, see [Adding HTTP headers to CloudFront responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/adding-response-headers.html) in the Amazon CloudFront Developer Guide.
    public struct ResponseHeadersPolicy: Swift.Equatable {
        /// The identifier for the response headers policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time when the response headers policy was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A response headers policy configuration. A response headers policy contains information about a set of HTTP response headers and their values. CloudFront adds the headers in the policy to HTTP responses that it sends for requests that match a cache behavior that’s associated with the policy.
        /// This member is required.
        public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

        public init (
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
        )
        {
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Header"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Header{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Header>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of HTTP header names that CloudFront includes as values for the Access-Control-Allow-Headers HTTP response header. For more information about the Access-Control-Allow-Headers HTTP response header, see [Access-Control-Allow-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlAllowHeaders: Swift.Equatable {
        /// The list of HTTP header names. You can specify * to allow all headers.
        /// This member is required.
        public var items: [Swift.String]?
        /// The number of HTTP header names in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for responseheaderspolicyaccesscontrolallowmethodsvalues0 in items {
                try itemsContainer.encode(responseheaderspolicyaccesscontrolallowmethodsvalues0, forKey: ClientRuntime.Key("Method"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Method{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Method>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of HTTP methods that CloudFront includes as values for the Access-Control-Allow-Methods HTTP response header. For more information about the Access-Control-Allow-Methods HTTP response header, see [Access-Control-Allow-Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlAllowMethods: Swift.Equatable {
        /// The list of HTTP methods. Valid values are:
        ///
        /// * GET
        ///
        /// * DELETE
        ///
        /// * HEAD
        ///
        /// * OPTIONS
        ///
        /// * PATCH
        ///
        /// * POST
        ///
        /// * PUT
        ///
        /// * ALL
        ///
        ///
        /// ALL is a special value that includes all of the listed HTTP methods.
        /// This member is required.
        public var items: [CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues]?
        /// The number of HTTP methods in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum ResponseHeadersPolicyAccessControlAllowMethodsValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseHeadersPolicyAccessControlAllowMethodsValues] {
            return [
                .all,
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResponseHeadersPolicyAccessControlAllowMethodsValues(rawValue: rawValue) ?? ResponseHeadersPolicyAccessControlAllowMethodsValues.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Origin"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Origin{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Origin>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of origins (domain names) that CloudFront can use as the value for the Access-Control-Allow-Origin HTTP response header. For more information about the Access-Control-Allow-Origin HTTP response header, see [Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlAllowOrigins: Swift.Equatable {
        /// The list of origins (domain names). You can specify * to allow all origins.
        /// This member is required.
        public var items: [Swift.String]?
        /// The number of origins in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Header"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Header{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Header>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of HTTP headers that CloudFront includes as values for the Access-Control-Expose-Headers HTTP response header. For more information about the Access-Control-Expose-Headers HTTP response header, see [Access-Control-Expose-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlExposeHeaders: Swift.Equatable {
        /// The list of HTTP headers. You can specify * to expose all headers.
        public var items: [Swift.String]?
        /// The number of HTTP headers in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension ResponseHeadersPolicyAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ResponseHeadersPolicyAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A response headers policy with this name already exists. You must provide a unique name. To modify an existing response headers policy, use UpdateResponseHeadersPolicy.
public struct ResponseHeadersPolicyAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResponseHeadersPolicyAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResponseHeadersPolicyAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case corsConfig = "CorsConfig"
        case customHeadersConfig = "CustomHeadersConfig"
        case name = "Name"
        case securityHeadersConfig = "SecurityHeadersConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let corsConfig = corsConfig {
            try container.encode(corsConfig, forKey: ClientRuntime.Key("CorsConfig"))
        }
        if let customHeadersConfig = customHeadersConfig {
            try container.encode(customHeadersConfig, forKey: ClientRuntime.Key("CustomHeadersConfig"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let securityHeadersConfig = securityHeadersConfig {
            try container.encode(securityHeadersConfig, forKey: ClientRuntime.Key("SecurityHeadersConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let corsConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig.self, forKey: .corsConfig)
        corsConfig = corsConfigDecoded
        let securityHeadersConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig.self, forKey: .securityHeadersConfig)
        securityHeadersConfig = securityHeadersConfigDecoded
        let customHeadersConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig.self, forKey: .customHeadersConfig)
        customHeadersConfig = customHeadersConfigDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A response headers policy configuration. A response headers policy configuration contains metadata about the response headers policy, and configurations for sets of HTTP response headers and their values. CloudFront adds the headers in the policy to HTTP responses that it sends for requests that match a cache behavior associated with the policy.
    public struct ResponseHeadersPolicyConfig: Swift.Equatable {
        /// A comment to describe the response headers policy. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A configuration for a set of HTTP response headers that are used for cross-origin resource sharing (CORS).
        public var corsConfig: CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig?
        /// A configuration for a set of custom HTTP response headers.
        public var customHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig?
        /// A name to identify the response headers policy. The name must be unique for response headers policies in this Amazon Web Services account.
        /// This member is required.
        public var name: Swift.String?
        /// A configuration for a set of security-related HTTP response headers.
        public var securityHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig?

        public init (
            comment: Swift.String? = nil,
            corsConfig: CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig? = nil,
            customHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig? = nil,
            name: Swift.String? = nil,
            securityHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig? = nil
        )
        {
            self.comment = comment
            self.corsConfig = corsConfig
            self.customHeadersConfig = customHeadersConfig
            self.name = name
            self.securityHeadersConfig = securityHeadersConfig
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentSecurityPolicy = "ContentSecurityPolicy"
        case `override` = "Override"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let contentSecurityPolicy = contentSecurityPolicy {
            try container.encode(contentSecurityPolicy, forKey: ClientRuntime.Key("ContentSecurityPolicy"))
        }
        if let `override` = `override` {
            try container.encode(`override`, forKey: ClientRuntime.Key("Override"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .override)
        `override` = overrideDecoded
        let contentSecurityPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentSecurityPolicy)
        contentSecurityPolicy = contentSecurityPolicyDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header. For more information about the Content-Security-Policy HTTP response header, see [Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) in the MDN Web Docs.
    public struct ResponseHeadersPolicyContentSecurityPolicy: Swift.Equatable {
        /// The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header.
        /// This member is required.
        public var contentSecurityPolicy: Swift.String?
        /// A Boolean that determines whether CloudFront overrides the Content-Security-Policy HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?

        public init (
            contentSecurityPolicy: Swift.String? = nil,
            `override`: Swift.Bool? = nil
        )
        {
            self.contentSecurityPolicy = contentSecurityPolicy
            self.`override` = `override`
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `override` = "Override"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let `override` = `override` {
            try container.encode(`override`, forKey: ClientRuntime.Key("Override"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .override)
        `override` = overrideDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Determines whether CloudFront includes the X-Content-Type-Options HTTP response header with its value set to nosniff. For more information about the X-Content-Type-Options HTTP response header, see [X-Content-Type-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options) in the MDN Web Docs.
    public struct ResponseHeadersPolicyContentTypeOptions: Swift.Equatable {
        /// A Boolean that determines whether CloudFront overrides the X-Content-Type-Options HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?

        public init (
            `override`: Swift.Bool? = nil
        )
        {
            self.`override` = `override`
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlAllowCredentials = "AccessControlAllowCredentials"
        case accessControlAllowHeaders = "AccessControlAllowHeaders"
        case accessControlAllowMethods = "AccessControlAllowMethods"
        case accessControlAllowOrigins = "AccessControlAllowOrigins"
        case accessControlExposeHeaders = "AccessControlExposeHeaders"
        case accessControlMaxAgeSec = "AccessControlMaxAgeSec"
        case originOverride = "OriginOverride"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessControlAllowCredentials = accessControlAllowCredentials {
            try container.encode(accessControlAllowCredentials, forKey: ClientRuntime.Key("AccessControlAllowCredentials"))
        }
        if let accessControlAllowHeaders = accessControlAllowHeaders {
            try container.encode(accessControlAllowHeaders, forKey: ClientRuntime.Key("AccessControlAllowHeaders"))
        }
        if let accessControlAllowMethods = accessControlAllowMethods {
            try container.encode(accessControlAllowMethods, forKey: ClientRuntime.Key("AccessControlAllowMethods"))
        }
        if let accessControlAllowOrigins = accessControlAllowOrigins {
            try container.encode(accessControlAllowOrigins, forKey: ClientRuntime.Key("AccessControlAllowOrigins"))
        }
        if let accessControlExposeHeaders = accessControlExposeHeaders {
            try container.encode(accessControlExposeHeaders, forKey: ClientRuntime.Key("AccessControlExposeHeaders"))
        }
        if let accessControlMaxAgeSec = accessControlMaxAgeSec {
            try container.encode(accessControlMaxAgeSec, forKey: ClientRuntime.Key("AccessControlMaxAgeSec"))
        }
        if let originOverride = originOverride {
            try container.encode(originOverride, forKey: ClientRuntime.Key("OriginOverride"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlAllowOriginsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins.self, forKey: .accessControlAllowOrigins)
        accessControlAllowOrigins = accessControlAllowOriginsDecoded
        let accessControlAllowHeadersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders.self, forKey: .accessControlAllowHeaders)
        accessControlAllowHeaders = accessControlAllowHeadersDecoded
        let accessControlAllowMethodsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods.self, forKey: .accessControlAllowMethods)
        accessControlAllowMethods = accessControlAllowMethodsDecoded
        let accessControlAllowCredentialsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accessControlAllowCredentials)
        accessControlAllowCredentials = accessControlAllowCredentialsDecoded
        let accessControlExposeHeadersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders.self, forKey: .accessControlExposeHeaders)
        accessControlExposeHeaders = accessControlExposeHeadersDecoded
        let accessControlMaxAgeSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .accessControlMaxAgeSec)
        accessControlMaxAgeSec = accessControlMaxAgeSecDecoded
        let originOverrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .originOverride)
        originOverride = originOverrideDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A configuration for a set of HTTP response headers that are used for cross-origin resource sharing (CORS). CloudFront adds these headers to HTTP responses that it sends for CORS requests that match a cache behavior associated with this response headers policy. For more information about CORS, see [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) in the MDN Web Docs.
    public struct ResponseHeadersPolicyCorsConfig: Swift.Equatable {
        /// A Boolean that CloudFront uses as the value for the Access-Control-Allow-Credentials HTTP response header. For more information about the Access-Control-Allow-Credentials HTTP response header, see [Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowCredentials: Swift.Bool?
        /// A list of HTTP header names that CloudFront includes as values for the Access-Control-Allow-Headers HTTP response header. For more information about the Access-Control-Allow-Headers HTTP response header, see [Access-Control-Allow-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders?
        /// A list of HTTP methods that CloudFront includes as values for the Access-Control-Allow-Methods HTTP response header. For more information about the Access-Control-Allow-Methods HTTP response header, see [Access-Control-Allow-Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowMethods: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods?
        /// A list of origins (domain names) that CloudFront can use as the value for the Access-Control-Allow-Origin HTTP response header. For more information about the Access-Control-Allow-Origin HTTP response header, see [Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowOrigins: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins?
        /// A list of HTTP headers that CloudFront includes as values for the Access-Control-Expose-Headers HTTP response header. For more information about the Access-Control-Expose-Headers HTTP response header, see [Access-Control-Expose-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers) in the MDN Web Docs.
        public var accessControlExposeHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders?
        /// A number that CloudFront uses as the value for the Access-Control-Max-Age HTTP response header. For more information about the Access-Control-Max-Age HTTP response header, see [Access-Control-Max-Age](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Max-Age) in the MDN Web Docs.
        public var accessControlMaxAgeSec: Swift.Int?
        /// A Boolean that determines whether CloudFront overrides HTTP response headers received from the origin with the ones specified in this response headers policy.
        /// This member is required.
        public var originOverride: Swift.Bool?

        public init (
            accessControlAllowCredentials: Swift.Bool? = nil,
            accessControlAllowHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders? = nil,
            accessControlAllowMethods: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods? = nil,
            accessControlAllowOrigins: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins? = nil,
            accessControlExposeHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders? = nil,
            accessControlMaxAgeSec: Swift.Int? = nil,
            originOverride: Swift.Bool? = nil
        )
        {
            self.accessControlAllowCredentials = accessControlAllowCredentials
            self.accessControlAllowHeaders = accessControlAllowHeaders
            self.accessControlAllowMethods = accessControlAllowMethods
            self.accessControlAllowOrigins = accessControlAllowOrigins
            self.accessControlExposeHeaders = accessControlExposeHeaders
            self.accessControlMaxAgeSec = accessControlMaxAgeSec
            self.originOverride = originOverride
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case header = "Header"
        case `override` = "Override"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let header = header {
            try container.encode(header, forKey: ClientRuntime.Key("Header"))
        }
        if let `override` = `override` {
            try container.encode(`override`, forKey: ClientRuntime.Key("Override"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .header)
        header = headerDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let overrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .override)
        `override` = overrideDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An HTTP response header name and its value. CloudFront includes this header in HTTP responses that it sends for requests that match a cache behavior that’s associated with this response headers policy.
    public struct ResponseHeadersPolicyCustomHeader: Swift.Equatable {
        /// The HTTP response header name.
        /// This member is required.
        public var header: Swift.String?
        /// A Boolean that determines whether CloudFront overrides a response header with the same name received from the origin with the header specified here.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// The value for the HTTP response header.
        /// This member is required.
        public var value: Swift.String?

        public init (
            header: Swift.String? = nil,
            `override`: Swift.Bool? = nil,
            value: Swift.String? = nil
        )
        {
            self.header = header
            self.`override` = `override`
            self.value = value
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for responseheaderspolicycustomheader0 in items {
                try itemsContainer.encode(responseheaderspolicycustomheader0, forKey: ClientRuntime.Key("ResponseHeadersPolicyCustomHeader"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct ResponseHeadersPolicyCustomHeader{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ResponseHeadersPolicyCustomHeader>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of HTTP response header names and their values. CloudFront includes these headers in HTTP responses that it sends for requests that match a cache behavior that’s associated with this response headers policy.
    public struct ResponseHeadersPolicyCustomHeadersConfig: Swift.Equatable {
        /// The list of HTTP response headers and their values.
        public var items: [CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader]?
        /// The number of HTTP response headers in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameOption = "FrameOption"
        case `override` = "Override"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let frameOption = frameOption {
            try container.encode(frameOption, forKey: ClientRuntime.Key("FrameOption"))
        }
        if let `override` = `override` {
            try container.encode(`override`, forKey: ClientRuntime.Key("Override"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .override)
        `override` = overrideDecoded
        let frameOptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FrameOptionsList.self, forKey: .frameOption)
        frameOption = frameOptionDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Determines whether CloudFront includes the X-Frame-Options HTTP response header and the header’s value. For more information about the X-Frame-Options HTTP response header, see [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options) in the MDN Web Docs.
    public struct ResponseHeadersPolicyFrameOptions: Swift.Equatable {
        /// The value of the X-Frame-Options HTTP response header. Valid values are DENY and SAMEORIGIN. For more information about these values, see [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options) in the MDN Web Docs.
        /// This member is required.
        public var frameOption: CloudFrontClientTypes.FrameOptionsList?
        /// A Boolean that determines whether CloudFront overrides the X-Frame-Options HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?

        public init (
            frameOption: CloudFrontClientTypes.FrameOptionsList? = nil,
            `override`: Swift.Bool? = nil
        )
        {
            self.frameOption = frameOption
            self.`override` = `override`
        }
    }

}

extension ResponseHeadersPolicyInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ResponseHeadersPolicyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot delete the response headers policy because it is attached to one or more cache behaviors in a CloudFront distribution.
public struct ResponseHeadersPolicyInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResponseHeadersPolicyInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResponseHeadersPolicyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for responseheaderspolicysummary0 in items {
                try itemsContainer.encode(responseheaderspolicysummary0, forKey: ClientRuntime.Key("ResponseHeadersPolicySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct ResponseHeadersPolicySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ResponseHeadersPolicySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.ResponseHeadersPolicySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.ResponseHeadersPolicySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.ResponseHeadersPolicySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of response headers policies.
    public struct ResponseHeadersPolicyList: Swift.Equatable {
        /// The response headers policies in the list.
        public var items: [CloudFrontClientTypes.ResponseHeadersPolicySummary]?
        /// The maximum number of response headers policies requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing response headers policies where you left off.
        public var nextMarker: Swift.String?
        /// The number of response headers policies returned.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.ResponseHeadersPolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `override` = "Override"
        case referrerPolicy = "ReferrerPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let `override` = `override` {
            try container.encode(`override`, forKey: ClientRuntime.Key("Override"))
        }
        if let referrerPolicy = referrerPolicy {
            try container.encode(referrerPolicy, forKey: ClientRuntime.Key("ReferrerPolicy"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .override)
        `override` = overrideDecoded
        let referrerPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ReferrerPolicyList.self, forKey: .referrerPolicy)
        referrerPolicy = referrerPolicyDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Determines whether CloudFront includes the Referrer-Policy HTTP response header and the header’s value. For more information about the Referrer-Policy HTTP response header, see [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy) in the MDN Web Docs.
    public struct ResponseHeadersPolicyReferrerPolicy: Swift.Equatable {
        /// A Boolean that determines whether CloudFront overrides the Referrer-Policy HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// The value of the Referrer-Policy HTTP response header. Valid values are:
        ///
        /// * no-referrer
        ///
        /// * no-referrer-when-downgrade
        ///
        /// * origin
        ///
        /// * origin-when-cross-origin
        ///
        /// * same-origin
        ///
        /// * strict-origin
        ///
        /// * strict-origin-when-cross-origin
        ///
        /// * unsafe-url
        ///
        ///
        /// For more information about these values, see [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy) in the MDN Web Docs.
        /// This member is required.
        public var referrerPolicy: CloudFrontClientTypes.ReferrerPolicyList?

        public init (
            `override`: Swift.Bool? = nil,
            referrerPolicy: CloudFrontClientTypes.ReferrerPolicyList? = nil
        )
        {
            self.`override` = `override`
            self.referrerPolicy = referrerPolicy
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentSecurityPolicy = "ContentSecurityPolicy"
        case contentTypeOptions = "ContentTypeOptions"
        case frameOptions = "FrameOptions"
        case referrerPolicy = "ReferrerPolicy"
        case strictTransportSecurity = "StrictTransportSecurity"
        case xSSProtection = "XSSProtection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let contentSecurityPolicy = contentSecurityPolicy {
            try container.encode(contentSecurityPolicy, forKey: ClientRuntime.Key("ContentSecurityPolicy"))
        }
        if let contentTypeOptions = contentTypeOptions {
            try container.encode(contentTypeOptions, forKey: ClientRuntime.Key("ContentTypeOptions"))
        }
        if let frameOptions = frameOptions {
            try container.encode(frameOptions, forKey: ClientRuntime.Key("FrameOptions"))
        }
        if let referrerPolicy = referrerPolicy {
            try container.encode(referrerPolicy, forKey: ClientRuntime.Key("ReferrerPolicy"))
        }
        if let strictTransportSecurity = strictTransportSecurity {
            try container.encode(strictTransportSecurity, forKey: ClientRuntime.Key("StrictTransportSecurity"))
        }
        if let xSSProtection = xSSProtection {
            try container.encode(xSSProtection, forKey: ClientRuntime.Key("XSSProtection"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let xSSProtectionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection.self, forKey: .xSSProtection)
        xSSProtection = xSSProtectionDecoded
        let frameOptionsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions.self, forKey: .frameOptions)
        frameOptions = frameOptionsDecoded
        let referrerPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy.self, forKey: .referrerPolicy)
        referrerPolicy = referrerPolicyDecoded
        let contentSecurityPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy.self, forKey: .contentSecurityPolicy)
        contentSecurityPolicy = contentSecurityPolicyDecoded
        let contentTypeOptionsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions.self, forKey: .contentTypeOptions)
        contentTypeOptions = contentTypeOptionsDecoded
        let strictTransportSecurityDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity.self, forKey: .strictTransportSecurity)
        strictTransportSecurity = strictTransportSecurityDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A configuration for a set of security-related HTTP response headers. CloudFront adds these headers to HTTP responses that it sends for requests that match a cache behavior associated with this response headers policy.
    public struct ResponseHeadersPolicySecurityHeadersConfig: Swift.Equatable {
        /// The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header. For more information about the Content-Security-Policy HTTP response header, see [Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) in the MDN Web Docs.
        public var contentSecurityPolicy: CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy?
        /// Determines whether CloudFront includes the X-Content-Type-Options HTTP response header with its value set to nosniff. For more information about the X-Content-Type-Options HTTP response header, see [X-Content-Type-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options) in the MDN Web Docs.
        public var contentTypeOptions: CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions?
        /// Determines whether CloudFront includes the X-Frame-Options HTTP response header and the header’s value. For more information about the X-Frame-Options HTTP response header, see [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options) in the MDN Web Docs.
        public var frameOptions: CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions?
        /// Determines whether CloudFront includes the Referrer-Policy HTTP response header and the header’s value. For more information about the Referrer-Policy HTTP response header, see [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy) in the MDN Web Docs.
        public var referrerPolicy: CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy?
        /// Determines whether CloudFront includes the Strict-Transport-Security HTTP response header and the header’s value. For more information about the Strict-Transport-Security HTTP response header, see [Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security) in the MDN Web Docs.
        public var strictTransportSecurity: CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity?
        /// Determines whether CloudFront includes the X-XSS-Protection HTTP response header and the header’s value. For more information about the X-XSS-Protection HTTP response header, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        public var xSSProtection: CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection?

        public init (
            contentSecurityPolicy: CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy? = nil,
            contentTypeOptions: CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions? = nil,
            frameOptions: CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions? = nil,
            referrerPolicy: CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy? = nil,
            strictTransportSecurity: CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity? = nil,
            xSSProtection: CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection? = nil
        )
        {
            self.contentSecurityPolicy = contentSecurityPolicy
            self.contentTypeOptions = contentTypeOptions
            self.frameOptions = frameOptions
            self.referrerPolicy = referrerPolicy
            self.strictTransportSecurity = strictTransportSecurity
            self.xSSProtection = xSSProtection
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlMaxAgeSec = "AccessControlMaxAgeSec"
        case includeSubdomains = "IncludeSubdomains"
        case `override` = "Override"
        case preload = "Preload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessControlMaxAgeSec = accessControlMaxAgeSec {
            try container.encode(accessControlMaxAgeSec, forKey: ClientRuntime.Key("AccessControlMaxAgeSec"))
        }
        if let includeSubdomains = includeSubdomains {
            try container.encode(includeSubdomains, forKey: ClientRuntime.Key("IncludeSubdomains"))
        }
        if let `override` = `override` {
            try container.encode(`override`, forKey: ClientRuntime.Key("Override"))
        }
        if let preload = preload {
            try container.encode(preload, forKey: ClientRuntime.Key("Preload"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .override)
        `override` = overrideDecoded
        let includeSubdomainsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeSubdomains)
        includeSubdomains = includeSubdomainsDecoded
        let preloadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preload)
        preload = preloadDecoded
        let accessControlMaxAgeSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .accessControlMaxAgeSec)
        accessControlMaxAgeSec = accessControlMaxAgeSecDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Determines whether CloudFront includes the Strict-Transport-Security HTTP response header and the header’s value. For more information about the Strict-Transport-Security HTTP response header, see [Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security) in the MDN Web Docs.
    public struct ResponseHeadersPolicyStrictTransportSecurity: Swift.Equatable {
        /// A number that CloudFront uses as the value for the max-age directive in the Strict-Transport-Security HTTP response header.
        /// This member is required.
        public var accessControlMaxAgeSec: Swift.Int?
        /// A Boolean that determines whether CloudFront includes the includeSubDomains directive in the Strict-Transport-Security HTTP response header.
        public var includeSubdomains: Swift.Bool?
        /// A Boolean that determines whether CloudFront overrides the Strict-Transport-Security HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// A Boolean that determines whether CloudFront includes the preload directive in the Strict-Transport-Security HTTP response header.
        public var preload: Swift.Bool?

        public init (
            accessControlMaxAgeSec: Swift.Int? = nil,
            includeSubdomains: Swift.Bool? = nil,
            `override`: Swift.Bool? = nil,
            preload: Swift.Bool? = nil
        )
        {
            self.accessControlMaxAgeSec = accessControlMaxAgeSec
            self.includeSubdomains = includeSubdomains
            self.`override` = `override`
            self.preload = preload
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicy = "ResponseHeadersPolicy"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let responseHeadersPolicy = responseHeadersPolicy {
            try container.encode(responseHeadersPolicy, forKey: ClientRuntime.Key("ResponseHeadersPolicy"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyType.self, forKey: .type)
        type = typeDecoded
        let responseHeadersPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicy.self, forKey: .responseHeadersPolicy)
        responseHeadersPolicy = responseHeadersPolicyDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains a response headers policy.
    public struct ResponseHeadersPolicySummary: Swift.Equatable {
        /// The response headers policy.
        /// This member is required.
        public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?
        /// The type of response headers policy, either managed (created by Amazon Web Services) or custom (created in this Amazon Web Services account).
        /// This member is required.
        public var type: CloudFrontClientTypes.ResponseHeadersPolicyType?

        public init (
            responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil,
            type: CloudFrontClientTypes.ResponseHeadersPolicyType? = nil
        )
        {
            self.responseHeadersPolicy = responseHeadersPolicy
            self.type = type
        }
    }

}

extension CloudFrontClientTypes {
    public enum ResponseHeadersPolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseHeadersPolicyType] {
            return [
                .custom,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResponseHeadersPolicyType(rawValue: rawValue) ?? ResponseHeadersPolicyType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modeBlock = "ModeBlock"
        case `override` = "Override"
        case protection = "Protection"
        case reportUri = "ReportUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let modeBlock = modeBlock {
            try container.encode(modeBlock, forKey: ClientRuntime.Key("ModeBlock"))
        }
        if let `override` = `override` {
            try container.encode(`override`, forKey: ClientRuntime.Key("Override"))
        }
        if let protection = protection {
            try container.encode(protection, forKey: ClientRuntime.Key("Protection"))
        }
        if let reportUri = reportUri {
            try container.encode(reportUri, forKey: ClientRuntime.Key("ReportUri"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .override)
        `override` = overrideDecoded
        let protectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .protection)
        protection = protectionDecoded
        let modeBlockDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .modeBlock)
        modeBlock = modeBlockDecoded
        let reportUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportUri)
        reportUri = reportUriDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Determines whether CloudFront includes the X-XSS-Protection HTTP response header and the header’s value. For more information about the X-XSS-Protection HTTP response header, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
    public struct ResponseHeadersPolicyXSSProtection: Swift.Equatable {
        /// A Boolean that determines whether CloudFront includes the mode=block directive in the X-XSS-Protection header. For more information about this directive, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        public var modeBlock: Swift.Bool?
        /// A Boolean that determines whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// A Boolean that determines the value of the X-XSS-Protection HTTP response header. When this setting is true, the value of the X-XSS-Protection header is 1. When this setting is false, the value of the X-XSS-Protection header is 0. For more information about these settings, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        /// This member is required.
        public var protection: Swift.Bool?
        /// A reporting URI, which CloudFront uses as the value of the report directive in the X-XSS-Protection header. You cannot specify a ReportUri when ModeBlock is true. For more information about using a reporting URL, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        public var reportUri: Swift.String?

        public init (
            modeBlock: Swift.Bool? = nil,
            `override`: Swift.Bool? = nil,
            protection: Swift.Bool? = nil,
            reportUri: Swift.String? = nil
        )
        {
            self.modeBlock = modeBlock
            self.`override` = `override`
            self.protection = protection
            self.reportUri = reportUri
        }
    }

}

extension CloudFrontClientTypes.Restrictions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geoRestriction = "GeoRestriction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let geoRestriction = geoRestriction {
            try container.encode(geoRestriction, forKey: ClientRuntime.Key("GeoRestriction"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoRestrictionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.GeoRestriction.self, forKey: .geoRestriction)
        geoRestriction = geoRestrictionDecoded
    }
}

extension CloudFrontClientTypes.Restrictions: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that identifies ways in which you want to restrict distribution of your content.
    public struct Restrictions: Swift.Equatable {
        /// A complex type that controls the countries in which your content is distributed. CloudFront determines the location of your users using MaxMind GeoIP databases.
        /// This member is required.
        public var geoRestriction: CloudFrontClientTypes.GeoRestriction?

        public init (
            geoRestriction: CloudFrontClientTypes.GeoRestriction? = nil
        )
        {
            self.geoRestriction = geoRestriction
        }
    }

}

extension CloudFrontClientTypes.S3Origin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case originAccessIdentity = "OriginAccessIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let originAccessIdentity = originAccessIdentity {
            try container.encode(originAccessIdentity, forKey: ClientRuntime.Key("OriginAccessIdentity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let originAccessIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originAccessIdentity)
        originAccessIdentity = originAccessIdentityDecoded
    }
}

extension CloudFrontClientTypes.S3Origin: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution.
    public struct S3Origin: Swift.Equatable {
        /// The DNS name of the Amazon S3 origin.
        /// This member is required.
        public var domainName: Swift.String?
        /// The CloudFront origin access identity to associate with the distribution. Use an origin access identity to configure the distribution so that end users can only access objects in an Amazon S3 bucket through CloudFront. If you want end users to be able to access objects using either the CloudFront URL or the Amazon S3 URL, specify an empty OriginAccessIdentity element. To delete the origin access identity from an existing distribution, update the distribution configuration and include an empty OriginAccessIdentity element. To replace the origin access identity, update the distribution configuration and specify the new origin access identity. For more information, see [Using an Origin Access Identity to Restrict Access to Your Amazon S3 Content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var originAccessIdentity: Swift.String?

        public init (
            domainName: Swift.String? = nil,
            originAccessIdentity: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.originAccessIdentity = originAccessIdentity
        }
    }

}

extension CloudFrontClientTypes.S3OriginConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccessIdentity = "OriginAccessIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originAccessIdentity = originAccessIdentity {
            try container.encode(originAccessIdentity, forKey: ClientRuntime.Key("OriginAccessIdentity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originAccessIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originAccessIdentity)
        originAccessIdentity = originAccessIdentityDecoded
    }
}

extension CloudFrontClientTypes.S3OriginConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the Amazon S3 origin. If the origin is a custom origin or an S3 bucket that is configured as a website endpoint, use the CustomOriginConfig element instead.
    public struct S3OriginConfig: Swift.Equatable {
        /// The CloudFront origin access identity to associate with the origin. Use an origin access identity to configure the origin so that viewers can only access objects in an Amazon S3 bucket through CloudFront. The format of the value is: origin-access-identity/cloudfront/ID-of-origin-access-identity where  ID-of-origin-access-identity  is the value that CloudFront returned in the ID element when you created the origin access identity. If you want viewers to be able to access objects using either the CloudFront URL or the Amazon S3 URL, specify an empty OriginAccessIdentity element. To delete the origin access identity from an existing distribution, update the distribution configuration and include an empty OriginAccessIdentity element. To replace the origin access identity, update the distribution configuration and specify the new origin access identity. For more information about the origin access identity, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var originAccessIdentity: Swift.String?

        public init (
            originAccessIdentity: Swift.String? = nil
        )
        {
            self.originAccessIdentity = originAccessIdentity
        }
    }

}

extension CloudFrontClientTypes {
    public enum SSLSupportMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sniOnly
        case staticIp
        case vip
        case sdkUnknown(Swift.String)

        public static var allCases: [SSLSupportMethod] {
            return [
                .sniOnly,
                .staticIp,
                .vip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sniOnly: return "sni-only"
            case .staticIp: return "static-ip"
            case .vip: return "vip"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SSLSupportMethod(rawValue: rawValue) ?? SSLSupportMethod.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.Signer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountNumber = "AwsAccountNumber"
        case keyPairIds = "KeyPairIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let awsAccountNumber = awsAccountNumber {
            try container.encode(awsAccountNumber, forKey: ClientRuntime.Key("AwsAccountNumber"))
        }
        if let keyPairIds = keyPairIds {
            try container.encode(keyPairIds, forKey: ClientRuntime.Key("KeyPairIds"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountNumber)
        awsAccountNumber = awsAccountNumberDecoded
        let keyPairIdsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyPairIds.self, forKey: .keyPairIds)
        keyPairIds = keyPairIdsDecoded
    }
}

extension CloudFrontClientTypes.Signer: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of Amazon Web Services accounts and the active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct Signer: Swift.Equatable {
        /// An Amazon Web Services account number that contains active CloudFront key pairs that CloudFront can use to verify the signatures of signed URLs and signed cookies. If the Amazon Web Services account that owns the key pairs is the same account that owns the CloudFront distribution, the value of this field is self.
        public var awsAccountNumber: Swift.String?
        /// A list of CloudFront key pair identifiers.
        public var keyPairIds: CloudFrontClientTypes.KeyPairIds?

        public init (
            awsAccountNumber: Swift.String? = nil,
            keyPairIds: CloudFrontClientTypes.KeyPairIds? = nil
        )
        {
            self.awsAccountNumber = awsAccountNumber
            self.keyPairIds = keyPairIds
        }
    }

}

extension CloudFrontClientTypes {
    public enum SslProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sslv3
        case tlsv1
        case tlsv11
        case tlsv12
        case sdkUnknown(Swift.String)

        public static var allCases: [SslProtocol] {
            return [
                .sslv3,
                .tlsv1,
                .tlsv11,
                .tlsv12,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sslv3: return "SSLv3"
            case .tlsv1: return "TLSv1"
            case .tlsv11: return "TLSv1.1"
            case .tlsv12: return "TLSv1.2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SslProtocol(rawValue: rawValue) ?? SslProtocol.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.StatusCodes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for integer0 in items {
                try itemsContainer.encode(integer0, forKey: ClientRuntime.Key("StatusCode"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct StatusCode{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.StatusCode>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.Int].self, forKey: .member)
                var itemsBuffer:[Swift.Int]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.Int]()
                    for integerContainer0 in itemsContainer {
                        itemsBuffer?.append(integerContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.StatusCodes: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for the status codes that you specify that, when returned by a primary origin, trigger CloudFront to failover to a second origin.
    public struct StatusCodes: Swift.Equatable {
        /// The items (status codes) for an origin group.
        /// This member is required.
        public var items: [Swift.Int]?
        /// The number of status codes.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.Int]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.StreamingDistribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case activeTrustedSigners = "ActiveTrustedSigners"
        case domainName = "DomainName"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case status = "Status"
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let activeTrustedSigners = activeTrustedSigners {
            try container.encode(activeTrustedSigners, forKey: ClientRuntime.Key("ActiveTrustedSigners"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let activeTrustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ActiveTrustedSigners.self, forKey: .activeTrustedSigners)
        activeTrustedSigners = activeTrustedSignersDecoded
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistribution: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A streaming distribution tells CloudFront where you want RTMP content to be delivered from, and the details about how to track and manage content delivery.
    public struct StreamingDistribution: Swift.Equatable {
        /// The ARN (Amazon Resource Name) for the distribution. For example: arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5, where 123456789012 is your Amazon Web Services account ID.
        /// This member is required.
        public var aRN: Swift.String?
        /// A complex type that lists the Amazon Web Services accounts, if any, that you included in the TrustedSigners complex type for this distribution. These are the accounts that you want to allow to create signed URLs for private content. The Signer complex type lists the Amazon Web Services account number of the trusted signer or self if the signer is the Amazon Web Services account that created the distribution. The Signer element also includes the IDs of any active CloudFront key pairs that are associated with the trusted signer's Amazon Web Services account. If no KeyPairId element appears for a Signer, that signer can't create signed URLs. For more information, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners?
        /// The domain name that corresponds to the streaming distribution, for example, s5c39gqb8ow64r.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// The identifier for the RTMP distribution. For example: EGTXBD79EXAMPLE.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time that the distribution was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The current status of the RTMP distribution. When the status is Deployed, the distribution's information is propagated to all CloudFront edge locations.
        /// This member is required.
        public var status: Swift.String?
        /// The current configuration information for the RTMP distribution.
        /// This member is required.
        public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

        public init (
            aRN: Swift.String? = nil,
            activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil,
            streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
        )
        {
            self.aRN = aRN
            self.activeTrustedSigners = activeTrustedSigners
            self.domainName = domainName
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.status = status
            self.streamingDistributionConfig = streamingDistributionConfig
        }
    }

}

extension StreamingDistributionAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<StreamingDistributionAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The caller reference you attempted to create the streaming distribution with is associated with another distribution
public struct StreamingDistributionAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StreamingDistributionAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension StreamingDistributionAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case callerReference = "CallerReference"
        case comment = "Comment"
        case enabled = "Enabled"
        case logging = "Logging"
        case priceClass = "PriceClass"
        case s3Origin = "S3Origin"
        case trustedSigners = "TrustedSigners"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let logging = logging {
            try container.encode(logging, forKey: ClientRuntime.Key("Logging"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let s3Origin = s3Origin {
            try container.encode(s3Origin, forKey: ClientRuntime.Key("S3Origin"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let s3OriginDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.S3Origin.self, forKey: .s3Origin)
        s3Origin = s3OriginDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingLoggingConfig.self, forKey: .logging)
        logging = loggingDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The RTMP distribution's configuration information.
    public struct StreamingDistributionConfig: Swift.Equatable {
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this streaming distribution.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// A unique value (for example, a date-time stamp) that ensures that the request can't be replayed. If the value of CallerReference is new (regardless of the content of the StreamingDistributionConfig object), CloudFront creates a new distribution. If CallerReference is a value that you already sent in a previous request to create a distribution, CloudFront returns a DistributionAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// Any comments you want to include about the streaming distribution.
        /// This member is required.
        public var comment: Swift.String?
        /// Whether the streaming distribution is enabled to accept user requests for content.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A complex type that controls whether access logs are written for the streaming distribution.
        public var logging: CloudFrontClientTypes.StreamingLoggingConfig?
        /// A complex type that contains information about price class for this streaming distribution.
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution.
        /// This member is required.
        public var s3Origin: CloudFrontClientTypes.S3Origin?
        /// A complex type that specifies any Amazon Web Services accounts that you want to permit to create signed URLs for private content. If you want the distribution to use signed URLs, include this element; if you want the distribution to use public URLs, remove this element. For more information, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?

        public init (
            aliases: CloudFrontClientTypes.Aliases? = nil,
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            logging: CloudFrontClientTypes.StreamingLoggingConfig? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            s3Origin: CloudFrontClientTypes.S3Origin? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil
        )
        {
            self.aliases = aliases
            self.callerReference = callerReference
            self.comment = comment
            self.enabled = enabled
            self.logging = logging
            self.priceClass = priceClass
            self.s3Origin = s3Origin
            self.trustedSigners = trustedSigners
        }
    }

}

extension CloudFrontClientTypes.StreamingDistributionConfigWithTags: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
        if let tags = tags {
            try container.encode(tags, forKey: ClientRuntime.Key("Tags"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionConfigWithTags: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A streaming distribution Configuration and a list of tags to be associated with the streaming distribution.
    public struct StreamingDistributionConfigWithTags: Swift.Equatable {
        /// A streaming distribution Configuration.
        /// This member is required.
        public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
        /// A complex type that contains zero or more Tag elements.
        /// This member is required.
        public var tags: CloudFrontClientTypes.Tags?

        public init (
            streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil,
            tags: CloudFrontClientTypes.Tags? = nil
        )
        {
            self.streamingDistributionConfig = streamingDistributionConfig
            self.tags = tags
        }
    }

}

extension CloudFrontClientTypes.StreamingDistributionList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for streamingdistributionsummary0 in items {
                try itemsContainer.encode(streamingdistributionsummary0, forKey: ClientRuntime.Key("StreamingDistributionSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct StreamingDistributionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.StreamingDistributionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.StreamingDistributionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.StreamingDistributionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.StreamingDistributionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.StreamingDistributionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A streaming distribution list.
    public struct StreamingDistributionList: Swift.Equatable {
        /// A flag that indicates whether more streaming distributions remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more distributions in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one StreamingDistributionSummary element for each distribution that was created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.StreamingDistributionSummary]?
        /// The value you provided for the Marker request parameter.
        /// This member is required.
        public var marker: Swift.String?
        /// The value you provided for the MaxItems request parameter.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your RTMP distributions where they left off.
        public var nextMarker: Swift.String?
        /// The number of streaming distributions that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.StreamingDistributionSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension StreamingDistributionNotDisabled {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<StreamingDistributionNotDisabledBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.
public struct StreamingDistributionNotDisabled: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StreamingDistributionNotDisabledBody: Swift.Equatable {
    let message: Swift.String?
}

extension StreamingDistributionNotDisabledBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case aliases = "Aliases"
        case comment = "Comment"
        case domainName = "DomainName"
        case enabled = "Enabled"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case priceClass = "PriceClass"
        case s3Origin = "S3Origin"
        case status = "Status"
        case trustedSigners = "TrustedSigners"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let s3Origin = s3Origin {
            try container.encode(s3Origin, forKey: ClientRuntime.Key("S3Origin"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let s3OriginDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.S3Origin.self, forKey: .s3Origin)
        s3Origin = s3OriginDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A summary of the information for a CloudFront streaming distribution.
    public struct StreamingDistributionSummary: Swift.Equatable {
        /// The ARN (Amazon Resource Name) for the streaming distribution. For example: arn:aws:cloudfront::123456789012:streaming-distribution/EDFDVBD632BHDS5, where 123456789012 is your Amazon Web Services account ID.
        /// This member is required.
        public var aRN: Swift.String?
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this streaming distribution.
        /// This member is required.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// The comment originally specified when this distribution was created.
        /// This member is required.
        public var comment: Swift.String?
        /// The domain name corresponding to the distribution, for example, d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// Whether the distribution is enabled to accept end user requests for content.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The identifier for the distribution, for example, EDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time the distribution was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A complex type that contains information about price class for this streaming distribution.
        /// This member is required.
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution.
        /// This member is required.
        public var s3Origin: CloudFrontClientTypes.S3Origin?
        /// Indicates the current status of the distribution. When the status is Deployed, the distribution's information is fully propagated throughout the Amazon CloudFront system.
        /// This member is required.
        public var status: Swift.String?
        /// A complex type that specifies the Amazon Web Services accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items.If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution. For more information, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?

        public init (
            aRN: Swift.String? = nil,
            aliases: CloudFrontClientTypes.Aliases? = nil,
            comment: Swift.String? = nil,
            domainName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            s3Origin: CloudFrontClientTypes.S3Origin? = nil,
            status: Swift.String? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil
        )
        {
            self.aRN = aRN
            self.aliases = aliases
            self.comment = comment
            self.domainName = domainName
            self.enabled = enabled
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.priceClass = priceClass
            self.s3Origin = s3Origin
            self.status = status
            self.trustedSigners = trustedSigners
        }
    }

}

extension CloudFrontClientTypes.StreamingLoggingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case enabled = "Enabled"
        case `prefix` = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension CloudFrontClientTypes.StreamingLoggingConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls whether access logs are written for this streaming distribution.
    public struct StreamingLoggingConfig: Swift.Equatable {
        /// The Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com.
        /// This member is required.
        public var bucket: Swift.String?
        /// Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't want to enable logging when you create a streaming distribution or if you want to disable logging for an existing streaming distribution, specify false for Enabled, and specify empty Bucket and Prefix elements. If you specify false for Enabled but you specify values for Bucket and Prefix, the values are automatically deleted.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// An optional string that you want CloudFront to prefix to the access log filenames for this streaming distribution, for example, myprefix/. If you want to enable logging, but you don't want to specify a prefix, you still must include an empty Prefix element in the Logging element.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.`prefix` = `prefix`
        }
    }

}

extension CloudFrontClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudFrontClientTypes.Tag: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains Tag key and Tag value.
    public struct Tag: Swift.Equatable {
        /// A string that contains Tag key. The string length should be between 1 and 128 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        /// This member is required.
        public var key: Swift.String?
        /// A string that contains an optional Tag value. The string length should be between 0 and 256 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension CloudFrontClientTypes.TagKeys: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for tagkey0 in items {
                try itemsContainer.encode(tagkey0, forKey: ClientRuntime.Key("Key"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.items) {
            struct KeyVal0{struct Key{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Key>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.TagKeys: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains zero or more Tag elements.
    public struct TagKeys: Swift.Equatable {
        /// A complex type that contains Tag key elements.
        public var items: [Swift.String]?

        public init (
            items: [Swift.String]? = nil
        )
        {
            self.items = items
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<TagResourceOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let tags = input.operationInput.tags {
                let tagsdata = try encoder.encode(tags)
                let tagsbody = ClientRuntime.HttpBody.data(tagsdata)
                input.builder.withBody(tagsbody)
            } else {
                let tagsdata = try encoder.encode(input.operationInput)
                let tagsbody = ClientRuntime.HttpBody.data(tagsdata)
                input.builder.withBody(tagsbody)
            }
        } catch let err {
            throw SdkError<TagResourceOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension TagResourceInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tags = tags {
            try container.encode(tags, forKey: ClientRuntime.Key("Tags"))
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "Operation", value: "Tag"))
        if let resource = resource {
            let resourceQueryItem = ClientRuntime.URLQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
            items.append(resourceQueryItem)
        }
        return items
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/tagging"
    }
}

/// The request to add tags to a CloudFront resource.
public struct TagResourceInput: Swift.Equatable {
    /// An ARN of a CloudFront resource.
    /// This member is required.
    public var resource: Swift.String?
    /// A complex type that contains zero or more Tag elements.
    /// This member is required.
    public var tags: CloudFrontClientTypes.Tags?

    public init (
        resource: Swift.String? = nil,
        tags: CloudFrontClientTypes.Tags? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: CloudFrontClientTypes.Tags?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case invalidTagging(InvalidTagging)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension CloudFrontClientTypes.Tags: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for tag0 in items {
                try itemsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.items) {
            struct KeyVal0{struct Tag{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Tag].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Tag]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Tag]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Tags: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains zero or more Tag elements.
    public struct Tags: Swift.Equatable {
        /// A complex type that contains Tag elements.
        public var items: [CloudFrontClientTypes.Tag]?

        public init (
            items: [CloudFrontClientTypes.Tag]? = nil
        )
        {
            self.items = items
        }
    }

}

extension TestFunctionFailed {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TestFunctionFailedBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The CloudFront function failed.
public struct TestFunctionFailed: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TestFunctionFailedBody: Swift.Equatable {
    let message: Swift.String?
}

extension TestFunctionFailedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TestFunctionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension TestFunctionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventObject = "EventObject"
        case stage = "Stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eventObject = eventObject {
            try container.encode(eventObject, forKey: ClientRuntime.Key("EventObject"))
        }
        if let stage = stage {
            try container.encode(stage, forKey: ClientRuntime.Key("Stage"))
        }
    }
}

extension TestFunctionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension TestFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())/test"
    }
}

public struct TestFunctionInput: Swift.Equatable {
    /// The event object to test the function with. For more information about the structure of the event object, see [Testing functions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/managing-functions.html#test-function) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var eventObject: ClientRuntime.Data?
    /// The current version (ETag value) of the function that you are testing, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are testing.
    /// This member is required.
    public var name: Swift.String?
    /// The stage of the function that you are testing, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init (
        eventObject: ClientRuntime.Data? = nil,
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.eventObject = eventObject
        self.ifMatch = ifMatch
        self.name = name
        self.stage = stage
    }
}

struct TestFunctionInputBody: Swift.Equatable {
    let stage: CloudFrontClientTypes.FunctionStage?
    let eventObject: ClientRuntime.Data?
}

extension TestFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventObject = "EventObject"
        case stage = "Stage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionStage.self, forKey: .stage)
        stage = stageDecoded
        if containerValues.contains(.eventObject) {
            do {
                let eventObjectDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .eventObject)
                eventObject = eventObjectDecoded
            } catch {
                eventObject = "".data(using: .utf8)
            }
        } else {
            eventObject = nil
        }
    }
}

extension TestFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TestFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TestFunctionFailed" : self = .testFunctionFailed(try TestFunctionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestFunctionOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case testFunctionFailed(TestFunctionFailed)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.TestResult = try responseDecoder.decode(responseBody: data)
                self.testResult = output
            } else {
                self.testResult = nil
            }
        } else {
            self.testResult = nil
        }
    }
}

public struct TestFunctionOutputResponse: Swift.Equatable {
    /// An object that represents the result of running the function with the provided event object.
    public var testResult: CloudFrontClientTypes.TestResult?

    public init (
        testResult: CloudFrontClientTypes.TestResult? = nil
    )
    {
        self.testResult = testResult
    }
}

struct TestFunctionOutputResponseBody: Swift.Equatable {
    let testResult: CloudFrontClientTypes.TestResult?
}

extension TestFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case testResult = "TestResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testResultDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TestResult.self, forKey: .testResult)
        testResult = testResultDecoded
    }
}

extension CloudFrontClientTypes.TestResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeUtilization = "ComputeUtilization"
        case functionErrorMessage = "FunctionErrorMessage"
        case functionExecutionLogs = "FunctionExecutionLogs"
        case functionOutput = "FunctionOutput"
        case functionSummary = "FunctionSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let computeUtilization = computeUtilization {
            try container.encode(computeUtilization, forKey: ClientRuntime.Key("ComputeUtilization"))
        }
        if let functionErrorMessage = functionErrorMessage {
            try container.encode(functionErrorMessage, forKey: ClientRuntime.Key("FunctionErrorMessage"))
        }
        if let functionExecutionLogs = functionExecutionLogs {
            var functionExecutionLogsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("FunctionExecutionLogs"))
            for string0 in functionExecutionLogs {
                try functionExecutionLogsContainer.encode(string0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let functionOutput = functionOutput {
            try container.encode(functionOutput, forKey: ClientRuntime.Key("FunctionOutput"))
        }
        if let functionSummary = functionSummary {
            try container.encode(functionSummary, forKey: ClientRuntime.Key("FunctionSummary"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
        let computeUtilizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computeUtilization)
        computeUtilization = computeUtilizationDecoded
        if containerValues.contains(.functionExecutionLogs) {
            struct KeyVal0{struct member{}}
            let functionExecutionLogsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .functionExecutionLogs)
            if let functionExecutionLogsWrappedContainer = functionExecutionLogsWrappedContainer {
                let functionExecutionLogsContainer = try functionExecutionLogsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var functionExecutionLogsBuffer:[Swift.String]? = nil
                if let functionExecutionLogsContainer = functionExecutionLogsContainer {
                    functionExecutionLogsBuffer = [Swift.String]()
                    for stringContainer0 in functionExecutionLogsContainer {
                        functionExecutionLogsBuffer?.append(stringContainer0)
                    }
                }
                functionExecutionLogs = functionExecutionLogsBuffer
            } else {
                functionExecutionLogs = []
            }
        } else {
            functionExecutionLogs = nil
        }
        let functionErrorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionErrorMessage)
        functionErrorMessage = functionErrorMessageDecoded
        let functionOutputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionOutput)
        functionOutput = functionOutputDecoded
    }
}

extension CloudFrontClientTypes.TestResult: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains the result of testing a CloudFront function with TestFunction.
    public struct TestResult: Swift.Equatable {
        /// The amount of time that the function took to run as a percentage of the maximum allowed time. For example, a compute utilization of 35 means that the function completed in 35% of the maximum allowed time.
        public var computeUtilization: Swift.String?
        /// If the result of testing the function was an error, this field contains the error message.
        public var functionErrorMessage: Swift.String?
        /// Contains the log lines that the function wrote (if any) when running the test.
        public var functionExecutionLogs: [Swift.String]?
        /// The event object returned by the function. For more information about the structure of the event object, see [Event object structure](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/functions-event-structure.html) in the Amazon CloudFront Developer Guide.
        public var functionOutput: Swift.String?
        /// Contains configuration information and metadata about the CloudFront function that was tested.
        public var functionSummary: CloudFrontClientTypes.FunctionSummary?

        public init (
            computeUtilization: Swift.String? = nil,
            functionErrorMessage: Swift.String? = nil,
            functionExecutionLogs: [Swift.String]? = nil,
            functionOutput: Swift.String? = nil,
            functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
        )
        {
            self.computeUtilization = computeUtilization
            self.functionErrorMessage = functionErrorMessage
            self.functionExecutionLogs = functionExecutionLogs
            self.functionOutput = functionOutput
            self.functionSummary = functionSummary
        }
    }

}

extension TooManyCacheBehaviors {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCacheBehaviorsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot create more cache behaviors for the distribution.
public struct TooManyCacheBehaviors: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCacheBehaviorsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCacheBehaviorsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCachePolicies {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCachePoliciesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of cache policies for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCachePolicies: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCachePoliciesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCachePoliciesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCertificates {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCertificatesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot create anymore custom SSL/TLS certificates.
public struct TooManyCertificates: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCertificatesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCertificatesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCloudFrontOriginAccessIdentities {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCloudFrontOriginAccessIdentitiesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of origin access identities allowed.
public struct TooManyCloudFrontOriginAccessIdentities: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCloudFrontOriginAccessIdentitiesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCloudFrontOriginAccessIdentitiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCookieNamesInWhiteList {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCookieNamesInWhiteListBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains more cookie names in the whitelist than are allowed per cache behavior.
public struct TooManyCookieNamesInWhiteList: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCookieNamesInWhiteListBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCookieNamesInWhiteListBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCookiesInCachePolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCookiesInCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of cookies in the cache policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCookiesInCachePolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCookiesInCachePolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCookiesInCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCookiesInOriginRequestPolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCookiesInOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of cookies in the origin request policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCookiesInOriginRequestPolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCookiesInOriginRequestPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCookiesInOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCustomHeadersInResponseHeadersPolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCustomHeadersInResponseHeadersPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of custom headers in the response headers policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCustomHeadersInResponseHeadersPolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCustomHeadersInResponseHeadersPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCustomHeadersInResponseHeadersPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionCNAMEs {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionCNAMEsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains more CNAMEs than are allowed per distribution.
public struct TooManyDistributionCNAMEs: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionCNAMEsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionCNAMEsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributions {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of distributions allowed.
public struct TooManyDistributions: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension TooManyDistributionsAssociatedToCachePolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsAssociatedToCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of distributions have been associated with the specified cache policy. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToCachePolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToCachePolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsAssociatedToCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfig {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsAssociatedToFieldLevelEncryptionConfigBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of distributions have been associated with the specified configuration for field-level encryption.
public struct TooManyDistributionsAssociatedToFieldLevelEncryptionConfig: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToFieldLevelEncryptionConfigBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfigBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToKeyGroup {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsAssociatedToKeyGroupBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of distributions that reference this key group is more than the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToKeyGroup: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToKeyGroupBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsAssociatedToKeyGroupBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToOriginRequestPolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsAssociatedToOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of distributions have been associated with the specified origin request policy. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToOriginRequestPolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToOriginRequestPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsAssociatedToOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToResponseHeadersPolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsAssociatedToResponseHeadersPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of distributions have been associated with the specified response headers policy. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToResponseHeadersPolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToResponseHeadersPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsAssociatedToResponseHeadersPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

struct TooManyDistributionsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsWithFunctionAssociations {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsWithFunctionAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of distributions that are associated with a CloudFront function. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsWithFunctionAssociations: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsWithFunctionAssociationsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsWithFunctionAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsWithLambdaAssociations {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsWithLambdaAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Processing your request would cause the maximum number of distributions with Lambda@Edge function associations per owner to be exceeded.
public struct TooManyDistributionsWithLambdaAssociations: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsWithLambdaAssociationsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsWithLambdaAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsWithSingleFunctionARN {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsWithSingleFunctionARNBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of distributions have been associated with the specified Lambda@Edge function.
public struct TooManyDistributionsWithSingleFunctionARN: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsWithSingleFunctionARNBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsWithSingleFunctionARNBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionConfigs {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionConfigsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of configurations for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionConfigs: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionConfigsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFieldLevelEncryptionConfigsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionContentTypeProfiles {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionContentTypeProfilesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of content type profiles for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionContentTypeProfiles: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionContentTypeProfilesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFieldLevelEncryptionContentTypeProfilesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionEncryptionEntities {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionEncryptionEntitiesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of encryption entities for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionEncryptionEntities: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionEncryptionEntitiesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFieldLevelEncryptionEncryptionEntitiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionFieldPatterns {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionFieldPatternsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of field patterns for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionFieldPatterns: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionFieldPatternsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFieldLevelEncryptionFieldPatternsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionProfiles {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionProfilesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of profiles for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionProfiles: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionProfilesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFieldLevelEncryptionProfilesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionQueryArgProfiles {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionQueryArgProfilesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of query arg profiles for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionQueryArgProfiles: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionQueryArgProfilesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFieldLevelEncryptionQueryArgProfilesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFunctionAssociations {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFunctionAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of CloudFront function associations for this distribution. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyFunctionAssociations: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFunctionAssociationsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFunctionAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFunctions {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFunctionsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of CloudFront functions for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyFunctions: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFunctionsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFunctionsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyHeadersInCachePolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyHeadersInCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of headers in the cache policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyHeadersInCachePolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyHeadersInCachePolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyHeadersInCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyHeadersInForwardedValues {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyHeadersInForwardedValuesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains too many headers in forwarded values.
public struct TooManyHeadersInForwardedValues: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyHeadersInForwardedValuesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyHeadersInForwardedValuesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyHeadersInOriginRequestPolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyHeadersInOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of headers in the origin request policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyHeadersInOriginRequestPolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyHeadersInOriginRequestPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyHeadersInOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyInvalidationsInProgress {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyInvalidationsInProgressBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects.
public struct TooManyInvalidationsInProgress: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyInvalidationsInProgressBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyInvalidationsInProgressBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyKeyGroups {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyKeyGroupsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of key groups for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyKeyGroups: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension TooManyKeyGroupsAssociatedToDistribution {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyKeyGroupsAssociatedToDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of key groups referenced by this distribution is more than the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyKeyGroupsAssociatedToDistribution: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyKeyGroupsAssociatedToDistributionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyKeyGroupsAssociatedToDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

struct TooManyKeyGroupsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyKeyGroupsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyLambdaFunctionAssociations {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyLambdaFunctionAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains more Lambda@Edge function associations than are allowed per distribution.
public struct TooManyLambdaFunctionAssociations: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyLambdaFunctionAssociationsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyLambdaFunctionAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginCustomHeaders {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyOriginCustomHeadersBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains too many origin custom headers.
public struct TooManyOriginCustomHeaders: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginCustomHeadersBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyOriginCustomHeadersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginGroupsPerDistribution {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyOriginGroupsPerDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of origin groups allowed.
public struct TooManyOriginGroupsPerDistribution: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginGroupsPerDistributionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyOriginGroupsPerDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginRequestPolicies {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyOriginRequestPoliciesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of origin request policies for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyOriginRequestPolicies: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginRequestPoliciesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyOriginRequestPoliciesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOrigins {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyOriginsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot create more origins for the distribution.
public struct TooManyOrigins: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyOriginsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyPublicKeys {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyPublicKeysBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of public keys for field-level encryption have been created. To create a new public key, delete one of the existing keys.
public struct TooManyPublicKeys: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyPublicKeysBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyPublicKeysBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyPublicKeysInKeyGroup {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyPublicKeysInKeyGroupBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of public keys in this key group is more than the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyPublicKeysInKeyGroup: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyPublicKeysInKeyGroupBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyPublicKeysInKeyGroupBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyQueryStringParameters {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyQueryStringParametersBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains too many query string parameters.
public struct TooManyQueryStringParameters: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyQueryStringParametersBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyQueryStringParametersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyQueryStringsInCachePolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyQueryStringsInCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of query strings in the cache policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyQueryStringsInCachePolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyQueryStringsInCachePolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyQueryStringsInCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyQueryStringsInOriginRequestPolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyQueryStringsInOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of query strings in the origin request policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyQueryStringsInOriginRequestPolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyQueryStringsInOriginRequestPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyQueryStringsInOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRealtimeLogConfigs {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyRealtimeLogConfigsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of real-time log configurations for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyRealtimeLogConfigs: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRealtimeLogConfigsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRealtimeLogConfigsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyResponseHeadersPolicies {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyResponseHeadersPoliciesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of response headers policies for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyResponseHeadersPolicies: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyResponseHeadersPoliciesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyResponseHeadersPoliciesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyStreamingDistributionCNAMEs {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyStreamingDistributionCNAMEsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains more CNAMEs than are allowed per distribution.
public struct TooManyStreamingDistributionCNAMEs: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyStreamingDistributionCNAMEsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyStreamingDistributionCNAMEsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyStreamingDistributions {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyStreamingDistributionsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of streaming distributions allowed.
public struct TooManyStreamingDistributions: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyStreamingDistributionsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyStreamingDistributionsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTrustedSigners {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyTrustedSignersBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains more trusted signers than are allowed per distribution.
public struct TooManyTrustedSigners: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTrustedSignersBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTrustedSignersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrustedKeyGroupDoesNotExist {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TrustedKeyGroupDoesNotExistBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified key group does not exist.
public struct TrustedKeyGroupDoesNotExist: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TrustedKeyGroupDoesNotExistBody: Swift.Equatable {
    let message: Swift.String?
}

extension TrustedKeyGroupDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.TrustedKeyGroups: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("KeyGroup"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyGroup{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyGroup>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.TrustedKeyGroups: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of key groups whose public keys CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct TrustedKeyGroups: Swift.Equatable {
        /// This field is true if any of the key groups in the list have public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of key groups identifiers.
        public var items: [Swift.String]?
        /// The number of key groups in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension TrustedSignerDoesNotExist {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TrustedSignerDoesNotExistBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of your trusted signers don't exist.
public struct TrustedSignerDoesNotExist: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TrustedSignerDoesNotExistBody: Swift.Equatable {
    let message: Swift.String?
}

extension TrustedSignerDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.TrustedSigners: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("AwsAccountNumber"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct AwsAccountNumber{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AwsAccountNumber>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.TrustedSigners: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of Amazon Web Services accounts whose public keys CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct TrustedSigners: Swift.Equatable {
        /// This field is true if any of the Amazon Web Services accounts have public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of Amazon Web Services account identifiers.
        public var items: [Swift.String]?
        /// The number of Amazon Web Services accounts in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension UnsupportedOperation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<UnsupportedOperationBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This operation is not supported in this region.
public struct UnsupportedOperation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedOperationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let tagKeys = input.operationInput.tagKeys {
                let tagKeysdata = try encoder.encode(tagKeys)
                let tagKeysbody = ClientRuntime.HttpBody.data(tagKeysdata)
                input.builder.withBody(tagKeysbody)
            } else {
                let tagKeysdata = try encoder.encode(input.operationInput)
                let tagKeysbody = ClientRuntime.HttpBody.data(tagKeysdata)
                input.builder.withBody(tagKeysbody)
            }
        } catch let err {
            throw SdkError<UntagResourceOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UntagResourceInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tagKeys = tagKeys {
            try container.encode(tagKeys, forKey: ClientRuntime.Key("TagKeys"))
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "Operation", value: "Untag"))
        if let resource = resource {
            let resourceQueryItem = ClientRuntime.URLQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
            items.append(resourceQueryItem)
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/tagging"
    }
}

/// The request to remove tags from a CloudFront resource.
public struct UntagResourceInput: Swift.Equatable {
    /// An ARN of a CloudFront resource.
    /// This member is required.
    public var resource: Swift.String?
    /// A complex type that contains zero or more Tag key elements.
    /// This member is required.
    public var tagKeys: CloudFrontClientTypes.TagKeys?

    public init (
        resource: Swift.String? = nil,
        tagKeys: CloudFrontClientTypes.TagKeys? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let tagKeys: CloudFrontClientTypes.TagKeys?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TagKeys.self, forKey: .tagKeys)
        tagKeys = tagKeysDecoded
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case invalidTagging(InvalidTagging)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

public struct UpdateCachePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCachePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let cachePolicyConfig = input.operationInput.cachePolicyConfig {
                let cachePolicyConfigdata = try encoder.encode(cachePolicyConfig)
                let cachePolicyConfigbody = ClientRuntime.HttpBody.data(cachePolicyConfigdata)
                input.builder.withBody(cachePolicyConfigbody)
            } else {
                let cachePolicyConfigdata = try encoder.encode(input.operationInput)
                let cachePolicyConfigbody = ClientRuntime.HttpBody.data(cachePolicyConfigdata)
                input.builder.withBody(cachePolicyConfigbody)
            }
        } catch let err {
            throw SdkError<UpdateCachePolicyOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateCachePolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateCachePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicyConfig = cachePolicyConfig {
            try container.encode(cachePolicyConfig, forKey: ClientRuntime.Key("CachePolicyConfig"))
        }
    }
}

extension UpdateCachePolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateCachePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())"
    }
}

public struct UpdateCachePolicyInput: Swift.Equatable {
    /// A cache policy configuration.
    /// This member is required.
    public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
    /// The unique identifier for the cache policy that you are updating. The identifier is returned in a cache behavior’s CachePolicyId field in the response to GetDistributionConfig.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the cache policy that you are updating. The version is returned in the cache policy’s ETag field in the response to GetCachePolicyConfig.
    public var ifMatch: Swift.String?

    public init (
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateCachePolicyInputBody: Swift.Equatable {
    let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
}

extension UpdateCachePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension UpdateCachePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateCachePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CachePolicyAlreadyExists" : self = .cachePolicyAlreadyExists(try CachePolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInCachePolicy" : self = .tooManyCookiesInCachePolicy(try TooManyCookiesInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInCachePolicy" : self = .tooManyHeadersInCachePolicy(try TooManyHeadersInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInCachePolicy" : self = .tooManyQueryStringsInCachePolicy(try TooManyQueryStringsInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCachePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cachePolicyAlreadyExists(CachePolicyAlreadyExists)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case preconditionFailed(PreconditionFailed)
    case tooManyCookiesInCachePolicy(TooManyCookiesInCachePolicy)
    case tooManyHeadersInCachePolicy(TooManyHeadersInCachePolicy)
    case tooManyQueryStringsInCachePolicy(TooManyQueryStringsInCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCachePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CachePolicy = try responseDecoder.decode(responseBody: data)
                self.cachePolicy = output
            } else {
                self.cachePolicy = nil
            }
        } else {
            self.cachePolicy = nil
        }
    }
}

public struct UpdateCachePolicyOutputResponse: Swift.Equatable {
    /// A cache policy.
    public var cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// The current version of the cache policy.
    public var eTag: Swift.String?

    public init (
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
    }
}

struct UpdateCachePolicyOutputResponseBody: Swift.Equatable {
    let cachePolicy: CloudFrontClientTypes.CachePolicy?
}

extension UpdateCachePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

public struct UpdateCloudFrontOriginAccessIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCloudFrontOriginAccessIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let cloudFrontOriginAccessIdentityConfig = input.operationInput.cloudFrontOriginAccessIdentityConfig {
                let cloudFrontOriginAccessIdentityConfigdata = try encoder.encode(cloudFrontOriginAccessIdentityConfig)
                let cloudFrontOriginAccessIdentityConfigbody = ClientRuntime.HttpBody.data(cloudFrontOriginAccessIdentityConfigdata)
                input.builder.withBody(cloudFrontOriginAccessIdentityConfigbody)
            } else {
                let cloudFrontOriginAccessIdentityConfigdata = try encoder.encode(input.operationInput)
                let cloudFrontOriginAccessIdentityConfigbody = ClientRuntime.HttpBody.data(cloudFrontOriginAccessIdentityConfigdata)
                input.builder.withBody(cloudFrontOriginAccessIdentityConfigbody)
            }
        } catch let err {
            throw SdkError<UpdateCloudFrontOriginAccessIdentityOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateCloudFrontOriginAccessIdentityInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateCloudFrontOriginAccessIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig {
            try container.encode(cloudFrontOriginAccessIdentityConfig, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentityConfig"))
        }
    }
}

extension UpdateCloudFrontOriginAccessIdentityInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateCloudFrontOriginAccessIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())/config"
    }
}

/// The request to update an origin access identity.
public struct UpdateCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The identity's configuration information.
    /// This member is required.
    public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
    /// The identity's id.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the identity's configuration. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
    let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
}

extension UpdateCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension UpdateCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCloudFrontOriginAccessIdentityOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case missingBody(MissingBody)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCloudFrontOriginAccessIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentity = try responseDecoder.decode(responseBody: data)
                self.cloudFrontOriginAccessIdentity = output
            } else {
                self.cloudFrontOriginAccessIdentity = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentity = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct UpdateCloudFrontOriginAccessIdentityOutputResponse: Swift.Equatable {
    /// The origin access identity's information.
    public var cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init (
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
    }
}

struct UpdateCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Equatable {
    let cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
}

extension UpdateCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentity = "CloudFrontOriginAccessIdentity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentity.self, forKey: .cloudFrontOriginAccessIdentity)
        cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentityDecoded
    }
}

public struct UpdateDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDistributionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let distributionConfig = input.operationInput.distributionConfig {
                let distributionConfigdata = try encoder.encode(distributionConfig)
                let distributionConfigbody = ClientRuntime.HttpBody.data(distributionConfigdata)
                input.builder.withBody(distributionConfigbody)
            } else {
                let distributionConfigdata = try encoder.encode(input.operationInput)
                let distributionConfigbody = ClientRuntime.HttpBody.data(distributionConfigdata)
                input.builder.withBody(distributionConfigbody)
            }
        } catch let err {
            throw SdkError<UpdateDistributionOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateDistributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
    }
}

extension UpdateDistributionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())/config"
    }
}

/// The request to update a distribution.
public struct UpdateDistributionInput: Swift.Equatable {
    /// The distribution's configuration information.
    /// This member is required.
    public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
    /// The distribution's id.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the distribution's configuration. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.distributionConfig = distributionConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateDistributionInputBody: Swift.Equatable {
    let distributionConfig: CloudFrontClientTypes.DistributionConfig?
}

extension UpdateDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
    }
}

extension UpdateDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" : self = .illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefaultRootObject" : self = .invalidDefaultRootObject(try InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidErrorCode" : self = .invalidErrorCode(try InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidForwardCookies" : self = .invalidForwardCookies(try InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFunctionAssociation" : self = .invalidFunctionAssociation(try InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGeoRestrictionParameter" : self = .invalidGeoRestrictionParameter(try InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHeadersForS3Origin" : self = .invalidHeadersForS3Origin(try InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaFunctionAssociation" : self = .invalidLambdaFunctionAssociation(try InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLocationCode" : self = .invalidLocationCode(try InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMinimumProtocolVersion" : self = .invalidMinimumProtocolVersion(try InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginKeepaliveTimeout" : self = .invalidOriginKeepaliveTimeout(try InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginReadTimeout" : self = .invalidOriginReadTimeout(try InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryStringParameters" : self = .invalidQueryStringParameters(try InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativePath" : self = .invalidRelativePath(try InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequiredProtocol" : self = .invalidRequiredProtocol(try InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResponseCode" : self = .invalidResponseCode(try InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTTLOrder" : self = .invalidTTLOrder(try InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidViewerCertificate" : self = .invalidViewerCertificate(try InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrigin" : self = .noSuchOrigin(try NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResponseHeadersPolicy" : self = .noSuchResponseHeadersPolicy(try NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigOwnerMismatch" : self = .realtimeLogConfigOwnerMismatch(try RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCacheBehaviors" : self = .tooManyCacheBehaviors(try TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificates" : self = .tooManyCertificates(try TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookieNamesInWhiteList" : self = .tooManyCookieNamesInWhiteList(try TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionCNAMEs" : self = .tooManyDistributionCNAMEs(try TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToCachePolicy" : self = .tooManyDistributionsAssociatedToCachePolicy(try TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" : self = .tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToKeyGroup" : self = .tooManyDistributionsAssociatedToKeyGroup(try TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToOriginRequestPolicy" : self = .tooManyDistributionsAssociatedToOriginRequestPolicy(try TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy" : self = .tooManyDistributionsAssociatedToResponseHeadersPolicy(try TooManyDistributionsAssociatedToResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithFunctionAssociations" : self = .tooManyDistributionsWithFunctionAssociations(try TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithLambdaAssociations" : self = .tooManyDistributionsWithLambdaAssociations(try TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithSingleFunctionARN" : self = .tooManyDistributionsWithSingleFunctionARN(try TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctionAssociations" : self = .tooManyFunctionAssociations(try TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInForwardedValues" : self = .tooManyHeadersInForwardedValues(try TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroupsAssociatedToDistribution" : self = .tooManyKeyGroupsAssociatedToDistribution(try TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLambdaFunctionAssociations" : self = .tooManyLambdaFunctionAssociations(try TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginCustomHeaders" : self = .tooManyOriginCustomHeaders(try TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginGroupsPerDistribution" : self = .tooManyOriginGroupsPerDistribution(try TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOrigins" : self = .tooManyOrigins(try TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringParameters" : self = .tooManyQueryStringParameters(try TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedKeyGroupDoesNotExist" : self = .trustedKeyGroupDoesNotExist(try TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidDefaultRootObject(InvalidDefaultRootObject)
    case invalidErrorCode(InvalidErrorCode)
    case invalidForwardCookies(InvalidForwardCookies)
    case invalidFunctionAssociation(InvalidFunctionAssociation)
    case invalidGeoRestrictionParameter(InvalidGeoRestrictionParameter)
    case invalidHeadersForS3Origin(InvalidHeadersForS3Origin)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case invalidLambdaFunctionAssociation(InvalidLambdaFunctionAssociation)
    case invalidLocationCode(InvalidLocationCode)
    case invalidMinimumProtocolVersion(InvalidMinimumProtocolVersion)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidOriginKeepaliveTimeout(InvalidOriginKeepaliveTimeout)
    case invalidOriginReadTimeout(InvalidOriginReadTimeout)
    case invalidQueryStringParameters(InvalidQueryStringParameters)
    case invalidRelativePath(InvalidRelativePath)
    case invalidRequiredProtocol(InvalidRequiredProtocol)
    case invalidResponseCode(InvalidResponseCode)
    case invalidTTLOrder(InvalidTTLOrder)
    case invalidViewerCertificate(InvalidViewerCertificate)
    case invalidWebACLId(InvalidWebACLId)
    case missingBody(MissingBody)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case noSuchDistribution(NoSuchDistribution)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchOrigin(NoSuchOrigin)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case noSuchResponseHeadersPolicy(NoSuchResponseHeadersPolicy)
    case preconditionFailed(PreconditionFailed)
    case realtimeLogConfigOwnerMismatch(RealtimeLogConfigOwnerMismatch)
    case tooManyCacheBehaviors(TooManyCacheBehaviors)
    case tooManyCertificates(TooManyCertificates)
    case tooManyCookieNamesInWhiteList(TooManyCookieNamesInWhiteList)
    case tooManyDistributionCNAMEs(TooManyDistributionCNAMEs)
    case tooManyDistributionsAssociatedToCachePolicy(TooManyDistributionsAssociatedToCachePolicy)
    case tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(TooManyDistributionsAssociatedToFieldLevelEncryptionConfig)
    case tooManyDistributionsAssociatedToKeyGroup(TooManyDistributionsAssociatedToKeyGroup)
    case tooManyDistributionsAssociatedToOriginRequestPolicy(TooManyDistributionsAssociatedToOriginRequestPolicy)
    case tooManyDistributionsAssociatedToResponseHeadersPolicy(TooManyDistributionsAssociatedToResponseHeadersPolicy)
    case tooManyDistributionsWithFunctionAssociations(TooManyDistributionsWithFunctionAssociations)
    case tooManyDistributionsWithLambdaAssociations(TooManyDistributionsWithLambdaAssociations)
    case tooManyDistributionsWithSingleFunctionARN(TooManyDistributionsWithSingleFunctionARN)
    case tooManyFunctionAssociations(TooManyFunctionAssociations)
    case tooManyHeadersInForwardedValues(TooManyHeadersInForwardedValues)
    case tooManyKeyGroupsAssociatedToDistribution(TooManyKeyGroupsAssociatedToDistribution)
    case tooManyLambdaFunctionAssociations(TooManyLambdaFunctionAssociations)
    case tooManyOriginCustomHeaders(TooManyOriginCustomHeaders)
    case tooManyOriginGroupsPerDistribution(TooManyOriginGroupsPerDistribution)
    case tooManyOrigins(TooManyOrigins)
    case tooManyQueryStringParameters(TooManyQueryStringParameters)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedKeyGroupDoesNotExist(TrustedKeyGroupDoesNotExist)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct UpdateDistributionOutputResponse: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init (
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

struct UpdateDistributionOutputResponseBody: Swift.Equatable {
    let distribution: CloudFrontClientTypes.Distribution?
}

extension UpdateDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

public struct UpdateFieldLevelEncryptionConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let fieldLevelEncryptionConfig = input.operationInput.fieldLevelEncryptionConfig {
                let fieldLevelEncryptionConfigdata = try encoder.encode(fieldLevelEncryptionConfig)
                let fieldLevelEncryptionConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionConfigdata)
                input.builder.withBody(fieldLevelEncryptionConfigbody)
            } else {
                let fieldLevelEncryptionConfigdata = try encoder.encode(input.operationInput)
                let fieldLevelEncryptionConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionConfigdata)
                input.builder.withBody(fieldLevelEncryptionConfigbody)
            }
        } catch let err {
            throw SdkError<UpdateFieldLevelEncryptionConfigOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateFieldLevelEncryptionConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateFieldLevelEncryptionConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionConfig = fieldLevelEncryptionConfig {
            try container.encode(fieldLevelEncryptionConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionConfig"))
        }
    }
}

extension UpdateFieldLevelEncryptionConfigInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateFieldLevelEncryptionConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())/config"
    }
}

public struct UpdateFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// Request to update a field-level encryption configuration.
    /// This member is required.
    public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
    /// The ID of the configuration you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the configuration identity to update. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateFieldLevelEncryptionConfigInputBody: Swift.Equatable {
    let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
}

extension UpdateFieldLevelEncryptionConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension UpdateFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateFieldLevelEncryptionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QueryArgProfileEmpty" : self = .queryArgProfileEmpty(try QueryArgProfileEmpty(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionContentTypeProfiles" : self = .tooManyFieldLevelEncryptionContentTypeProfiles(try TooManyFieldLevelEncryptionContentTypeProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionQueryArgProfiles" : self = .tooManyFieldLevelEncryptionQueryArgProfiles(try TooManyFieldLevelEncryptionQueryArgProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFieldLevelEncryptionConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case preconditionFailed(PreconditionFailed)
    case queryArgProfileEmpty(QueryArgProfileEmpty)
    case tooManyFieldLevelEncryptionContentTypeProfiles(TooManyFieldLevelEncryptionContentTypeProfiles)
    case tooManyFieldLevelEncryptionQueryArgProfiles(TooManyFieldLevelEncryptionQueryArgProfiles)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFieldLevelEncryptionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryption = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryption = output
            } else {
                self.fieldLevelEncryption = nil
            }
        } else {
            self.fieldLevelEncryption = nil
        }
    }
}

public struct UpdateFieldLevelEncryptionConfigOutputResponse: Swift.Equatable {
    /// The value of the ETag header that you received when updating the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the results of updating the configuration.
    public var fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
    }
}

struct UpdateFieldLevelEncryptionConfigOutputResponseBody: Swift.Equatable {
    let fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
}

extension UpdateFieldLevelEncryptionConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryption = "FieldLevelEncryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryption.self, forKey: .fieldLevelEncryption)
        fieldLevelEncryption = fieldLevelEncryptionDecoded
    }
}

public struct UpdateFieldLevelEncryptionProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let fieldLevelEncryptionProfileConfig = input.operationInput.fieldLevelEncryptionProfileConfig {
                let fieldLevelEncryptionProfileConfigdata = try encoder.encode(fieldLevelEncryptionProfileConfig)
                let fieldLevelEncryptionProfileConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionProfileConfigdata)
                input.builder.withBody(fieldLevelEncryptionProfileConfigbody)
            } else {
                let fieldLevelEncryptionProfileConfigdata = try encoder.encode(input.operationInput)
                let fieldLevelEncryptionProfileConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionProfileConfigdata)
                input.builder.withBody(fieldLevelEncryptionProfileConfigbody)
            }
        } catch let err {
            throw SdkError<UpdateFieldLevelEncryptionProfileOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateFieldLevelEncryptionProfileInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateFieldLevelEncryptionProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig {
            try container.encode(fieldLevelEncryptionProfileConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileConfig"))
        }
    }
}

extension UpdateFieldLevelEncryptionProfileInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateFieldLevelEncryptionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())/config"
    }
}

public struct UpdateFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// Request to update a field-level encryption profile.
    /// This member is required.
    public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
    /// The ID of the field-level encryption profile request.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the profile identity to update. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateFieldLevelEncryptionProfileInputBody: Swift.Equatable {
    let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
}

extension UpdateFieldLevelEncryptionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension UpdateFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateFieldLevelEncryptionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileAlreadyExists" : self = .fieldLevelEncryptionProfileAlreadyExists(try FieldLevelEncryptionProfileAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileSizeExceeded" : self = .fieldLevelEncryptionProfileSizeExceeded(try FieldLevelEncryptionProfileSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionEncryptionEntities" : self = .tooManyFieldLevelEncryptionEncryptionEntities(try TooManyFieldLevelEncryptionEncryptionEntities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionFieldPatterns" : self = .tooManyFieldLevelEncryptionFieldPatterns(try TooManyFieldLevelEncryptionFieldPatterns(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFieldLevelEncryptionProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case fieldLevelEncryptionProfileAlreadyExists(FieldLevelEncryptionProfileAlreadyExists)
    case fieldLevelEncryptionProfileSizeExceeded(FieldLevelEncryptionProfileSizeExceeded)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case noSuchPublicKey(NoSuchPublicKey)
    case preconditionFailed(PreconditionFailed)
    case tooManyFieldLevelEncryptionEncryptionEntities(TooManyFieldLevelEncryptionEncryptionEntities)
    case tooManyFieldLevelEncryptionFieldPatterns(TooManyFieldLevelEncryptionFieldPatterns)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFieldLevelEncryptionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionProfile = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionProfile = output
            } else {
                self.fieldLevelEncryptionProfile = nil
            }
        } else {
            self.fieldLevelEncryptionProfile = nil
        }
    }
}

public struct UpdateFieldLevelEncryptionProfileOutputResponse: Swift.Equatable {
    /// The result of the field-level encryption profile request.
    public var eTag: Swift.String?
    /// Return the results of updating the profile.
    public var fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
    }
}

struct UpdateFieldLevelEncryptionProfileOutputResponseBody: Swift.Equatable {
    let fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
}

extension UpdateFieldLevelEncryptionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfile = "FieldLevelEncryptionProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfile.self, forKey: .fieldLevelEncryptionProfile)
        fieldLevelEncryptionProfile = fieldLevelEncryptionProfileDecoded
    }
}

extension UpdateFunctionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateFunctionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let functionCode = functionCode {
            try container.encode(functionCode, forKey: ClientRuntime.Key("FunctionCode"))
        }
        if let functionConfig = functionConfig {
            try container.encode(functionConfig, forKey: ClientRuntime.Key("FunctionConfig"))
        }
    }
}

extension UpdateFunctionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())"
    }
}

public struct UpdateFunctionInput: Swift.Equatable {
    /// The function code. For more information about writing a CloudFront function, see [Writing function code for CloudFront Functions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var functionCode: ClientRuntime.Data?
    /// Configuration information about the function.
    /// This member is required.
    public var functionConfig: CloudFrontClientTypes.FunctionConfig?
    /// The current version (ETag value) of the function that you are updating, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are updating.
    /// This member is required.
    public var name: Swift.String?

    public init (
        functionCode: ClientRuntime.Data? = nil,
        functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionCode = functionCode
        self.functionConfig = functionConfig
        self.ifMatch = ifMatch
        self.name = name
    }
}

struct UpdateFunctionInputBody: Swift.Equatable {
    let functionConfig: CloudFrontClientTypes.FunctionConfig?
    let functionCode: ClientRuntime.Data?
}

extension UpdateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionConfig.self, forKey: .functionConfig)
        functionConfig = functionConfigDecoded
        if containerValues.contains(.functionCode) {
            do {
                let functionCodeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .functionCode)
                functionCode = functionCodeDecoded
            } catch {
                functionCode = "".data(using: .utf8)
            }
        } else {
            functionCode = nil
        }
    }
}

extension UpdateFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FunctionSizeLimitExceeded" : self = .functionSizeLimitExceeded(try FunctionSizeLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionOutputError: Swift.Error, Swift.Equatable {
    case functionSizeLimitExceeded(FunctionSizeLimitExceeded)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case preconditionFailed(PreconditionFailed)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETtag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct UpdateFunctionOutputResponse: Swift.Equatable {
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init (
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
    }
}

struct UpdateFunctionOutputResponseBody: Swift.Equatable {
    let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension UpdateFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

public struct UpdateKeyGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateKeyGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let keyGroupConfig = input.operationInput.keyGroupConfig {
                let keyGroupConfigdata = try encoder.encode(keyGroupConfig)
                let keyGroupConfigbody = ClientRuntime.HttpBody.data(keyGroupConfigdata)
                input.builder.withBody(keyGroupConfigbody)
            } else {
                let keyGroupConfigdata = try encoder.encode(input.operationInput)
                let keyGroupConfigbody = ClientRuntime.HttpBody.data(keyGroupConfigdata)
                input.builder.withBody(keyGroupConfigbody)
            }
        } catch let err {
            throw SdkError<UpdateKeyGroupOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateKeyGroupInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateKeyGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroupConfig = keyGroupConfig {
            try container.encode(keyGroupConfig, forKey: ClientRuntime.Key("KeyGroupConfig"))
        }
    }
}

extension UpdateKeyGroupInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateKeyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())"
    }
}

public struct UpdateKeyGroupInput: Swift.Equatable {
    /// The identifier of the key group that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the key group that you are updating. The version is the key group’s ETag value.
    public var ifMatch: Swift.String?
    /// The key group configuration.
    /// This member is required.
    public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.keyGroupConfig = keyGroupConfig
    }
}

struct UpdateKeyGroupInputBody: Swift.Equatable {
    let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
}

extension UpdateKeyGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension UpdateKeyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateKeyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyGroupAlreadyExists" : self = .keyGroupAlreadyExists(try KeyGroupAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPublicKeysInKeyGroup" : self = .tooManyPublicKeysInKeyGroup(try TooManyPublicKeysInKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateKeyGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case keyGroupAlreadyExists(KeyGroupAlreadyExists)
    case noSuchResource(NoSuchResource)
    case preconditionFailed(PreconditionFailed)
    case tooManyPublicKeysInKeyGroup(TooManyPublicKeysInKeyGroup)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateKeyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.KeyGroup = try responseDecoder.decode(responseBody: data)
                self.keyGroup = output
            } else {
                self.keyGroup = nil
            }
        } else {
            self.keyGroup = nil
        }
    }
}

public struct UpdateKeyGroupOutputResponse: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group that was just updated.
    public var keyGroup: CloudFrontClientTypes.KeyGroup?

    public init (
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
    }
}

struct UpdateKeyGroupOutputResponseBody: Swift.Equatable {
    let keyGroup: CloudFrontClientTypes.KeyGroup?
}

extension UpdateKeyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

public struct UpdateOriginRequestPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOriginRequestPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let originRequestPolicyConfig = input.operationInput.originRequestPolicyConfig {
                let originRequestPolicyConfigdata = try encoder.encode(originRequestPolicyConfig)
                let originRequestPolicyConfigbody = ClientRuntime.HttpBody.data(originRequestPolicyConfigdata)
                input.builder.withBody(originRequestPolicyConfigbody)
            } else {
                let originRequestPolicyConfigdata = try encoder.encode(input.operationInput)
                let originRequestPolicyConfigbody = ClientRuntime.HttpBody.data(originRequestPolicyConfigdata)
                input.builder.withBody(originRequestPolicyConfigbody)
            }
        } catch let err {
            throw SdkError<UpdateOriginRequestPolicyOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateOriginRequestPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateOriginRequestPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originRequestPolicyConfig = originRequestPolicyConfig {
            try container.encode(originRequestPolicyConfig, forKey: ClientRuntime.Key("OriginRequestPolicyConfig"))
        }
    }
}

extension UpdateOriginRequestPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateOriginRequestPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())"
    }
}

public struct UpdateOriginRequestPolicyInput: Swift.Equatable {
    /// The unique identifier for the origin request policy that you are updating. The identifier is returned in a cache behavior’s OriginRequestPolicyId field in the response to GetDistributionConfig.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the origin request policy that you are updating. The version is returned in the origin request policy’s ETag field in the response to GetOriginRequestPolicyConfig.
    public var ifMatch: Swift.String?
    /// An origin request policy configuration.
    /// This member is required.
    public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

struct UpdateOriginRequestPolicyInputBody: Swift.Equatable {
    let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?
}

extension UpdateOriginRequestPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension UpdateOriginRequestPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateOriginRequestPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OriginRequestPolicyAlreadyExists" : self = .originRequestPolicyAlreadyExists(try OriginRequestPolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInOriginRequestPolicy" : self = .tooManyCookiesInOriginRequestPolicy(try TooManyCookiesInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInOriginRequestPolicy" : self = .tooManyHeadersInOriginRequestPolicy(try TooManyHeadersInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInOriginRequestPolicy" : self = .tooManyQueryStringsInOriginRequestPolicy(try TooManyQueryStringsInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOriginRequestPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case originRequestPolicyAlreadyExists(OriginRequestPolicyAlreadyExists)
    case preconditionFailed(PreconditionFailed)
    case tooManyCookiesInOriginRequestPolicy(TooManyCookiesInOriginRequestPolicy)
    case tooManyHeadersInOriginRequestPolicy(TooManyHeadersInOriginRequestPolicy)
    case tooManyQueryStringsInOriginRequestPolicy(TooManyQueryStringsInOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOriginRequestPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.OriginRequestPolicy = try responseDecoder.decode(responseBody: data)
                self.originRequestPolicy = output
            } else {
                self.originRequestPolicy = nil
            }
        } else {
            self.originRequestPolicy = nil
        }
    }
}

public struct UpdateOriginRequestPolicyOutputResponse: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// An origin request policy.
    public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init (
        eTag: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicy = originRequestPolicy
    }
}

struct UpdateOriginRequestPolicyOutputResponseBody: Swift.Equatable {
    let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
}

extension UpdateOriginRequestPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

public struct UpdatePublicKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let publicKeyConfig = input.operationInput.publicKeyConfig {
                let publicKeyConfigdata = try encoder.encode(publicKeyConfig)
                let publicKeyConfigbody = ClientRuntime.HttpBody.data(publicKeyConfigdata)
                input.builder.withBody(publicKeyConfigbody)
            } else {
                let publicKeyConfigdata = try encoder.encode(input.operationInput)
                let publicKeyConfigbody = ClientRuntime.HttpBody.data(publicKeyConfigdata)
                input.builder.withBody(publicKeyConfigbody)
            }
        } catch let err {
            throw SdkError<UpdatePublicKeyOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdatePublicKeyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdatePublicKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let publicKeyConfig = publicKeyConfig {
            try container.encode(publicKeyConfig, forKey: ClientRuntime.Key("PublicKeyConfig"))
        }
    }
}

extension UpdatePublicKeyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdatePublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())/config"
    }
}

public struct UpdatePublicKeyInput: Swift.Equatable {
    /// The identifier of the public key that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the public key to update. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?
    /// A public key configuration.
    /// This member is required.
    public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.publicKeyConfig = publicKeyConfig
    }
}

struct UpdatePublicKeyInputBody: Swift.Equatable {
    let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?
}

extension UpdatePublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension UpdatePublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdatePublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CannotChangeImmutablePublicKeyFields" : self = .cannotChangeImmutablePublicKeyFields(try CannotChangeImmutablePublicKeyFields(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePublicKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cannotChangeImmutablePublicKeyFields(CannotChangeImmutablePublicKeyFields)
    case illegalUpdate(IllegalUpdate)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchPublicKey(NoSuchPublicKey)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.PublicKey = try responseDecoder.decode(responseBody: data)
                self.publicKey = output
            } else {
                self.publicKey = nil
            }
        } else {
            self.publicKey = nil
        }
    }
}

public struct UpdatePublicKeyOutputResponse: Swift.Equatable {
    /// The identifier of the current version of the public key.
    public var eTag: Swift.String?
    /// The public key.
    public var publicKey: CloudFrontClientTypes.PublicKey?

    public init (
        eTag: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.publicKey = publicKey
    }
}

struct UpdatePublicKeyOutputResponseBody: Swift.Equatable {
    let publicKey: CloudFrontClientTypes.PublicKey?
}

extension UpdatePublicKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKey = "PublicKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKey.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

extension UpdateRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateRealtimeLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let endPoints = endPoints {
            var endPointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EndPoints"))
            for endpoint0 in endPoints {
                try endPointsContainer.encode(endpoint0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Fields"))
            for string0 in fields {
                try fieldsContainer.encode(string0, forKey: ClientRuntime.Key("Field"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: ClientRuntime.Key("SamplingRate"))
        }
    }
}

extension UpdateRealtimeLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/realtime-log-config"
    }
}

public struct UpdateRealtimeLogConfigInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for this real-time log configuration.
    public var aRN: Swift.String?
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
    public var endPoints: [CloudFrontClientTypes.EndPoint]?
    /// A list of fields to include in each real-time log record. For more information about fields, see [Real-time log configuration fields](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields) in the Amazon CloudFront Developer Guide.
    public var fields: [Swift.String]?
    /// The name for this real-time log configuration.
    public var name: Swift.String?
    /// The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. You must provide an integer between 1 and 100, inclusive.
    public var samplingRate: Swift.Int?

    public init (
        aRN: Swift.String? = nil,
        endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
        fields: [Swift.String]? = nil,
        name: Swift.String? = nil,
        samplingRate: Swift.Int? = nil
    )
    {
        self.aRN = aRN
        self.endPoints = endPoints
        self.fields = fields
        self.name = name
        self.samplingRate = samplingRate
    }
}

struct UpdateRealtimeLogConfigInputBody: Swift.Equatable {
    let endPoints: [CloudFrontClientTypes.EndPoint]?
    let fields: [Swift.String]?
    let name: Swift.String?
    let aRN: Swift.String?
    let samplingRate: Swift.Int?
}

extension UpdateRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.endPoints) {
            struct KeyVal0{struct member{}}
            let endPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endPoints)
            if let endPointsWrappedContainer = endPointsWrappedContainer {
                let endPointsContainer = try endPointsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EndPoint].self, forKey: .member)
                var endPointsBuffer:[CloudFrontClientTypes.EndPoint]? = nil
                if let endPointsContainer = endPointsContainer {
                    endPointsBuffer = [CloudFrontClientTypes.EndPoint]()
                    for structureContainer0 in endPointsContainer {
                        endPointsBuffer?.append(structureContainer0)
                    }
                }
                endPoints = endPointsBuffer
            } else {
                endPoints = []
            }
        } else {
            endPoints = nil
        }
        if containerValues.contains(.fields) {
            struct KeyVal0{struct Field{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldsBuffer:[Swift.String]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [Swift.String]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
    }
}

extension UpdateRealtimeLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateRealtimeLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRealtimeLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRealtimeLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRealtimeLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.realtimeLogConfig = output.realtimeLogConfig
        } else {
            self.realtimeLogConfig = nil
        }
    }
}

public struct UpdateRealtimeLogConfigOutputResponse: Swift.Equatable {
    /// A real-time log configuration.
    public var realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init (
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

struct UpdateRealtimeLogConfigOutputResponseBody: Swift.Equatable {
    let realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?
}

extension UpdateRealtimeLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfig = "RealtimeLogConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfig.self, forKey: .realtimeLogConfig)
        realtimeLogConfig = realtimeLogConfigDecoded
    }
}

public struct UpdateResponseHeadersPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResponseHeadersPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResponseHeadersPolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateResponseHeadersPolicyOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let responseHeadersPolicyConfig = input.operationInput.responseHeadersPolicyConfig {
                let responseHeadersPolicyConfigdata = try encoder.encode(responseHeadersPolicyConfig)
                let responseHeadersPolicyConfigbody = ClientRuntime.HttpBody.data(responseHeadersPolicyConfigdata)
                input.builder.withBody(responseHeadersPolicyConfigbody)
            } else {
                let responseHeadersPolicyConfigdata = try encoder.encode(input.operationInput)
                let responseHeadersPolicyConfigbody = ClientRuntime.HttpBody.data(responseHeadersPolicyConfigdata)
                input.builder.withBody(responseHeadersPolicyConfigbody)
            }
        } catch let err {
            throw SdkError<UpdateResponseHeadersPolicyOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResponseHeadersPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResponseHeadersPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateResponseHeadersPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateResponseHeadersPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicyConfig = "ResponseHeadersPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let responseHeadersPolicyConfig = responseHeadersPolicyConfig {
            try container.encode(responseHeadersPolicyConfig, forKey: ClientRuntime.Key("ResponseHeadersPolicyConfig"))
        }
    }
}

extension UpdateResponseHeadersPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateResponseHeadersPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())"
    }
}

public struct UpdateResponseHeadersPolicyInput: Swift.Equatable {
    /// The identifier for the response headers policy that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the response headers policy that you are updating. The version is returned in the cache policy’s ETag field in the response to GetResponseHeadersPolicyConfig.
    public var ifMatch: Swift.String?
    /// A response headers policy configuration.
    /// This member is required.
    public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
    }
}

struct UpdateResponseHeadersPolicyInputBody: Swift.Equatable {
    let responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?
}

extension UpdateResponseHeadersPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicyConfig = "ResponseHeadersPolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseHeadersPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyConfig.self, forKey: .responseHeadersPolicyConfig)
        responseHeadersPolicyConfig = responseHeadersPolicyConfigDecoded
    }
}

extension UpdateResponseHeadersPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateResponseHeadersPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResponseHeadersPolicy" : self = .noSuchResponseHeadersPolicy(try NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResponseHeadersPolicyAlreadyExists" : self = .responseHeadersPolicyAlreadyExists(try ResponseHeadersPolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCustomHeadersInResponseHeadersPolicy" : self = .tooManyCustomHeadersInResponseHeadersPolicy(try TooManyCustomHeadersInResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResponseHeadersPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchResponseHeadersPolicy(NoSuchResponseHeadersPolicy)
    case preconditionFailed(PreconditionFailed)
    case responseHeadersPolicyAlreadyExists(ResponseHeadersPolicyAlreadyExists)
    case tooManyCustomHeadersInResponseHeadersPolicy(TooManyCustomHeadersInResponseHeadersPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResponseHeadersPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.ResponseHeadersPolicy = try responseDecoder.decode(responseBody: data)
                self.responseHeadersPolicy = output
            } else {
                self.responseHeadersPolicy = nil
            }
        } else {
            self.responseHeadersPolicy = nil
        }
    }
}

public struct UpdateResponseHeadersPolicyOutputResponse: Swift.Equatable {
    /// The current version of the response headers policy.
    public var eTag: Swift.String?
    /// A response headers policy.
    public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?

    public init (
        eTag: Swift.String? = nil,
        responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil
    )
    {
        self.eTag = eTag
        self.responseHeadersPolicy = responseHeadersPolicy
    }
}

struct UpdateResponseHeadersPolicyOutputResponseBody: Swift.Equatable {
    let responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?
}

extension UpdateResponseHeadersPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicy = "ResponseHeadersPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseHeadersPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicy.self, forKey: .responseHeadersPolicy)
        responseHeadersPolicy = responseHeadersPolicyDecoded
    }
}

public struct UpdateStreamingDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStreamingDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let streamingDistributionConfig = input.operationInput.streamingDistributionConfig {
                let streamingDistributionConfigdata = try encoder.encode(streamingDistributionConfig)
                let streamingDistributionConfigbody = ClientRuntime.HttpBody.data(streamingDistributionConfigdata)
                input.builder.withBody(streamingDistributionConfigbody)
            } else {
                let streamingDistributionConfigdata = try encoder.encode(input.operationInput)
                let streamingDistributionConfigbody = ClientRuntime.HttpBody.data(streamingDistributionConfigdata)
                input.builder.withBody(streamingDistributionConfigbody)
            }
        } catch let err {
            throw SdkError<UpdateStreamingDistributionOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateStreamingDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateStreamingDistributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
    }
}

extension UpdateStreamingDistributionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateStreamingDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())/config"
    }
}

/// The request to update a streaming distribution.
public struct UpdateStreamingDistributionInput: Swift.Equatable {
    /// The streaming distribution's id.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the streaming distribution's configuration. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?
    /// The streaming distribution's configuration information.
    /// This member is required.
    public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

struct UpdateStreamingDistributionInputBody: Swift.Equatable {
    let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
}

extension UpdateStreamingDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension UpdateStreamingDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateStreamingDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributionCNAMEs" : self = .tooManyStreamingDistributionCNAMEs(try TooManyStreamingDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStreamingDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case missingBody(MissingBody)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case preconditionFailed(PreconditionFailed)
    case tooManyStreamingDistributionCNAMEs(TooManyStreamingDistributionCNAMEs)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStreamingDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct UpdateStreamingDistributionOutputResponse: Swift.Equatable {
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init (
        eTag: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistribution = streamingDistribution
    }
}

struct UpdateStreamingDistributionOutputResponseBody: Swift.Equatable {
    let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension UpdateStreamingDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

extension CloudFrontClientTypes.ViewerCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aCMCertificateArn = "ACMCertificateArn"
        case certificate = "Certificate"
        case certificateSource = "CertificateSource"
        case cloudFrontDefaultCertificate = "CloudFrontDefaultCertificate"
        case iAMCertificateId = "IAMCertificateId"
        case minimumProtocolVersion = "MinimumProtocolVersion"
        case sSLSupportMethod = "SSLSupportMethod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aCMCertificateArn = aCMCertificateArn {
            try container.encode(aCMCertificateArn, forKey: ClientRuntime.Key("ACMCertificateArn"))
        }
        if let certificate = certificate {
            try container.encode(certificate, forKey: ClientRuntime.Key("Certificate"))
        }
        if let certificateSource = certificateSource {
            try container.encode(certificateSource, forKey: ClientRuntime.Key("CertificateSource"))
        }
        if let cloudFrontDefaultCertificate = cloudFrontDefaultCertificate {
            try container.encode(cloudFrontDefaultCertificate, forKey: ClientRuntime.Key("CloudFrontDefaultCertificate"))
        }
        if let iAMCertificateId = iAMCertificateId {
            try container.encode(iAMCertificateId, forKey: ClientRuntime.Key("IAMCertificateId"))
        }
        if let minimumProtocolVersion = minimumProtocolVersion {
            try container.encode(minimumProtocolVersion, forKey: ClientRuntime.Key("MinimumProtocolVersion"))
        }
        if let sSLSupportMethod = sSLSupportMethod {
            try container.encode(sSLSupportMethod, forKey: ClientRuntime.Key("SSLSupportMethod"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontDefaultCertificateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cloudFrontDefaultCertificate)
        cloudFrontDefaultCertificate = cloudFrontDefaultCertificateDecoded
        let iAMCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iAMCertificateId)
        iAMCertificateId = iAMCertificateIdDecoded
        let aCMCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aCMCertificateArn)
        aCMCertificateArn = aCMCertificateArnDecoded
        let sSLSupportMethodDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.SSLSupportMethod.self, forKey: .sSLSupportMethod)
        sSLSupportMethod = sSLSupportMethodDecoded
        let minimumProtocolVersionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MinimumProtocolVersion.self, forKey: .minimumProtocolVersion)
        minimumProtocolVersion = minimumProtocolVersionDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateSourceDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CertificateSource.self, forKey: .certificateSource)
        certificateSource = certificateSourceDecoded
    }
}

extension CloudFrontClientTypes.ViewerCertificate: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that determines the distribution’s SSL/TLS configuration for communicating with viewers. If the distribution doesn’t use Aliases (also known as alternate domain names or CNAMEs)—that is, if the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net—set CloudFrontDefaultCertificate to true and leave all other fields empty. If the distribution uses Aliases (alternate domain names or CNAMEs), use the fields in this type to specify the following settings:
    ///
    /// * Which viewers the distribution accepts HTTPS connections from: only viewers that support [server name indication (SNI)](https://en.wikipedia.org/wiki/Server_Name_Indication) (recommended), or all viewers including those that don’t support SNI.
    ///
    /// * To accept HTTPS connections from only viewers that support SNI, set SSLSupportMethod to sni-only. This is recommended. Most browsers and clients support SNI.
    ///
    /// * To accept HTTPS connections from all viewers, including those that don’t support SNI, set SSLSupportMethod to vip. This is not recommended, and results in additional monthly charges from CloudFront.
    ///
    ///
    ///
    ///
    /// * The minimum SSL/TLS protocol version that the distribution can use to communicate with viewers. To specify a minimum version, choose a value for MinimumProtocolVersion. For more information, see [Security Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy) in the Amazon CloudFront Developer Guide.
    ///
    /// * The location of the SSL/TLS certificate, [Certificate Manager (ACM)](https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html) (recommended) or [Identity and Access Management (IAM)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html). You specify the location by setting a value in one of the following fields (not both):
    ///
    /// * ACMCertificateArn
    ///
    /// * IAMCertificateId
    ///
    ///
    ///
    ///
    ///
    /// All distributions support HTTPS connections from viewers. To require viewers to use HTTPS only, or to redirect them from HTTP to HTTPS, use ViewerProtocolPolicy in the CacheBehavior or DefaultCacheBehavior. To specify how CloudFront should use SSL/TLS to communicate with your custom origin, use CustomOriginConfig. For more information, see [Using HTTPS with CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https.html) and [ Using Alternate Domain Names and HTTPS](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-alternate-domain-names.html) in the Amazon CloudFront Developer Guide.
    public struct ViewerCertificate: Swift.Equatable {
        /// If the distribution uses Aliases (alternate domain names or CNAMEs) and the SSL/TLS certificate is stored in [Certificate Manager (ACM)](https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html), provide the Amazon Resource Name (ARN) of the ACM certificate. CloudFront only supports ACM certificates in the US East (N. Virginia) Region (us-east-1). If you specify an ACM certificate ARN, you must also specify values for MinimumProtocolVersion and SSLSupportMethod.
        public var aCMCertificateArn: Swift.String?
        /// This field is deprecated. Use one of the following fields instead:
        ///
        /// * ACMCertificateArn
        ///
        /// * IAMCertificateId
        ///
        /// * CloudFrontDefaultCertificate
        @available(*, deprecated)
        public var certificate: Swift.String?
        /// This field is deprecated. Use one of the following fields instead:
        ///
        /// * ACMCertificateArn
        ///
        /// * IAMCertificateId
        ///
        /// * CloudFrontDefaultCertificate
        @available(*, deprecated)
        public var certificateSource: CloudFrontClientTypes.CertificateSource?
        /// If the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net, set this field to true. If the distribution uses Aliases (alternate domain names or CNAMEs), set this field to false and specify values for the following fields:
        ///
        /// * ACMCertificateArn or IAMCertificateId (specify a value for one, not both)
        ///
        /// * MinimumProtocolVersion
        ///
        /// * SSLSupportMethod
        public var cloudFrontDefaultCertificate: Swift.Bool?
        /// If the distribution uses Aliases (alternate domain names or CNAMEs) and the SSL/TLS certificate is stored in [Identity and Access Management (IAM)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html), provide the ID of the IAM certificate. If you specify an IAM certificate ID, you must also specify values for MinimumProtocolVersion and SSLSupportMethod.
        public var iAMCertificateId: Swift.String?
        /// If the distribution uses Aliases (alternate domain names or CNAMEs), specify the security policy that you want CloudFront to use for HTTPS connections with viewers. The security policy determines two settings:
        ///
        /// * The minimum SSL/TLS protocol that CloudFront can use to communicate with viewers.
        ///
        /// * The ciphers that CloudFront can use to encrypt the content that it returns to viewers.
        ///
        ///
        /// For more information, see [Security Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy) and [Supported Protocols and Ciphers Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html#secure-connections-supported-ciphers) in the Amazon CloudFront Developer Guide. On the CloudFront console, this setting is called Security Policy. When you’re using SNI only (you set SSLSupportMethod to sni-only), you must specify TLSv1 or higher. If the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net (you set CloudFrontDefaultCertificate to true), CloudFront automatically sets the security policy to TLSv1 regardless of the value that you set here.
        public var minimumProtocolVersion: CloudFrontClientTypes.MinimumProtocolVersion?
        /// If the distribution uses Aliases (alternate domain names or CNAMEs), specify which viewers the distribution accepts HTTPS connections from.
        ///
        /// * sni-only – The distribution accepts HTTPS connections from only viewers that support [server name indication (SNI)](https://en.wikipedia.org/wiki/Server_Name_Indication). This is recommended. Most browsers and clients support SNI.
        ///
        /// * vip – The distribution accepts HTTPS connections from all viewers including those that don’t support SNI. This is not recommended, and results in additional monthly charges from CloudFront.
        ///
        /// * static-ip - Do not specify this value unless your distribution has been enabled for this feature by the CloudFront team. If you have a use case that requires static IP addresses for a distribution, contact CloudFront through the [Amazon Web Services Support Center](https://console.aws.amazon.com/support/home).
        ///
        ///
        /// If the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net, don’t set a value for this field.
        public var sSLSupportMethod: CloudFrontClientTypes.SSLSupportMethod?

        public init (
            aCMCertificateArn: Swift.String? = nil,
            certificate: Swift.String? = nil,
            certificateSource: CloudFrontClientTypes.CertificateSource? = nil,
            cloudFrontDefaultCertificate: Swift.Bool? = nil,
            iAMCertificateId: Swift.String? = nil,
            minimumProtocolVersion: CloudFrontClientTypes.MinimumProtocolVersion? = nil,
            sSLSupportMethod: CloudFrontClientTypes.SSLSupportMethod? = nil
        )
        {
            self.aCMCertificateArn = aCMCertificateArn
            self.certificate = certificate
            self.certificateSource = certificateSource
            self.cloudFrontDefaultCertificate = cloudFrontDefaultCertificate
            self.iAMCertificateId = iAMCertificateId
            self.minimumProtocolVersion = minimumProtocolVersion
            self.sSLSupportMethod = sSLSupportMethod
        }
    }

}

extension CloudFrontClientTypes {
    public enum ViewerProtocolPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allowAll
        case httpsOnly
        case redirectToHttps
        case sdkUnknown(Swift.String)

        public static var allCases: [ViewerProtocolPolicy] {
            return [
                .allowAll,
                .httpsOnly,
                .redirectToHttps,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allowAll: return "allow-all"
            case .httpsOnly: return "https-only"
            case .redirectToHttps: return "redirect-to-https"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ViewerProtocolPolicy(rawValue: rawValue) ?? ViewerProtocolPolicy.sdkUnknown(rawValue)
        }
    }
}
