// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AssociateEntityToThingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case namespaceVersion
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let namespaceVersion = self.namespaceVersion {
            try encodeContainer.encode(namespaceVersion, forKey: .namespaceVersion)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

extension AssociateEntityToThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateEntityToThingInput: Swift.Equatable {
    /// The ID of the device to be associated with the thing. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:device:DEVICENAME
    /// This member is required.
    public var entityId: Swift.String?
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
    public var namespaceVersion: Swift.Int?
    /// The name of the thing to which the entity is to be associated.
    /// This member is required.
    public var thingName: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        namespaceVersion: Swift.Int? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.namespaceVersion = namespaceVersion
        self.thingName = thingName
    }
}

struct AssociateEntityToThingInputBody: Swift.Equatable {
    let thingName: Swift.String?
    let entityId: Swift.String?
    let namespaceVersion: Swift.Int?
}

extension AssociateEntityToThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case namespaceVersion
        case thingName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
    }
}

extension AssociateEntityToThingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateEntityToThingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateEntityToThingOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateEntityToThingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateEntityToThingOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateFlowTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleNamespaceVersion = self.compatibleNamespaceVersion {
            try encodeContainer.encode(compatibleNamespaceVersion, forKey: .compatibleNamespaceVersion)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
    }
}

extension CreateFlowTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFlowTemplateInput: Swift.Equatable {
    /// The namespace version in which the workflow is to be created. If no value is specified, the latest version is used by default.
    public var compatibleNamespaceVersion: Swift.Int?
    /// The workflow DefinitionDocument.
    /// This member is required.
    public var definition: IoTThingsGraphClientTypes.DefinitionDocument?

    public init (
        compatibleNamespaceVersion: Swift.Int? = nil,
        definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
    }
}

struct CreateFlowTemplateInputBody: Swift.Equatable {
    let definition: IoTThingsGraphClientTypes.DefinitionDocument?
    let compatibleNamespaceVersion: Swift.Int?
}

extension CreateFlowTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let compatibleNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compatibleNamespaceVersion)
        compatibleNamespaceVersion = compatibleNamespaceVersionDecoded
    }
}

extension CreateFlowTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFlowTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFlowTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFlowTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFlowTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct CreateFlowTemplateOutputResponse: Swift.Equatable {
    /// The summary object that describes the created workflow.
    public var summary: IoTThingsGraphClientTypes.FlowTemplateSummary?

    public init (
        summary: IoTThingsGraphClientTypes.FlowTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct CreateFlowTemplateOutputResponseBody: Swift.Equatable {
    let summary: IoTThingsGraphClientTypes.FlowTemplateSummary?
}

extension CreateFlowTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summary
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.FlowTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension CreateSystemInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case flowActionsRoleArn
        case greengrassGroupName
        case metricsConfiguration
        case s3BucketName
        case tags
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let flowActionsRoleArn = self.flowActionsRoleArn {
            try encodeContainer.encode(flowActionsRoleArn, forKey: .flowActionsRoleArn)
        }
        if let greengrassGroupName = self.greengrassGroupName {
            try encodeContainer.encode(greengrassGroupName, forKey: .greengrassGroupName)
        }
        if let metricsConfiguration = self.metricsConfiguration {
            try encodeContainer.encode(metricsConfiguration, forKey: .metricsConfiguration)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let target = self.target {
            try encodeContainer.encode(target.rawValue, forKey: .target)
        }
    }
}

extension CreateSystemInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSystemInstanceInput: Swift.Equatable {
    /// A document that defines an entity.
    /// This member is required.
    public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
    /// The ARN of the IAM role that AWS IoT Things Graph will assume when it executes the flow. This role must have read and write access to AWS Lambda and AWS IoT and any other AWS services that the flow uses when it executes. This value is required if the value of the target parameter is CLOUD.
    public var flowActionsRoleArn: Swift.String?
    /// The name of the Greengrass group where the system instance will be deployed. This value is required if the value of the target parameter is GREENGRASS.
    public var greengrassGroupName: Swift.String?
    /// An object that specifies whether cloud metrics are collected in a deployment and, if so, what role is used to collect metrics.
    public var metricsConfiguration: IoTThingsGraphClientTypes.MetricsConfiguration?
    /// The name of the Amazon Simple Storage Service bucket that will be used to store and deploy the system instance's resource file. This value is required if the value of the target parameter is GREENGRASS.
    public var s3BucketName: Swift.String?
    /// Metadata, consisting of key-value pairs, that can be used to categorize your system instances.
    public var tags: [IoTThingsGraphClientTypes.Tag]?
    /// The target type of the deployment. Valid values are GREENGRASS and CLOUD.
    /// This member is required.
    public var target: IoTThingsGraphClientTypes.DeploymentTarget?

    public init (
        definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
        flowActionsRoleArn: Swift.String? = nil,
        greengrassGroupName: Swift.String? = nil,
        metricsConfiguration: IoTThingsGraphClientTypes.MetricsConfiguration? = nil,
        s3BucketName: Swift.String? = nil,
        tags: [IoTThingsGraphClientTypes.Tag]? = nil,
        target: IoTThingsGraphClientTypes.DeploymentTarget? = nil
    )
    {
        self.definition = definition
        self.flowActionsRoleArn = flowActionsRoleArn
        self.greengrassGroupName = greengrassGroupName
        self.metricsConfiguration = metricsConfiguration
        self.s3BucketName = s3BucketName
        self.tags = tags
        self.target = target
    }
}

struct CreateSystemInstanceInputBody: Swift.Equatable {
    let tags: [IoTThingsGraphClientTypes.Tag]?
    let definition: IoTThingsGraphClientTypes.DefinitionDocument?
    let target: IoTThingsGraphClientTypes.DeploymentTarget?
    let greengrassGroupName: Swift.String?
    let s3BucketName: Swift.String?
    let metricsConfiguration: IoTThingsGraphClientTypes.MetricsConfiguration?
    let flowActionsRoleArn: Swift.String?
}

extension CreateSystemInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case flowActionsRoleArn
        case greengrassGroupName
        case metricsConfiguration
        case s3BucketName
        case tags
        case target
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTThingsGraphClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTThingsGraphClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DeploymentTarget.self, forKey: .target)
        target = targetDecoded
        let greengrassGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupName)
        greengrassGroupName = greengrassGroupNameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let metricsConfigurationDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.MetricsConfiguration.self, forKey: .metricsConfiguration)
        metricsConfiguration = metricsConfigurationDecoded
        let flowActionsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowActionsRoleArn)
        flowActionsRoleArn = flowActionsRoleArnDecoded
    }
}

extension CreateSystemInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSystemInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSystemInstanceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSystemInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSystemInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct CreateSystemInstanceOutputResponse: Swift.Equatable {
    /// The summary object that describes the new system instance.
    public var summary: IoTThingsGraphClientTypes.SystemInstanceSummary?

    public init (
        summary: IoTThingsGraphClientTypes.SystemInstanceSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct CreateSystemInstanceOutputResponseBody: Swift.Equatable {
    let summary: IoTThingsGraphClientTypes.SystemInstanceSummary?
}

extension CreateSystemInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summary
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemInstanceSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension CreateSystemTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleNamespaceVersion = self.compatibleNamespaceVersion {
            try encodeContainer.encode(compatibleNamespaceVersion, forKey: .compatibleNamespaceVersion)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
    }
}

extension CreateSystemTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSystemTemplateInput: Swift.Equatable {
    /// The namespace version in which the system is to be created. If no value is specified, the latest version is used by default.
    public var compatibleNamespaceVersion: Swift.Int?
    /// The DefinitionDocument used to create the system.
    /// This member is required.
    public var definition: IoTThingsGraphClientTypes.DefinitionDocument?

    public init (
        compatibleNamespaceVersion: Swift.Int? = nil,
        definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
    }
}

struct CreateSystemTemplateInputBody: Swift.Equatable {
    let definition: IoTThingsGraphClientTypes.DefinitionDocument?
    let compatibleNamespaceVersion: Swift.Int?
}

extension CreateSystemTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let compatibleNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compatibleNamespaceVersion)
        compatibleNamespaceVersion = compatibleNamespaceVersionDecoded
    }
}

extension CreateSystemTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSystemTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSystemTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSystemTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSystemTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct CreateSystemTemplateOutputResponse: Swift.Equatable {
    /// The summary object that describes the created system.
    public var summary: IoTThingsGraphClientTypes.SystemTemplateSummary?

    public init (
        summary: IoTThingsGraphClientTypes.SystemTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct CreateSystemTemplateOutputResponseBody: Swift.Equatable {
    let summary: IoTThingsGraphClientTypes.SystemTemplateSummary?
}

extension CreateSystemTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summary
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension IoTThingsGraphClientTypes.DefinitionDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let language = self.language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionLanguage.self, forKey: .language)
        language = languageDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// A document that defines an entity.
    public struct DefinitionDocument: Swift.Equatable {
        /// The language used to define the entity. GRAPHQL is the only valid value.
        /// This member is required.
        public var language: IoTThingsGraphClientTypes.DefinitionLanguage?
        /// The GraphQL text that defines the entity.
        /// This member is required.
        public var text: Swift.String?

        public init (
            language: IoTThingsGraphClientTypes.DefinitionLanguage? = nil,
            text: Swift.String? = nil
        )
        {
            self.language = language
            self.text = text
        }
    }

}

extension IoTThingsGraphClientTypes {
    public enum DefinitionLanguage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case graphql
        case sdkUnknown(Swift.String)

        public static var allCases: [DefinitionLanguage] {
            return [
                .graphql,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .graphql: return "GRAPHQL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DefinitionLanguage(rawValue: rawValue) ?? DefinitionLanguage.sdkUnknown(rawValue)
        }
    }
}

extension DeleteFlowTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteFlowTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFlowTemplateInput: Swift.Equatable {
    /// The ID of the workflow to be deleted. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteFlowTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteFlowTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteFlowTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFlowTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFlowTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFlowTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFlowTemplateOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteNamespaceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteNamespaceInput: Swift.Equatable {

    public init () { }
}

struct DeleteNamespaceInputBody: Swift.Equatable {
}

extension DeleteNamespaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteNamespaceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namespaceArn = output.namespaceArn
            self.namespaceName = output.namespaceName
        } else {
            self.namespaceArn = nil
            self.namespaceName = nil
        }
    }
}

public struct DeleteNamespaceOutputResponse: Swift.Equatable {
    /// The ARN of the namespace to be deleted.
    public var namespaceArn: Swift.String?
    /// The name of the namespace to be deleted.
    public var namespaceName: Swift.String?

    public init (
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil
    )
    {
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
    }
}

struct DeleteNamespaceOutputResponseBody: Swift.Equatable {
    let namespaceArn: Swift.String?
    let namespaceName: Swift.String?
}

extension DeleteNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceArn
        case namespaceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
    }
}

extension DeleteSystemInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteSystemInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSystemInstanceInput: Swift.Equatable {
    /// The ID of the system instance to be deleted.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteSystemInstanceInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteSystemInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteSystemInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSystemInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSystemInstanceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSystemInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSystemInstanceOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSystemTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteSystemTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSystemTemplateInput: Swift.Equatable {
    /// The ID of the system to be deleted. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteSystemTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteSystemTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteSystemTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSystemTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSystemTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSystemTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSystemTemplateOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTThingsGraphClientTypes.DependencyRevision: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case revisionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revisionNumber = self.revisionNumber {
            try encodeContainer.encode(revisionNumber, forKey: .revisionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let revisionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revisionNumber)
        revisionNumber = revisionNumberDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains the ID and revision number of a workflow or system that is part of a deployment.
    public struct DependencyRevision: Swift.Equatable {
        /// The ID of the workflow or system.
        public var id: Swift.String?
        /// The revision number of the workflow or system.
        public var revisionNumber: Swift.Int?

        public init (
            id: Swift.String? = nil,
            revisionNumber: Swift.Int? = nil
        )
        {
            self.id = id
            self.revisionNumber = revisionNumber
        }
    }

}

extension DeploySystemInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeploySystemInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeploySystemInstanceInput: Swift.Equatable {
    /// The ID of the system instance. This value is returned by the CreateSystemInstance action. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:deployment:DEPLOYMENTNAME
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeploySystemInstanceInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeploySystemInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeploySystemInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeploySystemInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeploySystemInstanceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeploySystemInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeploySystemInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.greengrassDeploymentId = output.greengrassDeploymentId
            self.summary = output.summary
        } else {
            self.greengrassDeploymentId = nil
            self.summary = nil
        }
    }
}

public struct DeploySystemInstanceOutputResponse: Swift.Equatable {
    /// The ID of the Greengrass deployment used to deploy the system instance.
    public var greengrassDeploymentId: Swift.String?
    /// An object that contains summary information about a system instance that was deployed.
    /// This member is required.
    public var summary: IoTThingsGraphClientTypes.SystemInstanceSummary?

    public init (
        greengrassDeploymentId: Swift.String? = nil,
        summary: IoTThingsGraphClientTypes.SystemInstanceSummary? = nil
    )
    {
        self.greengrassDeploymentId = greengrassDeploymentId
        self.summary = summary
    }
}

struct DeploySystemInstanceOutputResponseBody: Swift.Equatable {
    let summary: IoTThingsGraphClientTypes.SystemInstanceSummary?
    let greengrassDeploymentId: Swift.String?
}

extension DeploySystemInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case greengrassDeploymentId
        case summary
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemInstanceSummary.self, forKey: .summary)
        summary = summaryDecoded
        let greengrassDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassDeploymentId)
        greengrassDeploymentId = greengrassDeploymentIdDecoded
    }
}

extension IoTThingsGraphClientTypes {
    public enum DeploymentTarget: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloud
        case greengrass
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentTarget] {
            return [
                .cloud,
                .greengrass,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloud: return "CLOUD"
            case .greengrass: return "GREENGRASS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentTarget(rawValue: rawValue) ?? DeploymentTarget.sdkUnknown(rawValue)
        }
    }
}

extension DeprecateFlowTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeprecateFlowTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeprecateFlowTemplateInput: Swift.Equatable {
    /// The ID of the workflow to be deleted. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeprecateFlowTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeprecateFlowTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeprecateFlowTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeprecateFlowTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeprecateFlowTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeprecateFlowTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeprecateFlowTemplateOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeprecateSystemTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeprecateSystemTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeprecateSystemTemplateInput: Swift.Equatable {
    /// The ID of the system to delete. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeprecateSystemTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeprecateSystemTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeprecateSystemTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeprecateSystemTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeprecateSystemTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeprecateSystemTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeprecateSystemTemplateOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
    }
}

extension DescribeNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeNamespaceInput: Swift.Equatable {
    /// The name of the user's namespace. Set this to aws to get the public namespace.
    public var namespaceName: Swift.String?

    public init (
        namespaceName: Swift.String? = nil
    )
    {
        self.namespaceName = namespaceName
    }
}

struct DescribeNamespaceInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
}

extension DescribeNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
    }
}

extension DescribeNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeNamespaceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namespaceArn = output.namespaceArn
            self.namespaceName = output.namespaceName
            self.namespaceVersion = output.namespaceVersion
            self.trackingNamespaceName = output.trackingNamespaceName
            self.trackingNamespaceVersion = output.trackingNamespaceVersion
        } else {
            self.namespaceArn = nil
            self.namespaceName = nil
            self.namespaceVersion = nil
            self.trackingNamespaceName = nil
            self.trackingNamespaceVersion = nil
        }
    }
}

public struct DescribeNamespaceOutputResponse: Swift.Equatable {
    /// The ARN of the namespace.
    public var namespaceArn: Swift.String?
    /// The name of the namespace.
    public var namespaceName: Swift.String?
    /// The version of the user's namespace to describe.
    public var namespaceVersion: Swift.Int?
    /// The name of the public namespace that the latest namespace version is tracking.
    public var trackingNamespaceName: Swift.String?
    /// The version of the public namespace that the latest version is tracking.
    public var trackingNamespaceVersion: Swift.Int?

    public init (
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        namespaceVersion: Swift.Int? = nil,
        trackingNamespaceName: Swift.String? = nil,
        trackingNamespaceVersion: Swift.Int? = nil
    )
    {
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.namespaceVersion = namespaceVersion
        self.trackingNamespaceName = trackingNamespaceName
        self.trackingNamespaceVersion = trackingNamespaceVersion
    }
}

struct DescribeNamespaceOutputResponseBody: Swift.Equatable {
    let namespaceArn: Swift.String?
    let namespaceName: Swift.String?
    let trackingNamespaceName: Swift.String?
    let trackingNamespaceVersion: Swift.Int?
    let namespaceVersion: Swift.Int?
}

extension DescribeNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceArn
        case namespaceName
        case namespaceVersion
        case trackingNamespaceName
        case trackingNamespaceVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let trackingNamespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingNamespaceName)
        trackingNamespaceName = trackingNamespaceNameDecoded
        let trackingNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .trackingNamespaceVersion)
        trackingNamespaceVersion = trackingNamespaceVersionDecoded
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
    }
}

extension DissociateEntityFromThingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityType
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityType = self.entityType {
            try encodeContainer.encode(entityType.rawValue, forKey: .entityType)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

extension DissociateEntityFromThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DissociateEntityFromThingInput: Swift.Equatable {
    /// The entity type from which to disassociate the thing.
    /// This member is required.
    public var entityType: IoTThingsGraphClientTypes.EntityType?
    /// The name of the thing to disassociate.
    /// This member is required.
    public var thingName: Swift.String?

    public init (
        entityType: IoTThingsGraphClientTypes.EntityType? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.entityType = entityType
        self.thingName = thingName
    }
}

struct DissociateEntityFromThingInputBody: Swift.Equatable {
    let thingName: Swift.String?
    let entityType: IoTThingsGraphClientTypes.EntityType?
}

extension DissociateEntityFromThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityType
        case thingName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.EntityType.self, forKey: .entityType)
        entityType = entityTypeDecoded
    }
}

extension DissociateEntityFromThingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DissociateEntityFromThingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DissociateEntityFromThingOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DissociateEntityFromThingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DissociateEntityFromThingOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTThingsGraphClientTypes.EntityDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case definition
        case id
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.EntityType.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// Describes the properties of an entity.
    public struct EntityDescription: Swift.Equatable {
        /// The entity ARN.
        public var arn: Swift.String?
        /// The time at which the entity was created.
        public var createdAt: ClientRuntime.Date?
        /// The definition document of the entity.
        public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
        /// The entity ID.
        public var id: Swift.String?
        /// The entity type.
        public var type: IoTThingsGraphClientTypes.EntityType?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
            id: Swift.String? = nil,
            type: IoTThingsGraphClientTypes.EntityType? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.definition = definition
            self.id = id
            self.type = type
        }
    }

}

extension IoTThingsGraphClientTypes.EntityFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for entityfiltervalue0 in value {
                try valueContainer.encode(entityfiltervalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.EntityFilterName.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .value)
        var valueDecoded0:[Swift.String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [Swift.String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that filters an entity search. Multiple filters function as OR criteria in the search. For example a search that includes a NAMESPACE and a REFERENCED_ENTITY_ID filter searches for entities in the specified namespace that use the entity specified by the value of REFERENCED_ENTITY_ID.
    public struct EntityFilter: Swift.Equatable {
        /// The name of the entity search filter field. REFERENCED_ENTITY_ID filters on entities that are used by the entity in the result set. For example, you can filter on the ID of a property that is used in a state.
        public var name: IoTThingsGraphClientTypes.EntityFilterName?
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        public var value: [Swift.String]?

        public init (
            name: IoTThingsGraphClientTypes.EntityFilterName? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IoTThingsGraphClientTypes {
    public enum EntityFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case name
        case namespace
        case referencedEntityId
        case semanticTypePath
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityFilterName] {
            return [
                .name,
                .namespace,
                .referencedEntityId,
                .semanticTypePath,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case .namespace: return "NAMESPACE"
            case .referencedEntityId: return "REFERENCED_ENTITY_ID"
            case .semanticTypePath: return "SEMANTIC_TYPE_PATH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityFilterName(rawValue: rawValue) ?? EntityFilterName.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes {
    public enum EntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case action
        case capability
        case device
        case deviceModel
        case `enum`
        case event
        case mapping
        case property
        case service
        case state
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .action,
                .capability,
                .device,
                .deviceModel,
                .enum,
                .event,
                .mapping,
                .property,
                .service,
                .state,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .action: return "ACTION"
            case .capability: return "CAPABILITY"
            case .device: return "DEVICE"
            case .deviceModel: return "DEVICE_MODEL"
            case .enum: return "ENUM"
            case .event: return "EVENT"
            case .mapping: return "MAPPING"
            case .property: return "PROPERTY"
            case .service: return "SERVICE"
            case .state: return "STATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes {
    public enum FlowExecutionEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acknowledgeTaskMessage
        case activityFailed
        case activityScheduled
        case activityStarted
        case activitySucceeded
        case executionAborted
        case executionFailed
        case executionStarted
        case executionSucceeded
        case scheduleNextReadyStepsTask
        case startFlowExecutionTask
        case stepFailed
        case stepStarted
        case stepSucceeded
        case thingActionTask
        case thingActionTaskFailed
        case thingActionTaskSucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowExecutionEventType] {
            return [
                .acknowledgeTaskMessage,
                .activityFailed,
                .activityScheduled,
                .activityStarted,
                .activitySucceeded,
                .executionAborted,
                .executionFailed,
                .executionStarted,
                .executionSucceeded,
                .scheduleNextReadyStepsTask,
                .startFlowExecutionTask,
                .stepFailed,
                .stepStarted,
                .stepSucceeded,
                .thingActionTask,
                .thingActionTaskFailed,
                .thingActionTaskSucceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acknowledgeTaskMessage: return "ACKNOWLEDGE_TASK_MESSAGE"
            case .activityFailed: return "ACTIVITY_FAILED"
            case .activityScheduled: return "ACTIVITY_SCHEDULED"
            case .activityStarted: return "ACTIVITY_STARTED"
            case .activitySucceeded: return "ACTIVITY_SUCCEEDED"
            case .executionAborted: return "EXECUTION_ABORTED"
            case .executionFailed: return "EXECUTION_FAILED"
            case .executionStarted: return "EXECUTION_STARTED"
            case .executionSucceeded: return "EXECUTION_SUCCEEDED"
            case .scheduleNextReadyStepsTask: return "SCHEDULE_NEXT_READY_STEPS_TASK"
            case .startFlowExecutionTask: return "START_FLOW_EXECUTION_TASK"
            case .stepFailed: return "STEP_FAILED"
            case .stepStarted: return "STEP_STARTED"
            case .stepSucceeded: return "STEP_SUCCEEDED"
            case .thingActionTask: return "THING_ACTION_TASK"
            case .thingActionTaskFailed: return "THING_ACTION_TASK_FAILED"
            case .thingActionTaskSucceeded: return "THING_ACTION_TASK_SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FlowExecutionEventType(rawValue: rawValue) ?? FlowExecutionEventType.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes.FlowExecutionMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType
        case messageId
        case payload
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.FlowExecutionEventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains information about a flow event.
    public struct FlowExecutionMessage: Swift.Equatable {
        /// The type of flow event .
        public var eventType: IoTThingsGraphClientTypes.FlowExecutionEventType?
        /// The unique identifier of the message.
        public var messageId: Swift.String?
        /// A string containing information about the flow event.
        public var payload: Swift.String?
        /// The date and time when the message was last updated.
        public var timestamp: ClientRuntime.Date?

        public init (
            eventType: IoTThingsGraphClientTypes.FlowExecutionEventType? = nil,
            messageId: Swift.String? = nil,
            payload: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.eventType = eventType
            self.messageId = messageId
            self.payload = payload
            self.timestamp = timestamp
        }
    }

}

extension IoTThingsGraphClientTypes {
    public enum FlowExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aborted
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowExecutionStatus] {
            return [
                .aborted,
                .failed,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FlowExecutionStatus(rawValue: rawValue) ?? FlowExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes.FlowExecutionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case flowExecutionId
        case flowTemplateId
        case status
        case systemInstanceId
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let flowExecutionId = self.flowExecutionId {
            try encodeContainer.encode(flowExecutionId, forKey: .flowExecutionId)
        }
        if let flowTemplateId = self.flowTemplateId {
            try encodeContainer.encode(flowTemplateId, forKey: .flowTemplateId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let systemInstanceId = self.systemInstanceId {
            try encodeContainer.encode(systemInstanceId, forKey: .systemInstanceId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowExecutionId)
        flowExecutionId = flowExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.FlowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let systemInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .systemInstanceId)
        systemInstanceId = systemInstanceIdDecoded
        let flowTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowTemplateId)
        flowTemplateId = flowTemplateIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains summary information about a flow execution.
    public struct FlowExecutionSummary: Swift.Equatable {
        /// The date and time when the flow execution summary was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the flow execution.
        public var flowExecutionId: Swift.String?
        /// The ID of the flow.
        public var flowTemplateId: Swift.String?
        /// The current status of the flow execution.
        public var status: IoTThingsGraphClientTypes.FlowExecutionStatus?
        /// The ID of the system instance that contains the flow.
        public var systemInstanceId: Swift.String?
        /// The date and time when the flow execution summary was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            flowExecutionId: Swift.String? = nil,
            flowTemplateId: Swift.String? = nil,
            status: IoTThingsGraphClientTypes.FlowExecutionStatus? = nil,
            systemInstanceId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.flowExecutionId = flowExecutionId
            self.flowTemplateId = flowTemplateId
            self.status = status
            self.systemInstanceId = systemInstanceId
            self.updatedAt = updatedAt
        }
    }

}

extension IoTThingsGraphClientTypes.FlowTemplateDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case summary
        case validatedNamespaceVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let validatedNamespaceVersion = self.validatedNamespaceVersion {
            try encodeContainer.encode(validatedNamespaceVersion, forKey: .validatedNamespaceVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.FlowTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let validatedNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validatedNamespaceVersion)
        validatedNamespaceVersion = validatedNamespaceVersionDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains a workflow's definition and summary information.
    public struct FlowTemplateDescription: Swift.Equatable {
        /// A workflow's definition document.
        public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
        /// An object that contains summary information about a workflow.
        public var summary: IoTThingsGraphClientTypes.FlowTemplateSummary?
        /// The version of the user's namespace against which the workflow was validated. Use this value in your system instance.
        public var validatedNamespaceVersion: Swift.Int?

        public init (
            definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
            summary: IoTThingsGraphClientTypes.FlowTemplateSummary? = nil,
            validatedNamespaceVersion: Swift.Int? = nil
        )
        {
            self.definition = definition
            self.summary = summary
            self.validatedNamespaceVersion = validatedNamespaceVersion
        }
    }

}

extension IoTThingsGraphClientTypes.FlowTemplateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for flowtemplatefiltervalue0 in value {
                try valueContainer.encode(flowtemplatefiltervalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.FlowTemplateFilterName.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .value)
        var valueDecoded0:[Swift.String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [Swift.String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that filters a workflow search.
    public struct FlowTemplateFilter: Swift.Equatable {
        /// The name of the search filter field.
        /// This member is required.
        public var name: IoTThingsGraphClientTypes.FlowTemplateFilterName?
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        /// This member is required.
        public var value: [Swift.String]?

        public init (
            name: IoTThingsGraphClientTypes.FlowTemplateFilterName? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IoTThingsGraphClientTypes {
    public enum FlowTemplateFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deviceModelId
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowTemplateFilterName] {
            return [
                .deviceModelId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deviceModelId: return "DEVICE_MODEL_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FlowTemplateFilterName(rawValue: rawValue) ?? FlowTemplateFilterName.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes.FlowTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case revisionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revisionNumber = self.revisionNumber {
            try encodeContainer.encode(revisionNumber, forKey: .revisionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let revisionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revisionNumber)
        revisionNumber = revisionNumberDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains summary information about a workflow.
    public struct FlowTemplateSummary: Swift.Equatable {
        /// The ARN of the workflow.
        public var arn: Swift.String?
        /// The date when the workflow was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the workflow.
        public var id: Swift.String?
        /// The revision number of the workflow.
        public var revisionNumber: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            revisionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.revisionNumber = revisionNumber
        }
    }

}

extension GetEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case namespaceVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for urn0 in ids {
                try idsContainer.encode(urn0)
            }
        }
        if let namespaceVersion = self.namespaceVersion {
            try encodeContainer.encode(namespaceVersion, forKey: .namespaceVersion)
        }
    }
}

extension GetEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEntitiesInput: Swift.Equatable {
    /// An array of entity IDs. The IDs should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:device:DEVICENAME
    /// This member is required.
    public var ids: [Swift.String]?
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
    public var namespaceVersion: Swift.Int?

    public init (
        ids: [Swift.String]? = nil,
        namespaceVersion: Swift.Int? = nil
    )
    {
        self.ids = ids
        self.namespaceVersion = namespaceVersion
    }
}

struct GetEntitiesInputBody: Swift.Equatable {
    let ids: [Swift.String]?
    let namespaceVersion: Swift.Int?
}

extension GetEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case namespaceVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
    }
}

extension GetEntitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEntitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetEntitiesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEntitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.descriptions = output.descriptions
        } else {
            self.descriptions = nil
        }
    }
}

public struct GetEntitiesOutputResponse: Swift.Equatable {
    /// An array of descriptions for the specified entities.
    public var descriptions: [IoTThingsGraphClientTypes.EntityDescription]?

    public init (
        descriptions: [IoTThingsGraphClientTypes.EntityDescription]? = nil
    )
    {
        self.descriptions = descriptions
    }
}

struct GetEntitiesOutputResponseBody: Swift.Equatable {
    let descriptions: [IoTThingsGraphClientTypes.EntityDescription]?
}

extension GetEntitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case descriptions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionsContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.EntityDescription?].self, forKey: .descriptions)
        var descriptionsDecoded0:[IoTThingsGraphClientTypes.EntityDescription]? = nil
        if let descriptionsContainer = descriptionsContainer {
            descriptionsDecoded0 = [IoTThingsGraphClientTypes.EntityDescription]()
            for structure0 in descriptionsContainer {
                if let structure0 = structure0 {
                    descriptionsDecoded0?.append(structure0)
                }
            }
        }
        descriptions = descriptionsDecoded0
    }
}

extension GetFlowTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case revisionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revisionNumber = self.revisionNumber {
            try encodeContainer.encode(revisionNumber, forKey: .revisionNumber)
        }
    }
}

extension GetFlowTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFlowTemplateInput: Swift.Equatable {
    /// The ID of the workflow. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
    /// This member is required.
    public var id: Swift.String?
    /// The number of the workflow revision to retrieve.
    public var revisionNumber: Swift.Int?

    public init (
        id: Swift.String? = nil,
        revisionNumber: Swift.Int? = nil
    )
    {
        self.id = id
        self.revisionNumber = revisionNumber
    }
}

struct GetFlowTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
    let revisionNumber: Swift.Int?
}

extension GetFlowTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case revisionNumber
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let revisionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revisionNumber)
        revisionNumber = revisionNumberDecoded
    }
}

extension GetFlowTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFlowTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFlowTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFlowTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetFlowTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
        } else {
            self.description = nil
        }
    }
}

public struct GetFlowTemplateOutputResponse: Swift.Equatable {
    /// The object that describes the specified workflow.
    public var description: IoTThingsGraphClientTypes.FlowTemplateDescription?

    public init (
        description: IoTThingsGraphClientTypes.FlowTemplateDescription? = nil
    )
    {
        self.description = description
    }
}

struct GetFlowTemplateOutputResponseBody: Swift.Equatable {
    let description: IoTThingsGraphClientTypes.FlowTemplateDescription?
}

extension GetFlowTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.FlowTemplateDescription.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GetFlowTemplateRevisionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetFlowTemplateRevisionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFlowTemplateRevisionsInput: Swift.Equatable {
    /// The ID of the workflow. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init (
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetFlowTemplateRevisionsInputBody: Swift.Equatable {
    let id: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetFlowTemplateRevisionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetFlowTemplateRevisionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFlowTemplateRevisionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFlowTemplateRevisionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFlowTemplateRevisionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetFlowTemplateRevisionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct GetFlowTemplateRevisionsOutputResponse: Swift.Equatable {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that provide summary data about each revision.
    public var summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]?

    public init (
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct GetFlowTemplateRevisionsOutputResponseBody: Swift.Equatable {
    let summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]?
    let nextToken: Swift.String?
}

extension GetFlowTemplateRevisionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.FlowTemplateSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTThingsGraphClientTypes.FlowTemplateSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTThingsGraphClientTypes.FlowTemplateSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetNamespaceDeletionStatusInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetNamespaceDeletionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetNamespaceDeletionStatusInput: Swift.Equatable {

    public init () { }
}

struct GetNamespaceDeletionStatusInputBody: Swift.Equatable {
}

extension GetNamespaceDeletionStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNamespaceDeletionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNamespaceDeletionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetNamespaceDeletionStatusOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNamespaceDeletionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetNamespaceDeletionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.errorMessage = output.errorMessage
            self.namespaceArn = output.namespaceArn
            self.namespaceName = output.namespaceName
            self.status = output.status
        } else {
            self.errorCode = nil
            self.errorMessage = nil
            self.namespaceArn = nil
            self.namespaceName = nil
            self.status = nil
        }
    }
}

public struct GetNamespaceDeletionStatusOutputResponse: Swift.Equatable {
    /// An error code returned by the namespace deletion task.
    public var errorCode: IoTThingsGraphClientTypes.NamespaceDeletionStatusErrorCodes?
    /// An error code returned by the namespace deletion task.
    public var errorMessage: Swift.String?
    /// The ARN of the namespace that is being deleted.
    public var namespaceArn: Swift.String?
    /// The name of the namespace that is being deleted.
    public var namespaceName: Swift.String?
    /// The status of the deletion request.
    public var status: IoTThingsGraphClientTypes.NamespaceDeletionStatus?

    public init (
        errorCode: IoTThingsGraphClientTypes.NamespaceDeletionStatusErrorCodes? = nil,
        errorMessage: Swift.String? = nil,
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        status: IoTThingsGraphClientTypes.NamespaceDeletionStatus? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.status = status
    }
}

struct GetNamespaceDeletionStatusOutputResponseBody: Swift.Equatable {
    let namespaceArn: Swift.String?
    let namespaceName: Swift.String?
    let status: IoTThingsGraphClientTypes.NamespaceDeletionStatus?
    let errorCode: IoTThingsGraphClientTypes.NamespaceDeletionStatusErrorCodes?
    let errorMessage: Swift.String?
}

extension GetNamespaceDeletionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case namespaceArn
        case namespaceName
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.NamespaceDeletionStatus.self, forKey: .status)
        status = statusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.NamespaceDeletionStatusErrorCodes.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension GetSystemInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension GetSystemInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSystemInstanceInput: Swift.Equatable {
    /// The ID of the system deployment instance. This value is returned by CreateSystemInstance. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:deployment:DEPLOYMENTNAME
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetSystemInstanceInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension GetSystemInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetSystemInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSystemInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSystemInstanceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSystemInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSystemInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
        } else {
            self.description = nil
        }
    }
}

public struct GetSystemInstanceOutputResponse: Swift.Equatable {
    /// An object that describes the system instance.
    public var description: IoTThingsGraphClientTypes.SystemInstanceDescription?

    public init (
        description: IoTThingsGraphClientTypes.SystemInstanceDescription? = nil
    )
    {
        self.description = description
    }
}

struct GetSystemInstanceOutputResponseBody: Swift.Equatable {
    let description: IoTThingsGraphClientTypes.SystemInstanceDescription?
}

extension GetSystemInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemInstanceDescription.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GetSystemTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case revisionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revisionNumber = self.revisionNumber {
            try encodeContainer.encode(revisionNumber, forKey: .revisionNumber)
        }
    }
}

extension GetSystemTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSystemTemplateInput: Swift.Equatable {
    /// The ID of the system to get. This ID must be in the user's namespace. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
    /// This member is required.
    public var id: Swift.String?
    /// The number that specifies the revision of the system to get.
    public var revisionNumber: Swift.Int?

    public init (
        id: Swift.String? = nil,
        revisionNumber: Swift.Int? = nil
    )
    {
        self.id = id
        self.revisionNumber = revisionNumber
    }
}

struct GetSystemTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
    let revisionNumber: Swift.Int?
}

extension GetSystemTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case revisionNumber
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let revisionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revisionNumber)
        revisionNumber = revisionNumberDecoded
    }
}

extension GetSystemTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSystemTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSystemTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSystemTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSystemTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
        } else {
            self.description = nil
        }
    }
}

public struct GetSystemTemplateOutputResponse: Swift.Equatable {
    /// An object that contains summary data about the system.
    public var description: IoTThingsGraphClientTypes.SystemTemplateDescription?

    public init (
        description: IoTThingsGraphClientTypes.SystemTemplateDescription? = nil
    )
    {
        self.description = description
    }
}

struct GetSystemTemplateOutputResponseBody: Swift.Equatable {
    let description: IoTThingsGraphClientTypes.SystemTemplateDescription?
}

extension GetSystemTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemTemplateDescription.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GetSystemTemplateRevisionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetSystemTemplateRevisionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSystemTemplateRevisionsInput: Swift.Equatable {
    /// The ID of the system template. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init (
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetSystemTemplateRevisionsInputBody: Swift.Equatable {
    let id: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetSystemTemplateRevisionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetSystemTemplateRevisionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSystemTemplateRevisionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSystemTemplateRevisionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSystemTemplateRevisionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSystemTemplateRevisionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct GetSystemTemplateRevisionsOutputResponse: Swift.Equatable {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain summary data about the system template revisions.
    public var summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]?

    public init (
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct GetSystemTemplateRevisionsOutputResponseBody: Swift.Equatable {
    let summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]?
    let nextToken: Swift.String?
}

extension GetSystemTemplateRevisionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.SystemTemplateSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTThingsGraphClientTypes.SystemTemplateSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTThingsGraphClientTypes.SystemTemplateSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetUploadStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uploadId = self.uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

extension GetUploadStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetUploadStatusInput: Swift.Equatable {
    /// The ID of the upload. This value is returned by the UploadEntityDefinitions action.
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        uploadId: Swift.String? = nil
    )
    {
        self.uploadId = uploadId
    }
}

struct GetUploadStatusInputBody: Swift.Equatable {
    let uploadId: Swift.String?
}

extension GetUploadStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
    }
}

extension GetUploadStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUploadStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetUploadStatusOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUploadStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetUploadStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.failureReason = output.failureReason
            self.namespaceArn = output.namespaceArn
            self.namespaceName = output.namespaceName
            self.namespaceVersion = output.namespaceVersion
            self.uploadId = output.uploadId
            self.uploadStatus = output.uploadStatus
        } else {
            self.createdDate = nil
            self.failureReason = nil
            self.namespaceArn = nil
            self.namespaceName = nil
            self.namespaceVersion = nil
            self.uploadId = nil
            self.uploadStatus = nil
        }
    }
}

public struct GetUploadStatusOutputResponse: Swift.Equatable {
    /// The date at which the upload was created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// The reason for an upload failure.
    public var failureReason: [Swift.String]?
    /// The ARN of the upload.
    public var namespaceArn: Swift.String?
    /// The name of the upload's namespace.
    public var namespaceName: Swift.String?
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
    public var namespaceVersion: Swift.Int?
    /// The ID of the upload.
    /// This member is required.
    public var uploadId: Swift.String?
    /// The status of the upload. The initial status is IN_PROGRESS. The response show all validation failures if the upload fails.
    /// This member is required.
    public var uploadStatus: IoTThingsGraphClientTypes.UploadStatus?

    public init (
        createdDate: ClientRuntime.Date? = nil,
        failureReason: [Swift.String]? = nil,
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        namespaceVersion: Swift.Int? = nil,
        uploadId: Swift.String? = nil,
        uploadStatus: IoTThingsGraphClientTypes.UploadStatus? = nil
    )
    {
        self.createdDate = createdDate
        self.failureReason = failureReason
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.namespaceVersion = namespaceVersion
        self.uploadId = uploadId
        self.uploadStatus = uploadStatus
    }
}

struct GetUploadStatusOutputResponseBody: Swift.Equatable {
    let uploadId: Swift.String?
    let uploadStatus: IoTThingsGraphClientTypes.UploadStatus?
    let namespaceArn: Swift.String?
    let namespaceName: Swift.String?
    let namespaceVersion: Swift.Int?
    let failureReason: [Swift.String]?
    let createdDate: ClientRuntime.Date?
}

extension GetUploadStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case failureReason
        case namespaceArn
        case namespaceName
        case namespaceVersion
        case uploadId
        case uploadStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let uploadStatusDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.UploadStatus.self, forKey: .uploadStatus)
        uploadStatus = uploadStatusDecoded
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
        let failureReasonContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReason)
        var failureReasonDecoded0:[Swift.String]? = nil
        if let failureReasonContainer = failureReasonContainer {
            failureReasonDecoded0 = [Swift.String]()
            for string0 in failureReasonContainer {
                if let string0 = string0 {
                    failureReasonDecoded0?.append(string0)
                }
            }
        }
        failureReason = failureReasonDecoded0
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension InternalFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct InternalFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListFlowExecutionMessagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowExecutionId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowExecutionId = self.flowExecutionId {
            try encodeContainer.encode(flowExecutionId, forKey: .flowExecutionId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFlowExecutionMessagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFlowExecutionMessagesInput: Swift.Equatable {
    /// The ID of the flow execution.
    /// This member is required.
    public var flowExecutionId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init (
        flowExecutionId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowExecutionId = flowExecutionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFlowExecutionMessagesInputBody: Swift.Equatable {
    let flowExecutionId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListFlowExecutionMessagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowExecutionId
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowExecutionId)
        flowExecutionId = flowExecutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFlowExecutionMessagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFlowExecutionMessagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFlowExecutionMessagesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFlowExecutionMessagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFlowExecutionMessagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.messages = output.messages
            self.nextToken = output.nextToken
        } else {
            self.messages = nil
            self.nextToken = nil
        }
    }
}

public struct ListFlowExecutionMessagesOutputResponse: Swift.Equatable {
    /// A list of objects that contain information about events in the specified flow execution.
    public var messages: [IoTThingsGraphClientTypes.FlowExecutionMessage]?
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?

    public init (
        messages: [IoTThingsGraphClientTypes.FlowExecutionMessage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.messages = messages
        self.nextToken = nextToken
    }
}

struct ListFlowExecutionMessagesOutputResponseBody: Swift.Equatable {
    let messages: [IoTThingsGraphClientTypes.FlowExecutionMessage]?
    let nextToken: Swift.String?
}

extension ListFlowExecutionMessagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messages
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.FlowExecutionMessage?].self, forKey: .messages)
        var messagesDecoded0:[IoTThingsGraphClientTypes.FlowExecutionMessage]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [IoTThingsGraphClientTypes.FlowExecutionMessage]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of tags to return.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results to return.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource whose tags are to be returned.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let resourceArn: Swift.String?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The token that specifies the next page of results to return.
    public var nextToken: Swift.String?
    /// List of tags returned by the ListTagsForResource operation.
    public var tags: [IoTThingsGraphClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [IoTThingsGraphClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [IoTThingsGraphClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTThingsGraphClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTThingsGraphClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTThingsGraphClientTypes.MetricsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudMetricEnabled
        case metricRuleRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cloudMetricEnabled != false {
            try encodeContainer.encode(cloudMetricEnabled, forKey: .cloudMetricEnabled)
        }
        if let metricRuleRoleArn = self.metricRuleRoleArn {
            try encodeContainer.encode(metricRuleRoleArn, forKey: .metricRuleRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudMetricEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cloudMetricEnabled) ?? false
        cloudMetricEnabled = cloudMetricEnabledDecoded
        let metricRuleRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricRuleRoleArn)
        metricRuleRoleArn = metricRuleRoleArnDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that specifies whether cloud metrics are collected in a deployment and, if so, what role is used to collect metrics.
    public struct MetricsConfiguration: Swift.Equatable {
        /// A Boolean that specifies whether cloud metrics are collected.
        public var cloudMetricEnabled: Swift.Bool
        /// The ARN of the role that is used to collect cloud metrics.
        public var metricRuleRoleArn: Swift.String?

        public init (
            cloudMetricEnabled: Swift.Bool = false,
            metricRuleRoleArn: Swift.String? = nil
        )
        {
            self.cloudMetricEnabled = cloudMetricEnabled
            self.metricRuleRoleArn = metricRuleRoleArn
        }
    }

}

extension IoTThingsGraphClientTypes {
    public enum NamespaceDeletionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceDeletionStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceDeletionStatus(rawValue: rawValue) ?? NamespaceDeletionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes {
    public enum NamespaceDeletionStatusErrorCodes: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case validationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceDeletionStatusErrorCodes] {
            return [
                .validationFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .validationFailed: return "VALIDATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceDeletionStatusErrorCodes(rawValue: rawValue) ?? NamespaceDeletionStatusErrorCodes.sdkUnknown(rawValue)
        }
    }
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SearchEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityTypes
        case filters
        case maxResults
        case namespaceVersion
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityTypes = entityTypes {
            var entityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTypes)
            for entitytype0 in entityTypes {
                try entityTypesContainer.encode(entitytype0.rawValue)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for entityfilter0 in filters {
                try filtersContainer.encode(entityfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let namespaceVersion = self.namespaceVersion {
            try encodeContainer.encode(namespaceVersion, forKey: .namespaceVersion)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchEntitiesInput: Swift.Equatable {
    /// The entity types for which to search.
    /// This member is required.
    public var entityTypes: [IoTThingsGraphClientTypes.EntityType]?
    /// Optional filter to apply to the search. Valid filters are NAMENAMESPACE, SEMANTIC_TYPE_PATH and REFERENCED_ENTITY_ID. REFERENCED_ENTITY_ID filters on entities that are used by the entity in the result set. For example, you can filter on the ID of a property that is used in a state. Multiple filters function as OR criteria in the query. Multiple values passed inside the filter function as AND criteria.
    public var filters: [IoTThingsGraphClientTypes.EntityFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
    public var namespaceVersion: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init (
        entityTypes: [IoTThingsGraphClientTypes.EntityType]? = nil,
        filters: [IoTThingsGraphClientTypes.EntityFilter]? = nil,
        maxResults: Swift.Int? = nil,
        namespaceVersion: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entityTypes = entityTypes
        self.filters = filters
        self.maxResults = maxResults
        self.namespaceVersion = namespaceVersion
        self.nextToken = nextToken
    }
}

struct SearchEntitiesInputBody: Swift.Equatable {
    let entityTypes: [IoTThingsGraphClientTypes.EntityType]?
    let filters: [IoTThingsGraphClientTypes.EntityFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let namespaceVersion: Swift.Int?
}

extension SearchEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityTypes
        case filters
        case maxResults
        case namespaceVersion
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityTypesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.EntityType?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[IoTThingsGraphClientTypes.EntityType]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [IoTThingsGraphClientTypes.EntityType]()
            for string0 in entityTypesContainer {
                if let string0 = string0 {
                    entityTypesDecoded0?.append(string0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.EntityFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTThingsGraphClientTypes.EntityFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTThingsGraphClientTypes.EntityFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
    }
}

extension SearchEntitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchEntitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchEntitiesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchEntitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.descriptions = output.descriptions
            self.nextToken = output.nextToken
        } else {
            self.descriptions = nil
            self.nextToken = nil
        }
    }
}

public struct SearchEntitiesOutputResponse: Swift.Equatable {
    /// An array of descriptions for each entity returned in the search result.
    public var descriptions: [IoTThingsGraphClientTypes.EntityDescription]?
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?

    public init (
        descriptions: [IoTThingsGraphClientTypes.EntityDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.descriptions = descriptions
        self.nextToken = nextToken
    }
}

struct SearchEntitiesOutputResponseBody: Swift.Equatable {
    let descriptions: [IoTThingsGraphClientTypes.EntityDescription]?
    let nextToken: Swift.String?
}

extension SearchEntitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case descriptions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionsContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.EntityDescription?].self, forKey: .descriptions)
        var descriptionsDecoded0:[IoTThingsGraphClientTypes.EntityDescription]? = nil
        if let descriptionsContainer = descriptionsContainer {
            descriptionsDecoded0 = [IoTThingsGraphClientTypes.EntityDescription]()
            for structure0 in descriptionsContainer {
                if let structure0 = structure0 {
                    descriptionsDecoded0?.append(structure0)
                }
            }
        }
        descriptions = descriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SearchFlowExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case flowExecutionId
        case maxResults
        case nextToken
        case startTime
        case systemInstanceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let flowExecutionId = self.flowExecutionId {
            try encodeContainer.encode(flowExecutionId, forKey: .flowExecutionId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let systemInstanceId = self.systemInstanceId {
            try encodeContainer.encode(systemInstanceId, forKey: .systemInstanceId)
        }
    }
}

extension SearchFlowExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchFlowExecutionsInput: Swift.Equatable {
    /// The date and time of the latest flow execution to return.
    public var endTime: ClientRuntime.Date?
    /// The ID of a flow execution.
    public var flowExecutionId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?
    /// The date and time of the earliest flow execution to return.
    public var startTime: ClientRuntime.Date?
    /// The ID of the system instance that contains the flow.
    /// This member is required.
    public var systemInstanceId: Swift.String?

    public init (
        endTime: ClientRuntime.Date? = nil,
        flowExecutionId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        systemInstanceId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.flowExecutionId = flowExecutionId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.systemInstanceId = systemInstanceId
    }
}

struct SearchFlowExecutionsInputBody: Swift.Equatable {
    let systemInstanceId: Swift.String?
    let flowExecutionId: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchFlowExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case flowExecutionId
        case maxResults
        case nextToken
        case startTime
        case systemInstanceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let systemInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .systemInstanceId)
        systemInstanceId = systemInstanceIdDecoded
        let flowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowExecutionId)
        flowExecutionId = flowExecutionIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchFlowExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchFlowExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchFlowExecutionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchFlowExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchFlowExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct SearchFlowExecutionsOutputResponse: Swift.Equatable {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain summary information about each workflow execution in the result set.
    public var summaries: [IoTThingsGraphClientTypes.FlowExecutionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.FlowExecutionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct SearchFlowExecutionsOutputResponseBody: Swift.Equatable {
    let summaries: [IoTThingsGraphClientTypes.FlowExecutionSummary]?
    let nextToken: Swift.String?
}

extension SearchFlowExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.FlowExecutionSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTThingsGraphClientTypes.FlowExecutionSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTThingsGraphClientTypes.FlowExecutionSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SearchFlowTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for flowtemplatefilter0 in filters {
                try filtersContainer.encode(flowtemplatefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchFlowTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchFlowTemplatesInput: Swift.Equatable {
    /// An array of objects that limit the result set. The only valid filter is DEVICE_MODEL_ID.
    public var filters: [IoTThingsGraphClientTypes.FlowTemplateFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init (
        filters: [IoTThingsGraphClientTypes.FlowTemplateFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchFlowTemplatesInputBody: Swift.Equatable {
    let filters: [IoTThingsGraphClientTypes.FlowTemplateFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchFlowTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.FlowTemplateFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTThingsGraphClientTypes.FlowTemplateFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTThingsGraphClientTypes.FlowTemplateFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchFlowTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchFlowTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchFlowTemplatesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchFlowTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchFlowTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct SearchFlowTemplatesOutputResponse: Swift.Equatable {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain summary information about each workflow in the result set.
    public var summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]?

    public init (
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct SearchFlowTemplatesOutputResponseBody: Swift.Equatable {
    let summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]?
    let nextToken: Swift.String?
}

extension SearchFlowTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.FlowTemplateSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTThingsGraphClientTypes.FlowTemplateSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTThingsGraphClientTypes.FlowTemplateSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SearchSystemInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for systeminstancefilter0 in filters {
                try filtersContainer.encode(systeminstancefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchSystemInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchSystemInstancesInput: Swift.Equatable {
    /// Optional filter to apply to the search. Valid filters are SYSTEM_TEMPLATE_ID, STATUS, and GREENGRASS_GROUP_NAME. Multiple filters function as OR criteria in the query. Multiple values passed inside the filter function as AND criteria.
    public var filters: [IoTThingsGraphClientTypes.SystemInstanceFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init (
        filters: [IoTThingsGraphClientTypes.SystemInstanceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchSystemInstancesInputBody: Swift.Equatable {
    let filters: [IoTThingsGraphClientTypes.SystemInstanceFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchSystemInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.SystemInstanceFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTThingsGraphClientTypes.SystemInstanceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTThingsGraphClientTypes.SystemInstanceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchSystemInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchSystemInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchSystemInstancesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchSystemInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchSystemInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct SearchSystemInstancesOutputResponse: Swift.Equatable {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain summary data abour the system instances in the result set.
    public var summaries: [IoTThingsGraphClientTypes.SystemInstanceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.SystemInstanceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct SearchSystemInstancesOutputResponseBody: Swift.Equatable {
    let summaries: [IoTThingsGraphClientTypes.SystemInstanceSummary]?
    let nextToken: Swift.String?
}

extension SearchSystemInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.SystemInstanceSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTThingsGraphClientTypes.SystemInstanceSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTThingsGraphClientTypes.SystemInstanceSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SearchSystemTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for systemtemplatefilter0 in filters {
                try filtersContainer.encode(systemtemplatefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchSystemTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchSystemTemplatesInput: Swift.Equatable {
    /// An array of filters that limit the result set. The only valid filter is FLOW_TEMPLATE_ID.
    public var filters: [IoTThingsGraphClientTypes.SystemTemplateFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init (
        filters: [IoTThingsGraphClientTypes.SystemTemplateFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchSystemTemplatesInputBody: Swift.Equatable {
    let filters: [IoTThingsGraphClientTypes.SystemTemplateFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchSystemTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.SystemTemplateFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTThingsGraphClientTypes.SystemTemplateFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTThingsGraphClientTypes.SystemTemplateFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchSystemTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchSystemTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchSystemTemplatesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchSystemTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchSystemTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct SearchSystemTemplatesOutputResponse: Swift.Equatable {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain summary information about each system deployment in the result set.
    public var summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]?

    public init (
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct SearchSystemTemplatesOutputResponseBody: Swift.Equatable {
    let summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]?
    let nextToken: Swift.String?
}

extension SearchSystemTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.SystemTemplateSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTThingsGraphClientTypes.SystemTemplateSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTThingsGraphClientTypes.SystemTemplateSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SearchThingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case maxResults
        case namespaceVersion
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let namespaceVersion = self.namespaceVersion {
            try encodeContainer.encode(namespaceVersion, forKey: .namespaceVersion)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchThingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchThingsInput: Swift.Equatable {
    /// The ID of the entity to which the things are associated. The IDs should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:device:DEVICENAME
    /// This member is required.
    public var entityId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
    public var namespaceVersion: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespaceVersion: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.maxResults = maxResults
        self.namespaceVersion = namespaceVersion
        self.nextToken = nextToken
    }
}

struct SearchThingsInputBody: Swift.Equatable {
    let entityId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let namespaceVersion: Swift.Int?
}

extension SearchThingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case maxResults
        case namespaceVersion
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
    }
}

extension SearchThingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchThingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchThingsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchThingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchThingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.things = output.things
        } else {
            self.nextToken = nil
            self.things = nil
        }
    }
}

public struct SearchThingsOutputResponse: Swift.Equatable {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of things in the result set.
    public var things: [IoTThingsGraphClientTypes.Thing]?

    public init (
        nextToken: Swift.String? = nil,
        things: [IoTThingsGraphClientTypes.Thing]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

struct SearchThingsOutputResponseBody: Swift.Equatable {
    let things: [IoTThingsGraphClientTypes.Thing]?
    let nextToken: Swift.String?
}

extension SearchThingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case things
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingsContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.Thing?].self, forKey: .things)
        var thingsDecoded0:[IoTThingsGraphClientTypes.Thing]? = nil
        if let thingsContainer = thingsContainer {
            thingsDecoded0 = [IoTThingsGraphClientTypes.Thing]()
            for structure0 in thingsContainer {
                if let structure0 = structure0 {
                    thingsDecoded0?.append(structure0)
                }
            }
        }
        things = thingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTThingsGraphClientTypes {
    public enum SystemInstanceDeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bootstrap
        case deletedInTarget
        case deployedInTarget
        case deployInProgress
        case failed
        case notDeployed
        case pendingDelete
        case undeployInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [SystemInstanceDeploymentStatus] {
            return [
                .bootstrap,
                .deletedInTarget,
                .deployedInTarget,
                .deployInProgress,
                .failed,
                .notDeployed,
                .pendingDelete,
                .undeployInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bootstrap: return "BOOTSTRAP"
            case .deletedInTarget: return "DELETED_IN_TARGET"
            case .deployedInTarget: return "DEPLOYED_IN_TARGET"
            case .deployInProgress: return "DEPLOY_IN_PROGRESS"
            case .failed: return "FAILED"
            case .notDeployed: return "NOT_DEPLOYED"
            case .pendingDelete: return "PENDING_DELETE"
            case .undeployInProgress: return "UNDEPLOY_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SystemInstanceDeploymentStatus(rawValue: rawValue) ?? SystemInstanceDeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes.SystemInstanceDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case flowActionsRoleArn
        case metricsConfiguration
        case s3BucketName
        case summary
        case validatedDependencyRevisions
        case validatedNamespaceVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let flowActionsRoleArn = self.flowActionsRoleArn {
            try encodeContainer.encode(flowActionsRoleArn, forKey: .flowActionsRoleArn)
        }
        if let metricsConfiguration = self.metricsConfiguration {
            try encodeContainer.encode(metricsConfiguration, forKey: .metricsConfiguration)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let validatedDependencyRevisions = validatedDependencyRevisions {
            var validatedDependencyRevisionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validatedDependencyRevisions)
            for dependencyrevision0 in validatedDependencyRevisions {
                try validatedDependencyRevisionsContainer.encode(dependencyrevision0)
            }
        }
        if let validatedNamespaceVersion = self.validatedNamespaceVersion {
            try encodeContainer.encode(validatedNamespaceVersion, forKey: .validatedNamespaceVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemInstanceSummary.self, forKey: .summary)
        summary = summaryDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let metricsConfigurationDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.MetricsConfiguration.self, forKey: .metricsConfiguration)
        metricsConfiguration = metricsConfigurationDecoded
        let validatedNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validatedNamespaceVersion)
        validatedNamespaceVersion = validatedNamespaceVersionDecoded
        let validatedDependencyRevisionsContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.DependencyRevision?].self, forKey: .validatedDependencyRevisions)
        var validatedDependencyRevisionsDecoded0:[IoTThingsGraphClientTypes.DependencyRevision]? = nil
        if let validatedDependencyRevisionsContainer = validatedDependencyRevisionsContainer {
            validatedDependencyRevisionsDecoded0 = [IoTThingsGraphClientTypes.DependencyRevision]()
            for structure0 in validatedDependencyRevisionsContainer {
                if let structure0 = structure0 {
                    validatedDependencyRevisionsDecoded0?.append(structure0)
                }
            }
        }
        validatedDependencyRevisions = validatedDependencyRevisionsDecoded0
        let flowActionsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowActionsRoleArn)
        flowActionsRoleArn = flowActionsRoleArnDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains a system instance definition and summary information.
    public struct SystemInstanceDescription: Swift.Equatable {
        /// A document that defines an entity.
        public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
        /// The AWS Identity and Access Management (IAM) role that AWS IoT Things Graph assumes during flow execution in a cloud deployment. This role must have read and write permissionss to AWS Lambda and AWS IoT and to any other AWS services that the flow uses.
        public var flowActionsRoleArn: Swift.String?
        /// An object that specifies whether cloud metrics are collected in a deployment and, if so, what role is used to collect metrics.
        public var metricsConfiguration: IoTThingsGraphClientTypes.MetricsConfiguration?
        /// The Amazon Simple Storage Service bucket where information about a system instance is stored.
        public var s3BucketName: Swift.String?
        /// An object that contains summary information about a system instance.
        public var summary: IoTThingsGraphClientTypes.SystemInstanceSummary?
        /// A list of objects that contain all of the IDs and revision numbers of workflows and systems that are used in a system instance.
        public var validatedDependencyRevisions: [IoTThingsGraphClientTypes.DependencyRevision]?
        /// The version of the user's namespace against which the system instance was validated.
        public var validatedNamespaceVersion: Swift.Int?

        public init (
            definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
            flowActionsRoleArn: Swift.String? = nil,
            metricsConfiguration: IoTThingsGraphClientTypes.MetricsConfiguration? = nil,
            s3BucketName: Swift.String? = nil,
            summary: IoTThingsGraphClientTypes.SystemInstanceSummary? = nil,
            validatedDependencyRevisions: [IoTThingsGraphClientTypes.DependencyRevision]? = nil,
            validatedNamespaceVersion: Swift.Int? = nil
        )
        {
            self.definition = definition
            self.flowActionsRoleArn = flowActionsRoleArn
            self.metricsConfiguration = metricsConfiguration
            self.s3BucketName = s3BucketName
            self.summary = summary
            self.validatedDependencyRevisions = validatedDependencyRevisions
            self.validatedNamespaceVersion = validatedNamespaceVersion
        }
    }

}

extension IoTThingsGraphClientTypes.SystemInstanceFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for systeminstancefiltervalue0 in value {
                try valueContainer.encode(systeminstancefiltervalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemInstanceFilterName.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .value)
        var valueDecoded0:[Swift.String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [Swift.String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that filters a system instance search. Multiple filters function as OR criteria in the search. For example a search that includes a GREENGRASS_GROUP_NAME and a STATUS filter searches for system instances in the specified Greengrass group that have the specified status.
    public struct SystemInstanceFilter: Swift.Equatable {
        /// The name of the search filter field.
        public var name: IoTThingsGraphClientTypes.SystemInstanceFilterName?
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        public var value: [Swift.String]?

        public init (
            name: IoTThingsGraphClientTypes.SystemInstanceFilterName? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IoTThingsGraphClientTypes {
    public enum SystemInstanceFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case greengrassGroupName
        case status
        case systemTemplateId
        case sdkUnknown(Swift.String)

        public static var allCases: [SystemInstanceFilterName] {
            return [
                .greengrassGroupName,
                .status,
                .systemTemplateId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .greengrassGroupName: return "GREENGRASS_GROUP_NAME"
            case .status: return "STATUS"
            case .systemTemplateId: return "SYSTEM_TEMPLATE_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SystemInstanceFilterName(rawValue: rawValue) ?? SystemInstanceFilterName.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes.SystemInstanceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case greengrassGroupId
        case greengrassGroupName
        case greengrassGroupVersionId
        case id
        case status
        case target
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let greengrassGroupId = self.greengrassGroupId {
            try encodeContainer.encode(greengrassGroupId, forKey: .greengrassGroupId)
        }
        if let greengrassGroupName = self.greengrassGroupName {
            try encodeContainer.encode(greengrassGroupName, forKey: .greengrassGroupName)
        }
        if let greengrassGroupVersionId = self.greengrassGroupVersionId {
            try encodeContainer.encode(greengrassGroupVersionId, forKey: .greengrassGroupVersionId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let target = self.target {
            try encodeContainer.encode(target.rawValue, forKey: .target)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemInstanceDeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let targetDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DeploymentTarget.self, forKey: .target)
        target = targetDecoded
        let greengrassGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupName)
        greengrassGroupName = greengrassGroupNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let greengrassGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupId)
        greengrassGroupId = greengrassGroupIdDecoded
        let greengrassGroupVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupVersionId)
        greengrassGroupVersionId = greengrassGroupVersionIdDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains summary information about a system instance.
    public struct SystemInstanceSummary: Swift.Equatable {
        /// The ARN of the system instance.
        public var arn: Swift.String?
        /// The date when the system instance was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the Greengrass group where the system instance is deployed.
        public var greengrassGroupId: Swift.String?
        /// The ID of the Greengrass group where the system instance is deployed.
        public var greengrassGroupName: Swift.String?
        /// The version of the Greengrass group where the system instance is deployed.
        public var greengrassGroupVersionId: Swift.String?
        /// The ID of the system instance.
        public var id: Swift.String?
        /// The status of the system instance.
        public var status: IoTThingsGraphClientTypes.SystemInstanceDeploymentStatus?
        /// The target of the system instance.
        public var target: IoTThingsGraphClientTypes.DeploymentTarget?
        /// The date and time when the system instance was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            greengrassGroupId: Swift.String? = nil,
            greengrassGroupName: Swift.String? = nil,
            greengrassGroupVersionId: Swift.String? = nil,
            id: Swift.String? = nil,
            status: IoTThingsGraphClientTypes.SystemInstanceDeploymentStatus? = nil,
            target: IoTThingsGraphClientTypes.DeploymentTarget? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.greengrassGroupId = greengrassGroupId
            self.greengrassGroupName = greengrassGroupName
            self.greengrassGroupVersionId = greengrassGroupVersionId
            self.id = id
            self.status = status
            self.target = target
            self.updatedAt = updatedAt
        }
    }

}

extension IoTThingsGraphClientTypes.SystemTemplateDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case summary
        case validatedNamespaceVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let validatedNamespaceVersion = self.validatedNamespaceVersion {
            try encodeContainer.encode(validatedNamespaceVersion, forKey: .validatedNamespaceVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let validatedNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validatedNamespaceVersion)
        validatedNamespaceVersion = validatedNamespaceVersionDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains a system's definition document and summary information.
    public struct SystemTemplateDescription: Swift.Equatable {
        /// The definition document of a system.
        public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
        /// An object that contains summary information about a system.
        public var summary: IoTThingsGraphClientTypes.SystemTemplateSummary?
        /// The namespace version against which the system was validated. Use this value in your system instance.
        public var validatedNamespaceVersion: Swift.Int?

        public init (
            definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
            summary: IoTThingsGraphClientTypes.SystemTemplateSummary? = nil,
            validatedNamespaceVersion: Swift.Int? = nil
        )
        {
            self.definition = definition
            self.summary = summary
            self.validatedNamespaceVersion = validatedNamespaceVersion
        }
    }

}

extension IoTThingsGraphClientTypes.SystemTemplateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for systemtemplatefiltervalue0 in value {
                try valueContainer.encode(systemtemplatefiltervalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemTemplateFilterName.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .value)
        var valueDecoded0:[Swift.String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [Swift.String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that filters a system search.
    public struct SystemTemplateFilter: Swift.Equatable {
        /// The name of the system search filter field.
        /// This member is required.
        public var name: IoTThingsGraphClientTypes.SystemTemplateFilterName?
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        /// This member is required.
        public var value: [Swift.String]?

        public init (
            name: IoTThingsGraphClientTypes.SystemTemplateFilterName? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IoTThingsGraphClientTypes {
    public enum SystemTemplateFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case flowTemplateId
        case sdkUnknown(Swift.String)

        public static var allCases: [SystemTemplateFilterName] {
            return [
                .flowTemplateId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .flowTemplateId: return "FLOW_TEMPLATE_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SystemTemplateFilterName(rawValue: rawValue) ?? SystemTemplateFilterName.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes.SystemTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case revisionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revisionNumber = self.revisionNumber {
            try encodeContainer.encode(revisionNumber, forKey: .revisionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let revisionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revisionNumber)
        revisionNumber = revisionNumberDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains information about a system.
    public struct SystemTemplateSummary: Swift.Equatable {
        /// The ARN of the system.
        public var arn: Swift.String?
        /// The date when the system was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the system.
        public var id: Swift.String?
        /// The revision number of the system.
        public var revisionNumber: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            revisionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.revisionNumber = revisionNumber
        }
    }

}

extension IoTThingsGraphClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// Metadata assigned to an AWS IoT Things Graph resource consisting of a key-value pair.
    public struct Tag: Swift.Equatable {
        /// The required name of the tag. The string value can be from 1 to 128 Unicode characters in length.
        /// This member is required.
        public var key: Swift.String?
        /// The optional value of the tag. The string value can be from 1 to 256 Unicode characters in length.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource whose tags are returned.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags to add to the resource.>
    /// This member is required.
    public var tags: [IoTThingsGraphClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [IoTThingsGraphClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [IoTThingsGraphClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTThingsGraphClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTThingsGraphClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTThingsGraphClientTypes.Thing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An AWS IoT thing.
    public struct Thing: Swift.Equatable {
        /// The ARN of the thing.
        public var thingArn: Swift.String?
        /// The name of the thing.
        public var thingName: Swift.String?

        public init (
            thingArn: Swift.String? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.thingArn = thingArn
            self.thingName = thingName
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UndeploySystemInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension UndeploySystemInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UndeploySystemInstanceInput: Swift.Equatable {
    /// The ID of the system instance to remove from its target.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct UndeploySystemInstanceInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension UndeploySystemInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension UndeploySystemInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UndeploySystemInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UndeploySystemInstanceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UndeploySystemInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UndeploySystemInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct UndeploySystemInstanceOutputResponse: Swift.Equatable {
    /// An object that contains summary information about the system instance that was removed from its target.
    public var summary: IoTThingsGraphClientTypes.SystemInstanceSummary?

    public init (
        summary: IoTThingsGraphClientTypes.SystemInstanceSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct UndeploySystemInstanceOutputResponseBody: Swift.Equatable {
    let summary: IoTThingsGraphClientTypes.SystemInstanceSummary?
}

extension UndeploySystemInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summary
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemInstanceSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource whose tags are to be removed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag key names to remove from the resource. You don't specify the value. Both the key and its associated value are removed. This parameter to the API requires a JSON text string argument. For information on how to format a JSON parameter for the various command line tool environments, see [Using JSON for Parameters](https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters.html#cli-using-param-json) in the AWS CLI User Guide.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateFlowTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleNamespaceVersion = self.compatibleNamespaceVersion {
            try encodeContainer.encode(compatibleNamespaceVersion, forKey: .compatibleNamespaceVersion)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension UpdateFlowTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateFlowTemplateInput: Swift.Equatable {
    /// The version of the user's namespace. If no value is specified, the latest version is used by default. Use the GetFlowTemplateRevisions if you want to find earlier revisions of the flow to update.
    public var compatibleNamespaceVersion: Swift.Int?
    /// The DefinitionDocument that contains the updated workflow definition.
    /// This member is required.
    public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
    /// The ID of the workflow to be updated. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
    /// This member is required.
    public var id: Swift.String?

    public init (
        compatibleNamespaceVersion: Swift.Int? = nil,
        definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
        id: Swift.String? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
        self.id = id
    }
}

struct UpdateFlowTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
    let definition: IoTThingsGraphClientTypes.DefinitionDocument?
    let compatibleNamespaceVersion: Swift.Int?
}

extension UpdateFlowTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let compatibleNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compatibleNamespaceVersion)
        compatibleNamespaceVersion = compatibleNamespaceVersionDecoded
    }
}

extension UpdateFlowTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFlowTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFlowTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFlowTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateFlowTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct UpdateFlowTemplateOutputResponse: Swift.Equatable {
    /// An object containing summary information about the updated workflow.
    public var summary: IoTThingsGraphClientTypes.FlowTemplateSummary?

    public init (
        summary: IoTThingsGraphClientTypes.FlowTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct UpdateFlowTemplateOutputResponseBody: Swift.Equatable {
    let summary: IoTThingsGraphClientTypes.FlowTemplateSummary?
}

extension UpdateFlowTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summary
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.FlowTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension UpdateSystemTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleNamespaceVersion = self.compatibleNamespaceVersion {
            try encodeContainer.encode(compatibleNamespaceVersion, forKey: .compatibleNamespaceVersion)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension UpdateSystemTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSystemTemplateInput: Swift.Equatable {
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace. If no value is specified, the latest version is used by default.
    public var compatibleNamespaceVersion: Swift.Int?
    /// The DefinitionDocument that contains the updated system definition.
    /// This member is required.
    public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
    /// The ID of the system to be updated. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
    /// This member is required.
    public var id: Swift.String?

    public init (
        compatibleNamespaceVersion: Swift.Int? = nil,
        definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
        id: Swift.String? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
        self.id = id
    }
}

struct UpdateSystemTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
    let definition: IoTThingsGraphClientTypes.DefinitionDocument?
    let compatibleNamespaceVersion: Swift.Int?
}

extension UpdateSystemTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let compatibleNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compatibleNamespaceVersion)
        compatibleNamespaceVersion = compatibleNamespaceVersionDecoded
    }
}

extension UpdateSystemTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSystemTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSystemTemplateOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSystemTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSystemTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct UpdateSystemTemplateOutputResponse: Swift.Equatable {
    /// An object containing summary information about the updated system.
    public var summary: IoTThingsGraphClientTypes.SystemTemplateSummary?

    public init (
        summary: IoTThingsGraphClientTypes.SystemTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct UpdateSystemTemplateOutputResponseBody: Swift.Equatable {
    let summary: IoTThingsGraphClientTypes.SystemTemplateSummary?
}

extension UpdateSystemTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summary
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension UploadEntityDefinitionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deprecateExistingEntities
        case document
        case syncWithPublicNamespace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deprecateExistingEntities != false {
            try encodeContainer.encode(deprecateExistingEntities, forKey: .deprecateExistingEntities)
        }
        if let document = self.document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if syncWithPublicNamespace != false {
            try encodeContainer.encode(syncWithPublicNamespace, forKey: .syncWithPublicNamespace)
        }
    }
}

extension UploadEntityDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UploadEntityDefinitionsInput: Swift.Equatable {
    /// A Boolean that specifies whether to deprecate all entities in the latest version before uploading the new DefinitionDocument. If set to true, the upload will create a new namespace version.
    public var deprecateExistingEntities: Swift.Bool
    /// The DefinitionDocument that defines the updated entities.
    public var document: IoTThingsGraphClientTypes.DefinitionDocument?
    /// A Boolean that specifies whether to synchronize with the latest version of the public namespace. If set to true, the upload will create a new namespace version.
    public var syncWithPublicNamespace: Swift.Bool

    public init (
        deprecateExistingEntities: Swift.Bool = false,
        document: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
        syncWithPublicNamespace: Swift.Bool = false
    )
    {
        self.deprecateExistingEntities = deprecateExistingEntities
        self.document = document
        self.syncWithPublicNamespace = syncWithPublicNamespace
    }
}

struct UploadEntityDefinitionsInputBody: Swift.Equatable {
    let document: IoTThingsGraphClientTypes.DefinitionDocument?
    let syncWithPublicNamespace: Swift.Bool
    let deprecateExistingEntities: Swift.Bool
}

extension UploadEntityDefinitionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deprecateExistingEntities
        case document
        case syncWithPublicNamespace
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .document)
        document = documentDecoded
        let syncWithPublicNamespaceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .syncWithPublicNamespace) ?? false
        syncWithPublicNamespace = syncWithPublicNamespaceDecoded
        let deprecateExistingEntitiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deprecateExistingEntities) ?? false
        deprecateExistingEntities = deprecateExistingEntitiesDecoded
    }
}

extension UploadEntityDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UploadEntityDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UploadEntityDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadEntityDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UploadEntityDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.uploadId = output.uploadId
        } else {
            self.uploadId = nil
        }
    }
}

public struct UploadEntityDefinitionsOutputResponse: Swift.Equatable {
    /// The ID that specifies the upload action. You can use this to track the status of the upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        uploadId: Swift.String? = nil
    )
    {
        self.uploadId = uploadId
    }
}

struct UploadEntityDefinitionsOutputResponseBody: Swift.Equatable {
    let uploadId: Swift.String?
}

extension UploadEntityDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
    }
}

extension IoTThingsGraphClientTypes {
    public enum UploadStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UploadStatus(rawValue: rawValue) ?? UploadStatus.sdkUnknown(rawValue)
        }
    }
}
