// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Alternative: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case transcript = "Transcript"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for itemlist0 in items {
                try itemsContainer.encode(itemlist0)
            }
        }
        if let transcript = transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transcript)
        transcript = transcriptDecoded
        let itemsContainer = try containerValues.decodeIfPresent([Item?].self, forKey: .items)
        var itemsDecoded0:[Item]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Item]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension Alternative: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Alternative(items: \(String(describing: items)), transcript: \(String(describing: transcript)))"}
}

/// <p>A list of possible transcriptions for the audio.</p>
public struct Alternative: Equatable {
    /// <p>One or more alternative interpretations of the input audio. </p>
    public let items: [Item]?
    /// <p>The text that was transcribed from the audio.</p>
    public let transcript: String?

    public init (
        items: [Item]? = nil,
        transcript: String? = nil
    )
    {
        self.items = items
        self.transcript = transcript
    }
}

extension AudioEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audioChunk = "AudioChunk"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioChunk = audioChunk {
            try encodeContainer.encode(audioChunk.base64EncodedString(), forKey: .audioChunk)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioChunkDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .audioChunk)
        audioChunk = audioChunkDecoded
    }
}

extension AudioEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AudioEvent(audioChunk: \(String(describing: audioChunk)))"}
}

/// <p>Provides a wrapper for the audio chunks that you are sending.</p>
///          <p>For information on audio encoding in Amazon Transcribe, see <a>input</a>. For information
///       on audio encoding formats in Amazon Transcribe Medical, see <a>input-med</a>.</p>
public struct AudioEvent: Equatable {
    /// <p>An audio blob that contains the next part of the audio that you want to transcribe. The
    ///       maximum audio chunk size is 32 KB.</p>
    public let audioChunk: Data?

    public init (
        audioChunk: Data? = nil
    )
    {
        self.audioChunk = audioChunk
    }
}

extension AudioStream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audioEvent = "AudioEvent"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .audioEvent(audioEvent):
                if let audioEvent = audioEvent {
                    try container.encode(audioEvent, forKey: .audioEvent)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let audioEventDecoded = try values.decodeIfPresent(AudioEvent.self, forKey: .audioEvent)
        if let audioEvent = audioEventDecoded {
            self = .audioEvent(audioEvent)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Represents the audio stream from your application to Amazon Transcribe.</p>
public enum AudioStream: Equatable {
    /// <p>A blob of audio from your application. You audio stream consists of one or more audio
    ///       events.</p>
    ///          <p>For information on audio encoding formats in Amazon Transcribe, see <a>input</a>. For
    ///       information on audio encoding formats in Amazon Transcribe Medical, see <a>input-med</a>.</p>
    ///          <p>For more information on stream encoding in Amazon Transcribe, see <a>event-stream</a>. For
    ///       information on stream encoding in Amazon Transcribe Medical, see <a>event-stream-med</a>.</p>
    case audioEvent(AudioEvent?)
    case sdkUnknown(String?)
}

extension BadRequestException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more arguments to the <code>StartStreamTranscription</code> or
///         <code>StartMedicalStreamTranscription</code> operation was invalid. For example,
///         <code>MediaEncoding</code> was not set to a valid encoding, or <code>LanguageCode</code> was
///       not set to a valid code. Check the parameters and try your request again.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A new stream started with the same session ID. The current stream has been
///       terminated.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalFailureException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailureException(message: \(String(describing: message)))"}
}

extension InternalFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A problem occurred while processing the audio. Amazon Transcribe or Amazon Transcribe Medical terminated processing. Try
///       your request again.</p>
public struct InternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Equatable {
    public let message: String?
}

extension InternalFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Item: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case confidence = "Confidence"
        case content = "Content"
        case endTime = "EndTime"
        case speaker = "Speaker"
        case stable = "Stable"
        case startTime = "StartTime"
        case type = "Type"
        case vocabularyFilterMatch = "VocabularyFilterMatch"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confidence = confidence {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if endTime != 0.0 {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let speaker = speaker {
            try encodeContainer.encode(speaker, forKey: .speaker)
        }
        if let stable = stable {
            try encodeContainer.encode(stable, forKey: .stable)
        }
        if startTime != 0.0 {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if vocabularyFilterMatch != false {
            try encodeContainer.encode(vocabularyFilterMatch, forKey: .vocabularyFilterMatch)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decode(Double.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decode(Double.self, forKey: .endTime)
        endTime = endTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ItemType.self, forKey: .type)
        type = typeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let vocabularyFilterMatchDecoded = try containerValues.decode(Bool.self, forKey: .vocabularyFilterMatch)
        vocabularyFilterMatch = vocabularyFilterMatchDecoded
        let speakerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .speaker)
        speaker = speakerDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .confidence)
        confidence = confidenceDecoded
        let stableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .stable)
        stable = stableDecoded
    }
}

extension Item: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Item(confidence: \(String(describing: confidence)), content: \(String(describing: content)), endTime: \(String(describing: endTime)), speaker: \(String(describing: speaker)), stable: \(String(describing: stable)), startTime: \(String(describing: startTime)), type: \(String(describing: type)), vocabularyFilterMatch: \(String(describing: vocabularyFilterMatch)))"}
}

/// <p>A word, phrase, or punctuation mark that is transcribed from the input audio.</p>
public struct Item: Equatable {
    /// <p>A value between 0 and 1 for an item that is a confidence score that Amazon Transcribe assigns to each
    ///       word or phrase that it transcribes.</p>
    public let confidence: Double?
    /// <p>The word or punctuation that was recognized in the input audio.</p>
    public let content: String?
    /// <p>The offset from the beginning of the audio stream to the end of the audio that resulted in
    ///       the item.</p>
    public let endTime: Double
    /// <p>If speaker identification is enabled, shows the speakers identified in the real-time
    ///       stream.</p>
    public let speaker: String?
    /// <p>If partial result stabilization has been enabled, indicates whether the word or phrase in
    ///       the item is stable. If <code>Stable</code> is <code>true</code>, the result is stable.</p>
    public let stable: Bool?
    /// <p>The offset from the beginning of the audio stream to the beginning of the audio that
    ///       resulted in the item.</p>
    public let startTime: Double
    /// <p>The type of the item. <code>PRONUNCIATION</code> indicates that the item is a word that
    ///       was recognized in the input audio. <code>PUNCTUATION</code> indicates that the item was
    ///       interpreted as a pause in the input audio.</p>
    public let type: ItemType?
    /// <p>Indicates whether a word in the item matches a word in the vocabulary filter you've chosen
    ///       for your real-time stream. If <code>true</code> then a word in the item matches your
    ///       vocabulary filter.</p>
    public let vocabularyFilterMatch: Bool

    public init (
        confidence: Double? = nil,
        content: String? = nil,
        endTime: Double = 0.0,
        speaker: String? = nil,
        stable: Bool? = nil,
        startTime: Double = 0.0,
        type: ItemType? = nil,
        vocabularyFilterMatch: Bool = false
    )
    {
        self.confidence = confidence
        self.content = content
        self.endTime = endTime
        self.speaker = speaker
        self.stable = stable
        self.startTime = startTime
        self.type = type
        self.vocabularyFilterMatch = vocabularyFilterMatch
    }
}

public enum ItemType {
    case pronunciation
    case punctuation
    case sdkUnknown(String)
}

extension ItemType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ItemType] {
        return [
            .pronunciation,
            .punctuation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .pronunciation: return "pronunciation"
        case .punctuation: return "punctuation"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ItemType(rawValue: rawValue) ?? ItemType.sdkUnknown(rawValue)
    }
}

public enum LanguageCode {
    case deDe
    case enAu
    case enGb
    case enUs
    case esUs
    case frCa
    case frFr
    case itIt
    case jaJp
    case koKr
    case ptBr
    case zhCn
    case sdkUnknown(String)
}

extension LanguageCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LanguageCode] {
        return [
            .deDe,
            .enAu,
            .enGb,
            .enUs,
            .esUs,
            .frCa,
            .frFr,
            .itIt,
            .jaJp,
            .koKr,
            .ptBr,
            .zhCn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deDe: return "de-DE"
        case .enAu: return "en-AU"
        case .enGb: return "en-GB"
        case .enUs: return "en-US"
        case .esUs: return "es-US"
        case .frCa: return "fr-CA"
        case .frFr: return "fr-FR"
        case .itIt: return "it-IT"
        case .jaJp: return "ja-JP"
        case .koKr: return "ko-KR"
        case .ptBr: return "pt-BR"
        case .zhCn: return "zh-CN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LanguageCode(rawValue: rawValue) ?? LanguageCode.sdkUnknown(rawValue)
    }
}

extension LimitExceededException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the maximum number of concurrent transcription streams, are starting
///       transcription streams too quickly, or the maximum audio length of 4 hours. Wait until a stream
///       has finished processing, or break your audio stream into smaller chunks and try your request
///       again.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum MediaEncoding {
    case flac
    case oggOpus
    case pcm
    case sdkUnknown(String)
}

extension MediaEncoding : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MediaEncoding] {
        return [
            .flac,
            .oggOpus,
            .pcm,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .flac: return "flac"
        case .oggOpus: return "ogg-opus"
        case .pcm: return "pcm"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MediaEncoding(rawValue: rawValue) ?? MediaEncoding.sdkUnknown(rawValue)
    }
}

extension MedicalAlternative: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entities = "Entities"
        case items = "Items"
        case transcript = "Transcript"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entities = entities {
            var entitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entities)
            for medicalentitylist0 in entities {
                try entitiesContainer.encode(medicalentitylist0)
            }
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for medicalitemlist0 in items {
                try itemsContainer.encode(medicalitemlist0)
            }
        }
        if let transcript = transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transcript)
        transcript = transcriptDecoded
        let itemsContainer = try containerValues.decodeIfPresent([MedicalItem?].self, forKey: .items)
        var itemsDecoded0:[MedicalItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MedicalItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let entitiesContainer = try containerValues.decodeIfPresent([MedicalEntity?].self, forKey: .entities)
        var entitiesDecoded0:[MedicalEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [MedicalEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
    }
}

extension MedicalAlternative: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MedicalAlternative(entities: \(String(describing: entities)), items: \(String(describing: items)), transcript: \(String(describing: transcript)))"}
}

/// <p>A list of possible transcriptions for the audio.</p>
public struct MedicalAlternative: Equatable {
    /// <p>Contains the medical entities identified as personal health information in the transcription output.</p>
    public let entities: [MedicalEntity]?
    /// <p>A list of objects that contains words and punctuation marks that represents one or
    ///             more interpretations of the input audio.</p>
    public let items: [MedicalItem]?
    /// <p>The text that was transcribed from the audio.</p>
    public let transcript: String?

    public init (
        entities: [MedicalEntity]? = nil,
        items: [MedicalItem]? = nil,
        transcript: String? = nil
    )
    {
        self.entities = entities
        self.items = items
        self.transcript = transcript
    }
}

public enum MedicalContentIdentificationType {
    case phi
    case sdkUnknown(String)
}

extension MedicalContentIdentificationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MedicalContentIdentificationType] {
        return [
            .phi,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .phi: return "PHI"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MedicalContentIdentificationType(rawValue: rawValue) ?? MedicalContentIdentificationType.sdkUnknown(rawValue)
    }
}

extension MedicalEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case category = "Category"
        case confidence = "Confidence"
        case content = "Content"
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let confidence = confidence {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if endTime != 0.0 {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if startTime != 0.0 {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decode(Double.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decode(Double.self, forKey: .endTime)
        endTime = endTimeDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .category)
        category = categoryDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .confidence)
        confidence = confidenceDecoded
    }
}

extension MedicalEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MedicalEntity(category: \(String(describing: category)), confidence: \(String(describing: confidence)), content: \(String(describing: content)), endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)))"}
}

/// <p>The medical entity identified as personal health information.</p>
public struct MedicalEntity: Equatable {
    /// <p>The type of personal health information of the medical entity.</p>
    public let category: String?
    /// <p>A value between zero and one that Amazon Transcribe Medical assigned to the personal health information
    ///             that it identified in the source audio. Larger values indicate that Amazon Transcribe Medical has higher
    ///             confidence in the personal health information that it identified.</p>
    public let confidence: Double?
    /// <p>The word or words in the transcription output that have been identified as a
    ///             medical entity.</p>
    public let content: String?
    /// <p>The end time of the speech that was identified as a medical entity.</p>
    public let endTime: Double
    /// <p>The start time of the speech that was identified as a medical entity.</p>
    public let startTime: Double

    public init (
        category: String? = nil,
        confidence: Double? = nil,
        content: String? = nil,
        endTime: Double = 0.0,
        startTime: Double = 0.0
    )
    {
        self.category = category
        self.confidence = confidence
        self.content = content
        self.endTime = endTime
        self.startTime = startTime
    }
}

extension MedicalItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case confidence = "Confidence"
        case content = "Content"
        case endTime = "EndTime"
        case speaker = "Speaker"
        case startTime = "StartTime"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confidence = confidence {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if endTime != 0.0 {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let speaker = speaker {
            try encodeContainer.encode(speaker, forKey: .speaker)
        }
        if startTime != 0.0 {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decode(Double.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decode(Double.self, forKey: .endTime)
        endTime = endTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ItemType.self, forKey: .type)
        type = typeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .confidence)
        confidence = confidenceDecoded
        let speakerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .speaker)
        speaker = speakerDecoded
    }
}

extension MedicalItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MedicalItem(confidence: \(String(describing: confidence)), content: \(String(describing: content)), endTime: \(String(describing: endTime)), speaker: \(String(describing: speaker)), startTime: \(String(describing: startTime)), type: \(String(describing: type)))"}
}

/// <p>A word, phrase, or punctuation mark that is transcribed from the input audio.</p>
public struct MedicalItem: Equatable {
    /// <p>A value between 0 and 1 for an item that is a confidence score that Amazon Transcribe Medical assigns to
    ///             each word that it transcribes.</p>
    public let confidence: Double?
    /// <p>The word or punctuation mark that was recognized in the input audio.</p>
    public let content: String?
    /// <p>The number of seconds into an audio stream that indicates the creation time of an
    ///             item.</p>
    public let endTime: Double
    /// <p>If speaker identification is enabled, shows the integer values that correspond to the
    ///             different speakers identified in the stream. For example, if the value of
    ///                 <code>Speaker</code> in the stream is either a <code>0</code> or a <code>1</code>,
    ///             that indicates that Amazon Transcribe Medical has identified two speakers in the stream. The value of
    ///                 <code>0</code> corresponds to one speaker and the value of <code>1</code>
    ///             corresponds to the other speaker.</p>
    public let speaker: String?
    /// <p>The number of seconds into an audio stream that indicates the creation time of an
    ///             item.</p>
    public let startTime: Double
    /// <p>The type of the item. <code>PRONUNCIATION</code> indicates that the item is a word
    ///             that was recognized in the input audio. <code>PUNCTUATION</code> indicates that the item
    ///             was interpreted as a pause in the input audio, such as a period to indicate the end of a
    ///             sentence.</p>
    public let type: ItemType?

    public init (
        confidence: Double? = nil,
        content: String? = nil,
        endTime: Double = 0.0,
        speaker: String? = nil,
        startTime: Double = 0.0,
        type: ItemType? = nil
    )
    {
        self.confidence = confidence
        self.content = content
        self.endTime = endTime
        self.speaker = speaker
        self.startTime = startTime
        self.type = type
    }
}

extension MedicalResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alternatives = "Alternatives"
        case channelId = "ChannelId"
        case endTime = "EndTime"
        case isPartial = "IsPartial"
        case resultId = "ResultId"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternatives = alternatives {
            var alternativesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alternatives)
            for medicalalternativelist0 in alternatives {
                try alternativesContainer.encode(medicalalternativelist0)
            }
        }
        if let channelId = channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if endTime != 0.0 {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if isPartial != false {
            try encodeContainer.encode(isPartial, forKey: .isPartial)
        }
        if let resultId = resultId {
            try encodeContainer.encode(resultId, forKey: .resultId)
        }
        if startTime != 0.0 {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resultId)
        resultId = resultIdDecoded
        let startTimeDecoded = try containerValues.decode(Double.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decode(Double.self, forKey: .endTime)
        endTime = endTimeDecoded
        let isPartialDecoded = try containerValues.decode(Bool.self, forKey: .isPartial)
        isPartial = isPartialDecoded
        let alternativesContainer = try containerValues.decodeIfPresent([MedicalAlternative?].self, forKey: .alternatives)
        var alternativesDecoded0:[MedicalAlternative]? = nil
        if let alternativesContainer = alternativesContainer {
            alternativesDecoded0 = [MedicalAlternative]()
            for structure0 in alternativesContainer {
                if let structure0 = structure0 {
                    alternativesDecoded0?.append(structure0)
                }
            }
        }
        alternatives = alternativesDecoded0
        let channelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelId)
        channelId = channelIdDecoded
    }
}

extension MedicalResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MedicalResult(alternatives: \(String(describing: alternatives)), channelId: \(String(describing: channelId)), endTime: \(String(describing: endTime)), isPartial: \(String(describing: isPartial)), resultId: \(String(describing: resultId)), startTime: \(String(describing: startTime)))"}
}

/// <p>The results of transcribing a portion of the input audio stream.</p>
public struct MedicalResult: Equatable {
    /// <p>A list of possible transcriptions of the audio. Each alternative typically contains
    ///             one <code>Item</code> that contains the result of the transcription.</p>
    public let alternatives: [MedicalAlternative]?
    /// <p>When channel identification is enabled, Amazon Transcribe Medical transcribes the speech from each audio
    ///             channel separately.</p>
    ///         <p>You can use <code>ChannelId</code> to retrieve the transcription results for a single
    ///             channel in your audio stream.</p>
    public let channelId: String?
    /// <p>The time, in seconds, from the beginning of the audio stream to the end of the
    ///             result.</p>
    public let endTime: Double
    /// <p>Amazon Transcribe Medical divides the incoming audio stream into segments at natural points in the audio.
    ///             Transcription results are returned based on these segments.</p>
    ///         <p>The <code>IsPartial</code> field is <code>true</code> to indicate that Amazon Transcribe Medical has
    ///             additional transcription data to send. The <code>IsPartial</code> field is
    ///                 <code>false</code> to indicate that this is the last transcription result for the
    ///             segment.</p>
    public let isPartial: Bool
    /// <p>A unique identifier for the result.</p>
    public let resultId: String?
    /// <p>The time, in seconds, from the beginning of the audio stream to the beginning of the
    ///             result.</p>
    public let startTime: Double

    public init (
        alternatives: [MedicalAlternative]? = nil,
        channelId: String? = nil,
        endTime: Double = 0.0,
        isPartial: Bool = false,
        resultId: String? = nil,
        startTime: Double = 0.0
    )
    {
        self.alternatives = alternatives
        self.channelId = channelId
        self.endTime = endTime
        self.isPartial = isPartial
        self.resultId = resultId
        self.startTime = startTime
    }
}

extension MedicalTranscript: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case results = "Results"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let results = results {
            var resultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .results)
            for medicalresultlist0 in results {
                try resultsContainer.encode(medicalresultlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([MedicalResult?].self, forKey: .results)
        var resultsDecoded0:[MedicalResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [MedicalResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

extension MedicalTranscript: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MedicalTranscript(results: \(String(describing: results)))"}
}

/// <p>The medical transcript in a <a>MedicalTranscriptEvent</a>.</p>
public struct MedicalTranscript: Equatable {
    /// <p>
    ///             <a>MedicalResult</a> objects that contain the results of transcribing a
    ///             portion of the input audio stream. The array can be empty.</p>
    public let results: [MedicalResult]?

    public init (
        results: [MedicalResult]? = nil
    )
    {
        self.results = results
    }
}

extension MedicalTranscriptEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case transcript = "Transcript"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transcript = transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptDecoded = try containerValues.decodeIfPresent(MedicalTranscript.self, forKey: .transcript)
        transcript = transcriptDecoded
    }
}

extension MedicalTranscriptEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MedicalTranscriptEvent(transcript: \(String(describing: transcript)))"}
}

/// <p>Represents a set of transcription results from the server to the client. It contains
///             one or more segments of the transcription.</p>
public struct MedicalTranscriptEvent: Equatable {
    /// <p>The transcription of the audio stream. The transcription is composed of all of the
    ///             items in the results list.</p>
    public let transcript: MedicalTranscript?

    public init (
        transcript: MedicalTranscript? = nil
    )
    {
        self.transcript = transcript
    }
}

extension MedicalTranscriptResultStream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case internalFailureException = "InternalFailureException"
        case limitExceededException = "LimitExceededException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case transcriptEvent = "TranscriptEvent"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .badRequestException(badRequestException):
                if let badRequestException = badRequestException {
                    try container.encode(badRequestException, forKey: .badRequestException)
                }
            case let .conflictException(conflictException):
                if let conflictException = conflictException {
                    try container.encode(conflictException, forKey: .conflictException)
                }
            case let .internalFailureException(internalFailureException):
                if let internalFailureException = internalFailureException {
                    try container.encode(internalFailureException, forKey: .internalFailureException)
                }
            case let .limitExceededException(limitExceededException):
                if let limitExceededException = limitExceededException {
                    try container.encode(limitExceededException, forKey: .limitExceededException)
                }
            case let .serviceUnavailableException(serviceUnavailableException):
                if let serviceUnavailableException = serviceUnavailableException {
                    try container.encode(serviceUnavailableException, forKey: .serviceUnavailableException)
                }
            case let .transcriptEvent(transcriptEvent):
                if let transcriptEvent = transcriptEvent {
                    try container.encode(transcriptEvent, forKey: .transcriptEvent)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptEventDecoded = try values.decodeIfPresent(MedicalTranscriptEvent.self, forKey: .transcriptEvent)
        if let transcriptEvent = transcriptEventDecoded {
            self = .transcriptEvent(transcriptEvent)
            return
        }
        let badRequestExceptionDecoded = try values.decodeIfPresent(BadRequestException.self, forKey: .badRequestException)
        if let badRequestException = badRequestExceptionDecoded {
            self = .badRequestException(badRequestException)
            return
        }
        let limitExceededExceptionDecoded = try values.decodeIfPresent(LimitExceededException.self, forKey: .limitExceededException)
        if let limitExceededException = limitExceededExceptionDecoded {
            self = .limitExceededException(limitExceededException)
            return
        }
        let internalFailureExceptionDecoded = try values.decodeIfPresent(InternalFailureException.self, forKey: .internalFailureException)
        if let internalFailureException = internalFailureExceptionDecoded {
            self = .internalFailureException(internalFailureException)
            return
        }
        let conflictExceptionDecoded = try values.decodeIfPresent(ConflictException.self, forKey: .conflictException)
        if let conflictException = conflictExceptionDecoded {
            self = .conflictException(conflictException)
            return
        }
        let serviceUnavailableExceptionDecoded = try values.decodeIfPresent(ServiceUnavailableException.self, forKey: .serviceUnavailableException)
        if let serviceUnavailableException = serviceUnavailableExceptionDecoded {
            self = .serviceUnavailableException(serviceUnavailableException)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Represents the transcription result stream from Amazon Transcribe Medical to your application.</p>
public enum MedicalTranscriptResultStream: Equatable {
    /// <p>A portion of the transcription of the audio stream. Events are sent periodically from
    ///             Amazon Transcribe Medical to your application. The event can be a partial transcription of a section of the
    ///             audio stream, or it can be the entire transcription of that portion of the audio
    ///             stream.</p>
    case transcriptEvent(MedicalTranscriptEvent?)
    /// <p>One or more arguments to the <code>StartStreamTranscription</code> or
    ///         <code>StartMedicalStreamTranscription</code> operation was invalid. For example,
    ///         <code>MediaEncoding</code> was not set to a valid encoding, or <code>LanguageCode</code> was
    ///       not set to a valid code. Check the parameters and try your request again.</p>
    case badRequestException(BadRequestException?)
    /// <p>You have exceeded the maximum number of concurrent transcription streams, are starting
    ///       transcription streams too quickly, or the maximum audio length of 4 hours. Wait until a stream
    ///       has finished processing, or break your audio stream into smaller chunks and try your request
    ///       again.</p>
    case limitExceededException(LimitExceededException?)
    /// <p>A problem occurred while processing the audio. Amazon Transcribe or Amazon Transcribe Medical terminated processing. Try
    ///       your request again.</p>
    case internalFailureException(InternalFailureException?)
    /// <p>A new stream started with the same session ID. The current stream has been
    ///       terminated.</p>
    case conflictException(ConflictException?)
    /// <p>Service is currently unavailable. Try your request later.</p>
    case serviceUnavailableException(ServiceUnavailableException?)
    case sdkUnknown(String?)
}

public enum PartialResultsStability {
    case high
    case low
    case medium
    case sdkUnknown(String)
}

extension PartialResultsStability : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PartialResultsStability] {
        return [
            .high,
            .low,
            .medium,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .high: return "high"
        case .low: return "low"
        case .medium: return "medium"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PartialResultsStability(rawValue: rawValue) ?? PartialResultsStability.sdkUnknown(rawValue)
    }
}

extension Result: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alternatives = "Alternatives"
        case channelId = "ChannelId"
        case endTime = "EndTime"
        case isPartial = "IsPartial"
        case resultId = "ResultId"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternatives = alternatives {
            var alternativesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alternatives)
            for alternativelist0 in alternatives {
                try alternativesContainer.encode(alternativelist0)
            }
        }
        if let channelId = channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if endTime != 0.0 {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if isPartial != false {
            try encodeContainer.encode(isPartial, forKey: .isPartial)
        }
        if let resultId = resultId {
            try encodeContainer.encode(resultId, forKey: .resultId)
        }
        if startTime != 0.0 {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resultId)
        resultId = resultIdDecoded
        let startTimeDecoded = try containerValues.decode(Double.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decode(Double.self, forKey: .endTime)
        endTime = endTimeDecoded
        let isPartialDecoded = try containerValues.decode(Bool.self, forKey: .isPartial)
        isPartial = isPartialDecoded
        let alternativesContainer = try containerValues.decodeIfPresent([Alternative?].self, forKey: .alternatives)
        var alternativesDecoded0:[Alternative]? = nil
        if let alternativesContainer = alternativesContainer {
            alternativesDecoded0 = [Alternative]()
            for structure0 in alternativesContainer {
                if let structure0 = structure0 {
                    alternativesDecoded0?.append(structure0)
                }
            }
        }
        alternatives = alternativesDecoded0
        let channelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelId)
        channelId = channelIdDecoded
    }
}

extension Result: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Result(alternatives: \(String(describing: alternatives)), channelId: \(String(describing: channelId)), endTime: \(String(describing: endTime)), isPartial: \(String(describing: isPartial)), resultId: \(String(describing: resultId)), startTime: \(String(describing: startTime)))"}
}

/// <p>The result of transcribing a portion of the input audio stream. </p>
public struct Result: Equatable {
    /// <p>A list of possible transcriptions for the audio. Each alternative typically contains one
    ///         <code>item</code> that contains the result of the transcription.</p>
    public let alternatives: [Alternative]?
    /// <p>When channel identification is enabled, Amazon Transcribe transcribes the speech from each audio
    ///       channel separately.</p>
    ///          <p>You can use <code>ChannelId</code> to retrieve the transcription results for a single
    ///       channel in your audio stream.</p>
    public let channelId: String?
    /// <p>The offset in seconds from the beginning of the audio stream to the end of the
    ///       result.</p>
    public let endTime: Double
    /// <p>Amazon Transcribe divides the incoming audio stream into segments at natural points in the audio.
    ///       Transcription results are returned based on these segments. </p>
    ///          <p>The <code>IsPartial</code> field is <code>true</code> to indicate that Amazon Transcribe has
    ///       additional transcription data to send, <code>false</code> to indicate that this is the last
    ///       transcription result for the segment.</p>
    public let isPartial: Bool
    /// <p>A unique identifier for the result. </p>
    public let resultId: String?
    /// <p>The offset in seconds from the beginning of the audio stream to the beginning of the
    ///       result.</p>
    public let startTime: Double

    public init (
        alternatives: [Alternative]? = nil,
        channelId: String? = nil,
        endTime: Double = 0.0,
        isPartial: Bool = false,
        resultId: String? = nil,
        startTime: Double = 0.0
    )
    {
        self.alternatives = alternatives
        self.channelId = channelId
        self.endTime = endTime
        self.isPartial = isPartial
        self.resultId = resultId
        self.startTime = startTime
    }
}

extension ServiceUnavailableException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Service is currently unavailable. Try your request later.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Specialty {
    case cardiology
    case neurology
    case oncology
    case primarycare
    case radiology
    case urology
    case sdkUnknown(String)
}

extension Specialty : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Specialty] {
        return [
            .cardiology,
            .neurology,
            .oncology,
            .primarycare,
            .radiology,
            .urology,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cardiology: return "CARDIOLOGY"
        case .neurology: return "NEUROLOGY"
        case .oncology: return "ONCOLOGY"
        case .primarycare: return "PRIMARYCARE"
        case .radiology: return "RADIOLOGY"
        case .urology: return "UROLOGY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Specialty(rawValue: rawValue) ?? Specialty.sdkUnknown(rawValue)
    }
}

public struct StartMedicalStreamTranscriptionInputBodyMiddleware: Middleware {
    public let id: String = "StartMedicalStreamTranscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMedicalStreamTranscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMedicalStreamTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let audioStream = input.operationInput.audioStream {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(audioStream)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMedicalStreamTranscriptionInput>
    public typealias MOutput = OperationOutput<StartMedicalStreamTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMedicalStreamTranscriptionOutputError>
}

extension StartMedicalStreamTranscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartMedicalStreamTranscriptionInput(audioStream: \(String(describing: audioStream)), contentIdentificationType: \(String(describing: contentIdentificationType)), enableChannelIdentification: \(String(describing: enableChannelIdentification)), languageCode: \(String(describing: languageCode)), mediaEncoding: \(String(describing: mediaEncoding)), mediaSampleRateHertz: \(String(describing: mediaSampleRateHertz)), numberOfChannels: \(String(describing: numberOfChannels)), sessionId: \(String(describing: sessionId)), showSpeakerLabel: \(String(describing: showSpeakerLabel)), specialty: \(String(describing: specialty)), type: \(String(describing: type)), vocabularyName: \(String(describing: vocabularyName)))"}
}

extension StartMedicalStreamTranscriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audioStream = "AudioStream"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioStream = audioStream {
            try encodeContainer.encode(audioStream, forKey: .audioStream)
        }
    }
}

public struct StartMedicalStreamTranscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "StartMedicalStreamTranscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMedicalStreamTranscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMedicalStreamTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentIdentificationType = input.operationInput.contentIdentificationType {
            input.builder.withHeader(name: "x-amzn-transcribe-content-identification-type", value: String(contentIdentificationType.rawValue))
        }
        input.builder.withHeader(name: "x-amzn-transcribe-enable-channel-identification", value: String(input.operationInput.enableChannelIdentification))
        if let languageCode = input.operationInput.languageCode {
            input.builder.withHeader(name: "x-amzn-transcribe-language-code", value: String(languageCode.rawValue))
        }
        if let mediaEncoding = input.operationInput.mediaEncoding {
            input.builder.withHeader(name: "x-amzn-transcribe-media-encoding", value: String(mediaEncoding.rawValue))
        }
        if let mediaSampleRateHertz = input.operationInput.mediaSampleRateHertz {
            input.builder.withHeader(name: "x-amzn-transcribe-sample-rate", value: String(mediaSampleRateHertz))
        }
        if let numberOfChannels = input.operationInput.numberOfChannels {
            input.builder.withHeader(name: "x-amzn-transcribe-number-of-channels", value: String(numberOfChannels))
        }
        if let sessionId = input.operationInput.sessionId {
            input.builder.withHeader(name: "x-amzn-transcribe-session-id", value: String(sessionId))
        }
        input.builder.withHeader(name: "x-amzn-transcribe-show-speaker-label", value: String(input.operationInput.showSpeakerLabel))
        if let specialty = input.operationInput.specialty {
            input.builder.withHeader(name: "x-amzn-transcribe-specialty", value: String(specialty.rawValue))
        }
        if let type = input.operationInput.type {
            input.builder.withHeader(name: "x-amzn-transcribe-type", value: String(type.rawValue))
        }
        if let vocabularyName = input.operationInput.vocabularyName {
            input.builder.withHeader(name: "x-amzn-transcribe-vocabulary-name", value: String(vocabularyName))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMedicalStreamTranscriptionInput>
    public typealias MOutput = OperationOutput<StartMedicalStreamTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMedicalStreamTranscriptionOutputError>
}

public struct StartMedicalStreamTranscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartMedicalStreamTranscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMedicalStreamTranscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMedicalStreamTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMedicalStreamTranscriptionInput>
    public typealias MOutput = OperationOutput<StartMedicalStreamTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMedicalStreamTranscriptionOutputError>
}

public struct StartMedicalStreamTranscriptionInput: Equatable {
    /// <p>Represents the audio stream from your application to Amazon Transcribe.</p>
    public let audioStream: AudioStream?
    /// <p>Set this field to <code>PHI</code> to identify personal health information in the
    ///             transcription output.</p>
    public let contentIdentificationType: MedicalContentIdentificationType?
    /// <p>When <code>true</code>, instructs Amazon Transcribe Medical to process each audio channel separately and
    ///             then merge the transcription output of each channel into a single transcription.</p>
    ///         <p>Amazon Transcribe Medical also produces a transcription of each item. An item includes the start time,
    ///             end time, and any alternative transcriptions.</p>
    ///         <p>You can't set both <code>ShowSpeakerLabel</code> and
    ///                 <code>EnableChannelIdentification</code> in the same request. If you set both, your
    ///             request returns a <code>BadRequestException</code>.</p>
    public let enableChannelIdentification: Bool
    /// <p> Indicates the source language used in the input audio stream. For Amazon Transcribe Medical, this is US
    ///             English (en-US). </p>
    public let languageCode: LanguageCode?
    /// <p>The encoding used for the input audio.</p>
    public let mediaEncoding: MediaEncoding?
    /// <p>The sample rate of the input audio in Hertz. Sample rates of 16000 Hz or higher are
    ///             accepted.</p>
    public let mediaSampleRateHertz: Int?
    /// <p>The number of channels that are in your audio stream.</p>
    public let numberOfChannels: Int?
    /// <p> Optional. An identifier for the transcription session. If you don't provide a session
    ///             ID, Amazon Transcribe generates one for you and returns it in the response. </p>
    public let sessionId: String?
    /// <p>When <code>true</code>, enables speaker identification in your real-time
    ///             stream.</p>
    public let showSpeakerLabel: Bool
    /// <p>The medical specialty of the clinician or provider.</p>
    public let specialty: Specialty?
    /// <p>The type of input audio. Choose <code>DICTATION</code> for a provider dictating
    ///             patient notes. Choose <code>CONVERSATION</code> for a dialogue between a patient and one
    ///             or more medical professionanls.</p>
    public let type: `Type`?
    /// <p>The name of the medical custom vocabulary to use when processing the real-time
    ///             stream.</p>
    public let vocabularyName: String?

    public init (
        audioStream: AudioStream? = nil,
        contentIdentificationType: MedicalContentIdentificationType? = nil,
        enableChannelIdentification: Bool = false,
        languageCode: LanguageCode? = nil,
        mediaEncoding: MediaEncoding? = nil,
        mediaSampleRateHertz: Int? = nil,
        numberOfChannels: Int? = nil,
        sessionId: String? = nil,
        showSpeakerLabel: Bool = false,
        specialty: Specialty? = nil,
        type: `Type`? = nil,
        vocabularyName: String? = nil
    )
    {
        self.audioStream = audioStream
        self.contentIdentificationType = contentIdentificationType
        self.enableChannelIdentification = enableChannelIdentification
        self.languageCode = languageCode
        self.mediaEncoding = mediaEncoding
        self.mediaSampleRateHertz = mediaSampleRateHertz
        self.numberOfChannels = numberOfChannels
        self.sessionId = sessionId
        self.showSpeakerLabel = showSpeakerLabel
        self.specialty = specialty
        self.type = type
        self.vocabularyName = vocabularyName
    }
}

struct StartMedicalStreamTranscriptionInputBody: Equatable {
    public let audioStream: AudioStream?
}

extension StartMedicalStreamTranscriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case audioStream = "AudioStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(AudioStream.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

extension StartMedicalStreamTranscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMedicalStreamTranscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartMedicalStreamTranscriptionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMedicalStreamTranscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartMedicalStreamTranscriptionOutputResponse(contentIdentificationType: \(String(describing: contentIdentificationType)), enableChannelIdentification: \(String(describing: enableChannelIdentification)), languageCode: \(String(describing: languageCode)), mediaEncoding: \(String(describing: mediaEncoding)), mediaSampleRateHertz: \(String(describing: mediaSampleRateHertz)), numberOfChannels: \(String(describing: numberOfChannels)), requestId: \(String(describing: requestId)), sessionId: \(String(describing: sessionId)), showSpeakerLabel: \(String(describing: showSpeakerLabel)), specialty: \(String(describing: specialty)), transcriptResultStream: \(String(describing: transcriptResultStream)), type: \(String(describing: type)), vocabularyName: \(String(describing: vocabularyName)))"}
}

extension StartMedicalStreamTranscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let contentIdentificationTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-content-identification-type") {
            self.contentIdentificationType = MedicalContentIdentificationType(rawValue: contentIdentificationTypeHeaderValue)
        } else {
            self.contentIdentificationType = nil
        }
        if let enableChannelIdentificationHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-enable-channel-identification") {
            self.enableChannelIdentification = Bool(enableChannelIdentificationHeaderValue) ?? false
        } else {
            self.enableChannelIdentification = false
        }
        if let languageCodeHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-language-code") {
            self.languageCode = LanguageCode(rawValue: languageCodeHeaderValue)
        } else {
            self.languageCode = nil
        }
        if let mediaEncodingHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-media-encoding") {
            self.mediaEncoding = MediaEncoding(rawValue: mediaEncodingHeaderValue)
        } else {
            self.mediaEncoding = nil
        }
        if let mediaSampleRateHertzHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-sample-rate") {
            self.mediaSampleRateHertz = Int(mediaSampleRateHertzHeaderValue) ?? 0
        } else {
            self.mediaSampleRateHertz = nil
        }
        if let numberOfChannelsHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-number-of-channels") {
            self.numberOfChannels = Int(numberOfChannelsHeaderValue) ?? 0
        } else {
            self.numberOfChannels = nil
        }
        if let requestIdHeaderValue = httpResponse.headers.value(for: "x-amzn-request-id") {
            self.requestId = requestIdHeaderValue
        } else {
            self.requestId = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if let showSpeakerLabelHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-show-speaker-label") {
            self.showSpeakerLabel = Bool(showSpeakerLabelHeaderValue) ?? false
        } else {
            self.showSpeakerLabel = false
        }
        if let specialtyHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-specialty") {
            self.specialty = Specialty(rawValue: specialtyHeaderValue)
        } else {
            self.specialty = nil
        }
        if let typeHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-type") {
            self.type = `Type`(rawValue: typeHeaderValue)
        } else {
            self.type = nil
        }
        if let vocabularyNameHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-vocabulary-name") {
            self.vocabularyName = vocabularyNameHeaderValue
        } else {
            self.vocabularyName = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MedicalTranscriptResultStream = try responseDecoder.decode(responseBody: unwrappedData)
                self.transcriptResultStream = output
            } else {
                self.transcriptResultStream = nil
            }
        } else {
            self.transcriptResultStream = nil
        }
    }
}

public struct StartMedicalStreamTranscriptionOutputResponse: Equatable {
    /// <p>If the value is <code>PHI</code>, indicates that you've configured your stream to
    ///             identify personal health information.</p>
    public let contentIdentificationType: MedicalContentIdentificationType?
    /// <p>Shows whether channel identification has been enabled in the stream.</p>
    public let enableChannelIdentification: Bool
    /// <p>The language code for the response transcript. For Amazon Transcribe Medical, this is US English
    ///             (en-US).</p>
    public let languageCode: LanguageCode?
    /// <p>The encoding used for the input audio stream.</p>
    public let mediaEncoding: MediaEncoding?
    /// <p>The sample rate of the input audio in Hertz. Valid value: 16000 Hz.</p>
    public let mediaSampleRateHertz: Int?
    /// <p>The number of channels identified in the stream.</p>
    public let numberOfChannels: Int?
    /// <p>An identifier for the streaming transcription.</p>
    public let requestId: String?
    /// <p>Optional. An identifier for the transcription session. If you don't provide a session
    ///             ID, Amazon Transcribe generates one for you and returns it in the response.</p>
    public let sessionId: String?
    /// <p>Shows whether speaker identification was enabled in the stream.</p>
    public let showSpeakerLabel: Bool
    /// <p>The specialty in the medical domain.</p>
    public let specialty: Specialty?
    /// <p>Represents the stream of transcription events from Amazon Transcribe Medical to your application. </p>
    public let transcriptResultStream: MedicalTranscriptResultStream?
    /// <p>The type of audio that was transcribed. </p>
    public let type: `Type`?
    /// <p>The name of the vocabulary used when processing the stream.</p>
    public let vocabularyName: String?

    public init (
        contentIdentificationType: MedicalContentIdentificationType? = nil,
        enableChannelIdentification: Bool = false,
        languageCode: LanguageCode? = nil,
        mediaEncoding: MediaEncoding? = nil,
        mediaSampleRateHertz: Int? = nil,
        numberOfChannels: Int? = nil,
        requestId: String? = nil,
        sessionId: String? = nil,
        showSpeakerLabel: Bool = false,
        specialty: Specialty? = nil,
        transcriptResultStream: MedicalTranscriptResultStream? = nil,
        type: `Type`? = nil,
        vocabularyName: String? = nil
    )
    {
        self.contentIdentificationType = contentIdentificationType
        self.enableChannelIdentification = enableChannelIdentification
        self.languageCode = languageCode
        self.mediaEncoding = mediaEncoding
        self.mediaSampleRateHertz = mediaSampleRateHertz
        self.numberOfChannels = numberOfChannels
        self.requestId = requestId
        self.sessionId = sessionId
        self.showSpeakerLabel = showSpeakerLabel
        self.specialty = specialty
        self.transcriptResultStream = transcriptResultStream
        self.type = type
        self.vocabularyName = vocabularyName
    }
}

struct StartMedicalStreamTranscriptionOutputResponseBody: Equatable {
    public let transcriptResultStream: MedicalTranscriptResultStream?
}

extension StartMedicalStreamTranscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transcriptResultStream = "TranscriptResultStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptResultStreamDecoded = try containerValues.decodeIfPresent(MedicalTranscriptResultStream.self, forKey: .transcriptResultStream)
        transcriptResultStream = transcriptResultStreamDecoded
    }
}

public struct StartStreamTranscriptionInputBodyMiddleware: Middleware {
    public let id: String = "StartStreamTranscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartStreamTranscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartStreamTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let audioStream = input.operationInput.audioStream {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(audioStream)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartStreamTranscriptionInput>
    public typealias MOutput = OperationOutput<StartStreamTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartStreamTranscriptionOutputError>
}

extension StartStreamTranscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartStreamTranscriptionInput(audioStream: \(String(describing: audioStream)), enableChannelIdentification: \(String(describing: enableChannelIdentification)), enablePartialResultsStabilization: \(String(describing: enablePartialResultsStabilization)), languageCode: \(String(describing: languageCode)), mediaEncoding: \(String(describing: mediaEncoding)), mediaSampleRateHertz: \(String(describing: mediaSampleRateHertz)), numberOfChannels: \(String(describing: numberOfChannels)), partialResultsStability: \(String(describing: partialResultsStability)), sessionId: \(String(describing: sessionId)), showSpeakerLabel: \(String(describing: showSpeakerLabel)), vocabularyFilterMethod: \(String(describing: vocabularyFilterMethod)), vocabularyFilterName: \(String(describing: vocabularyFilterName)), vocabularyName: \(String(describing: vocabularyName)))"}
}

extension StartStreamTranscriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audioStream = "AudioStream"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioStream = audioStream {
            try encodeContainer.encode(audioStream, forKey: .audioStream)
        }
    }
}

public struct StartStreamTranscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "StartStreamTranscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartStreamTranscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartStreamTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withHeader(name: "x-amzn-transcribe-enable-channel-identification", value: String(input.operationInput.enableChannelIdentification))
        input.builder.withHeader(name: "x-amzn-transcribe-enable-partial-results-stabilization", value: String(input.operationInput.enablePartialResultsStabilization))
        if let languageCode = input.operationInput.languageCode {
            input.builder.withHeader(name: "x-amzn-transcribe-language-code", value: String(languageCode.rawValue))
        }
        if let mediaEncoding = input.operationInput.mediaEncoding {
            input.builder.withHeader(name: "x-amzn-transcribe-media-encoding", value: String(mediaEncoding.rawValue))
        }
        if let mediaSampleRateHertz = input.operationInput.mediaSampleRateHertz {
            input.builder.withHeader(name: "x-amzn-transcribe-sample-rate", value: String(mediaSampleRateHertz))
        }
        if let numberOfChannels = input.operationInput.numberOfChannels {
            input.builder.withHeader(name: "x-amzn-transcribe-number-of-channels", value: String(numberOfChannels))
        }
        if let partialResultsStability = input.operationInput.partialResultsStability {
            input.builder.withHeader(name: "x-amzn-transcribe-partial-results-stability", value: String(partialResultsStability.rawValue))
        }
        if let sessionId = input.operationInput.sessionId {
            input.builder.withHeader(name: "x-amzn-transcribe-session-id", value: String(sessionId))
        }
        input.builder.withHeader(name: "x-amzn-transcribe-show-speaker-label", value: String(input.operationInput.showSpeakerLabel))
        if let vocabularyFilterMethod = input.operationInput.vocabularyFilterMethod {
            input.builder.withHeader(name: "x-amzn-transcribe-vocabulary-filter-method", value: String(vocabularyFilterMethod.rawValue))
        }
        if let vocabularyFilterName = input.operationInput.vocabularyFilterName {
            input.builder.withHeader(name: "x-amzn-transcribe-vocabulary-filter-name", value: String(vocabularyFilterName))
        }
        if let vocabularyName = input.operationInput.vocabularyName {
            input.builder.withHeader(name: "x-amzn-transcribe-vocabulary-name", value: String(vocabularyName))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartStreamTranscriptionInput>
    public typealias MOutput = OperationOutput<StartStreamTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartStreamTranscriptionOutputError>
}

public struct StartStreamTranscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartStreamTranscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartStreamTranscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartStreamTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartStreamTranscriptionInput>
    public typealias MOutput = OperationOutput<StartStreamTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartStreamTranscriptionOutputError>
}

public struct StartStreamTranscriptionInput: Equatable {
    /// <p>PCM-encoded stream of audio blobs. The audio stream is encoded as an HTTP2 data
    ///       frame.</p>
    public let audioStream: AudioStream?
    /// <p>When <code>true</code>, instructs Amazon Transcribe to process each audio channel separately and then
    ///       merge the transcription output of each channel into a single transcription.</p>
    ///          <p>Amazon Transcribe also produces a transcription of each item. An item includes the start time, end
    ///       time, and any alternative transcriptions.</p>
    ///          <p>You can't set both <code>ShowSpeakerLabel</code> and
    ///         <code>EnableChannelIdentification</code> in the same request. If you set both, your request
    ///       returns a <code>BadRequestException</code>.</p>
    public let enableChannelIdentification: Bool
    /// <p>When <code>true</code>, instructs Amazon Transcribe to present transcription results that have the
    ///       partial results stabilized. Normally, any word or phrase from one partial result can change in
    ///       a subsequent partial result. With partial results stabilization enabled, only the last few
    ///       words of one partial result can change in another partial result.</p>
    public let enablePartialResultsStabilization: Bool
    /// <p>Indicates the source language used in the input audio stream.</p>
    public let languageCode: LanguageCode?
    /// <p>The encoding used for the input audio.</p>
    public let mediaEncoding: MediaEncoding?
    /// <p>The sample rate, in Hertz, of the input audio. We suggest that you use 8000 Hz for low
    ///       quality audio and 16000 Hz for high quality audio.</p>
    public let mediaSampleRateHertz: Int?
    /// <p>The number of channels that are in your audio stream.</p>
    public let numberOfChannels: Int?
    /// <p>You can use this field to set the stability level of the transcription results. A higher
    ///       stability level means that the transcription results are less likely to change. Higher
    ///       stability levels can come with lower overall transcription accuracy.</p>
    public let partialResultsStability: PartialResultsStability?
    /// <p>A identifier for the transcription session. Use this parameter when you want to retry a
    ///       session. If you don't provide a session ID, Amazon Transcribe will generate one for you and return it in
    ///       the response.</p>
    public let sessionId: String?
    /// <p>When <code>true</code>, enables speaker identification in your real-time stream.</p>
    public let showSpeakerLabel: Bool
    /// <p>The manner in which you use your vocabulary filter to filter words in your transcript.
    ///         <code>Remove</code> removes filtered words from your transcription results.
    ///         <code>Mask</code> masks those words with a <code>***</code> in your transcription results.
    ///         <code>Tag</code> keeps the filtered words in your transcription results and tags them. The
    ///       tag appears as <code>VocabularyFilterMatch</code> equal to <code>True</code>
    ///          </p>
    public let vocabularyFilterMethod: VocabularyFilterMethod?
    /// <p>The name of the vocabulary filter you've created that is unique to your AWS account.
    ///       Provide the name in this field to successfully use it in a stream.</p>
    public let vocabularyFilterName: String?
    /// <p>The name of the vocabulary to use when processing the transcription job.</p>
    public let vocabularyName: String?

    public init (
        audioStream: AudioStream? = nil,
        enableChannelIdentification: Bool = false,
        enablePartialResultsStabilization: Bool = false,
        languageCode: LanguageCode? = nil,
        mediaEncoding: MediaEncoding? = nil,
        mediaSampleRateHertz: Int? = nil,
        numberOfChannels: Int? = nil,
        partialResultsStability: PartialResultsStability? = nil,
        sessionId: String? = nil,
        showSpeakerLabel: Bool = false,
        vocabularyFilterMethod: VocabularyFilterMethod? = nil,
        vocabularyFilterName: String? = nil,
        vocabularyName: String? = nil
    )
    {
        self.audioStream = audioStream
        self.enableChannelIdentification = enableChannelIdentification
        self.enablePartialResultsStabilization = enablePartialResultsStabilization
        self.languageCode = languageCode
        self.mediaEncoding = mediaEncoding
        self.mediaSampleRateHertz = mediaSampleRateHertz
        self.numberOfChannels = numberOfChannels
        self.partialResultsStability = partialResultsStability
        self.sessionId = sessionId
        self.showSpeakerLabel = showSpeakerLabel
        self.vocabularyFilterMethod = vocabularyFilterMethod
        self.vocabularyFilterName = vocabularyFilterName
        self.vocabularyName = vocabularyName
    }
}

struct StartStreamTranscriptionInputBody: Equatable {
    public let audioStream: AudioStream?
}

extension StartStreamTranscriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case audioStream = "AudioStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(AudioStream.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

extension StartStreamTranscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartStreamTranscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartStreamTranscriptionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartStreamTranscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartStreamTranscriptionOutputResponse(enableChannelIdentification: \(String(describing: enableChannelIdentification)), enablePartialResultsStabilization: \(String(describing: enablePartialResultsStabilization)), languageCode: \(String(describing: languageCode)), mediaEncoding: \(String(describing: mediaEncoding)), mediaSampleRateHertz: \(String(describing: mediaSampleRateHertz)), numberOfChannels: \(String(describing: numberOfChannels)), partialResultsStability: \(String(describing: partialResultsStability)), requestId: \(String(describing: requestId)), sessionId: \(String(describing: sessionId)), showSpeakerLabel: \(String(describing: showSpeakerLabel)), transcriptResultStream: \(String(describing: transcriptResultStream)), vocabularyFilterMethod: \(String(describing: vocabularyFilterMethod)), vocabularyFilterName: \(String(describing: vocabularyFilterName)), vocabularyName: \(String(describing: vocabularyName)))"}
}

extension StartStreamTranscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let enableChannelIdentificationHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-enable-channel-identification") {
            self.enableChannelIdentification = Bool(enableChannelIdentificationHeaderValue) ?? false
        } else {
            self.enableChannelIdentification = false
        }
        if let enablePartialResultsStabilizationHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-enable-partial-results-stabilization") {
            self.enablePartialResultsStabilization = Bool(enablePartialResultsStabilizationHeaderValue) ?? false
        } else {
            self.enablePartialResultsStabilization = false
        }
        if let languageCodeHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-language-code") {
            self.languageCode = LanguageCode(rawValue: languageCodeHeaderValue)
        } else {
            self.languageCode = nil
        }
        if let mediaEncodingHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-media-encoding") {
            self.mediaEncoding = MediaEncoding(rawValue: mediaEncodingHeaderValue)
        } else {
            self.mediaEncoding = nil
        }
        if let mediaSampleRateHertzHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-sample-rate") {
            self.mediaSampleRateHertz = Int(mediaSampleRateHertzHeaderValue) ?? 0
        } else {
            self.mediaSampleRateHertz = nil
        }
        if let numberOfChannelsHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-number-of-channels") {
            self.numberOfChannels = Int(numberOfChannelsHeaderValue) ?? 0
        } else {
            self.numberOfChannels = nil
        }
        if let partialResultsStabilityHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-partial-results-stability") {
            self.partialResultsStability = PartialResultsStability(rawValue: partialResultsStabilityHeaderValue)
        } else {
            self.partialResultsStability = nil
        }
        if let requestIdHeaderValue = httpResponse.headers.value(for: "x-amzn-request-id") {
            self.requestId = requestIdHeaderValue
        } else {
            self.requestId = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if let showSpeakerLabelHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-show-speaker-label") {
            self.showSpeakerLabel = Bool(showSpeakerLabelHeaderValue) ?? false
        } else {
            self.showSpeakerLabel = false
        }
        if let vocabularyFilterMethodHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-vocabulary-filter-method") {
            self.vocabularyFilterMethod = VocabularyFilterMethod(rawValue: vocabularyFilterMethodHeaderValue)
        } else {
            self.vocabularyFilterMethod = nil
        }
        if let vocabularyFilterNameHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-vocabulary-filter-name") {
            self.vocabularyFilterName = vocabularyFilterNameHeaderValue
        } else {
            self.vocabularyFilterName = nil
        }
        if let vocabularyNameHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-vocabulary-name") {
            self.vocabularyName = vocabularyNameHeaderValue
        } else {
            self.vocabularyName = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: TranscriptResultStream = try responseDecoder.decode(responseBody: unwrappedData)
                self.transcriptResultStream = output
            } else {
                self.transcriptResultStream = nil
            }
        } else {
            self.transcriptResultStream = nil
        }
    }
}

public struct StartStreamTranscriptionOutputResponse: Equatable {
    /// <p>Shows whether channel identification has been enabled in the stream.</p>
    public let enableChannelIdentification: Bool
    /// <p>Shows whether partial results stabilization has been enabled in the stream.</p>
    public let enablePartialResultsStabilization: Bool
    /// <p>The language code for the input audio stream.</p>
    public let languageCode: LanguageCode?
    /// <p>The encoding used for the input audio stream.</p>
    public let mediaEncoding: MediaEncoding?
    /// <p>The sample rate for the input audio stream. Use 8000 Hz for low quality audio and 16000 Hz
    ///       for high quality audio.</p>
    public let mediaSampleRateHertz: Int?
    /// <p>The number of channels identified in the stream.</p>
    public let numberOfChannels: Int?
    /// <p>If partial results stabilization has been enabled in the stream, shows the stability
    ///       level.</p>
    public let partialResultsStability: PartialResultsStability?
    /// <p>An identifier for the streaming transcription.</p>
    public let requestId: String?
    /// <p>An identifier for a specific transcription session.</p>
    public let sessionId: String?
    /// <p>Shows whether speaker identification was enabled in the stream.</p>
    public let showSpeakerLabel: Bool
    /// <p>Represents the stream of transcription events from Amazon Transcribe to your application.</p>
    public let transcriptResultStream: TranscriptResultStream?
    /// <p>The vocabulary filtering method used in the real-time stream.</p>
    public let vocabularyFilterMethod: VocabularyFilterMethod?
    /// <p>The name of the vocabulary filter used in your real-time stream.</p>
    public let vocabularyFilterName: String?
    /// <p>The name of the vocabulary used when processing the stream.</p>
    public let vocabularyName: String?

    public init (
        enableChannelIdentification: Bool = false,
        enablePartialResultsStabilization: Bool = false,
        languageCode: LanguageCode? = nil,
        mediaEncoding: MediaEncoding? = nil,
        mediaSampleRateHertz: Int? = nil,
        numberOfChannels: Int? = nil,
        partialResultsStability: PartialResultsStability? = nil,
        requestId: String? = nil,
        sessionId: String? = nil,
        showSpeakerLabel: Bool = false,
        transcriptResultStream: TranscriptResultStream? = nil,
        vocabularyFilterMethod: VocabularyFilterMethod? = nil,
        vocabularyFilterName: String? = nil,
        vocabularyName: String? = nil
    )
    {
        self.enableChannelIdentification = enableChannelIdentification
        self.enablePartialResultsStabilization = enablePartialResultsStabilization
        self.languageCode = languageCode
        self.mediaEncoding = mediaEncoding
        self.mediaSampleRateHertz = mediaSampleRateHertz
        self.numberOfChannels = numberOfChannels
        self.partialResultsStability = partialResultsStability
        self.requestId = requestId
        self.sessionId = sessionId
        self.showSpeakerLabel = showSpeakerLabel
        self.transcriptResultStream = transcriptResultStream
        self.vocabularyFilterMethod = vocabularyFilterMethod
        self.vocabularyFilterName = vocabularyFilterName
        self.vocabularyName = vocabularyName
    }
}

struct StartStreamTranscriptionOutputResponseBody: Equatable {
    public let transcriptResultStream: TranscriptResultStream?
}

extension StartStreamTranscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transcriptResultStream = "TranscriptResultStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptResultStreamDecoded = try containerValues.decodeIfPresent(TranscriptResultStream.self, forKey: .transcriptResultStream)
        transcriptResultStream = transcriptResultStreamDecoded
    }
}

extension Transcript: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case results = "Results"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let results = results {
            var resultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .results)
            for resultlist0 in results {
                try resultsContainer.encode(resultlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([Result?].self, forKey: .results)
        var resultsDecoded0:[Result]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [Result]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

extension Transcript: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Transcript(results: \(String(describing: results)))"}
}

/// <p>The transcription in a <a>TranscriptEvent</a>.</p>
public struct Transcript: Equatable {
    /// <p>
    ///             <a>Result</a> objects that contain the results of transcribing a portion of the
    ///       input audio stream. The array can be empty.</p>
    public let results: [Result]?

    public init (
        results: [Result]? = nil
    )
    {
        self.results = results
    }
}

extension TranscriptEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case transcript = "Transcript"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transcript = transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptDecoded = try containerValues.decodeIfPresent(Transcript.self, forKey: .transcript)
        transcript = transcriptDecoded
    }
}

extension TranscriptEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TranscriptEvent(transcript: \(String(describing: transcript)))"}
}

/// <p>Represents a set of transcription results from the server to the client. It contains one
///       or more segments of the transcription.</p>
public struct TranscriptEvent: Equatable {
    /// <p>The transcription of the audio stream. The transcription is composed of all of the items
    ///       in the results list.</p>
    public let transcript: Transcript?

    public init (
        transcript: Transcript? = nil
    )
    {
        self.transcript = transcript
    }
}

extension TranscriptResultStream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case internalFailureException = "InternalFailureException"
        case limitExceededException = "LimitExceededException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case transcriptEvent = "TranscriptEvent"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .badRequestException(badRequestException):
                if let badRequestException = badRequestException {
                    try container.encode(badRequestException, forKey: .badRequestException)
                }
            case let .conflictException(conflictException):
                if let conflictException = conflictException {
                    try container.encode(conflictException, forKey: .conflictException)
                }
            case let .internalFailureException(internalFailureException):
                if let internalFailureException = internalFailureException {
                    try container.encode(internalFailureException, forKey: .internalFailureException)
                }
            case let .limitExceededException(limitExceededException):
                if let limitExceededException = limitExceededException {
                    try container.encode(limitExceededException, forKey: .limitExceededException)
                }
            case let .serviceUnavailableException(serviceUnavailableException):
                if let serviceUnavailableException = serviceUnavailableException {
                    try container.encode(serviceUnavailableException, forKey: .serviceUnavailableException)
                }
            case let .transcriptEvent(transcriptEvent):
                if let transcriptEvent = transcriptEvent {
                    try container.encode(transcriptEvent, forKey: .transcriptEvent)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptEventDecoded = try values.decodeIfPresent(TranscriptEvent.self, forKey: .transcriptEvent)
        if let transcriptEvent = transcriptEventDecoded {
            self = .transcriptEvent(transcriptEvent)
            return
        }
        let badRequestExceptionDecoded = try values.decodeIfPresent(BadRequestException.self, forKey: .badRequestException)
        if let badRequestException = badRequestExceptionDecoded {
            self = .badRequestException(badRequestException)
            return
        }
        let limitExceededExceptionDecoded = try values.decodeIfPresent(LimitExceededException.self, forKey: .limitExceededException)
        if let limitExceededException = limitExceededExceptionDecoded {
            self = .limitExceededException(limitExceededException)
            return
        }
        let internalFailureExceptionDecoded = try values.decodeIfPresent(InternalFailureException.self, forKey: .internalFailureException)
        if let internalFailureException = internalFailureExceptionDecoded {
            self = .internalFailureException(internalFailureException)
            return
        }
        let conflictExceptionDecoded = try values.decodeIfPresent(ConflictException.self, forKey: .conflictException)
        if let conflictException = conflictExceptionDecoded {
            self = .conflictException(conflictException)
            return
        }
        let serviceUnavailableExceptionDecoded = try values.decodeIfPresent(ServiceUnavailableException.self, forKey: .serviceUnavailableException)
        if let serviceUnavailableException = serviceUnavailableExceptionDecoded {
            self = .serviceUnavailableException(serviceUnavailableException)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Represents the transcription result stream from Amazon Transcribe to your application.</p>
public enum TranscriptResultStream: Equatable {
    /// <p>A portion of the transcription of the audio stream. Events are sent periodically from
    ///       Amazon Transcribe to your application. The event can be a partial transcription of a section of the audio
    ///       stream, or it can be the entire transcription of that portion of the audio stream.
    ///       </p>
    case transcriptEvent(TranscriptEvent?)
    /// <p>A client error occurred when the stream was created. Check the parameters of the request
    ///       and try your request again.</p>
    case badRequestException(BadRequestException?)
    /// <p>Your client has exceeded one of the Amazon Transcribe limits, typically the limit on audio length.
    ///       Break your audio stream into smaller chunks and try your request again.</p>
    case limitExceededException(LimitExceededException?)
    /// <p>A problem occurred while processing the audio. Amazon Transcribe terminated processing.</p>
    case internalFailureException(InternalFailureException?)
    /// <p>A new stream started with the same session ID. The current stream has been
    ///       terminated.</p>
    case conflictException(ConflictException?)
    /// <p>Service is currently unavailable. Try your request later.</p>
    case serviceUnavailableException(ServiceUnavailableException?)
    case sdkUnknown(String?)
}

public enum `Type` {
    case conversation
    case dictation
    case sdkUnknown(String)
}

extension `Type` : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [`Type`] {
        return [
            .conversation,
            .dictation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .conversation: return "CONVERSATION"
        case .dictation: return "DICTATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = `Type`(rawValue: rawValue) ?? `Type`.sdkUnknown(rawValue)
    }
}

public enum VocabularyFilterMethod {
    case mask
    case remove
    case tag
    case sdkUnknown(String)
}

extension VocabularyFilterMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VocabularyFilterMethod] {
        return [
            .mask,
            .remove,
            .tag,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .mask: return "mask"
        case .remove: return "remove"
        case .tag: return "tag"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VocabularyFilterMethod(rawValue: rawValue) ?? VocabularyFilterMethod.sdkUnknown(rawValue)
    }
}
