// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ClientLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClientLimitExceededException(message: \(String(describing: message)))"}
}

extension ClientLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ClientLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Kinesis Video Streams has throttled the request because you have exceeded a limit. Try making the call later. For information about limits, see <a href="http://docs.aws.amazon.com/kinesisvideostreams/latest/dg/limits.html">Kinesis Video Streams Limits</a>.</p>
public struct ClientLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClientLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ClientLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClipFragmentSelector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fragmentSelectorType = "FragmentSelectorType"
        case timestampRange = "TimestampRange"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fragmentSelectorType = fragmentSelectorType {
            try encodeContainer.encode(fragmentSelectorType.rawValue, forKey: .fragmentSelectorType)
        }
        if let timestampRange = timestampRange {
            try encodeContainer.encode(timestampRange, forKey: .timestampRange)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fragmentSelectorTypeDecoded = try containerValues.decodeIfPresent(ClipFragmentSelectorType.self, forKey: .fragmentSelectorType)
        fragmentSelectorType = fragmentSelectorTypeDecoded
        let timestampRangeDecoded = try containerValues.decodeIfPresent(ClipTimestampRange.self, forKey: .timestampRange)
        timestampRange = timestampRangeDecoded
    }
}

extension ClipFragmentSelector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClipFragmentSelector(fragmentSelectorType: \(String(describing: fragmentSelectorType)), timestampRange: \(String(describing: timestampRange)))"}
}

/// <p>Describes the timestamp range and timestamp origin of a range of fragments.</p>
///         <p>Fragments that have duplicate producer timestamps are deduplicated. This means that if
///             producers are producing a stream of fragments with producer timestamps that are
///             approximately equal to the true clock time, the clip will contain all of the fragments
///             within the requested timestamp range. If some fragments are ingested within the same
///             time range and very different points in time, only the oldest ingested collection of
///             fragments are returned.</p>
public struct ClipFragmentSelector: Equatable {
    /// <p>The origin of the timestamps to use (Server or Producer).</p>
    public let fragmentSelectorType: ClipFragmentSelectorType?
    /// <p>The range of timestamps to return.</p>
    public let timestampRange: ClipTimestampRange?

    public init (
        fragmentSelectorType: ClipFragmentSelectorType? = nil,
        timestampRange: ClipTimestampRange? = nil
    )
    {
        self.fragmentSelectorType = fragmentSelectorType
        self.timestampRange = timestampRange
    }
}

public enum ClipFragmentSelectorType {
    case producerTimestamp
    case serverTimestamp
    case sdkUnknown(String)
}

extension ClipFragmentSelectorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ClipFragmentSelectorType] {
        return [
            .producerTimestamp,
            .serverTimestamp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .producerTimestamp: return "PRODUCER_TIMESTAMP"
        case .serverTimestamp: return "SERVER_TIMESTAMP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ClipFragmentSelectorType(rawValue: rawValue) ?? ClipFragmentSelectorType.sdkUnknown(rawValue)
    }
}

extension ClipTimestampRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTimestamp = "EndTimestamp"
        case startTimestamp = "StartTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTimestamp = endTimestamp {
            try encodeContainer.encode(endTimestamp.timeIntervalSince1970, forKey: .endTimestamp)
        }
        if let startTimestamp = startTimestamp {
            try encodeContainer.encode(startTimestamp.timeIntervalSince1970, forKey: .startTimestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTimestamp)
        startTimestamp = startTimestampDecoded
        let endTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTimestamp)
        endTimestamp = endTimestampDecoded
    }
}

extension ClipTimestampRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClipTimestampRange(endTimestamp: \(String(describing: endTimestamp)), startTimestamp: \(String(describing: startTimestamp)))"}
}

/// <p>The range of timestamps for which to return fragments.</p>
public struct ClipTimestampRange: Equatable {
    /// <p>The end of the timestamp range for the requested media.</p>
    ///         <p>This value must be within 24 hours of the specified <code>StartTimestamp</code>, and
    ///             it must be later than the <code>StartTimestamp</code> value. If
    ///                 <code>FragmentSelectorType</code> for the request is <code>SERVER_TIMESTAMP</code>,
    ///             this value must be in the past. </p>
    ///         <p>This value is inclusive. The <code>EndTimestamp</code> is compared to the (starting)
    ///             timestamp of the fragment. Fragments that start before the <code>EndTimestamp</code>
    ///             value and continue past it are included in the session. </p>
    public let endTimestamp: Date?
    /// <p>The starting timestamp in the range of timestamps for which to return fragments. </p>
    ///         <p>Only fragments that start exactly at or after <code>StartTimestamp</code> are included
    ///             in the session. Fragments that start before <code>StartTimestamp</code> and continue
    ///             past it aren't included in the session. If <code>FragmentSelectorType</code> is
    ///                 <code>SERVER_TIMESTAMP</code>, the <code>StartTimestamp</code> must be later than
    ///             the stream head. </p>
    public let startTimestamp: Date?

    public init (
        endTimestamp: Date? = nil,
        startTimestamp: Date? = nil
    )
    {
        self.endTimestamp = endTimestamp
        self.startTimestamp = startTimestamp
    }
}

public enum ContainerFormat {
    case fragmentedMp4
    case mpegTs
    case sdkUnknown(String)
}

extension ContainerFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContainerFormat] {
        return [
            .fragmentedMp4,
            .mpegTs,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fragmentedMp4: return "FRAGMENTED_MP4"
        case .mpegTs: return "MPEG_TS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContainerFormat(rawValue: rawValue) ?? ContainerFormat.sdkUnknown(rawValue)
    }
}

public enum DASHDisplayFragmentNumber {
    case always
    case never
    case sdkUnknown(String)
}

extension DASHDisplayFragmentNumber : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DASHDisplayFragmentNumber] {
        return [
            .always,
            .never,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .always: return "ALWAYS"
        case .never: return "NEVER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DASHDisplayFragmentNumber(rawValue: rawValue) ?? DASHDisplayFragmentNumber.sdkUnknown(rawValue)
    }
}

public enum DASHDisplayFragmentTimestamp {
    case always
    case never
    case sdkUnknown(String)
}

extension DASHDisplayFragmentTimestamp : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DASHDisplayFragmentTimestamp] {
        return [
            .always,
            .never,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .always: return "ALWAYS"
        case .never: return "NEVER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DASHDisplayFragmentTimestamp(rawValue: rawValue) ?? DASHDisplayFragmentTimestamp.sdkUnknown(rawValue)
    }
}

extension DASHFragmentSelector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fragmentSelectorType = "FragmentSelectorType"
        case timestampRange = "TimestampRange"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fragmentSelectorType = fragmentSelectorType {
            try encodeContainer.encode(fragmentSelectorType.rawValue, forKey: .fragmentSelectorType)
        }
        if let timestampRange = timestampRange {
            try encodeContainer.encode(timestampRange, forKey: .timestampRange)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fragmentSelectorTypeDecoded = try containerValues.decodeIfPresent(DASHFragmentSelectorType.self, forKey: .fragmentSelectorType)
        fragmentSelectorType = fragmentSelectorTypeDecoded
        let timestampRangeDecoded = try containerValues.decodeIfPresent(DASHTimestampRange.self, forKey: .timestampRange)
        timestampRange = timestampRangeDecoded
    }
}

extension DASHFragmentSelector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DASHFragmentSelector(fragmentSelectorType: \(String(describing: fragmentSelectorType)), timestampRange: \(String(describing: timestampRange)))"}
}

/// <p>Contains the range of timestamps for the requested media, and the source of the
///             timestamps. </p>
public struct DASHFragmentSelector: Equatable {
    /// <p>The source of the timestamps for the requested media.</p>
    ///         <p>When <code>FragmentSelectorType</code> is set to <code>PRODUCER_TIMESTAMP</code> and
    ///                 <a>GetDASHStreamingSessionURLInput$PlaybackMode</a> is
    ///                 <code>ON_DEMAND</code> or <code>LIVE_REPLAY</code>, the first fragment ingested with
    ///             a producer timestamp within the specified <a>FragmentSelector$TimestampRange</a> is included in the media playlist. In
    ///             addition, the fragments with producer timestamps within the <code>TimestampRange</code>
    ///             ingested immediately following the first fragment (up to the <a>GetDASHStreamingSessionURLInput$MaxManifestFragmentResults</a> value) are
    ///             included. </p>
    ///         <p>Fragments that have duplicate producer timestamps are deduplicated. This means that if
    ///             producers are producing a stream of fragments with producer timestamps that are
    ///             approximately equal to the true clock time, the MPEG-DASH manifest will contain all of
    ///             the fragments within the requested timestamp range. If some fragments are ingested
    ///             within the same time range and very different points in time, only the oldest ingested
    ///             collection of fragments are returned.</p>
    ///         <p>When <code>FragmentSelectorType</code> is set to <code>PRODUCER_TIMESTAMP</code> and
    ///                 <a>GetDASHStreamingSessionURLInput$PlaybackMode</a> is <code>LIVE</code>,
    ///             the producer timestamps are used in the MP4 fragments and for deduplication. But the
    ///             most recently ingested fragments based on server timestamps are included in the
    ///             MPEG-DASH manifest. This means that even if fragments ingested in the past have producer
    ///             timestamps with values now, they are not included in the HLS media playlist.</p>
    ///         <p>The default is <code>SERVER_TIMESTAMP</code>.</p>
    public let fragmentSelectorType: DASHFragmentSelectorType?
    /// <p>The start and end of the timestamp range for the requested media.</p>
    ///         <p>This value should not be present if <code>PlaybackType</code> is
    ///             <code>LIVE</code>.</p>
    public let timestampRange: DASHTimestampRange?

    public init (
        fragmentSelectorType: DASHFragmentSelectorType? = nil,
        timestampRange: DASHTimestampRange? = nil
    )
    {
        self.fragmentSelectorType = fragmentSelectorType
        self.timestampRange = timestampRange
    }
}

public enum DASHFragmentSelectorType {
    case producerTimestamp
    case serverTimestamp
    case sdkUnknown(String)
}

extension DASHFragmentSelectorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DASHFragmentSelectorType] {
        return [
            .producerTimestamp,
            .serverTimestamp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .producerTimestamp: return "PRODUCER_TIMESTAMP"
        case .serverTimestamp: return "SERVER_TIMESTAMP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DASHFragmentSelectorType(rawValue: rawValue) ?? DASHFragmentSelectorType.sdkUnknown(rawValue)
    }
}

public enum DASHPlaybackMode {
    case live
    case liveReplay
    case onDemand
    case sdkUnknown(String)
}

extension DASHPlaybackMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DASHPlaybackMode] {
        return [
            .live,
            .liveReplay,
            .onDemand,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .live: return "LIVE"
        case .liveReplay: return "LIVE_REPLAY"
        case .onDemand: return "ON_DEMAND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DASHPlaybackMode(rawValue: rawValue) ?? DASHPlaybackMode.sdkUnknown(rawValue)
    }
}

extension DASHTimestampRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTimestamp = "EndTimestamp"
        case startTimestamp = "StartTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTimestamp = endTimestamp {
            try encodeContainer.encode(endTimestamp.timeIntervalSince1970, forKey: .endTimestamp)
        }
        if let startTimestamp = startTimestamp {
            try encodeContainer.encode(startTimestamp.timeIntervalSince1970, forKey: .startTimestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTimestamp)
        startTimestamp = startTimestampDecoded
        let endTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTimestamp)
        endTimestamp = endTimestampDecoded
    }
}

extension DASHTimestampRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DASHTimestampRange(endTimestamp: \(String(describing: endTimestamp)), startTimestamp: \(String(describing: startTimestamp)))"}
}

/// <p>The start and end of the timestamp range for the requested media.</p>
///         <p>This value should not be present if <code>PlaybackType</code> is
///             <code>LIVE</code>.</p>
///         <p>The values in <code>DASHimestampRange</code> are inclusive. Fragments that start
///             exactly at or after the start time are included in the session. Fragments that start
///             before the start time and continue past it are not included in the session.</p>
public struct DASHTimestampRange: Equatable {
    /// <p>The end of the timestamp range for the requested media. This value must be within 24
    ///             hours of the specified <code>StartTimestamp</code>, and it must be later than the
    ///                 <code>StartTimestamp</code> value.</p>
    ///         <p>If <code>FragmentSelectorType</code> for the request is <code>SERVER_TIMESTAMP</code>,
    ///             this value must be in the past.</p>
    ///
    ///         <p>The <code>EndTimestamp</code> value is required for <code>ON_DEMAND</code> mode, but
    ///             optional for <code>LIVE_REPLAY</code> mode. If the <code>EndTimestamp</code> is not set
    ///             for <code>LIVE_REPLAY</code> mode then the session will continue to include newly
    ///             ingested fragments until the session expires.</p>
    ///         <note>
    ///             <p>This value is inclusive. The <code>EndTimestamp</code> is compared to the
    ///                 (starting) timestamp of the fragment. Fragments that start before the
    ///                     <code>EndTimestamp</code> value and continue past it are included in the
    ///                 session.</p>
    ///         </note>
    public let endTimestamp: Date?
    /// <p>The start of the timestamp range for the requested media.</p>
    ///         <p>If the <code>DASHTimestampRange</code> value is specified, the
    ///                 <code>StartTimestamp</code> value is required.</p>
    ///         <p>Only fragments that start exactly at or after <code>StartTimestamp</code> are included
    ///             in the session. Fragments that start before <code>StartTimestamp</code> and continue
    ///             past it aren't included in the session. If <code>FragmentSelectorType</code> is
    ///                 <code>SERVER_TIMESTAMP</code>, the <code>StartTimestamp</code> must be later than
    ///             the stream head. </p>
    public let startTimestamp: Date?

    public init (
        endTimestamp: Date? = nil,
        startTimestamp: Date? = nil
    )
    {
        self.endTimestamp = endTimestamp
        self.startTimestamp = startTimestamp
    }
}

extension Fragment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fragmentLengthInMilliseconds = "FragmentLengthInMilliseconds"
        case fragmentNumber = "FragmentNumber"
        case fragmentSizeInBytes = "FragmentSizeInBytes"
        case producerTimestamp = "ProducerTimestamp"
        case serverTimestamp = "ServerTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if fragmentLengthInMilliseconds != 0 {
            try encodeContainer.encode(fragmentLengthInMilliseconds, forKey: .fragmentLengthInMilliseconds)
        }
        if let fragmentNumber = fragmentNumber {
            try encodeContainer.encode(fragmentNumber, forKey: .fragmentNumber)
        }
        if fragmentSizeInBytes != 0 {
            try encodeContainer.encode(fragmentSizeInBytes, forKey: .fragmentSizeInBytes)
        }
        if let producerTimestamp = producerTimestamp {
            try encodeContainer.encode(producerTimestamp.timeIntervalSince1970, forKey: .producerTimestamp)
        }
        if let serverTimestamp = serverTimestamp {
            try encodeContainer.encode(serverTimestamp.timeIntervalSince1970, forKey: .serverTimestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fragmentNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fragmentNumber)
        fragmentNumber = fragmentNumberDecoded
        let fragmentSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .fragmentSizeInBytes)
        fragmentSizeInBytes = fragmentSizeInBytesDecoded
        let producerTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .producerTimestamp)
        producerTimestamp = producerTimestampDecoded
        let serverTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .serverTimestamp)
        serverTimestamp = serverTimestampDecoded
        let fragmentLengthInMillisecondsDecoded = try containerValues.decode(Int.self, forKey: .fragmentLengthInMilliseconds)
        fragmentLengthInMilliseconds = fragmentLengthInMillisecondsDecoded
    }
}

extension Fragment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Fragment(fragmentLengthInMilliseconds: \(String(describing: fragmentLengthInMilliseconds)), fragmentNumber: \(String(describing: fragmentNumber)), fragmentSizeInBytes: \(String(describing: fragmentSizeInBytes)), producerTimestamp: \(String(describing: producerTimestamp)), serverTimestamp: \(String(describing: serverTimestamp)))"}
}

/// <p>Represents a segment of video or other time-delimited data.</p>
public struct Fragment: Equatable {
    /// <p>The playback duration or other time value associated with the fragment.</p>
    public let fragmentLengthInMilliseconds: Int
    /// <p>The unique identifier of the fragment. This value monotonically increases based on the
    ///             ingestion order.</p>
    public let fragmentNumber: String?
    /// <p>The total fragment size, including information about the fragment and contained media
    ///             data.</p>
    public let fragmentSizeInBytes: Int
    /// <p>The timestamp from the producer corresponding to the fragment.</p>
    public let producerTimestamp: Date?
    /// <p>The timestamp from the AWS server corresponding to the fragment.</p>
    public let serverTimestamp: Date?

    public init (
        fragmentLengthInMilliseconds: Int = 0,
        fragmentNumber: String? = nil,
        fragmentSizeInBytes: Int = 0,
        producerTimestamp: Date? = nil,
        serverTimestamp: Date? = nil
    )
    {
        self.fragmentLengthInMilliseconds = fragmentLengthInMilliseconds
        self.fragmentNumber = fragmentNumber
        self.fragmentSizeInBytes = fragmentSizeInBytes
        self.producerTimestamp = producerTimestamp
        self.serverTimestamp = serverTimestamp
    }
}

extension FragmentSelector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fragmentSelectorType = "FragmentSelectorType"
        case timestampRange = "TimestampRange"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fragmentSelectorType = fragmentSelectorType {
            try encodeContainer.encode(fragmentSelectorType.rawValue, forKey: .fragmentSelectorType)
        }
        if let timestampRange = timestampRange {
            try encodeContainer.encode(timestampRange, forKey: .timestampRange)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fragmentSelectorTypeDecoded = try containerValues.decodeIfPresent(FragmentSelectorType.self, forKey: .fragmentSelectorType)
        fragmentSelectorType = fragmentSelectorTypeDecoded
        let timestampRangeDecoded = try containerValues.decodeIfPresent(TimestampRange.self, forKey: .timestampRange)
        timestampRange = timestampRangeDecoded
    }
}

extension FragmentSelector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FragmentSelector(fragmentSelectorType: \(String(describing: fragmentSelectorType)), timestampRange: \(String(describing: timestampRange)))"}
}

/// <p>Describes the timestamp range and timestamp origin of a range of fragments.</p>
///         <p>Only fragments with a start timestamp greater than or equal to the given start time
///             and less than or equal to the end time are returned. For example, if a stream contains
///             fragments with the following start timestamps: </p>
///         <ul>
///             <li>
///                 <p>00:00:00</p>
///             </li>
///             <li>
///                 <p>00:00:02</p>
///             </li>
///             <li>
///                 <p>00:00:04</p>
///             </li>
///             <li>
///                 <p>00:00:06</p>
///             </li>
///          </ul>
///         <p> A fragment selector range with a start time of 00:00:01 and end time of 00:00:04
///             would return the fragments with start times of 00:00:02 and 00:00:04. </p>
public struct FragmentSelector: Equatable {
    /// <p>The origin of the timestamps to use (Server or Producer).</p>
    public let fragmentSelectorType: FragmentSelectorType?
    /// <p>The range of timestamps to return.</p>
    public let timestampRange: TimestampRange?

    public init (
        fragmentSelectorType: FragmentSelectorType? = nil,
        timestampRange: TimestampRange? = nil
    )
    {
        self.fragmentSelectorType = fragmentSelectorType
        self.timestampRange = timestampRange
    }
}

public enum FragmentSelectorType {
    case producerTimestamp
    case serverTimestamp
    case sdkUnknown(String)
}

extension FragmentSelectorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FragmentSelectorType] {
        return [
            .producerTimestamp,
            .serverTimestamp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .producerTimestamp: return "PRODUCER_TIMESTAMP"
        case .serverTimestamp: return "SERVER_TIMESTAMP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FragmentSelectorType(rawValue: rawValue) ?? FragmentSelectorType.sdkUnknown(rawValue)
    }
}

public struct GetClipInputBodyMiddleware: Middleware {
    public let id: String = "GetClipInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClipInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClipInput>
    public typealias MOutput = OperationOutput<GetClipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClipOutputError>
}

extension GetClipInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetClipInput(clipFragmentSelector: \(String(describing: clipFragmentSelector)), streamARN: \(String(describing: streamARN)), streamName: \(String(describing: streamName)))"}
}

extension GetClipInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clipFragmentSelector = "ClipFragmentSelector"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clipFragmentSelector = clipFragmentSelector {
            try encodeContainer.encode(clipFragmentSelector, forKey: .clipFragmentSelector)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct GetClipInputHeadersMiddleware: Middleware {
    public let id: String = "GetClipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClipInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClipInput>
    public typealias MOutput = OperationOutput<GetClipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClipOutputError>
}

public struct GetClipInputQueryItemMiddleware: Middleware {
    public let id: String = "GetClipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClipInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClipInput>
    public typealias MOutput = OperationOutput<GetClipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClipOutputError>
}

public struct GetClipInput: Equatable {
    /// <p>The time range of the requested clip and the source of the timestamps.</p>
    public let clipFragmentSelector: ClipFragmentSelector?
    /// <p>The Amazon Resource Name (ARN) of the stream for which to retrieve the media clip. </p>
    ///         <p>You must specify either the StreamName or the StreamARN. </p>
    public let streamARN: String?
    /// <p>The name of the stream for which to retrieve the media clip. </p>
    ///         <p>You must specify either the StreamName or the StreamARN. </p>
    public let streamName: String?

    public init (
        clipFragmentSelector: ClipFragmentSelector? = nil,
        streamARN: String? = nil,
        streamName: String? = nil
    )
    {
        self.clipFragmentSelector = clipFragmentSelector
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct GetClipInputBody: Equatable {
    public let streamName: String?
    public let streamARN: String?
    public let clipFragmentSelector: ClipFragmentSelector?
}

extension GetClipInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clipFragmentSelector = "ClipFragmentSelector"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let clipFragmentSelectorDecoded = try containerValues.decodeIfPresent(ClipFragmentSelector.self, forKey: .clipFragmentSelector)
        clipFragmentSelector = clipFragmentSelectorDecoded
    }
}

extension GetClipOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetClipOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCodecPrivateDataException" : self = .invalidCodecPrivateDataException(try InvalidCodecPrivateDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMediaFrameException" : self = .invalidMediaFrameException(try InvalidMediaFrameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingCodecPrivateDataException" : self = .missingCodecPrivateDataException(try MissingCodecPrivateDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoDataRetentionException" : self = .noDataRetentionException(try NoDataRetentionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedStreamMediaTypeException" : self = .unsupportedStreamMediaTypeException(try UnsupportedStreamMediaTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetClipOutputError: Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidCodecPrivateDataException(InvalidCodecPrivateDataException)
    case invalidMediaFrameException(InvalidMediaFrameException)
    case missingCodecPrivateDataException(MissingCodecPrivateDataException)
    case noDataRetentionException(NoDataRetentionException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedStreamMediaTypeException(UnsupportedStreamMediaTypeException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetClipOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetClipOutputResponse(contentType: \(String(describing: contentType)), payload: \(String(describing: payload)))"}
}

extension GetClipOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.payload = unwrappedData
        } else {
            self.payload = nil
        }
    }
}

public struct GetClipOutputResponse: Equatable {
    /// <p>The content type of the media in the requested clip.</p>
    public let contentType: String?
    /// <p>Traditional MP4 file that contains the media clip from the specified video stream. The
    ///             output will contain the first 100 MB or the first 200 fragments from the specified start
    ///             timestamp. For more information, see <a href="https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/limits.html">Kinesis
    ///                 Video Streams Limits</a>. </p>
    public let payload: Data?

    public init (
        contentType: String? = nil,
        payload: Data? = nil
    )
    {
        self.contentType = contentType
        self.payload = payload
    }
}

struct GetClipOutputResponseBody: Equatable {
    public let payload: Data?
}

extension GetClipOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case payload = "Payload"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

public struct GetDASHStreamingSessionURLInputBodyMiddleware: Middleware {
    public let id: String = "GetDASHStreamingSessionURLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDASHStreamingSessionURLInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDASHStreamingSessionURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDASHStreamingSessionURLInput>
    public typealias MOutput = OperationOutput<GetDASHStreamingSessionURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDASHStreamingSessionURLOutputError>
}

extension GetDASHStreamingSessionURLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDASHStreamingSessionURLInput(dASHFragmentSelector: \(String(describing: dASHFragmentSelector)), displayFragmentNumber: \(String(describing: displayFragmentNumber)), displayFragmentTimestamp: \(String(describing: displayFragmentTimestamp)), expires: \(String(describing: expires)), maxManifestFragmentResults: \(String(describing: maxManifestFragmentResults)), playbackMode: \(String(describing: playbackMode)), streamARN: \(String(describing: streamARN)), streamName: \(String(describing: streamName)))"}
}

extension GetDASHStreamingSessionURLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dASHFragmentSelector = "DASHFragmentSelector"
        case displayFragmentNumber = "DisplayFragmentNumber"
        case displayFragmentTimestamp = "DisplayFragmentTimestamp"
        case expires = "Expires"
        case maxManifestFragmentResults = "MaxManifestFragmentResults"
        case playbackMode = "PlaybackMode"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dASHFragmentSelector = dASHFragmentSelector {
            try encodeContainer.encode(dASHFragmentSelector, forKey: .dASHFragmentSelector)
        }
        if let displayFragmentNumber = displayFragmentNumber {
            try encodeContainer.encode(displayFragmentNumber.rawValue, forKey: .displayFragmentNumber)
        }
        if let displayFragmentTimestamp = displayFragmentTimestamp {
            try encodeContainer.encode(displayFragmentTimestamp.rawValue, forKey: .displayFragmentTimestamp)
        }
        if let expires = expires {
            try encodeContainer.encode(expires, forKey: .expires)
        }
        if let maxManifestFragmentResults = maxManifestFragmentResults {
            try encodeContainer.encode(maxManifestFragmentResults, forKey: .maxManifestFragmentResults)
        }
        if let playbackMode = playbackMode {
            try encodeContainer.encode(playbackMode.rawValue, forKey: .playbackMode)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct GetDASHStreamingSessionURLInputHeadersMiddleware: Middleware {
    public let id: String = "GetDASHStreamingSessionURLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDASHStreamingSessionURLInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDASHStreamingSessionURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDASHStreamingSessionURLInput>
    public typealias MOutput = OperationOutput<GetDASHStreamingSessionURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDASHStreamingSessionURLOutputError>
}

public struct GetDASHStreamingSessionURLInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDASHStreamingSessionURLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDASHStreamingSessionURLInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDASHStreamingSessionURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDASHStreamingSessionURLInput>
    public typealias MOutput = OperationOutput<GetDASHStreamingSessionURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDASHStreamingSessionURLOutputError>
}

public struct GetDASHStreamingSessionURLInput: Equatable {
    /// <p>The time range of the requested fragment and the source of the timestamps.</p>
    ///         <p>This parameter is required if <code>PlaybackMode</code> is <code>ON_DEMAND</code> or
    ///                 <code>LIVE_REPLAY</code>. This parameter is optional if PlaybackMode is<code></code>
    ///             <code>LIVE</code>. If <code>PlaybackMode</code> is <code>LIVE</code>, the
    ///                 <code>FragmentSelectorType</code> can be set, but the <code>TimestampRange</code>
    ///             should not be set. If <code>PlaybackMode</code> is <code>ON_DEMAND</code> or
    ///                 <code>LIVE_REPLAY</code>, both <code>FragmentSelectorType</code> and
    ///                 <code>TimestampRange</code> must be set.</p>
    public let dASHFragmentSelector: DASHFragmentSelector?
    /// <p>Fragments are identified in the manifest file based on their sequence number in the
    ///             session. If DisplayFragmentNumber is set to <code>ALWAYS</code>, the Kinesis Video
    ///             Streams fragment number is added to each S element in the manifest file with the
    ///             attribute name “kvs:fn”. These fragment numbers can be used for logging or for use with
    ///             other APIs (e.g. <code>GetMedia</code> and <code>GetMediaForFragmentList</code>). A
    ///             custom MPEG-DASH media player is necessary to leverage these this custom
    ///             attribute.</p>
    ///         <p>The default value is <code>NEVER</code>.</p>
    public let displayFragmentNumber: DASHDisplayFragmentNumber?
    /// <p>Per the MPEG-DASH specification, the wall-clock time of fragments in the manifest file
    ///             can be derived using attributes in the manifest itself. However, typically, MPEG-DASH
    ///             compatible media players do not properly handle gaps in the media timeline. Kinesis
    ///             Video Streams adjusts the media timeline in the manifest file to enable playback of
    ///             media with discontinuities. Therefore, the wall-clock time derived from the manifest
    ///             file may be inaccurate. If DisplayFragmentTimestamp is set to <code>ALWAYS</code>, the
    ///             accurate fragment timestamp is added to each S element in the manifest file with the
    ///             attribute name “kvs:ts”. A custom MPEG-DASH media player is necessary to leverage this
    ///             custom attribute.</p>
    ///         <p>The default value is <code>NEVER</code>. When <a>DASHFragmentSelector</a>
    ///             is <code>SERVER_TIMESTAMP</code>, the timestamps will be the server start timestamps.
    ///             Similarly, when <a>DASHFragmentSelector</a> is
    ///                 <code>PRODUCER_TIMESTAMP</code>, the timestamps will be the producer start
    ///             timestamps. </p>
    public let displayFragmentTimestamp: DASHDisplayFragmentTimestamp?
    /// <p>The time in seconds until the requested session expires. This value can be between 300
    ///             (5 minutes) and 43200 (12 hours).</p>
    ///         <p>When a session expires, no new calls to <code>GetDashManifest</code>,
    ///                 <code>GetMP4InitFragment</code>, or <code>GetMP4MediaFragment</code> can be made for
    ///             that session.</p>
    ///         <p>The default is 300 (5 minutes).</p>
    public let expires: Int?
    /// <p>The maximum number of fragments that are returned in the MPEG-DASH manifest.</p>
    ///         <p>When the <code>PlaybackMode</code> is <code>LIVE</code>, the most recent fragments are
    ///             returned up to this value. When the <code>PlaybackMode</code> is <code>ON_DEMAND</code>,
    ///             the oldest fragments are returned, up to this maximum number.</p>
    ///         <p>When there are a higher number of fragments available in a live MPEG-DASH manifest,
    ///             video players often buffer content before starting playback. Increasing the buffer size
    ///             increases the playback latency, but it decreases the likelihood that rebuffering will
    ///             occur during playback. We recommend that a live MPEG-DASH manifest have a minimum of 3
    ///             fragments and a maximum of 10 fragments.</p>
    ///         <p>The default is 5 fragments if <code>PlaybackMode</code> is <code>LIVE</code> or
    ///                 <code>LIVE_REPLAY</code>, and 1,000 if <code>PlaybackMode</code> is
    ///                 <code>ON_DEMAND</code>. </p>
    ///         <p>The maximum value of 1,000 fragments corresponds to more than 16 minutes of video on
    ///             streams with 1-second fragments, and more than 2 1/2 hours of video on streams with
    ///             10-second fragments.</p>
    public let maxManifestFragmentResults: Int?
    /// <p>Whether to retrieve live, live replay, or archived, on-demand data.</p>
    ///         <p>Features of the three types of sessions include the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <b>
    ///                         <code>LIVE</code>
    ///                     </b>: For sessions of this type, the MPEG-DASH manifest is continually
    ///                     updated with the latest fragments as they become available. We recommend that
    ///                     the media player retrieve a new manifest on a one-second interval. When this
    ///                     type of session is played in a media player, the user interface typically
    ///                     displays a "live" notification, with no scrubber control for choosing the
    ///                     position in the playback window to display.</p>
    ///                 <note>
    ///                     <p>In <code>LIVE</code> mode, the newest available fragments are included in
    ///                         an MPEG-DASH manifest, even if there is a gap between fragments (that is, if
    ///                         a fragment is missing). A gap like this might cause a media player to halt
    ///                         or cause a jump in playback. In this mode, fragments are not added to the
    ///                         MPEG-DASH manifest if they are older than the newest fragment in the
    ///                         playlist. If the missing fragment becomes available after a subsequent
    ///                         fragment is added to the manifest, the older fragment is not added, and the
    ///                         gap is not filled.</p>
    ///                 </note>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>
    ///                         <code>LIVE_REPLAY</code>
    ///                     </b>: For sessions of this type, the MPEG-DASH manifest is updated
    ///                     similarly to how it is updated for <code>LIVE</code> mode except that it starts
    ///                     by including fragments from a given start time. Instead of fragments being added
    ///                     as they are ingested, fragments are added as the duration of the next fragment
    ///                     elapses. For example, if the fragments in the session are two seconds long, then
    ///                     a new fragment is added to the manifest every two seconds. This mode is useful
    ///                     to be able to start playback from when an event is detected and continue live
    ///                     streaming media that has not yet been ingested as of the time of the session
    ///                     creation. This mode is also useful to stream previously archived media without
    ///                     being limited by the 1,000 fragment limit in the <code>ON_DEMAND</code> mode.
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>
    ///                         <code>ON_DEMAND</code>
    ///                     </b>: For sessions of this type, the MPEG-DASH manifest contains all the
    ///                     fragments for the session, up to the number that is specified in
    ///                         <code>MaxManifestFragmentResults</code>. The manifest must be retrieved only
    ///                     once for each session. When this type of session is played in a media player,
    ///                     the user interface typically displays a scrubber control for choosing the
    ///                     position in the playback window to display.</p>
    ///             </li>
    ///          </ul>
    ///         <p>In all playback modes, if <code>FragmentSelectorType</code> is
    ///                 <code>PRODUCER_TIMESTAMP</code>, and if there are multiple fragments with the same
    ///             start timestamp, the fragment that has the larger fragment number (that is, the newer
    ///             fragment) is included in the MPEG-DASH manifest. The other fragments are not included.
    ///             Fragments that have different timestamps but have overlapping durations are still
    ///             included in the MPEG-DASH manifest. This can lead to unexpected behavior in the media
    ///             player.</p>
    ///         <p>The default is <code>LIVE</code>.</p>
    public let playbackMode: DASHPlaybackMode?
    /// <p>The Amazon Resource Name (ARN) of the stream for which to retrieve the MPEG-DASH
    ///             manifest URL.</p>
    ///         <p>You must specify either the <code>StreamName</code> or the
    ///             <code>StreamARN</code>.</p>
    public let streamARN: String?
    /// <p>The name of the stream for which to retrieve the MPEG-DASH manifest URL.</p>
    ///         <p>You must specify either the <code>StreamName</code> or the
    ///             <code>StreamARN</code>.</p>
    public let streamName: String?

    public init (
        dASHFragmentSelector: DASHFragmentSelector? = nil,
        displayFragmentNumber: DASHDisplayFragmentNumber? = nil,
        displayFragmentTimestamp: DASHDisplayFragmentTimestamp? = nil,
        expires: Int? = nil,
        maxManifestFragmentResults: Int? = nil,
        playbackMode: DASHPlaybackMode? = nil,
        streamARN: String? = nil,
        streamName: String? = nil
    )
    {
        self.dASHFragmentSelector = dASHFragmentSelector
        self.displayFragmentNumber = displayFragmentNumber
        self.displayFragmentTimestamp = displayFragmentTimestamp
        self.expires = expires
        self.maxManifestFragmentResults = maxManifestFragmentResults
        self.playbackMode = playbackMode
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct GetDASHStreamingSessionURLInputBody: Equatable {
    public let streamName: String?
    public let streamARN: String?
    public let playbackMode: DASHPlaybackMode?
    public let displayFragmentTimestamp: DASHDisplayFragmentTimestamp?
    public let displayFragmentNumber: DASHDisplayFragmentNumber?
    public let dASHFragmentSelector: DASHFragmentSelector?
    public let expires: Int?
    public let maxManifestFragmentResults: Int?
}

extension GetDASHStreamingSessionURLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dASHFragmentSelector = "DASHFragmentSelector"
        case displayFragmentNumber = "DisplayFragmentNumber"
        case displayFragmentTimestamp = "DisplayFragmentTimestamp"
        case expires = "Expires"
        case maxManifestFragmentResults = "MaxManifestFragmentResults"
        case playbackMode = "PlaybackMode"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let playbackModeDecoded = try containerValues.decodeIfPresent(DASHPlaybackMode.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let displayFragmentTimestampDecoded = try containerValues.decodeIfPresent(DASHDisplayFragmentTimestamp.self, forKey: .displayFragmentTimestamp)
        displayFragmentTimestamp = displayFragmentTimestampDecoded
        let displayFragmentNumberDecoded = try containerValues.decodeIfPresent(DASHDisplayFragmentNumber.self, forKey: .displayFragmentNumber)
        displayFragmentNumber = displayFragmentNumberDecoded
        let dASHFragmentSelectorDecoded = try containerValues.decodeIfPresent(DASHFragmentSelector.self, forKey: .dASHFragmentSelector)
        dASHFragmentSelector = dASHFragmentSelectorDecoded
        let expiresDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expires)
        expires = expiresDecoded
        let maxManifestFragmentResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxManifestFragmentResults)
        maxManifestFragmentResults = maxManifestFragmentResultsDecoded
    }
}

extension GetDASHStreamingSessionURLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDASHStreamingSessionURLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCodecPrivateDataException" : self = .invalidCodecPrivateDataException(try InvalidCodecPrivateDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingCodecPrivateDataException" : self = .missingCodecPrivateDataException(try MissingCodecPrivateDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoDataRetentionException" : self = .noDataRetentionException(try NoDataRetentionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedStreamMediaTypeException" : self = .unsupportedStreamMediaTypeException(try UnsupportedStreamMediaTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDASHStreamingSessionURLOutputError: Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidCodecPrivateDataException(InvalidCodecPrivateDataException)
    case missingCodecPrivateDataException(MissingCodecPrivateDataException)
    case noDataRetentionException(NoDataRetentionException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedStreamMediaTypeException(UnsupportedStreamMediaTypeException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDASHStreamingSessionURLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDASHStreamingSessionURLOutputResponse(dASHStreamingSessionURL: \(String(describing: dASHStreamingSessionURL)))"}
}

extension GetDASHStreamingSessionURLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDASHStreamingSessionURLOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dASHStreamingSessionURL = output.dASHStreamingSessionURL
        } else {
            self.dASHStreamingSessionURL = nil
        }
    }
}

public struct GetDASHStreamingSessionURLOutputResponse: Equatable {
    /// <p>The URL (containing the session token) that a media player can use to retrieve the
    ///             MPEG-DASH manifest.</p>
    public let dASHStreamingSessionURL: String?

    public init (
        dASHStreamingSessionURL: String? = nil
    )
    {
        self.dASHStreamingSessionURL = dASHStreamingSessionURL
    }
}

struct GetDASHStreamingSessionURLOutputResponseBody: Equatable {
    public let dASHStreamingSessionURL: String?
}

extension GetDASHStreamingSessionURLOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dASHStreamingSessionURL = "DASHStreamingSessionURL"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dASHStreamingSessionURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dASHStreamingSessionURL)
        dASHStreamingSessionURL = dASHStreamingSessionURLDecoded
    }
}

public struct GetHLSStreamingSessionURLInputBodyMiddleware: Middleware {
    public let id: String = "GetHLSStreamingSessionURLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHLSStreamingSessionURLInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHLSStreamingSessionURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHLSStreamingSessionURLInput>
    public typealias MOutput = OperationOutput<GetHLSStreamingSessionURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHLSStreamingSessionURLOutputError>
}

extension GetHLSStreamingSessionURLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetHLSStreamingSessionURLInput(containerFormat: \(String(describing: containerFormat)), discontinuityMode: \(String(describing: discontinuityMode)), displayFragmentTimestamp: \(String(describing: displayFragmentTimestamp)), expires: \(String(describing: expires)), hLSFragmentSelector: \(String(describing: hLSFragmentSelector)), maxMediaPlaylistFragmentResults: \(String(describing: maxMediaPlaylistFragmentResults)), playbackMode: \(String(describing: playbackMode)), streamARN: \(String(describing: streamARN)), streamName: \(String(describing: streamName)))"}
}

extension GetHLSStreamingSessionURLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerFormat = "ContainerFormat"
        case discontinuityMode = "DiscontinuityMode"
        case displayFragmentTimestamp = "DisplayFragmentTimestamp"
        case expires = "Expires"
        case hLSFragmentSelector = "HLSFragmentSelector"
        case maxMediaPlaylistFragmentResults = "MaxMediaPlaylistFragmentResults"
        case playbackMode = "PlaybackMode"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerFormat = containerFormat {
            try encodeContainer.encode(containerFormat.rawValue, forKey: .containerFormat)
        }
        if let discontinuityMode = discontinuityMode {
            try encodeContainer.encode(discontinuityMode.rawValue, forKey: .discontinuityMode)
        }
        if let displayFragmentTimestamp = displayFragmentTimestamp {
            try encodeContainer.encode(displayFragmentTimestamp.rawValue, forKey: .displayFragmentTimestamp)
        }
        if let expires = expires {
            try encodeContainer.encode(expires, forKey: .expires)
        }
        if let hLSFragmentSelector = hLSFragmentSelector {
            try encodeContainer.encode(hLSFragmentSelector, forKey: .hLSFragmentSelector)
        }
        if let maxMediaPlaylistFragmentResults = maxMediaPlaylistFragmentResults {
            try encodeContainer.encode(maxMediaPlaylistFragmentResults, forKey: .maxMediaPlaylistFragmentResults)
        }
        if let playbackMode = playbackMode {
            try encodeContainer.encode(playbackMode.rawValue, forKey: .playbackMode)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct GetHLSStreamingSessionURLInputHeadersMiddleware: Middleware {
    public let id: String = "GetHLSStreamingSessionURLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHLSStreamingSessionURLInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHLSStreamingSessionURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHLSStreamingSessionURLInput>
    public typealias MOutput = OperationOutput<GetHLSStreamingSessionURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHLSStreamingSessionURLOutputError>
}

public struct GetHLSStreamingSessionURLInputQueryItemMiddleware: Middleware {
    public let id: String = "GetHLSStreamingSessionURLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHLSStreamingSessionURLInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHLSStreamingSessionURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHLSStreamingSessionURLInput>
    public typealias MOutput = OperationOutput<GetHLSStreamingSessionURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHLSStreamingSessionURLOutputError>
}

public struct GetHLSStreamingSessionURLInput: Equatable {
    /// <p>Specifies which format should be used for packaging the media. Specifying the
    ///                 <code>FRAGMENTED_MP4</code> container format packages the media into MP4 fragments
    ///             (fMP4 or CMAF). This is the recommended packaging because there is minimal packaging
    ///             overhead. The other container format option is <code>MPEG_TS</code>. HLS has supported
    ///             MPEG TS chunks since it was released and is sometimes the only supported packaging on
    ///             older HLS players. MPEG TS typically has a 5-25 percent packaging overhead. This means
    ///             MPEG TS typically requires 5-25 percent more bandwidth and cost than fMP4.</p>
    ///         <p>The default is <code>FRAGMENTED_MP4</code>.</p>
    public let containerFormat: ContainerFormat?
    /// <p>Specifies when flags marking discontinuities between fragments are added to the media
    ///             playlists.</p>
    ///         <p>Media players typically build a timeline of media content to play, based on the
    ///             timestamps of each fragment. This means that if there is any overlap or gap between
    ///             fragments (as is typical if <a>HLSFragmentSelector</a> is set to
    ///                 <code>SERVER_TIMESTAMP</code>), the media player timeline will also have small gaps
    ///             between fragments in some places, and will overwrite frames in other places. Gaps in the
    ///             media player timeline can cause playback to stall and overlaps can cause playback to be
    ///             jittery. When there are discontinuity flags between fragments, the media player is
    ///             expected to reset the timeline, resulting in the next fragment being played immediately
    ///             after the previous fragment. </p>
    ///         <p>The following modes are supported:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>ALWAYS</code>: a discontinuity marker is placed between every fragment in
    ///                     the HLS media playlist. It is recommended to use a value of <code>ALWAYS</code>
    ///                     if the fragment timestamps are not accurate.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>NEVER</code>: no discontinuity markers are placed anywhere. It is
    ///                     recommended to use a value of <code>NEVER</code> to ensure the media player
    ///                     timeline most accurately maps to the producer timestamps. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ON_DISCONTINUITY</code>: a discontinuity marker is placed between
    ///                     fragments that have a gap or overlap of more than 50 milliseconds. For most
    ///                     playback scenarios, it is recommended to use a value of
    ///                         <code>ON_DISCONTINUITY</code> so that the media player timeline is only
    ///                     reset when there is a significant issue with the media timeline (e.g. a missing
    ///                     fragment).</p>
    ///             </li>
    ///          </ul>
    ///         <p>The default is <code>ALWAYS</code> when <a>HLSFragmentSelector</a> is set
    ///             to <code>SERVER_TIMESTAMP</code>, and <code>NEVER</code> when it is set to
    ///                 <code>PRODUCER_TIMESTAMP</code>.</p>
    public let discontinuityMode: HLSDiscontinuityMode?
    /// <p>Specifies when the fragment start timestamps should be included in the HLS media
    ///             playlist. Typically, media players report the playhead position as a time relative to
    ///             the start of the first fragment in the playback session. However, when the start
    ///             timestamps are included in the HLS media playlist, some media players might report the
    ///             current playhead as an absolute time based on the fragment timestamps. This can be
    ///             useful for creating a playback experience that shows viewers the wall-clock time of the
    ///             media.</p>
    ///         <p>The default is <code>NEVER</code>. When <a>HLSFragmentSelector</a> is
    ///                 <code>SERVER_TIMESTAMP</code>, the timestamps will be the server start timestamps.
    ///             Similarly, when <a>HLSFragmentSelector</a> is
    ///             <code>PRODUCER_TIMESTAMP</code>, the timestamps will be the producer start timestamps.
    ///         </p>
    public let displayFragmentTimestamp: HLSDisplayFragmentTimestamp?
    /// <p>The time in seconds until the requested session expires. This value can be between 300
    ///             (5 minutes) and 43200 (12 hours).</p>
    ///         <p>When a session expires, no new calls to <code>GetHLSMasterPlaylist</code>,
    ///                 <code>GetHLSMediaPlaylist</code>, <code>GetMP4InitFragment</code>,
    ///                 <code>GetMP4MediaFragment</code>, or <code>GetTSFragment</code> can be made for that
    ///             session.</p>
    ///         <p>The default is 300 (5 minutes).</p>
    public let expires: Int?
    /// <p>The time range of the requested fragment and the source of the timestamps.</p>
    ///         <p>This parameter is required if <code>PlaybackMode</code> is <code>ON_DEMAND</code> or
    ///                 <code>LIVE_REPLAY</code>. This parameter is optional if PlaybackMode is<code></code>
    ///             <code>LIVE</code>. If <code>PlaybackMode</code> is <code>LIVE</code>, the
    ///                 <code>FragmentSelectorType</code> can be set, but the <code>TimestampRange</code>
    ///             should not be set. If <code>PlaybackMode</code> is <code>ON_DEMAND</code> or
    ///                 <code>LIVE_REPLAY</code>, both <code>FragmentSelectorType</code> and
    ///                 <code>TimestampRange</code> must be set.</p>
    public let hLSFragmentSelector: HLSFragmentSelector?
    /// <p>The maximum number of fragments that are returned in the HLS media playlists.</p>
    ///         <p>When the <code>PlaybackMode</code> is <code>LIVE</code>, the most recent fragments are
    ///             returned up to this value. When the <code>PlaybackMode</code> is <code>ON_DEMAND</code>,
    ///             the oldest fragments are returned, up to this maximum number.</p>
    ///         <p>When there are a higher number of fragments available in a live HLS media playlist,
    ///             video players often buffer content before starting playback. Increasing the buffer size
    ///             increases the playback latency, but it decreases the likelihood that rebuffering will
    ///             occur during playback. We recommend that a live HLS media playlist have a minimum of 3
    ///             fragments and a maximum of 10 fragments.</p>
    ///         <p>The default is 5 fragments if <code>PlaybackMode</code> is <code>LIVE</code> or
    ///                 <code>LIVE_REPLAY</code>, and 1,000 if <code>PlaybackMode</code> is
    ///                 <code>ON_DEMAND</code>. </p>
    ///         <p>The maximum value of 5,000 fragments corresponds to more than 80 minutes of video on
    ///             streams with 1-second fragments, and more than 13 hours of video on streams with
    ///             10-second fragments.</p>
    public let maxMediaPlaylistFragmentResults: Int?
    /// <p>Whether to retrieve live, live replay, or archived, on-demand data.</p>
    ///         <p>Features of the three types of sessions include the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <b>
    ///                         <code>LIVE</code>
    ///                     </b>: For sessions of this type, the HLS media playlist is continually
    ///                     updated with the latest fragments as they become available. We recommend that
    ///                     the media player retrieve a new playlist on a one-second interval. When this
    ///                     type of session is played in a media player, the user interface typically
    ///                     displays a "live" notification, with no scrubber control for choosing the
    ///                     position in the playback window to display.</p>
    ///                 <note>
    ///                     <p>In <code>LIVE</code> mode, the newest available fragments are included in
    ///                         an HLS media playlist, even if there is a gap between fragments (that is, if
    ///                         a fragment is missing). A gap like this might cause a media player to halt
    ///                         or cause a jump in playback. In this mode, fragments are not added to the
    ///                         HLS media playlist if they are older than the newest fragment in the
    ///                         playlist. If the missing fragment becomes available after a subsequent
    ///                         fragment is added to the playlist, the older fragment is not added, and the
    ///                         gap is not filled.</p>
    ///                 </note>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>
    ///                         <code>LIVE_REPLAY</code>
    ///                     </b>: For sessions of this type, the HLS media playlist is updated
    ///                     similarly to how it is updated for <code>LIVE</code> mode except that it starts
    ///                     by including fragments from a given start time. Instead of fragments being added
    ///                     as they are ingested, fragments are added as the duration of the next fragment
    ///                     elapses. For example, if the fragments in the session are two seconds long, then
    ///                     a new fragment is added to the media playlist every two seconds. This mode is
    ///                     useful to be able to start playback from when an event is detected and continue
    ///                     live streaming media that has not yet been ingested as of the time of the
    ///                     session creation. This mode is also useful to stream previously archived media
    ///                     without being limited by the 1,000 fragment limit in the <code>ON_DEMAND</code>
    ///                     mode. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>
    ///                         <code>ON_DEMAND</code>
    ///                     </b>: For sessions of this type, the HLS media playlist contains all the
    ///                     fragments for the session, up to the number that is specified in
    ///                         <code>MaxMediaPlaylistFragmentResults</code>. The playlist must be retrieved
    ///                     only once for each session. When this type of session is played in a media
    ///                     player, the user interface typically displays a scrubber control for choosing
    ///                     the position in the playback window to display.</p>
    ///             </li>
    ///          </ul>
    ///         <p>In all playback modes, if <code>FragmentSelectorType</code> is
    ///                 <code>PRODUCER_TIMESTAMP</code>, and if there are multiple fragments with the same
    ///             start timestamp, the fragment that has the largest fragment number (that is, the newest
    ///             fragment) is included in the HLS media playlist. The other fragments are not included.
    ///             Fragments that have different timestamps but have overlapping durations are still
    ///             included in the HLS media playlist. This can lead to unexpected behavior in the media
    ///             player.</p>
    ///         <p>The default is <code>LIVE</code>.</p>
    public let playbackMode: HLSPlaybackMode?
    /// <p>The Amazon Resource Name (ARN) of the stream for which to retrieve the HLS master
    ///             playlist URL.</p>
    ///         <p>You must specify either the <code>StreamName</code> or the
    ///             <code>StreamARN</code>.</p>
    public let streamARN: String?
    /// <p>The name of the stream for which to retrieve the HLS master playlist URL.</p>
    ///         <p>You must specify either the <code>StreamName</code> or the
    ///             <code>StreamARN</code>.</p>
    public let streamName: String?

    public init (
        containerFormat: ContainerFormat? = nil,
        discontinuityMode: HLSDiscontinuityMode? = nil,
        displayFragmentTimestamp: HLSDisplayFragmentTimestamp? = nil,
        expires: Int? = nil,
        hLSFragmentSelector: HLSFragmentSelector? = nil,
        maxMediaPlaylistFragmentResults: Int? = nil,
        playbackMode: HLSPlaybackMode? = nil,
        streamARN: String? = nil,
        streamName: String? = nil
    )
    {
        self.containerFormat = containerFormat
        self.discontinuityMode = discontinuityMode
        self.displayFragmentTimestamp = displayFragmentTimestamp
        self.expires = expires
        self.hLSFragmentSelector = hLSFragmentSelector
        self.maxMediaPlaylistFragmentResults = maxMediaPlaylistFragmentResults
        self.playbackMode = playbackMode
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct GetHLSStreamingSessionURLInputBody: Equatable {
    public let streamName: String?
    public let streamARN: String?
    public let playbackMode: HLSPlaybackMode?
    public let hLSFragmentSelector: HLSFragmentSelector?
    public let containerFormat: ContainerFormat?
    public let discontinuityMode: HLSDiscontinuityMode?
    public let displayFragmentTimestamp: HLSDisplayFragmentTimestamp?
    public let expires: Int?
    public let maxMediaPlaylistFragmentResults: Int?
}

extension GetHLSStreamingSessionURLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerFormat = "ContainerFormat"
        case discontinuityMode = "DiscontinuityMode"
        case displayFragmentTimestamp = "DisplayFragmentTimestamp"
        case expires = "Expires"
        case hLSFragmentSelector = "HLSFragmentSelector"
        case maxMediaPlaylistFragmentResults = "MaxMediaPlaylistFragmentResults"
        case playbackMode = "PlaybackMode"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let playbackModeDecoded = try containerValues.decodeIfPresent(HLSPlaybackMode.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let hLSFragmentSelectorDecoded = try containerValues.decodeIfPresent(HLSFragmentSelector.self, forKey: .hLSFragmentSelector)
        hLSFragmentSelector = hLSFragmentSelectorDecoded
        let containerFormatDecoded = try containerValues.decodeIfPresent(ContainerFormat.self, forKey: .containerFormat)
        containerFormat = containerFormatDecoded
        let discontinuityModeDecoded = try containerValues.decodeIfPresent(HLSDiscontinuityMode.self, forKey: .discontinuityMode)
        discontinuityMode = discontinuityModeDecoded
        let displayFragmentTimestampDecoded = try containerValues.decodeIfPresent(HLSDisplayFragmentTimestamp.self, forKey: .displayFragmentTimestamp)
        displayFragmentTimestamp = displayFragmentTimestampDecoded
        let expiresDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expires)
        expires = expiresDecoded
        let maxMediaPlaylistFragmentResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxMediaPlaylistFragmentResults)
        maxMediaPlaylistFragmentResults = maxMediaPlaylistFragmentResultsDecoded
    }
}

extension GetHLSStreamingSessionURLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetHLSStreamingSessionURLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCodecPrivateDataException" : self = .invalidCodecPrivateDataException(try InvalidCodecPrivateDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingCodecPrivateDataException" : self = .missingCodecPrivateDataException(try MissingCodecPrivateDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoDataRetentionException" : self = .noDataRetentionException(try NoDataRetentionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedStreamMediaTypeException" : self = .unsupportedStreamMediaTypeException(try UnsupportedStreamMediaTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetHLSStreamingSessionURLOutputError: Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidCodecPrivateDataException(InvalidCodecPrivateDataException)
    case missingCodecPrivateDataException(MissingCodecPrivateDataException)
    case noDataRetentionException(NoDataRetentionException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedStreamMediaTypeException(UnsupportedStreamMediaTypeException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetHLSStreamingSessionURLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetHLSStreamingSessionURLOutputResponse(hLSStreamingSessionURL: \(String(describing: hLSStreamingSessionURL)))"}
}

extension GetHLSStreamingSessionURLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetHLSStreamingSessionURLOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hLSStreamingSessionURL = output.hLSStreamingSessionURL
        } else {
            self.hLSStreamingSessionURL = nil
        }
    }
}

public struct GetHLSStreamingSessionURLOutputResponse: Equatable {
    /// <p>The URL (containing the session token) that a media player can use to retrieve the HLS
    ///             master playlist.</p>
    public let hLSStreamingSessionURL: String?

    public init (
        hLSStreamingSessionURL: String? = nil
    )
    {
        self.hLSStreamingSessionURL = hLSStreamingSessionURL
    }
}

struct GetHLSStreamingSessionURLOutputResponseBody: Equatable {
    public let hLSStreamingSessionURL: String?
}

extension GetHLSStreamingSessionURLOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hLSStreamingSessionURL = "HLSStreamingSessionURL"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hLSStreamingSessionURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hLSStreamingSessionURL)
        hLSStreamingSessionURL = hLSStreamingSessionURLDecoded
    }
}

public struct GetMediaForFragmentListInputBodyMiddleware: Middleware {
    public let id: String = "GetMediaForFragmentListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMediaForFragmentListInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMediaForFragmentListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMediaForFragmentListInput>
    public typealias MOutput = OperationOutput<GetMediaForFragmentListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMediaForFragmentListOutputError>
}

extension GetMediaForFragmentListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMediaForFragmentListInput(fragments: \(String(describing: fragments)), streamARN: \(String(describing: streamARN)), streamName: \(String(describing: streamName)))"}
}

extension GetMediaForFragmentListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fragments = "Fragments"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fragments = fragments {
            var fragmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fragments)
            for fragmentnumberlist0 in fragments {
                try fragmentsContainer.encode(fragmentnumberlist0)
            }
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct GetMediaForFragmentListInputHeadersMiddleware: Middleware {
    public let id: String = "GetMediaForFragmentListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMediaForFragmentListInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMediaForFragmentListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMediaForFragmentListInput>
    public typealias MOutput = OperationOutput<GetMediaForFragmentListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMediaForFragmentListOutputError>
}

public struct GetMediaForFragmentListInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMediaForFragmentListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMediaForFragmentListInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMediaForFragmentListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMediaForFragmentListInput>
    public typealias MOutput = OperationOutput<GetMediaForFragmentListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMediaForFragmentListOutputError>
}

public struct GetMediaForFragmentListInput: Equatable {
    /// <p>A list of the numbers of fragments for which to retrieve media. You retrieve these
    ///             values with <a>ListFragments</a>.</p>
    public let fragments: [String]?
    /// <p>The Amazon Resource Name (ARN) of the stream from which to retrieve fragment media. Specify either this parameter or the <code>StreamName</code> parameter.</p>
    public let streamARN: String?
    /// <p>The name of the stream from which to retrieve fragment media. Specify either this parameter or the <code>StreamARN</code> parameter.</p>
    public let streamName: String?

    public init (
        fragments: [String]? = nil,
        streamARN: String? = nil,
        streamName: String? = nil
    )
    {
        self.fragments = fragments
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct GetMediaForFragmentListInputBody: Equatable {
    public let streamName: String?
    public let streamARN: String?
    public let fragments: [String]?
}

extension GetMediaForFragmentListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fragments = "Fragments"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let fragmentsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .fragments)
        var fragmentsDecoded0:[String]? = nil
        if let fragmentsContainer = fragmentsContainer {
            fragmentsDecoded0 = [String]()
            for string0 in fragmentsContainer {
                if let string0 = string0 {
                    fragmentsDecoded0?.append(string0)
                }
            }
        }
        fragments = fragmentsDecoded0
    }
}

extension GetMediaForFragmentListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMediaForFragmentListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMediaForFragmentListOutputError: Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMediaForFragmentListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMediaForFragmentListOutputResponse(contentType: \(String(describing: contentType)), payload: \(String(describing: payload)))"}
}

extension GetMediaForFragmentListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.payload = unwrappedData
        } else {
            self.payload = nil
        }
    }
}

public struct GetMediaForFragmentListOutputResponse: Equatable {
    /// <p>The content type of the requested media.</p>
    public let contentType: String?
    /// <p>The payload that Kinesis Video Streams returns is a sequence of chunks from the
    ///             specified stream. For information about the chunks, see <a href="http://docs.aws.amazon.com/kinesisvideostreams/latest/dg/API_dataplane_PutMedia.html">PutMedia</a>. The chunks that Kinesis Video Streams returns in the
    ///                 <code>GetMediaForFragmentList</code> call also include the following additional
    ///             Matroska (MKV) tags: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>AWS_KINESISVIDEO_FRAGMENT_NUMBER - Fragment number returned in the
    ///                     chunk.</p>
    ///             </li>
    ///             <li>
    ///                 <p>AWS_KINESISVIDEO_SERVER_SIDE_TIMESTAMP - Server-side timestamp of the
    ///                     fragment.</p>
    ///             </li>
    ///             <li>
    ///                 <p>AWS_KINESISVIDEO_PRODUCER_SIDE_TIMESTAMP - Producer-side timestamp of the
    ///                     fragment.</p>
    ///             </li>
    ///          </ul>
    ///         <p>The following tags will be included if an exception occurs:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>AWS_KINESISVIDEO_FRAGMENT_NUMBER - The number of the fragment that threw the
    ///                     exception</p>
    ///             </li>
    ///             <li>
    ///                 <p>AWS_KINESISVIDEO_EXCEPTION_ERROR_CODE - The integer code of the
    ///                     exception</p>
    ///             </li>
    ///             <li>
    ///                 <p>AWS_KINESISVIDEO_EXCEPTION_MESSAGE - A text description of the
    ///                     exception</p>
    ///             </li>
    ///          </ul>
    public let payload: Data?

    public init (
        contentType: String? = nil,
        payload: Data? = nil
    )
    {
        self.contentType = contentType
        self.payload = payload
    }
}

struct GetMediaForFragmentListOutputResponseBody: Equatable {
    public let payload: Data?
}

extension GetMediaForFragmentListOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case payload = "Payload"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

public enum HLSDiscontinuityMode {
    case always
    case never
    case onDiscontinuity
    case sdkUnknown(String)
}

extension HLSDiscontinuityMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HLSDiscontinuityMode] {
        return [
            .always,
            .never,
            .onDiscontinuity,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .always: return "ALWAYS"
        case .never: return "NEVER"
        case .onDiscontinuity: return "ON_DISCONTINUITY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HLSDiscontinuityMode(rawValue: rawValue) ?? HLSDiscontinuityMode.sdkUnknown(rawValue)
    }
}

public enum HLSDisplayFragmentTimestamp {
    case always
    case never
    case sdkUnknown(String)
}

extension HLSDisplayFragmentTimestamp : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HLSDisplayFragmentTimestamp] {
        return [
            .always,
            .never,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .always: return "ALWAYS"
        case .never: return "NEVER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HLSDisplayFragmentTimestamp(rawValue: rawValue) ?? HLSDisplayFragmentTimestamp.sdkUnknown(rawValue)
    }
}

extension HLSFragmentSelector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fragmentSelectorType = "FragmentSelectorType"
        case timestampRange = "TimestampRange"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fragmentSelectorType = fragmentSelectorType {
            try encodeContainer.encode(fragmentSelectorType.rawValue, forKey: .fragmentSelectorType)
        }
        if let timestampRange = timestampRange {
            try encodeContainer.encode(timestampRange, forKey: .timestampRange)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fragmentSelectorTypeDecoded = try containerValues.decodeIfPresent(HLSFragmentSelectorType.self, forKey: .fragmentSelectorType)
        fragmentSelectorType = fragmentSelectorTypeDecoded
        let timestampRangeDecoded = try containerValues.decodeIfPresent(HLSTimestampRange.self, forKey: .timestampRange)
        timestampRange = timestampRangeDecoded
    }
}

extension HLSFragmentSelector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HLSFragmentSelector(fragmentSelectorType: \(String(describing: fragmentSelectorType)), timestampRange: \(String(describing: timestampRange)))"}
}

/// <p>Contains the range of timestamps for the requested media, and the source of the
///             timestamps.</p>
public struct HLSFragmentSelector: Equatable {
    /// <p>The source of the timestamps for the requested media.</p>
    ///         <p>When <code>FragmentSelectorType</code> is set to <code>PRODUCER_TIMESTAMP</code> and
    ///                 <a>GetHLSStreamingSessionURLInput$PlaybackMode</a> is
    ///                 <code>ON_DEMAND</code> or <code>LIVE_REPLAY</code>, the first fragment ingested with
    ///             a producer timestamp within the specified <a>FragmentSelector$TimestampRange</a> is included in the media playlist. In
    ///             addition, the fragments with producer timestamps within the <code>TimestampRange</code>
    ///             ingested immediately following the first fragment (up to the <a>GetHLSStreamingSessionURLInput$MaxMediaPlaylistFragmentResults</a> value)
    ///             are included. </p>
    ///         <p>Fragments that have duplicate producer timestamps are deduplicated. This means that if
    ///             producers are producing a stream of fragments with producer timestamps that are
    ///             approximately equal to the true clock time, the HLS media playlists will contain all of
    ///             the fragments within the requested timestamp range. If some fragments are ingested
    ///             within the same time range and very different points in time, only the oldest ingested
    ///             collection of fragments are returned.</p>
    ///         <p>When <code>FragmentSelectorType</code> is set to <code>PRODUCER_TIMESTAMP</code> and
    ///                 <a>GetHLSStreamingSessionURLInput$PlaybackMode</a> is <code>LIVE</code>,
    ///             the producer timestamps are used in the MP4 fragments and for deduplication. But the
    ///             most recently ingested fragments based on server timestamps are included in the HLS
    ///             media playlist. This means that even if fragments ingested in the past have producer
    ///             timestamps with values now, they are not included in the HLS media playlist.</p>
    ///         <p>The default is <code>SERVER_TIMESTAMP</code>.</p>
    public let fragmentSelectorType: HLSFragmentSelectorType?
    /// <p>The start and end of the timestamp range for the requested media.</p>
    ///         <p>This value should not be present if <code>PlaybackType</code> is
    ///             <code>LIVE</code>.</p>
    public let timestampRange: HLSTimestampRange?

    public init (
        fragmentSelectorType: HLSFragmentSelectorType? = nil,
        timestampRange: HLSTimestampRange? = nil
    )
    {
        self.fragmentSelectorType = fragmentSelectorType
        self.timestampRange = timestampRange
    }
}

public enum HLSFragmentSelectorType {
    case producerTimestamp
    case serverTimestamp
    case sdkUnknown(String)
}

extension HLSFragmentSelectorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HLSFragmentSelectorType] {
        return [
            .producerTimestamp,
            .serverTimestamp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .producerTimestamp: return "PRODUCER_TIMESTAMP"
        case .serverTimestamp: return "SERVER_TIMESTAMP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HLSFragmentSelectorType(rawValue: rawValue) ?? HLSFragmentSelectorType.sdkUnknown(rawValue)
    }
}

public enum HLSPlaybackMode {
    case live
    case liveReplay
    case onDemand
    case sdkUnknown(String)
}

extension HLSPlaybackMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HLSPlaybackMode] {
        return [
            .live,
            .liveReplay,
            .onDemand,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .live: return "LIVE"
        case .liveReplay: return "LIVE_REPLAY"
        case .onDemand: return "ON_DEMAND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HLSPlaybackMode(rawValue: rawValue) ?? HLSPlaybackMode.sdkUnknown(rawValue)
    }
}

extension HLSTimestampRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTimestamp = "EndTimestamp"
        case startTimestamp = "StartTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTimestamp = endTimestamp {
            try encodeContainer.encode(endTimestamp.timeIntervalSince1970, forKey: .endTimestamp)
        }
        if let startTimestamp = startTimestamp {
            try encodeContainer.encode(startTimestamp.timeIntervalSince1970, forKey: .startTimestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTimestamp)
        startTimestamp = startTimestampDecoded
        let endTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTimestamp)
        endTimestamp = endTimestampDecoded
    }
}

extension HLSTimestampRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HLSTimestampRange(endTimestamp: \(String(describing: endTimestamp)), startTimestamp: \(String(describing: startTimestamp)))"}
}

/// <p>The start and end of the timestamp range for the requested media.</p>
///         <p>This value should not be present if <code>PlaybackType</code> is
///             <code>LIVE</code>.</p>
public struct HLSTimestampRange: Equatable {
    /// <p>The end of the timestamp range for the requested media. This value must be within 24
    ///             hours of the specified <code>StartTimestamp</code>, and it must be later than the
    ///                 <code>StartTimestamp</code> value.</p>
    ///         <p>If <code>FragmentSelectorType</code> for the request is <code>SERVER_TIMESTAMP</code>,
    ///             this value must be in the past.</p>
    ///         <p>The <code>EndTimestamp</code> value is required for <code>ON_DEMAND</code> mode, but
    ///             optional for <code>LIVE_REPLAY</code> mode. If the <code>EndTimestamp</code> is not set
    ///             for <code>LIVE_REPLAY</code> mode then the session will continue to include newly
    ///             ingested fragments until the session expires.</p>
    ///         <note>
    ///             <p>This value is inclusive. The <code>EndTimestamp</code> is compared to the
    ///                 (starting) timestamp of the fragment. Fragments that start before the
    ///                     <code>EndTimestamp</code> value and continue past it are included in the
    ///                 session.</p>
    ///         </note>
    public let endTimestamp: Date?
    /// <p>The start of the timestamp range for the requested media.</p>
    ///         <p>If the <code>HLSTimestampRange</code> value is specified, the
    ///                 <code>StartTimestamp</code> value is required. </p>
    ///         <p>Only fragments that start exactly at or after <code>StartTimestamp</code> are included
    ///             in the session. Fragments that start before <code>StartTimestamp</code> and continue
    ///             past it aren't included in the session. If <code>FragmentSelectorType</code> is
    ///                 <code>SERVER_TIMESTAMP</code>, the <code>StartTimestamp</code> must be later than
    ///             the stream head. </p>
    public let startTimestamp: Date?

    public init (
        endTimestamp: Date? = nil,
        startTimestamp: Date? = nil
    )
    {
        self.endTimestamp = endTimestamp
        self.startTimestamp = startTimestamp
    }
}

extension InvalidArgumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArgumentException(message: \(String(describing: message)))"}
}

extension InvalidArgumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified parameter exceeds its restrictions, is not supported, or can't be
///             used.</p>
public struct InvalidArgumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArgumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCodecPrivateDataException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCodecPrivateDataException(message: \(String(describing: message)))"}
}

extension InvalidCodecPrivateDataException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidCodecPrivateDataExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The codec private data in at least one of the tracks of the video stream is not valid
///             for this operation.</p>
public struct InvalidCodecPrivateDataException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCodecPrivateDataExceptionBody: Equatable {
    public let message: String?
}

extension InvalidCodecPrivateDataExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMediaFrameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidMediaFrameException(message: \(String(describing: message)))"}
}

extension InvalidMediaFrameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidMediaFrameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more frames in the requested clip could not be parsed based on the specified
///             codec.</p>
public struct InvalidMediaFrameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMediaFrameExceptionBody: Equatable {
    public let message: String?
}

extension InvalidMediaFrameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListFragmentsInputBodyMiddleware: Middleware {
    public let id: String = "ListFragmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFragmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFragmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFragmentsInput>
    public typealias MOutput = OperationOutput<ListFragmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFragmentsOutputError>
}

extension ListFragmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFragmentsInput(fragmentSelector: \(String(describing: fragmentSelector)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), streamARN: \(String(describing: streamARN)), streamName: \(String(describing: streamName)))"}
}

extension ListFragmentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fragmentSelector = "FragmentSelector"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fragmentSelector = fragmentSelector {
            try encodeContainer.encode(fragmentSelector, forKey: .fragmentSelector)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct ListFragmentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFragmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFragmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFragmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFragmentsInput>
    public typealias MOutput = OperationOutput<ListFragmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFragmentsOutputError>
}

public struct ListFragmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFragmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFragmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFragmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFragmentsInput>
    public typealias MOutput = OperationOutput<ListFragmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFragmentsOutputError>
}

public struct ListFragmentsInput: Equatable {
    /// <p>Describes the timestamp range and timestamp origin for the range of fragments to
    ///             return.</p>
    public let fragmentSelector: FragmentSelector?
    /// <p>The total number of fragments to return. If the total number of fragments available is
    ///             more than the value specified in <code>max-results</code>, then a <a>ListFragmentsOutput$NextToken</a> is provided in the output that you can use
    ///             to resume pagination.</p>
    public let maxResults: Int?
    /// <p>A token to specify where to start paginating. This is the <a>ListFragmentsOutput$NextToken</a> from a previously truncated
    ///             response.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the stream from which to retrieve a fragment list. Specify either this parameter or the <code>StreamName</code> parameter.</p>
    public let streamARN: String?
    /// <p>The name of the stream from which to retrieve a fragment list. Specify either this parameter or the <code>StreamARN</code> parameter.</p>
    public let streamName: String?

    public init (
        fragmentSelector: FragmentSelector? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        streamARN: String? = nil,
        streamName: String? = nil
    )
    {
        self.fragmentSelector = fragmentSelector
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct ListFragmentsInputBody: Equatable {
    public let streamName: String?
    public let streamARN: String?
    public let maxResults: Int?
    public let nextToken: String?
    public let fragmentSelector: FragmentSelector?
}

extension ListFragmentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fragmentSelector = "FragmentSelector"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let fragmentSelectorDecoded = try containerValues.decodeIfPresent(FragmentSelector.self, forKey: .fragmentSelector)
        fragmentSelector = fragmentSelectorDecoded
    }
}

extension ListFragmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFragmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFragmentsOutputError: Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFragmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFragmentsOutputResponse(fragments: \(String(describing: fragments)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFragmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFragmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fragments = output.fragments
            self.nextToken = output.nextToken
        } else {
            self.fragments = nil
            self.nextToken = nil
        }
    }
}

public struct ListFragmentsOutputResponse: Equatable {
    /// <p>A list of archived <a>Fragment</a> objects from the stream that meet the
    ///             selector criteria. Results are in no specific order, even across pages.</p>
    public let fragments: [Fragment]?
    /// <p>If the returned list is truncated, the operation returns this token to use to retrieve
    ///             the next page of results. This value is <code>null</code> when there are no more results
    ///             to return.</p>
    public let nextToken: String?

    public init (
        fragments: [Fragment]? = nil,
        nextToken: String? = nil
    )
    {
        self.fragments = fragments
        self.nextToken = nextToken
    }
}

struct ListFragmentsOutputResponseBody: Equatable {
    public let fragments: [Fragment]?
    public let nextToken: String?
}

extension ListFragmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fragments = "Fragments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fragmentsContainer = try containerValues.decodeIfPresent([Fragment?].self, forKey: .fragments)
        var fragmentsDecoded0:[Fragment]? = nil
        if let fragmentsContainer = fragmentsContainer {
            fragmentsDecoded0 = [Fragment]()
            for structure0 in fragmentsContainer {
                if let structure0 = structure0 {
                    fragmentsDecoded0?.append(structure0)
                }
            }
        }
        fragments = fragmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MissingCodecPrivateDataException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MissingCodecPrivateDataException(message: \(String(describing: message)))"}
}

extension MissingCodecPrivateDataException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MissingCodecPrivateDataExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No codec private data was found in at least one of tracks of the video stream.</p>
public struct MissingCodecPrivateDataException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MissingCodecPrivateDataExceptionBody: Equatable {
    public let message: String?
}

extension MissingCodecPrivateDataExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoDataRetentionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoDataRetentionException(message: \(String(describing: message)))"}
}

extension NoDataRetentionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoDataRetentionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A streaming session was requested for a stream that does not retain data (that is, has
///             a <code>DataRetentionInHours</code> of 0). </p>
public struct NoDataRetentionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoDataRetentionExceptionBody: Equatable {
    public let message: String?
}

extension NoDataRetentionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotAuthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotAuthorizedException(message: \(String(describing: message)))"}
}

extension NotAuthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Status Code: 403, The caller is not authorized to perform an operation on the given
///             stream, or the token has expired.</p>
public struct NotAuthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Equatable {
    public let message: String?
}

extension NotAuthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <code>GetMedia</code> throws this error when Kinesis Video Streams can't find the stream
///             that you specified.</p>
///         <p>
///             <code>GetHLSStreamingSessionURL</code> and <code>GetDASHStreamingSessionURL</code> throw
///             this error if a session with a <code>PlaybackMode</code> of <code>ON_DEMAND</code> or
///                 <code>LIVE_REPLAY</code>is requested for a stream that has no fragments within the
///             requested time range, or if a session with a <code>PlaybackMode</code> of
///                 <code>LIVE</code> is requested for a stream that has no fragments within the last 30
///             seconds.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestampRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTimestamp = "EndTimestamp"
        case startTimestamp = "StartTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTimestamp = endTimestamp {
            try encodeContainer.encode(endTimestamp.timeIntervalSince1970, forKey: .endTimestamp)
        }
        if let startTimestamp = startTimestamp {
            try encodeContainer.encode(startTimestamp.timeIntervalSince1970, forKey: .startTimestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTimestamp)
        startTimestamp = startTimestampDecoded
        let endTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTimestamp)
        endTimestamp = endTimestampDecoded
    }
}

extension TimestampRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimestampRange(endTimestamp: \(String(describing: endTimestamp)), startTimestamp: \(String(describing: startTimestamp)))"}
}

/// <p>The range of timestamps for which to return fragments.</p>
public struct TimestampRange: Equatable {
    /// <p>The ending timestamp in the range of timestamps for which to return fragments.</p>
    public let endTimestamp: Date?
    /// <p>The starting timestamp in the range of timestamps for which to return
    ///             fragments.</p>
    public let startTimestamp: Date?

    public init (
        endTimestamp: Date? = nil,
        startTimestamp: Date? = nil
    )
    {
        self.endTimestamp = endTimestamp
        self.startTimestamp = startTimestamp
    }
}

extension UnsupportedStreamMediaTypeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedStreamMediaTypeException(message: \(String(describing: message)))"}
}

extension UnsupportedStreamMediaTypeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedStreamMediaTypeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The type of the media (for example, h.264 or h.265 video or ACC or G.711 audio) could
///             not be determined from the codec IDs of the tracks in the first fragment for a playback
///             session. The codec ID for track 1 should be <code>V_MPEG/ISO/AVC</code> and, optionally,
///             the codec ID for track 2 should be <code>A_AAC</code>.</p>
public struct UnsupportedStreamMediaTypeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedStreamMediaTypeExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedStreamMediaTypeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
