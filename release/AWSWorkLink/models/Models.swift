// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AssociateDomainInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDomainOutputError>
}

extension AssociateDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateDomainInput(acmCertificateArn: \(Swift.String(describing: acmCertificateArn)), displayName: \(Swift.String(describing: displayName)), domainName: \(Swift.String(describing: domainName)), fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension AssociateDomainInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acmCertificateArn = "AcmCertificateArn"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acmCertificateArn = acmCertificateArn {
            try encodeContainer.encode(acmCertificateArn, forKey: .acmCertificateArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct AssociateDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDomainOutputError>
}

public struct AssociateDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDomainOutputError>
}

public struct AssociateDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDomainInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/associateDomain"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDomainOutputError>
}

public struct AssociateDomainInput: Swift.Equatable {
    /// The ARN of an issued ACM certificate that is valid for the domain being associated.
    /// This member is required.
    public var acmCertificateArn: Swift.String?
    /// The name to display.
    public var displayName: Swift.String?
    /// The fully qualified domain name (FQDN).
    /// This member is required.
    public var domainName: Swift.String?
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        acmCertificateArn: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.acmCertificateArn = acmCertificateArn
        self.displayName = displayName
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct AssociateDomainInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let domainName: Swift.String?
    public let displayName: Swift.String?
    public let acmCertificateArn: Swift.String?
}

extension AssociateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acmCertificateArn = "AcmCertificateArn"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let acmCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acmCertificateArn)
        acmCertificateArn = acmCertificateArnDecoded
    }
}

extension AssociateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDomainOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateDomainOutputResponse()"}
}

extension AssociateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDomainOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateDomainOutputResponseBody: Swift.Equatable {
}

extension AssociateDomainOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AssociateWebsiteAuthorizationProviderInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWebsiteAuthorizationProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateWebsiteAuthorizationProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWebsiteAuthorizationProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateWebsiteAuthorizationProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWebsiteAuthorizationProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWebsiteAuthorizationProviderOutputError>
}

extension AssociateWebsiteAuthorizationProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateWebsiteAuthorizationProviderInput(authorizationProviderType: \(Swift.String(describing: authorizationProviderType)), domainName: \(Swift.String(describing: domainName)), fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension AssociateWebsiteAuthorizationProviderInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderType = "AuthorizationProviderType"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationProviderType = authorizationProviderType {
            try encodeContainer.encode(authorizationProviderType.rawValue, forKey: .authorizationProviderType)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct AssociateWebsiteAuthorizationProviderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWebsiteAuthorizationProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateWebsiteAuthorizationProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWebsiteAuthorizationProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateWebsiteAuthorizationProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWebsiteAuthorizationProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWebsiteAuthorizationProviderOutputError>
}

public struct AssociateWebsiteAuthorizationProviderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWebsiteAuthorizationProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateWebsiteAuthorizationProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWebsiteAuthorizationProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateWebsiteAuthorizationProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWebsiteAuthorizationProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWebsiteAuthorizationProviderOutputError>
}

public struct AssociateWebsiteAuthorizationProviderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWebsiteAuthorizationProviderInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateWebsiteAuthorizationProviderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWebsiteAuthorizationProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/associateWebsiteAuthorizationProvider"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateWebsiteAuthorizationProviderInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWebsiteAuthorizationProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWebsiteAuthorizationProviderOutputError>
}

public struct AssociateWebsiteAuthorizationProviderInput: Swift.Equatable {
    /// The authorization provider type.
    /// This member is required.
    public var authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType?
    /// The domain name of the authorization provider. This applies only to SAML-based
    ///             authorization providers.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType? = nil,
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.authorizationProviderType = authorizationProviderType
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct AssociateWebsiteAuthorizationProviderInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType?
    public let domainName: Swift.String?
}

extension AssociateWebsiteAuthorizationProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderType = "AuthorizationProviderType"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let authorizationProviderTypeDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.AuthorizationProviderType.self, forKey: .authorizationProviderType)
        authorizationProviderType = authorizationProviderTypeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension AssociateWebsiteAuthorizationProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWebsiteAuthorizationProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWebsiteAuthorizationProviderOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWebsiteAuthorizationProviderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateWebsiteAuthorizationProviderOutputResponse(authorizationProviderId: \(Swift.String(describing: authorizationProviderId)))"}
}

extension AssociateWebsiteAuthorizationProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateWebsiteAuthorizationProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authorizationProviderId = output.authorizationProviderId
        } else {
            self.authorizationProviderId = nil
        }
    }
}

public struct AssociateWebsiteAuthorizationProviderOutputResponse: Swift.Equatable {
    /// A unique identifier for the authorization provider.
    public var authorizationProviderId: Swift.String?

    public init (
        authorizationProviderId: Swift.String? = nil
    )
    {
        self.authorizationProviderId = authorizationProviderId
    }
}

struct AssociateWebsiteAuthorizationProviderOutputResponseBody: Swift.Equatable {
    public let authorizationProviderId: Swift.String?
}

extension AssociateWebsiteAuthorizationProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationProviderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationProviderId)
        authorizationProviderId = authorizationProviderIdDecoded
    }
}

public struct AssociateWebsiteCertificateAuthorityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWebsiteCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateWebsiteCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWebsiteCertificateAuthorityOutputError>
}

extension AssociateWebsiteCertificateAuthorityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateWebsiteCertificateAuthorityInput(certificate: \(Swift.String(describing: certificate)), displayName: \(Swift.String(describing: displayName)), fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension AssociateWebsiteCertificateAuthorityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct AssociateWebsiteCertificateAuthorityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWebsiteCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateWebsiteCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWebsiteCertificateAuthorityOutputError>
}

public struct AssociateWebsiteCertificateAuthorityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWebsiteCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateWebsiteCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWebsiteCertificateAuthorityOutputError>
}

public struct AssociateWebsiteCertificateAuthorityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWebsiteCertificateAuthorityInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateWebsiteCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/associateWebsiteCertificateAuthority"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateWebsiteCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWebsiteCertificateAuthorityOutputError>
}

public struct AssociateWebsiteCertificateAuthorityInput: Swift.Equatable {
    /// The root certificate of the CA.
    /// This member is required.
    public var certificate: Swift.String?
    /// The certificate name to display.
    public var displayName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        certificate: Swift.String? = nil,
        displayName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.displayName = displayName
        self.fleetArn = fleetArn
    }
}

struct AssociateWebsiteCertificateAuthorityInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let certificate: Swift.String?
    public let displayName: Swift.String?
}

extension AssociateWebsiteCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension AssociateWebsiteCertificateAuthorityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWebsiteCertificateAuthorityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWebsiteCertificateAuthorityOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWebsiteCertificateAuthorityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateWebsiteCertificateAuthorityOutputResponse(websiteCaId: \(Swift.String(describing: websiteCaId)))"}
}

extension AssociateWebsiteCertificateAuthorityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateWebsiteCertificateAuthorityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.websiteCaId = output.websiteCaId
        } else {
            self.websiteCaId = nil
        }
    }
}

public struct AssociateWebsiteCertificateAuthorityOutputResponse: Swift.Equatable {
    /// A unique identifier for the CA.
    public var websiteCaId: Swift.String?

    public init (
        websiteCaId: Swift.String? = nil
    )
    {
        self.websiteCaId = websiteCaId
    }
}

struct AssociateWebsiteCertificateAuthorityOutputResponseBody: Swift.Equatable {
    public let websiteCaId: Swift.String?
}

extension AssociateWebsiteCertificateAuthorityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case websiteCaId = "WebsiteCaId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
    }
}

extension WorkLinkClientTypes {
    public enum AuthorizationProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationProviderType] {
            return [
                .saml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthorizationProviderType(rawValue: rawValue) ?? AuthorizationProviderType.sdkUnknown(rawValue)
        }
    }
}

public struct CreateFleetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFleetOutputError>
}

extension CreateFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFleetInput(displayName: \(Swift.String(describing: displayName)), fleetName: \(Swift.String(describing: fleetName)), optimizeForEndUserLocation: \(Swift.String(describing: optimizeForEndUserLocation)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateFleetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case fleetName = "FleetName"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let optimizeForEndUserLocation = optimizeForEndUserLocation {
            try encodeContainer.encode(optimizeForEndUserLocation, forKey: .optimizeForEndUserLocation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateFleetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFleetOutputError>
}

public struct CreateFleetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFleetOutputError>
}

public struct CreateFleetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFleetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/createFleet"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFleetOutputError>
}

public struct CreateFleetInput: Swift.Equatable {
    /// The fleet name to display.
    public var displayName: Swift.String?
    /// A unique name for the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The option to optimize for better performance by routing traffic through the closest
    ///             AWS Region to users, which may be outside of your home Region.
    public var optimizeForEndUserLocation: Swift.Bool?
    ///  The tags to add to the resource. A tag is a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        displayName: Swift.String? = nil,
        fleetName: Swift.String? = nil,
        optimizeForEndUserLocation: Swift.Bool? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.displayName = displayName
        self.fleetName = fleetName
        self.optimizeForEndUserLocation = optimizeForEndUserLocation
        self.tags = tags
    }
}

struct CreateFleetInputBody: Swift.Equatable {
    public let fleetName: Swift.String?
    public let displayName: Swift.String?
    public let optimizeForEndUserLocation: Swift.Bool?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case fleetName = "FleetName"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let optimizeForEndUserLocationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optimizeForEndUserLocation)
        optimizeForEndUserLocation = optimizeForEndUserLocationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFleetOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFleetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFleetOutputResponse(fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension CreateFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleetArn = output.fleetArn
        } else {
            self.fleetArn = nil
        }
    }
}

public struct CreateFleetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleetArn: Swift.String?

    public init (
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct CreateFleetOutputResponseBody: Swift.Equatable {
    public let fleetArn: Swift.String?
}

extension CreateFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

public struct DeleteFleetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFleetOutputError>
}

extension DeleteFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFleetInput(fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension DeleteFleetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DeleteFleetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFleetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/deleteFleet"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DeleteFleetInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
}

extension DeleteFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DeleteFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFleetOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFleetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFleetOutputResponse()"}
}

extension DeleteFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFleetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFleetOutputResponseBody: Swift.Equatable {
}

extension DeleteFleetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeAuditStreamConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAuditStreamConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAuditStreamConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAuditStreamConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAuditStreamConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAuditStreamConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAuditStreamConfigurationOutputError>
}

extension DescribeAuditStreamConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAuditStreamConfigurationInput(fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension DescribeAuditStreamConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DescribeAuditStreamConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAuditStreamConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAuditStreamConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAuditStreamConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAuditStreamConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAuditStreamConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAuditStreamConfigurationOutputError>
}

public struct DescribeAuditStreamConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAuditStreamConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAuditStreamConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAuditStreamConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAuditStreamConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAuditStreamConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAuditStreamConfigurationOutputError>
}

public struct DescribeAuditStreamConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAuditStreamConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeAuditStreamConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAuditStreamConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/describeAuditStreamConfiguration"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAuditStreamConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAuditStreamConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAuditStreamConfigurationOutputError>
}

public struct DescribeAuditStreamConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeAuditStreamConfigurationInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
}

extension DescribeAuditStreamConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeAuditStreamConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAuditStreamConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAuditStreamConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAuditStreamConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAuditStreamConfigurationOutputResponse(auditStreamArn: \(Swift.String(describing: auditStreamArn)))"}
}

extension DescribeAuditStreamConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAuditStreamConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.auditStreamArn = output.auditStreamArn
        } else {
            self.auditStreamArn = nil
        }
    }
}

public struct DescribeAuditStreamConfigurationOutputResponse: Swift.Equatable {
    /// The ARN of the Amazon Kinesis data stream that will receive the audit events.
    public var auditStreamArn: Swift.String?

    public init (
        auditStreamArn: Swift.String? = nil
    )
    {
        self.auditStreamArn = auditStreamArn
    }
}

struct DescribeAuditStreamConfigurationOutputResponseBody: Swift.Equatable {
    public let auditStreamArn: Swift.String?
}

extension DescribeAuditStreamConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditStreamArn = "AuditStreamArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditStreamArn)
        auditStreamArn = auditStreamArnDecoded
    }
}

public struct DescribeCompanyNetworkConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCompanyNetworkConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCompanyNetworkConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCompanyNetworkConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCompanyNetworkConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCompanyNetworkConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCompanyNetworkConfigurationOutputError>
}

extension DescribeCompanyNetworkConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCompanyNetworkConfigurationInput(fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension DescribeCompanyNetworkConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DescribeCompanyNetworkConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCompanyNetworkConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCompanyNetworkConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCompanyNetworkConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCompanyNetworkConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCompanyNetworkConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCompanyNetworkConfigurationOutputError>
}

public struct DescribeCompanyNetworkConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCompanyNetworkConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCompanyNetworkConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCompanyNetworkConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCompanyNetworkConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCompanyNetworkConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCompanyNetworkConfigurationOutputError>
}

public struct DescribeCompanyNetworkConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCompanyNetworkConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeCompanyNetworkConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCompanyNetworkConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/describeCompanyNetworkConfiguration"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCompanyNetworkConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCompanyNetworkConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCompanyNetworkConfigurationOutputError>
}

public struct DescribeCompanyNetworkConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeCompanyNetworkConfigurationInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
}

extension DescribeCompanyNetworkConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeCompanyNetworkConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCompanyNetworkConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCompanyNetworkConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCompanyNetworkConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCompanyNetworkConfigurationOutputResponse(securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension DescribeCompanyNetworkConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCompanyNetworkConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityGroupIds = output.securityGroupIds
            self.subnetIds = output.subnetIds
            self.vpcId = output.vpcId
        } else {
            self.securityGroupIds = nil
            self.subnetIds = nil
            self.vpcId = nil
        }
    }
}

public struct DescribeCompanyNetworkConfigurationOutputResponse: Swift.Equatable {
    /// The security groups associated with access to the provided subnets.
    public var securityGroupIds: [Swift.String]?
    /// The subnets used for X-ENI connections from Amazon WorkLink rendering containers.
    public var subnetIds: [Swift.String]?
    /// The VPC with connectivity to associated websites.
    public var vpcId: Swift.String?

    public init (
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

struct DescribeCompanyNetworkConfigurationOutputResponseBody: Swift.Equatable {
    public let vpcId: Swift.String?
    public let subnetIds: [Swift.String]?
    public let securityGroupIds: [Swift.String]?
}

extension DescribeCompanyNetworkConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

public struct DescribeDeviceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDeviceOutputError>
}

extension DescribeDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDeviceInput(deviceId: \(Swift.String(describing: deviceId)), fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension DescribeDeviceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DescribeDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDeviceOutputError>
}

public struct DescribeDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDeviceOutputError>
}

public struct DescribeDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDeviceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/describeDevice"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDeviceOutputError>
}

public struct DescribeDeviceInput: Swift.Equatable {
    /// A unique identifier for a registered user's device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.fleetArn = fleetArn
    }
}

struct DescribeDeviceInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let deviceId: Swift.String?
}

extension DescribeDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension DescribeDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDeviceOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDeviceOutputResponse(firstAccessedTime: \(Swift.String(describing: firstAccessedTime)), lastAccessedTime: \(Swift.String(describing: lastAccessedTime)), manufacturer: \(Swift.String(describing: manufacturer)), model: \(Swift.String(describing: model)), operatingSystem: \(Swift.String(describing: operatingSystem)), operatingSystemVersion: \(Swift.String(describing: operatingSystemVersion)), patchLevel: \(Swift.String(describing: patchLevel)), status: \(Swift.String(describing: status)), username: \(Swift.String(describing: username)))"}
}

extension DescribeDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firstAccessedTime = output.firstAccessedTime
            self.lastAccessedTime = output.lastAccessedTime
            self.manufacturer = output.manufacturer
            self.model = output.model
            self.operatingSystem = output.operatingSystem
            self.operatingSystemVersion = output.operatingSystemVersion
            self.patchLevel = output.patchLevel
            self.status = output.status
            self.username = output.username
        } else {
            self.firstAccessedTime = nil
            self.lastAccessedTime = nil
            self.manufacturer = nil
            self.model = nil
            self.operatingSystem = nil
            self.operatingSystemVersion = nil
            self.patchLevel = nil
            self.status = nil
            self.username = nil
        }
    }
}

public struct DescribeDeviceOutputResponse: Swift.Equatable {
    /// The date that the device first signed in to Amazon WorkLink.
    public var firstAccessedTime: ClientRuntime.Date?
    /// The date that the device last accessed Amazon WorkLink.
    public var lastAccessedTime: ClientRuntime.Date?
    /// The manufacturer of the device.
    public var manufacturer: Swift.String?
    /// The model of the device.
    public var model: Swift.String?
    /// The operating system of the device.
    public var operatingSystem: Swift.String?
    /// The operating system version of the device.
    public var operatingSystemVersion: Swift.String?
    /// The operating system patch level of the device.
    public var patchLevel: Swift.String?
    /// The current state of the device.
    public var status: WorkLinkClientTypes.DeviceStatus?
    /// The user name associated with the device.
    public var username: Swift.String?

    public init (
        firstAccessedTime: ClientRuntime.Date? = nil,
        lastAccessedTime: ClientRuntime.Date? = nil,
        manufacturer: Swift.String? = nil,
        model: Swift.String? = nil,
        operatingSystem: Swift.String? = nil,
        operatingSystemVersion: Swift.String? = nil,
        patchLevel: Swift.String? = nil,
        status: WorkLinkClientTypes.DeviceStatus? = nil,
        username: Swift.String? = nil
    )
    {
        self.firstAccessedTime = firstAccessedTime
        self.lastAccessedTime = lastAccessedTime
        self.manufacturer = manufacturer
        self.model = model
        self.operatingSystem = operatingSystem
        self.operatingSystemVersion = operatingSystemVersion
        self.patchLevel = patchLevel
        self.status = status
        self.username = username
    }
}

struct DescribeDeviceOutputResponseBody: Swift.Equatable {
    public let status: WorkLinkClientTypes.DeviceStatus?
    public let model: Swift.String?
    public let manufacturer: Swift.String?
    public let operatingSystem: Swift.String?
    public let operatingSystemVersion: Swift.String?
    public let patchLevel: Swift.String?
    public let firstAccessedTime: ClientRuntime.Date?
    public let lastAccessedTime: ClientRuntime.Date?
    public let username: Swift.String?
}

extension DescribeDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firstAccessedTime = "FirstAccessedTime"
        case lastAccessedTime = "LastAccessedTime"
        case manufacturer = "Manufacturer"
        case model = "Model"
        case operatingSystem = "OperatingSystem"
        case operatingSystemVersion = "OperatingSystemVersion"
        case patchLevel = "PatchLevel"
        case status = "Status"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.DeviceStatus.self, forKey: .status)
        status = statusDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let manufacturerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manufacturer)
        manufacturer = manufacturerDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let operatingSystemVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystemVersion)
        operatingSystemVersion = operatingSystemVersionDecoded
        let patchLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchLevel)
        patchLevel = patchLevelDecoded
        let firstAccessedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .firstAccessedTime)
        firstAccessedTime = firstAccessedTimeDecoded
        let lastAccessedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAccessedTime)
        lastAccessedTime = lastAccessedTimeDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

public struct DescribeDevicePolicyConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDevicePolicyConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDevicePolicyConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDevicePolicyConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDevicePolicyConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDevicePolicyConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDevicePolicyConfigurationOutputError>
}

extension DescribeDevicePolicyConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDevicePolicyConfigurationInput(fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension DescribeDevicePolicyConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DescribeDevicePolicyConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDevicePolicyConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDevicePolicyConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDevicePolicyConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDevicePolicyConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDevicePolicyConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDevicePolicyConfigurationOutputError>
}

public struct DescribeDevicePolicyConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDevicePolicyConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDevicePolicyConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDevicePolicyConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDevicePolicyConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDevicePolicyConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDevicePolicyConfigurationOutputError>
}

public struct DescribeDevicePolicyConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDevicePolicyConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDevicePolicyConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDevicePolicyConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/describeDevicePolicyConfiguration"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDevicePolicyConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDevicePolicyConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDevicePolicyConfigurationOutputError>
}

public struct DescribeDevicePolicyConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeDevicePolicyConfigurationInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
}

extension DescribeDevicePolicyConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeDevicePolicyConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDevicePolicyConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDevicePolicyConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDevicePolicyConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDevicePolicyConfigurationOutputResponse(deviceCaCertificate: \(Swift.String(describing: deviceCaCertificate)))"}
}

extension DescribeDevicePolicyConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDevicePolicyConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceCaCertificate = output.deviceCaCertificate
        } else {
            self.deviceCaCertificate = nil
        }
    }
}

public struct DescribeDevicePolicyConfigurationOutputResponse: Swift.Equatable {
    /// The certificate chain, including intermediate certificates and the root certificate authority certificate used to issue device certificates.
    public var deviceCaCertificate: Swift.String?

    public init (
        deviceCaCertificate: Swift.String? = nil
    )
    {
        self.deviceCaCertificate = deviceCaCertificate
    }
}

struct DescribeDevicePolicyConfigurationOutputResponseBody: Swift.Equatable {
    public let deviceCaCertificate: Swift.String?
}

extension DescribeDevicePolicyConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceCaCertificate = "DeviceCaCertificate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceCaCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCaCertificate)
        deviceCaCertificate = deviceCaCertificateDecoded
    }
}

public struct DescribeDomainInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainOutputError>
}

extension DescribeDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDomainInput(domainName: \(Swift.String(describing: domainName)), fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension DescribeDomainInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DescribeDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainOutputError>
}

public struct DescribeDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainOutputError>
}

public struct DescribeDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/describeDomain"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainOutputError>
}

public struct DescribeDomainInput: Swift.Equatable {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct DescribeDomainInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let domainName: Swift.String?
}

extension DescribeDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DescribeDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDomainOutputResponse(acmCertificateArn: \(Swift.String(describing: acmCertificateArn)), createdTime: \(Swift.String(describing: createdTime)), displayName: \(Swift.String(describing: displayName)), domainName: \(Swift.String(describing: domainName)), domainStatus: \(Swift.String(describing: domainStatus)))"}
}

extension DescribeDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.acmCertificateArn = output.acmCertificateArn
            self.createdTime = output.createdTime
            self.displayName = output.displayName
            self.domainName = output.domainName
            self.domainStatus = output.domainStatus
        } else {
            self.acmCertificateArn = nil
            self.createdTime = nil
            self.displayName = nil
            self.domainName = nil
            self.domainStatus = nil
        }
    }
}

public struct DescribeDomainOutputResponse: Swift.Equatable {
    /// The ARN of an issued ACM certificate that is valid for the domain being associated.
    public var acmCertificateArn: Swift.String?
    /// The time that the domain was added.
    public var createdTime: ClientRuntime.Date?
    /// The name to display.
    public var displayName: Swift.String?
    /// The name of the domain.
    public var domainName: Swift.String?
    /// The current state for the domain.
    public var domainStatus: WorkLinkClientTypes.DomainStatus?

    public init (
        acmCertificateArn: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainStatus: WorkLinkClientTypes.DomainStatus? = nil
    )
    {
        self.acmCertificateArn = acmCertificateArn
        self.createdTime = createdTime
        self.displayName = displayName
        self.domainName = domainName
        self.domainStatus = domainStatus
    }
}

struct DescribeDomainOutputResponseBody: Swift.Equatable {
    public let domainName: Swift.String?
    public let displayName: Swift.String?
    public let createdTime: ClientRuntime.Date?
    public let domainStatus: WorkLinkClientTypes.DomainStatus?
    public let acmCertificateArn: Swift.String?
}

extension DescribeDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acmCertificateArn = "AcmCertificateArn"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case domainStatus = "DomainStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let acmCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acmCertificateArn)
        acmCertificateArn = acmCertificateArnDecoded
    }
}

public struct DescribeFleetMetadataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFleetMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFleetMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFleetMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFleetMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFleetMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFleetMetadataOutputError>
}

extension DescribeFleetMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFleetMetadataInput(fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension DescribeFleetMetadataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DescribeFleetMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFleetMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFleetMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFleetMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFleetMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFleetMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFleetMetadataOutputError>
}

public struct DescribeFleetMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFleetMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFleetMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFleetMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFleetMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFleetMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFleetMetadataOutputError>
}

public struct DescribeFleetMetadataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFleetMetadataInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeFleetMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFleetMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/describeFleetMetadata"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFleetMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFleetMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFleetMetadataOutputError>
}

public struct DescribeFleetMetadataInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeFleetMetadataInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
}

extension DescribeFleetMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeFleetMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFleetMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFleetMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFleetMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFleetMetadataOutputResponse(companyCode: \(Swift.String(describing: companyCode)), createdTime: \(Swift.String(describing: createdTime)), displayName: \(Swift.String(describing: displayName)), fleetName: \(Swift.String(describing: fleetName)), fleetStatus: \(Swift.String(describing: fleetStatus)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), optimizeForEndUserLocation: \(Swift.String(describing: optimizeForEndUserLocation)), tags: \(Swift.String(describing: tags)))"}
}

extension DescribeFleetMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFleetMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.companyCode = output.companyCode
            self.createdTime = output.createdTime
            self.displayName = output.displayName
            self.fleetName = output.fleetName
            self.fleetStatus = output.fleetStatus
            self.lastUpdatedTime = output.lastUpdatedTime
            self.optimizeForEndUserLocation = output.optimizeForEndUserLocation
            self.tags = output.tags
        } else {
            self.companyCode = nil
            self.createdTime = nil
            self.displayName = nil
            self.fleetName = nil
            self.fleetStatus = nil
            self.lastUpdatedTime = nil
            self.optimizeForEndUserLocation = nil
            self.tags = nil
        }
    }
}

public struct DescribeFleetMetadataOutputResponse: Swift.Equatable {
    /// The identifier used by users to sign in to the Amazon WorkLink app.
    public var companyCode: Swift.String?
    /// The time that the fleet was created.
    public var createdTime: ClientRuntime.Date?
    /// The name to display.
    public var displayName: Swift.String?
    /// The name of the fleet.
    public var fleetName: Swift.String?
    /// The current state of the fleet.
    public var fleetStatus: WorkLinkClientTypes.FleetStatus?
    /// The time that the fleet was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The option to optimize for better performance by routing traffic through the closest
    ///             AWS Region to users, which may be outside of your home Region.
    public var optimizeForEndUserLocation: Swift.Bool?
    /// The tags attached to the resource. A tag is a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        companyCode: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        fleetName: Swift.String? = nil,
        fleetStatus: WorkLinkClientTypes.FleetStatus? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        optimizeForEndUserLocation: Swift.Bool? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.companyCode = companyCode
        self.createdTime = createdTime
        self.displayName = displayName
        self.fleetName = fleetName
        self.fleetStatus = fleetStatus
        self.lastUpdatedTime = lastUpdatedTime
        self.optimizeForEndUserLocation = optimizeForEndUserLocation
        self.tags = tags
    }
}

struct DescribeFleetMetadataOutputResponseBody: Swift.Equatable {
    public let createdTime: ClientRuntime.Date?
    public let lastUpdatedTime: ClientRuntime.Date?
    public let fleetName: Swift.String?
    public let displayName: Swift.String?
    public let optimizeForEndUserLocation: Swift.Bool?
    public let companyCode: Swift.String?
    public let fleetStatus: WorkLinkClientTypes.FleetStatus?
    public let tags: [Swift.String:Swift.String]?
}

extension DescribeFleetMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case companyCode = "CompanyCode"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case fleetName = "FleetName"
        case fleetStatus = "FleetStatus"
        case lastUpdatedTime = "LastUpdatedTime"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let optimizeForEndUserLocationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optimizeForEndUserLocation)
        optimizeForEndUserLocation = optimizeForEndUserLocationDecoded
        let companyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .companyCode)
        companyCode = companyCodeDecoded
        let fleetStatusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.FleetStatus.self, forKey: .fleetStatus)
        fleetStatus = fleetStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeIdentityProviderConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityProviderConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIdentityProviderConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityProviderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIdentityProviderConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityProviderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityProviderConfigurationOutputError>
}

extension DescribeIdentityProviderConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeIdentityProviderConfigurationInput(fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension DescribeIdentityProviderConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DescribeIdentityProviderConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityProviderConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIdentityProviderConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityProviderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIdentityProviderConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityProviderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityProviderConfigurationOutputError>
}

public struct DescribeIdentityProviderConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityProviderConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIdentityProviderConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityProviderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIdentityProviderConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityProviderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityProviderConfigurationOutputError>
}

public struct DescribeIdentityProviderConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityProviderConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeIdentityProviderConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityProviderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/describeIdentityProviderConfiguration"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeIdentityProviderConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityProviderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityProviderConfigurationOutputError>
}

public struct DescribeIdentityProviderConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeIdentityProviderConfigurationInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
}

extension DescribeIdentityProviderConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeIdentityProviderConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIdentityProviderConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIdentityProviderConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIdentityProviderConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeIdentityProviderConfigurationOutputResponse(identityProviderSamlMetadata: \(Swift.String(describing: identityProviderSamlMetadata)), identityProviderType: \(Swift.String(describing: identityProviderType)), serviceProviderSamlMetadata: \(Swift.String(describing: serviceProviderSamlMetadata)))"}
}

extension DescribeIdentityProviderConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeIdentityProviderConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProviderSamlMetadata = output.identityProviderSamlMetadata
            self.identityProviderType = output.identityProviderType
            self.serviceProviderSamlMetadata = output.serviceProviderSamlMetadata
        } else {
            self.identityProviderSamlMetadata = nil
            self.identityProviderType = nil
            self.serviceProviderSamlMetadata = nil
        }
    }
}

public struct DescribeIdentityProviderConfigurationOutputResponse: Swift.Equatable {
    /// The SAML metadata document provided by the users identity provider.
    public var identityProviderSamlMetadata: Swift.String?
    /// The type of identity provider.
    public var identityProviderType: WorkLinkClientTypes.IdentityProviderType?
    /// The SAML metadata document uploaded to the users identity provider.
    public var serviceProviderSamlMetadata: Swift.String?

    public init (
        identityProviderSamlMetadata: Swift.String? = nil,
        identityProviderType: WorkLinkClientTypes.IdentityProviderType? = nil,
        serviceProviderSamlMetadata: Swift.String? = nil
    )
    {
        self.identityProviderSamlMetadata = identityProviderSamlMetadata
        self.identityProviderType = identityProviderType
        self.serviceProviderSamlMetadata = serviceProviderSamlMetadata
    }
}

struct DescribeIdentityProviderConfigurationOutputResponseBody: Swift.Equatable {
    public let identityProviderType: WorkLinkClientTypes.IdentityProviderType?
    public let serviceProviderSamlMetadata: Swift.String?
    public let identityProviderSamlMetadata: Swift.String?
}

extension DescribeIdentityProviderConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderSamlMetadata = "IdentityProviderSamlMetadata"
        case identityProviderType = "IdentityProviderType"
        case serviceProviderSamlMetadata = "ServiceProviderSamlMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let serviceProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceProviderSamlMetadata)
        serviceProviderSamlMetadata = serviceProviderSamlMetadataDecoded
        let identityProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderSamlMetadata)
        identityProviderSamlMetadata = identityProviderSamlMetadataDecoded
    }
}

public struct DescribeWebsiteCertificateAuthorityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWebsiteCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWebsiteCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWebsiteCertificateAuthorityOutputError>
}

extension DescribeWebsiteCertificateAuthorityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeWebsiteCertificateAuthorityInput(fleetArn: \(Swift.String(describing: fleetArn)), websiteCaId: \(Swift.String(describing: websiteCaId)))"}
}

extension DescribeWebsiteCertificateAuthorityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let websiteCaId = websiteCaId {
            try encodeContainer.encode(websiteCaId, forKey: .websiteCaId)
        }
    }
}

public struct DescribeWebsiteCertificateAuthorityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWebsiteCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWebsiteCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWebsiteCertificateAuthorityOutputError>
}

public struct DescribeWebsiteCertificateAuthorityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWebsiteCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWebsiteCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWebsiteCertificateAuthorityOutputError>
}

public struct DescribeWebsiteCertificateAuthorityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWebsiteCertificateAuthorityInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeWebsiteCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/describeWebsiteCertificateAuthority"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeWebsiteCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWebsiteCertificateAuthorityOutputError>
}

public struct DescribeWebsiteCertificateAuthorityInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// A unique identifier for the certificate authority.
    /// This member is required.
    public var websiteCaId: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        websiteCaId: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.websiteCaId = websiteCaId
    }
}

struct DescribeWebsiteCertificateAuthorityInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let websiteCaId: Swift.String?
}

extension DescribeWebsiteCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
    }
}

extension DescribeWebsiteCertificateAuthorityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWebsiteCertificateAuthorityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWebsiteCertificateAuthorityOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWebsiteCertificateAuthorityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeWebsiteCertificateAuthorityOutputResponse(certificate: \(Swift.String(describing: certificate)), createdTime: \(Swift.String(describing: createdTime)), displayName: \(Swift.String(describing: displayName)))"}
}

extension DescribeWebsiteCertificateAuthorityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWebsiteCertificateAuthorityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
            self.createdTime = output.createdTime
            self.displayName = output.displayName
        } else {
            self.certificate = nil
            self.createdTime = nil
            self.displayName = nil
        }
    }
}

public struct DescribeWebsiteCertificateAuthorityOutputResponse: Swift.Equatable {
    /// The root certificate of the certificate authority.
    public var certificate: Swift.String?
    /// The time that the certificate authority was added.
    public var createdTime: ClientRuntime.Date?
    /// The certificate name to display.
    public var displayName: Swift.String?

    public init (
        certificate: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.createdTime = createdTime
        self.displayName = displayName
    }
}

struct DescribeWebsiteCertificateAuthorityOutputResponseBody: Swift.Equatable {
    public let certificate: Swift.String?
    public let createdTime: ClientRuntime.Date?
    public let displayName: Swift.String?
}

extension DescribeWebsiteCertificateAuthorityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension WorkLinkClientTypes {
    public enum DeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case signedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .active,
                .signedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .signedOut: return "SIGNED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceStatus(rawValue: rawValue) ?? DeviceStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkLinkClientTypes.DeviceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case deviceStatus = "DeviceStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let deviceStatus = deviceStatus {
            try encodeContainer.encode(deviceStatus.rawValue, forKey: .deviceStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
    }
}

extension WorkLinkClientTypes.DeviceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceSummary(deviceId: \(Swift.String(describing: deviceId)), deviceStatus: \(Swift.String(describing: deviceStatus)))"}
}

extension WorkLinkClientTypes {
    /// The summary of devices.
    public struct DeviceSummary: Swift.Equatable {
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The status of the device.
        public var deviceStatus: WorkLinkClientTypes.DeviceStatus?

        public init (
            deviceId: Swift.String? = nil,
            deviceStatus: WorkLinkClientTypes.DeviceStatus? = nil
        )
        {
            self.deviceId = deviceId
            self.deviceStatus = deviceStatus
        }
    }

}

public struct DisassociateDomainInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDomainOutputError>
}

extension DisassociateDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateDomainInput(domainName: \(Swift.String(describing: domainName)), fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension DisassociateDomainInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DisassociateDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDomainOutputError>
}

public struct DisassociateDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDomainOutputError>
}

public struct DisassociateDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDomainInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/disassociateDomain"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDomainOutputError>
}

public struct DisassociateDomainInput: Swift.Equatable {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct DisassociateDomainInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let domainName: Swift.String?
}

extension DisassociateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DisassociateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateDomainOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateDomainOutputResponse()"}
}

extension DisassociateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDomainOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateDomainOutputResponseBody: Swift.Equatable {
}

extension DisassociateDomainOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DisassociateWebsiteAuthorizationProviderInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWebsiteAuthorizationProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateWebsiteAuthorizationProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWebsiteAuthorizationProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateWebsiteAuthorizationProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWebsiteAuthorizationProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWebsiteAuthorizationProviderOutputError>
}

extension DisassociateWebsiteAuthorizationProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateWebsiteAuthorizationProviderInput(authorizationProviderId: \(Swift.String(describing: authorizationProviderId)), fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension DisassociateWebsiteAuthorizationProviderInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationProviderId = authorizationProviderId {
            try encodeContainer.encode(authorizationProviderId, forKey: .authorizationProviderId)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DisassociateWebsiteAuthorizationProviderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWebsiteAuthorizationProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateWebsiteAuthorizationProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWebsiteAuthorizationProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateWebsiteAuthorizationProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWebsiteAuthorizationProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWebsiteAuthorizationProviderOutputError>
}

public struct DisassociateWebsiteAuthorizationProviderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWebsiteAuthorizationProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateWebsiteAuthorizationProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWebsiteAuthorizationProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateWebsiteAuthorizationProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWebsiteAuthorizationProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWebsiteAuthorizationProviderOutputError>
}

public struct DisassociateWebsiteAuthorizationProviderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWebsiteAuthorizationProviderInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateWebsiteAuthorizationProviderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWebsiteAuthorizationProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/disassociateWebsiteAuthorizationProvider"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateWebsiteAuthorizationProviderInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWebsiteAuthorizationProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWebsiteAuthorizationProviderOutputError>
}

public struct DisassociateWebsiteAuthorizationProviderInput: Swift.Equatable {
    /// A unique identifier for the authorization provider.
    /// This member is required.
    public var authorizationProviderId: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        authorizationProviderId: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.authorizationProviderId = authorizationProviderId
        self.fleetArn = fleetArn
    }
}

struct DisassociateWebsiteAuthorizationProviderInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let authorizationProviderId: Swift.String?
}

extension DisassociateWebsiteAuthorizationProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let authorizationProviderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationProviderId)
        authorizationProviderId = authorizationProviderIdDecoded
    }
}

extension DisassociateWebsiteAuthorizationProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWebsiteAuthorizationProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWebsiteAuthorizationProviderOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWebsiteAuthorizationProviderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateWebsiteAuthorizationProviderOutputResponse()"}
}

extension DisassociateWebsiteAuthorizationProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWebsiteAuthorizationProviderOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateWebsiteAuthorizationProviderOutputResponseBody: Swift.Equatable {
}

extension DisassociateWebsiteAuthorizationProviderOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DisassociateWebsiteCertificateAuthorityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWebsiteCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateWebsiteCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWebsiteCertificateAuthorityOutputError>
}

extension DisassociateWebsiteCertificateAuthorityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateWebsiteCertificateAuthorityInput(fleetArn: \(Swift.String(describing: fleetArn)), websiteCaId: \(Swift.String(describing: websiteCaId)))"}
}

extension DisassociateWebsiteCertificateAuthorityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let websiteCaId = websiteCaId {
            try encodeContainer.encode(websiteCaId, forKey: .websiteCaId)
        }
    }
}

public struct DisassociateWebsiteCertificateAuthorityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWebsiteCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateWebsiteCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWebsiteCertificateAuthorityOutputError>
}

public struct DisassociateWebsiteCertificateAuthorityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWebsiteCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateWebsiteCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWebsiteCertificateAuthorityOutputError>
}

public struct DisassociateWebsiteCertificateAuthorityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWebsiteCertificateAuthorityInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateWebsiteCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/disassociateWebsiteCertificateAuthority"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateWebsiteCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWebsiteCertificateAuthorityOutputError>
}

public struct DisassociateWebsiteCertificateAuthorityInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// A unique identifier for the CA.
    /// This member is required.
    public var websiteCaId: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        websiteCaId: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.websiteCaId = websiteCaId
    }
}

struct DisassociateWebsiteCertificateAuthorityInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let websiteCaId: Swift.String?
}

extension DisassociateWebsiteCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
    }
}

extension DisassociateWebsiteCertificateAuthorityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWebsiteCertificateAuthorityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWebsiteCertificateAuthorityOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWebsiteCertificateAuthorityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateWebsiteCertificateAuthorityOutputResponse()"}
}

extension DisassociateWebsiteCertificateAuthorityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWebsiteCertificateAuthorityOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateWebsiteCertificateAuthorityOutputResponseBody: Swift.Equatable {
}

extension DisassociateWebsiteCertificateAuthorityOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension WorkLinkClientTypes {
    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case associating
        case disassociated
        case disassociating
        case failedToAssociate
        case failedToDisassociate
        case inactive
        case pendingValidation
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .active,
                .associating,
                .disassociated,
                .disassociating,
                .failedToAssociate,
                .failedToDisassociate,
                .inactive,
                .pendingValidation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .associating: return "ASSOCIATING"
            case .disassociated: return "DISASSOCIATED"
            case .disassociating: return "DISASSOCIATING"
            case .failedToAssociate: return "FAILED_TO_ASSOCIATE"
            case .failedToDisassociate: return "FAILED_TO_DISASSOCIATE"
            case .inactive: return "INACTIVE"
            case .pendingValidation: return "PENDING_VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkLinkClientTypes.DomainSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case domainStatus = "DomainStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainStatus = domainStatus {
            try encodeContainer.encode(domainStatus.rawValue, forKey: .domainStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
    }
}

extension WorkLinkClientTypes.DomainSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainSummary(createdTime: \(Swift.String(describing: createdTime)), displayName: \(Swift.String(describing: displayName)), domainName: \(Swift.String(describing: domainName)), domainStatus: \(Swift.String(describing: domainStatus)))"}
}

extension WorkLinkClientTypes {
    /// The summary of the domain.
    public struct DomainSummary: Swift.Equatable {
        /// The time that the domain was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The name to display.
        public var displayName: Swift.String?
        /// The name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// The status of the domain.
        /// This member is required.
        public var domainStatus: WorkLinkClientTypes.DomainStatus?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainStatus: WorkLinkClientTypes.DomainStatus? = nil
        )
        {
            self.createdTime = createdTime
            self.displayName = displayName
            self.domainName = domainName
            self.domainStatus = domainStatus
        }
    }

}

extension WorkLinkClientTypes {
    public enum FleetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case failedToCreate
        case failedToDelete
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .failedToCreate,
                .failedToDelete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failedToCreate: return "FAILED_TO_CREATE"
            case .failedToDelete: return "FAILED_TO_DELETE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetStatus(rawValue: rawValue) ?? FleetStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkLinkClientTypes.FleetSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case companyCode = "CompanyCode"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
        case fleetName = "FleetName"
        case fleetStatus = "FleetStatus"
        case lastUpdatedTime = "LastUpdatedTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let companyCode = companyCode {
            try encodeContainer.encode(companyCode, forKey: .companyCode)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let fleetStatus = fleetStatus {
            try encodeContainer.encode(fleetStatus.rawValue, forKey: .fleetStatus)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let companyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .companyCode)
        companyCode = companyCodeDecoded
        let fleetStatusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.FleetStatus.self, forKey: .fleetStatus)
        fleetStatus = fleetStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WorkLinkClientTypes.FleetSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FleetSummary(companyCode: \(Swift.String(describing: companyCode)), createdTime: \(Swift.String(describing: createdTime)), displayName: \(Swift.String(describing: displayName)), fleetArn: \(Swift.String(describing: fleetArn)), fleetName: \(Swift.String(describing: fleetName)), fleetStatus: \(Swift.String(describing: fleetStatus)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), tags: \(Swift.String(describing: tags)))"}
}

extension WorkLinkClientTypes {
    /// The summary of the fleet.
    public struct FleetSummary: Swift.Equatable {
        /// The identifier used by users to sign into the Amazon WorkLink app.
        public var companyCode: Swift.String?
        /// The time when the fleet was created.
        public var createdTime: ClientRuntime.Date?
        /// The name of the fleet to display.
        public var displayName: Swift.String?
        /// The Amazon Resource Name (ARN) of the fleet.
        public var fleetArn: Swift.String?
        /// The name of the fleet.
        public var fleetName: Swift.String?
        /// The status of the fleet.
        public var fleetStatus: WorkLinkClientTypes.FleetStatus?
        /// The time when the fleet was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The tags attached to the resource. A tag is a key-value pair.
        public var tags: [Swift.String:Swift.String]?

        public init (
            companyCode: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            fleetArn: Swift.String? = nil,
            fleetName: Swift.String? = nil,
            fleetStatus: WorkLinkClientTypes.FleetStatus? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.companyCode = companyCode
            self.createdTime = createdTime
            self.displayName = displayName
            self.fleetArn = fleetArn
            self.fleetName = fleetName
            self.fleetStatus = fleetStatus
            self.lastUpdatedTime = lastUpdatedTime
            self.tags = tags
        }
    }

}

extension WorkLinkClientTypes {
    public enum IdentityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityProviderType] {
            return [
                .saml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityProviderType(rawValue: rawValue) ?? IdentityProviderType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerErrorException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is temporarily unavailable.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request is not valid.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListDevicesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicesOutputError>
}

extension ListDevicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevicesInput(fleetArn: \(Swift.String(describing: fleetArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDevicesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDevicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicesOutputError>
}

public struct ListDevicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicesOutputError>
}

public struct ListDevicesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDevicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/listDevices"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDevicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicesOutputError>
}

public struct ListDevicesInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If
    ///             this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDevicesInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListDevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDevicesOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevicesOutputResponse(devices: \(Swift.String(describing: devices)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevicesOutputResponse: Swift.Equatable {
    /// Information about the devices.
    public var devices: [WorkLinkClientTypes.DeviceSummary]?
    /// The pagination token used to retrieve the next page of results for this operation. If
    ///             there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        devices: [WorkLinkClientTypes.DeviceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct ListDevicesOutputResponseBody: Swift.Equatable {
    public let devices: [WorkLinkClientTypes.DeviceSummary]?
    public let nextToken: Swift.String?
}

extension ListDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([WorkLinkClientTypes.DeviceSummary?].self, forKey: .devices)
        var devicesDecoded0:[WorkLinkClientTypes.DeviceSummary]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [WorkLinkClientTypes.DeviceSummary]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDomainsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainsOutputError>
}

extension ListDomainsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDomainsInput(fleetArn: \(Swift.String(describing: fleetArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDomainsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDomainsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainsOutputError>
}

public struct ListDomainsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainsOutputError>
}

public struct ListDomainsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDomainsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/listDomains"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDomainsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainsOutputError>
}

public struct ListDomainsInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If
    ///             this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainsOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDomainsOutputResponse(domains: \(Swift.String(describing: domains)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domains = output.domains
            self.nextToken = output.nextToken
        } else {
            self.domains = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutputResponse: Swift.Equatable {
    /// Information about the domains.
    public var domains: [WorkLinkClientTypes.DomainSummary]?
    /// The pagination token used to retrieve the next page of results for this operation. If
    ///             there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        domains: [WorkLinkClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputResponseBody: Swift.Equatable {
    public let domains: [WorkLinkClientTypes.DomainSummary]?
    public let nextToken: Swift.String?
}

extension ListDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains = "Domains"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([WorkLinkClientTypes.DomainSummary?].self, forKey: .domains)
        var domainsDecoded0:[WorkLinkClientTypes.DomainSummary]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [WorkLinkClientTypes.DomainSummary]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFleetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFleetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFleetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFleetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFleetsOutputError>
}

extension ListFleetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFleetsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFleetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFleetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFleetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFleetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFleetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFleetsOutputError>
}

public struct ListFleetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFleetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFleetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFleetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFleetsOutputError>
}

public struct ListFleetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFleetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListFleetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/listFleets"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFleetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFleetsOutputError>
}

public struct ListFleetsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If
    ///             this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFleetsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListFleetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFleetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFleetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFleetsOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFleetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFleetsOutputResponse(fleetSummaryList: \(Swift.String(describing: fleetSummaryList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFleetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFleetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleetSummaryList = output.fleetSummaryList
            self.nextToken = output.nextToken
        } else {
            self.fleetSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFleetsOutputResponse: Swift.Equatable {
    /// The summary list of the fleets.
    public var fleetSummaryList: [WorkLinkClientTypes.FleetSummary]?
    /// The pagination token used to retrieve the next page of results for this operation. If
    ///             there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        fleetSummaryList: [WorkLinkClientTypes.FleetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetSummaryList = fleetSummaryList
        self.nextToken = nextToken
    }
}

struct ListFleetsOutputResponseBody: Swift.Equatable {
    public let fleetSummaryList: [WorkLinkClientTypes.FleetSummary]?
    public let nextToken: Swift.String?
}

extension ListFleetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetSummaryList = "FleetSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetSummaryListContainer = try containerValues.decodeIfPresent([WorkLinkClientTypes.FleetSummary?].self, forKey: .fleetSummaryList)
        var fleetSummaryListDecoded0:[WorkLinkClientTypes.FleetSummary]? = nil
        if let fleetSummaryListContainer = fleetSummaryListContainer {
            fleetSummaryListDecoded0 = [WorkLinkClientTypes.FleetSummary]()
            for structure0 in fleetSummaryListContainer {
                if let structure0 = structure0 {
                    fleetSummaryListDecoded0?.append(structure0)
                }
            }
        }
        fleetSummaryList = fleetSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags attached to the resource. A tag is a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListWebsiteAuthorizationProvidersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWebsiteAuthorizationProvidersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWebsiteAuthorizationProvidersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWebsiteAuthorizationProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWebsiteAuthorizationProvidersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWebsiteAuthorizationProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWebsiteAuthorizationProvidersOutputError>
}

extension ListWebsiteAuthorizationProvidersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWebsiteAuthorizationProvidersInput(fleetArn: \(Swift.String(describing: fleetArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListWebsiteAuthorizationProvidersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWebsiteAuthorizationProvidersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWebsiteAuthorizationProvidersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWebsiteAuthorizationProvidersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWebsiteAuthorizationProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWebsiteAuthorizationProvidersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWebsiteAuthorizationProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWebsiteAuthorizationProvidersOutputError>
}

public struct ListWebsiteAuthorizationProvidersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWebsiteAuthorizationProvidersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWebsiteAuthorizationProvidersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWebsiteAuthorizationProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWebsiteAuthorizationProvidersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWebsiteAuthorizationProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWebsiteAuthorizationProvidersOutputError>
}

public struct ListWebsiteAuthorizationProvidersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWebsiteAuthorizationProvidersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListWebsiteAuthorizationProvidersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWebsiteAuthorizationProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/listWebsiteAuthorizationProviders"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListWebsiteAuthorizationProvidersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListWebsiteAuthorizationProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWebsiteAuthorizationProvidersOutputError>
}

public struct ListWebsiteAuthorizationProvidersInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWebsiteAuthorizationProvidersInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListWebsiteAuthorizationProvidersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWebsiteAuthorizationProvidersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWebsiteAuthorizationProvidersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWebsiteAuthorizationProvidersOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWebsiteAuthorizationProvidersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWebsiteAuthorizationProvidersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), websiteAuthorizationProviders: \(Swift.String(describing: websiteAuthorizationProviders)))"}
}

extension ListWebsiteAuthorizationProvidersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWebsiteAuthorizationProvidersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.websiteAuthorizationProviders = output.websiteAuthorizationProviders
        } else {
            self.nextToken = nil
            self.websiteAuthorizationProviders = nil
        }
    }
}

public struct ListWebsiteAuthorizationProvidersOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The website authorization providers.
    public var websiteAuthorizationProviders: [WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]?

    public init (
        nextToken: Swift.String? = nil,
        websiteAuthorizationProviders: [WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.websiteAuthorizationProviders = websiteAuthorizationProviders
    }
}

struct ListWebsiteAuthorizationProvidersOutputResponseBody: Swift.Equatable {
    public let websiteAuthorizationProviders: [WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]?
    public let nextToken: Swift.String?
}

extension ListWebsiteAuthorizationProvidersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case websiteAuthorizationProviders = "WebsiteAuthorizationProviders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteAuthorizationProvidersContainer = try containerValues.decodeIfPresent([WorkLinkClientTypes.WebsiteAuthorizationProviderSummary?].self, forKey: .websiteAuthorizationProviders)
        var websiteAuthorizationProvidersDecoded0:[WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]? = nil
        if let websiteAuthorizationProvidersContainer = websiteAuthorizationProvidersContainer {
            websiteAuthorizationProvidersDecoded0 = [WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]()
            for structure0 in websiteAuthorizationProvidersContainer {
                if let structure0 = structure0 {
                    websiteAuthorizationProvidersDecoded0?.append(structure0)
                }
            }
        }
        websiteAuthorizationProviders = websiteAuthorizationProvidersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListWebsiteCertificateAuthoritiesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWebsiteCertificateAuthoritiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWebsiteCertificateAuthoritiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWebsiteCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWebsiteCertificateAuthoritiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWebsiteCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWebsiteCertificateAuthoritiesOutputError>
}

extension ListWebsiteCertificateAuthoritiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWebsiteCertificateAuthoritiesInput(fleetArn: \(Swift.String(describing: fleetArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListWebsiteCertificateAuthoritiesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWebsiteCertificateAuthoritiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWebsiteCertificateAuthoritiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWebsiteCertificateAuthoritiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWebsiteCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWebsiteCertificateAuthoritiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWebsiteCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWebsiteCertificateAuthoritiesOutputError>
}

public struct ListWebsiteCertificateAuthoritiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWebsiteCertificateAuthoritiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWebsiteCertificateAuthoritiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWebsiteCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWebsiteCertificateAuthoritiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWebsiteCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWebsiteCertificateAuthoritiesOutputError>
}

public struct ListWebsiteCertificateAuthoritiesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWebsiteCertificateAuthoritiesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListWebsiteCertificateAuthoritiesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWebsiteCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/listWebsiteCertificateAuthorities"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListWebsiteCertificateAuthoritiesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListWebsiteCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWebsiteCertificateAuthoritiesOutputError>
}

public struct ListWebsiteCertificateAuthoritiesInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If
    ///             this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWebsiteCertificateAuthoritiesInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListWebsiteCertificateAuthoritiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWebsiteCertificateAuthoritiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWebsiteCertificateAuthoritiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWebsiteCertificateAuthoritiesOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWebsiteCertificateAuthoritiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWebsiteCertificateAuthoritiesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), websiteCertificateAuthorities: \(Swift.String(describing: websiteCertificateAuthorities)))"}
}

extension ListWebsiteCertificateAuthoritiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWebsiteCertificateAuthoritiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.websiteCertificateAuthorities = output.websiteCertificateAuthorities
        } else {
            self.nextToken = nil
            self.websiteCertificateAuthorities = nil
        }
    }
}

public struct ListWebsiteCertificateAuthoritiesOutputResponse: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation. If
    ///             there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the certificates.
    public var websiteCertificateAuthorities: [WorkLinkClientTypes.WebsiteCaSummary]?

    public init (
        nextToken: Swift.String? = nil,
        websiteCertificateAuthorities: [WorkLinkClientTypes.WebsiteCaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.websiteCertificateAuthorities = websiteCertificateAuthorities
    }
}

struct ListWebsiteCertificateAuthoritiesOutputResponseBody: Swift.Equatable {
    public let websiteCertificateAuthorities: [WorkLinkClientTypes.WebsiteCaSummary]?
    public let nextToken: Swift.String?
}

extension ListWebsiteCertificateAuthoritiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case websiteCertificateAuthorities = "WebsiteCertificateAuthorities"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteCertificateAuthoritiesContainer = try containerValues.decodeIfPresent([WorkLinkClientTypes.WebsiteCaSummary?].self, forKey: .websiteCertificateAuthorities)
        var websiteCertificateAuthoritiesDecoded0:[WorkLinkClientTypes.WebsiteCaSummary]? = nil
        if let websiteCertificateAuthoritiesContainer = websiteCertificateAuthoritiesContainer {
            websiteCertificateAuthoritiesDecoded0 = [WorkLinkClientTypes.WebsiteCaSummary]()
            for structure0 in websiteCertificateAuthoritiesContainer {
                if let structure0 = structure0 {
                    websiteCertificateAuthoritiesDecoded0?.append(structure0)
                }
            }
        }
        websiteCertificateAuthorities = websiteCertificateAuthoritiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ResourceAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RestoreDomainAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDomainAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDomainAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDomainAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDomainAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDomainAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDomainAccessOutputError>
}

extension RestoreDomainAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDomainAccessInput(domainName: \(Swift.String(describing: domainName)), fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension RestoreDomainAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct RestoreDomainAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDomainAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDomainAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDomainAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDomainAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDomainAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDomainAccessOutputError>
}

public struct RestoreDomainAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDomainAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDomainAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDomainAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDomainAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDomainAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDomainAccessOutputError>
}

public struct RestoreDomainAccessInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDomainAccessInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RestoreDomainAccessInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDomainAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/restoreDomainAccess"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RestoreDomainAccessInput
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDomainAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDomainAccessOutputError>
}

public struct RestoreDomainAccessInput: Swift.Equatable {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct RestoreDomainAccessInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let domainName: Swift.String?
}

extension RestoreDomainAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension RestoreDomainAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreDomainAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDomainAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDomainAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDomainAccessOutputResponse()"}
}

extension RestoreDomainAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RestoreDomainAccessOutputResponse: Swift.Equatable {

    public init() {}
}

struct RestoreDomainAccessOutputResponseBody: Swift.Equatable {
}

extension RestoreDomainAccessOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct RevokeDomainAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeDomainAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeDomainAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeDomainAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeDomainAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeDomainAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeDomainAccessOutputError>
}

extension RevokeDomainAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevokeDomainAccessInput(domainName: \(Swift.String(describing: domainName)), fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension RevokeDomainAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct RevokeDomainAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeDomainAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeDomainAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeDomainAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeDomainAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeDomainAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeDomainAccessOutputError>
}

public struct RevokeDomainAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeDomainAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeDomainAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeDomainAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeDomainAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeDomainAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeDomainAccessOutputError>
}

public struct RevokeDomainAccessInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeDomainAccessInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RevokeDomainAccessInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeDomainAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/revokeDomainAccess"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RevokeDomainAccessInput
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeDomainAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeDomainAccessOutputError>
}

public struct RevokeDomainAccessInput: Swift.Equatable {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct RevokeDomainAccessInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let domainName: Swift.String?
}

extension RevokeDomainAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension RevokeDomainAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeDomainAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeDomainAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeDomainAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevokeDomainAccessOutputResponse()"}
}

extension RevokeDomainAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RevokeDomainAccessOutputResponse: Swift.Equatable {

    public init() {}
}

struct RevokeDomainAccessOutputResponseBody: Swift.Equatable {
}

extension RevokeDomainAccessOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct SignOutUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SignOutUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SignOutUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SignOutUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SignOutUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SignOutUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SignOutUserOutputError>
}

extension SignOutUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SignOutUserInput(fleetArn: \(Swift.String(describing: fleetArn)), username: \(Swift.String(describing: username)))"}
}

extension SignOutUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct SignOutUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SignOutUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SignOutUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SignOutUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SignOutUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SignOutUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SignOutUserOutputError>
}

public struct SignOutUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SignOutUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SignOutUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SignOutUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SignOutUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SignOutUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SignOutUserOutputError>
}

public struct SignOutUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SignOutUserInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SignOutUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SignOutUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/signOutUser"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SignOutUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<SignOutUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SignOutUserOutputError>
}

public struct SignOutUserInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The name of the user.
    /// This member is required.
    public var username: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.username = username
    }
}

struct SignOutUserInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let username: Swift.String?
}

extension SignOutUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension SignOutUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SignOutUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SignOutUserOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SignOutUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SignOutUserOutputResponse()"}
}

extension SignOutUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SignOutUserOutputResponse: Swift.Equatable {

    public init() {}
}

struct SignOutUserOutputResponseBody: Swift.Equatable {
}

extension SignOutUserOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is a key-value pair.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TooManyRequestsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequestsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of requests exceeds the limit.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnauthorizedException(message: \(Swift.String(describing: message)))"}
}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are not authorized to perform this action.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateAuditStreamConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAuditStreamConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAuditStreamConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAuditStreamConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAuditStreamConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAuditStreamConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAuditStreamConfigurationOutputError>
}

extension UpdateAuditStreamConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAuditStreamConfigurationInput(auditStreamArn: \(Swift.String(describing: auditStreamArn)), fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension UpdateAuditStreamConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditStreamArn = "AuditStreamArn"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditStreamArn = auditStreamArn {
            try encodeContainer.encode(auditStreamArn, forKey: .auditStreamArn)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct UpdateAuditStreamConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAuditStreamConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAuditStreamConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAuditStreamConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAuditStreamConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAuditStreamConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAuditStreamConfigurationOutputError>
}

public struct UpdateAuditStreamConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAuditStreamConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAuditStreamConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAuditStreamConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAuditStreamConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAuditStreamConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAuditStreamConfigurationOutputError>
}

public struct UpdateAuditStreamConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAuditStreamConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateAuditStreamConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAuditStreamConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/updateAuditStreamConfiguration"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAuditStreamConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAuditStreamConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAuditStreamConfigurationOutputError>
}

public struct UpdateAuditStreamConfigurationInput: Swift.Equatable {
    /// The ARN of the Amazon Kinesis data stream that receives the audit events.
    public var auditStreamArn: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        auditStreamArn: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.auditStreamArn = auditStreamArn
        self.fleetArn = fleetArn
    }
}

struct UpdateAuditStreamConfigurationInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let auditStreamArn: Swift.String?
}

extension UpdateAuditStreamConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditStreamArn = "AuditStreamArn"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let auditStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditStreamArn)
        auditStreamArn = auditStreamArnDecoded
    }
}

extension UpdateAuditStreamConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAuditStreamConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAuditStreamConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAuditStreamConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAuditStreamConfigurationOutputResponse()"}
}

extension UpdateAuditStreamConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAuditStreamConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateAuditStreamConfigurationOutputResponseBody: Swift.Equatable {
}

extension UpdateAuditStreamConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateCompanyNetworkConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCompanyNetworkConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCompanyNetworkConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCompanyNetworkConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCompanyNetworkConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCompanyNetworkConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCompanyNetworkConfigurationOutputError>
}

extension UpdateCompanyNetworkConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCompanyNetworkConfigurationInput(fleetArn: \(Swift.String(describing: fleetArn)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension UpdateCompanyNetworkConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

public struct UpdateCompanyNetworkConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCompanyNetworkConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCompanyNetworkConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCompanyNetworkConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCompanyNetworkConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCompanyNetworkConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCompanyNetworkConfigurationOutputError>
}

public struct UpdateCompanyNetworkConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCompanyNetworkConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCompanyNetworkConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCompanyNetworkConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCompanyNetworkConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCompanyNetworkConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCompanyNetworkConfigurationOutputError>
}

public struct UpdateCompanyNetworkConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCompanyNetworkConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateCompanyNetworkConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCompanyNetworkConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/updateCompanyNetworkConfiguration"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateCompanyNetworkConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCompanyNetworkConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCompanyNetworkConfigurationOutputError>
}

public struct UpdateCompanyNetworkConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The security groups associated with access to the provided subnets.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The subnets used for X-ENI connections from Amazon WorkLink rendering containers.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The VPC with connectivity to associated websites.
    /// This member is required.
    public var vpcId: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

struct UpdateCompanyNetworkConfigurationInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let vpcId: Swift.String?
    public let subnetIds: [Swift.String]?
    public let securityGroupIds: [Swift.String]?
}

extension UpdateCompanyNetworkConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension UpdateCompanyNetworkConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCompanyNetworkConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCompanyNetworkConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCompanyNetworkConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCompanyNetworkConfigurationOutputResponse()"}
}

extension UpdateCompanyNetworkConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCompanyNetworkConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateCompanyNetworkConfigurationOutputResponseBody: Swift.Equatable {
}

extension UpdateCompanyNetworkConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDevicePolicyConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDevicePolicyConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDevicePolicyConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDevicePolicyConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDevicePolicyConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDevicePolicyConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDevicePolicyConfigurationOutputError>
}

extension UpdateDevicePolicyConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDevicePolicyConfigurationInput(deviceCaCertificate: \(Swift.String(describing: deviceCaCertificate)), fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension UpdateDevicePolicyConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceCaCertificate = "DeviceCaCertificate"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceCaCertificate = deviceCaCertificate {
            try encodeContainer.encode(deviceCaCertificate, forKey: .deviceCaCertificate)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct UpdateDevicePolicyConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDevicePolicyConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDevicePolicyConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDevicePolicyConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDevicePolicyConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDevicePolicyConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDevicePolicyConfigurationOutputError>
}

public struct UpdateDevicePolicyConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDevicePolicyConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDevicePolicyConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDevicePolicyConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDevicePolicyConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDevicePolicyConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDevicePolicyConfigurationOutputError>
}

public struct UpdateDevicePolicyConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDevicePolicyConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateDevicePolicyConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDevicePolicyConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/updateDevicePolicyConfiguration"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDevicePolicyConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDevicePolicyConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDevicePolicyConfigurationOutputError>
}

public struct UpdateDevicePolicyConfigurationInput: Swift.Equatable {
    /// The certificate chain, including intermediate certificates and the root certificate authority certificate used to issue device certificates.
    public var deviceCaCertificate: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        deviceCaCertificate: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.deviceCaCertificate = deviceCaCertificate
        self.fleetArn = fleetArn
    }
}

struct UpdateDevicePolicyConfigurationInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let deviceCaCertificate: Swift.String?
}

extension UpdateDevicePolicyConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceCaCertificate = "DeviceCaCertificate"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let deviceCaCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCaCertificate)
        deviceCaCertificate = deviceCaCertificateDecoded
    }
}

extension UpdateDevicePolicyConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDevicePolicyConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDevicePolicyConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDevicePolicyConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDevicePolicyConfigurationOutputResponse()"}
}

extension UpdateDevicePolicyConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDevicePolicyConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateDevicePolicyConfigurationOutputResponseBody: Swift.Equatable {
}

extension UpdateDevicePolicyConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDomainMetadataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDomainMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDomainMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDomainMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDomainMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDomainMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDomainMetadataOutputError>
}

extension UpdateDomainMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainMetadataInput(displayName: \(Swift.String(describing: displayName)), domainName: \(Swift.String(describing: domainName)), fleetArn: \(Swift.String(describing: fleetArn)))"}
}

extension UpdateDomainMetadataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct UpdateDomainMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDomainMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDomainMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDomainMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDomainMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDomainMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDomainMetadataOutputError>
}

public struct UpdateDomainMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDomainMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDomainMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDomainMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDomainMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDomainMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDomainMetadataOutputError>
}

public struct UpdateDomainMetadataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDomainMetadataInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateDomainMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDomainMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/updateDomainMetadata"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDomainMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDomainMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDomainMetadataOutputError>
}

public struct UpdateDomainMetadataInput: Swift.Equatable {
    /// The name to display.
    public var displayName: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct UpdateDomainMetadataInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let domainName: Swift.String?
    public let displayName: Swift.String?
}

extension UpdateDomainMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension UpdateDomainMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainMetadataOutputResponse()"}
}

extension UpdateDomainMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDomainMetadataOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateDomainMetadataOutputResponseBody: Swift.Equatable {
}

extension UpdateDomainMetadataOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateFleetMetadataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFleetMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFleetMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFleetMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFleetMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFleetMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFleetMetadataOutputError>
}

extension UpdateFleetMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFleetMetadataInput(displayName: \(Swift.String(describing: displayName)), fleetArn: \(Swift.String(describing: fleetArn)), optimizeForEndUserLocation: \(Swift.String(describing: optimizeForEndUserLocation)))"}
}

extension UpdateFleetMetadataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let optimizeForEndUserLocation = optimizeForEndUserLocation {
            try encodeContainer.encode(optimizeForEndUserLocation, forKey: .optimizeForEndUserLocation)
        }
    }
}

public struct UpdateFleetMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFleetMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFleetMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFleetMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFleetMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFleetMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFleetMetadataOutputError>
}

public struct UpdateFleetMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFleetMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFleetMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFleetMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFleetMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFleetMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFleetMetadataOutputError>
}

public struct UpdateFleetMetadataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFleetMetadataInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateFleetMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFleetMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/UpdateFleetMetadata"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFleetMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFleetMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFleetMetadataOutputError>
}

public struct UpdateFleetMetadataInput: Swift.Equatable {
    /// The fleet name to display. The existing DisplayName is unset if null is passed.
    public var displayName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The option to optimize for better performance by routing traffic through the closest
    ///             AWS Region to users, which may be outside of your home Region.
    public var optimizeForEndUserLocation: Swift.Bool?

    public init (
        displayName: Swift.String? = nil,
        fleetArn: Swift.String? = nil,
        optimizeForEndUserLocation: Swift.Bool? = nil
    )
    {
        self.displayName = displayName
        self.fleetArn = fleetArn
        self.optimizeForEndUserLocation = optimizeForEndUserLocation
    }
}

struct UpdateFleetMetadataInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let displayName: Swift.String?
    public let optimizeForEndUserLocation: Swift.Bool?
}

extension UpdateFleetMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let optimizeForEndUserLocationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optimizeForEndUserLocation)
        optimizeForEndUserLocation = optimizeForEndUserLocationDecoded
    }
}

extension UpdateFleetMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFleetMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFleetMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFleetMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFleetMetadataOutputResponse()"}
}

extension UpdateFleetMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFleetMetadataOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateFleetMetadataOutputResponseBody: Swift.Equatable {
}

extension UpdateFleetMetadataOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateIdentityProviderConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateIdentityProviderConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateIdentityProviderConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateIdentityProviderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateIdentityProviderConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateIdentityProviderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateIdentityProviderConfigurationOutputError>
}

extension UpdateIdentityProviderConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIdentityProviderConfigurationInput(fleetArn: \(Swift.String(describing: fleetArn)), identityProviderSamlMetadata: \(Swift.String(describing: identityProviderSamlMetadata)), identityProviderType: \(Swift.String(describing: identityProviderType)))"}
}

extension UpdateIdentityProviderConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case identityProviderSamlMetadata = "IdentityProviderSamlMetadata"
        case identityProviderType = "IdentityProviderType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let identityProviderSamlMetadata = identityProviderSamlMetadata {
            try encodeContainer.encode(identityProviderSamlMetadata, forKey: .identityProviderSamlMetadata)
        }
        if let identityProviderType = identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }
}

public struct UpdateIdentityProviderConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateIdentityProviderConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateIdentityProviderConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateIdentityProviderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateIdentityProviderConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateIdentityProviderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateIdentityProviderConfigurationOutputError>
}

public struct UpdateIdentityProviderConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateIdentityProviderConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateIdentityProviderConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateIdentityProviderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateIdentityProviderConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateIdentityProviderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateIdentityProviderConfigurationOutputError>
}

public struct UpdateIdentityProviderConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateIdentityProviderConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateIdentityProviderConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateIdentityProviderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/updateIdentityProviderConfiguration"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateIdentityProviderConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateIdentityProviderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateIdentityProviderConfigurationOutputError>
}

public struct UpdateIdentityProviderConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The SAML metadata document provided by the customers identity provider. The existing
    ///             IdentityProviderSamlMetadata is unset if null is passed.
    public var identityProviderSamlMetadata: Swift.String?
    /// The type of identity provider.
    /// This member is required.
    public var identityProviderType: WorkLinkClientTypes.IdentityProviderType?

    public init (
        fleetArn: Swift.String? = nil,
        identityProviderSamlMetadata: Swift.String? = nil,
        identityProviderType: WorkLinkClientTypes.IdentityProviderType? = nil
    )
    {
        self.fleetArn = fleetArn
        self.identityProviderSamlMetadata = identityProviderSamlMetadata
        self.identityProviderType = identityProviderType
    }
}

struct UpdateIdentityProviderConfigurationInputBody: Swift.Equatable {
    public let fleetArn: Swift.String?
    public let identityProviderType: WorkLinkClientTypes.IdentityProviderType?
    public let identityProviderSamlMetadata: Swift.String?
}

extension UpdateIdentityProviderConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case identityProviderSamlMetadata = "IdentityProviderSamlMetadata"
        case identityProviderType = "IdentityProviderType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderSamlMetadata)
        identityProviderSamlMetadata = identityProviderSamlMetadataDecoded
    }
}

extension UpdateIdentityProviderConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIdentityProviderConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIdentityProviderConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIdentityProviderConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIdentityProviderConfigurationOutputResponse()"}
}

extension UpdateIdentityProviderConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateIdentityProviderConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateIdentityProviderConfigurationOutputResponseBody: Swift.Equatable {
}

extension UpdateIdentityProviderConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension WorkLinkClientTypes.WebsiteAuthorizationProviderSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
        case authorizationProviderType = "AuthorizationProviderType"
        case createdTime = "CreatedTime"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationProviderId = authorizationProviderId {
            try encodeContainer.encode(authorizationProviderId, forKey: .authorizationProviderId)
        }
        if let authorizationProviderType = authorizationProviderType {
            try encodeContainer.encode(authorizationProviderType.rawValue, forKey: .authorizationProviderType)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationProviderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationProviderId)
        authorizationProviderId = authorizationProviderIdDecoded
        let authorizationProviderTypeDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.AuthorizationProviderType.self, forKey: .authorizationProviderType)
        authorizationProviderType = authorizationProviderTypeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension WorkLinkClientTypes.WebsiteAuthorizationProviderSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WebsiteAuthorizationProviderSummary(authorizationProviderId: \(Swift.String(describing: authorizationProviderId)), authorizationProviderType: \(Swift.String(describing: authorizationProviderType)), createdTime: \(Swift.String(describing: createdTime)), domainName: \(Swift.String(describing: domainName)))"}
}

extension WorkLinkClientTypes {
    /// The summary of the website authorization provider.
    public struct WebsiteAuthorizationProviderSummary: Swift.Equatable {
        /// A unique identifier for the authorization provider.
        public var authorizationProviderId: Swift.String?
        /// The authorization provider type.
        /// This member is required.
        public var authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType?
        /// The time of creation.
        public var createdTime: ClientRuntime.Date?
        /// The domain name of the authorization provider. This applies only to SAML-based
        ///             authorization providers.
        public var domainName: Swift.String?

        public init (
            authorizationProviderId: Swift.String? = nil,
            authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType? = nil,
            createdTime: ClientRuntime.Date? = nil,
            domainName: Swift.String? = nil
        )
        {
            self.authorizationProviderId = authorizationProviderId
            self.authorizationProviderType = authorizationProviderType
            self.createdTime = createdTime
            self.domainName = domainName
        }
    }

}

extension WorkLinkClientTypes.WebsiteCaSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case websiteCaId = "WebsiteCaId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let websiteCaId = websiteCaId {
            try encodeContainer.encode(websiteCaId, forKey: .websiteCaId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension WorkLinkClientTypes.WebsiteCaSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WebsiteCaSummary(createdTime: \(Swift.String(describing: createdTime)), displayName: \(Swift.String(describing: displayName)), websiteCaId: \(Swift.String(describing: websiteCaId)))"}
}

extension WorkLinkClientTypes {
    /// The summary of the certificate authority (CA).
    public struct WebsiteCaSummary: Swift.Equatable {
        /// The time when the CA was added.
        public var createdTime: ClientRuntime.Date?
        /// The name to display.
        public var displayName: Swift.String?
        /// A unique identifier for the CA.
        public var websiteCaId: Swift.String?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            websiteCaId: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.displayName = displayName
            self.websiteCaId = websiteCaId
        }
    }

}
