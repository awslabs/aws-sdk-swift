// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationSeconds
        case enabled
        case managedPolicyArns
        case name
        case requireInstanceProperties
        case roleArns
        case sessionPolicy
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let managedPolicyArns = managedPolicyArns {
            var managedPolicyArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedPolicyArns)
            for string0 in managedPolicyArns {
                try managedPolicyArnsContainer.encode(string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requireInstanceProperties = self.requireInstanceProperties {
            try encodeContainer.encode(requireInstanceProperties, forKey: .requireInstanceProperties)
        }
        if let roleArns = roleArns {
            var roleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roleArns)
            for rolearn0 in roleArns {
                try roleArnsContainer.encode(rolearn0)
            }
        }
        if let sessionPolicy = self.sessionPolicy {
            try encodeContainer.encode(sessionPolicy, forKey: .sessionPolicy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/profiles"
    }
}

public struct CreateProfileInput: Swift.Equatable {
    /// The number of seconds the vended session credentials are valid for.
    public var durationSeconds: Swift.Int?
    /// Specifies whether the profile is enabled.
    public var enabled: Swift.Bool?
    /// A list of managed policy ARNs that apply to the vended session credentials.
    public var managedPolicyArns: [Swift.String]?
    /// The name of the profile.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies whether instance properties are required in [CreateSession](https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html) requests with this profile.
    public var requireInstanceProperties: Swift.Bool?
    /// A list of IAM roles that this profile can assume in a [CreateSession](https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html) operation.
    /// This member is required.
    public var roleArns: [Swift.String]?
    /// A session policy that applies to the trust boundary of the vended session credentials.
    public var sessionPolicy: Swift.String?
    /// The tags to attach to the profile.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init (
        durationSeconds: Swift.Int? = nil,
        enabled: Swift.Bool? = nil,
        managedPolicyArns: [Swift.String]? = nil,
        name: Swift.String? = nil,
        requireInstanceProperties: Swift.Bool? = nil,
        roleArns: [Swift.String]? = nil,
        sessionPolicy: Swift.String? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.enabled = enabled
        self.managedPolicyArns = managedPolicyArns
        self.name = name
        self.requireInstanceProperties = requireInstanceProperties
        self.roleArns = roleArns
        self.sessionPolicy = sessionPolicy
        self.tags = tags
    }
}

struct CreateProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let requireInstanceProperties: Swift.Bool?
    let sessionPolicy: Swift.String?
    let roleArns: [Swift.String]?
    let managedPolicyArns: [Swift.String]?
    let durationSeconds: Swift.Int?
    let enabled: Swift.Bool?
    let tags: [RolesAnywhereClientTypes.Tag]?
}

extension CreateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationSeconds
        case enabled
        case managedPolicyArns
        case name
        case requireInstanceProperties
        case roleArns
        case sessionPolicy
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requireInstancePropertiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireInstanceProperties)
        requireInstanceProperties = requireInstancePropertiesDecoded
        let sessionPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionPolicy)
        sessionPolicy = sessionPolicyDecoded
        let roleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .roleArns)
        var roleArnsDecoded0:[Swift.String]? = nil
        if let roleArnsContainer = roleArnsContainer {
            roleArnsDecoded0 = [Swift.String]()
            for string0 in roleArnsContainer {
                if let string0 = string0 {
                    roleArnsDecoded0?.append(string0)
                }
            }
        }
        roleArns = roleArnsDecoded0
        let managedPolicyArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .managedPolicyArns)
        var managedPolicyArnsDecoded0:[Swift.String]? = nil
        if let managedPolicyArnsContainer = managedPolicyArnsContainer {
            managedPolicyArnsDecoded0 = [Swift.String]()
            for string0 in managedPolicyArnsContainer {
                if let string0 = string0 {
                    managedPolicyArnsDecoded0?.append(string0)
                }
            }
        }
        managedPolicyArns = managedPolicyArnsDecoded0
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RolesAnywhereClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RolesAnywhereClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct CreateProfileOutputResponse: Swift.Equatable {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init (
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

struct CreateProfileOutputResponseBody: Swift.Equatable {
    let profile: RolesAnywhereClientTypes.ProfileDetail?
}

extension CreateProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.ProfileDetail.self, forKey: .profile)
        profile = profileDecoded
    }
}

extension CreateTrustAnchorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case name
        case source
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateTrustAnchorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/trustanchors"
    }
}

public struct CreateTrustAnchorInput: Swift.Equatable {
    /// Specifies whether the trust anchor is enabled.
    public var enabled: Swift.Bool?
    /// The name of the trust anchor.
    /// This member is required.
    public var name: Swift.String?
    /// The trust anchor type and its related certificate data.
    /// This member is required.
    public var source: RolesAnywhereClientTypes.Source?
    /// The tags to attach to the trust anchor.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init (
        enabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        source: RolesAnywhereClientTypes.Source? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.name = name
        self.source = source
        self.tags = tags
    }
}

struct CreateTrustAnchorInputBody: Swift.Equatable {
    let name: Swift.String?
    let source: RolesAnywhereClientTypes.Source?
    let enabled: Swift.Bool?
    let tags: [RolesAnywhereClientTypes.Tag]?
}

extension CreateTrustAnchorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case name
        case source
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RolesAnywhereClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RolesAnywhereClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTrustAnchorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTrustAnchorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTrustAnchorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTrustAnchorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTrustAnchorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trustAnchor = output.trustAnchor
        } else {
            self.trustAnchor = nil
        }
    }
}

public struct CreateTrustAnchorOutputResponse: Swift.Equatable {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init (
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

struct CreateTrustAnchorOutputResponseBody: Swift.Equatable {
    let trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?
}

extension CreateTrustAnchorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustAnchor
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorDetail.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

extension RolesAnywhereClientTypes.CredentialSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case failed
        case issuer
        case seenAt
        case serialNumber
        case x509CertificateData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let failed = self.failed {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let seenAt = self.seenAt {
            try encodeContainer.encodeTimestamp(seenAt, format: .dateTime, forKey: .seenAt)
        }
        if let serialNumber = self.serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let x509CertificateData = self.x509CertificateData {
            try encodeContainer.encode(x509CertificateData, forKey: .x509CertificateData)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let seenAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .seenAt)
        seenAt = seenAtDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let x509CertificateDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .x509CertificateData)
        x509CertificateData = x509CertificateDataDecoded
        let failedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failed)
        failed = failedDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// A record of a presented X509 credential to [CreateSession](https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html).
    public struct CredentialSummary: Swift.Equatable {
        /// Indicates whether the credential is enabled.
        public var enabled: Swift.Bool?
        /// Indicates whether the [CreateSession](https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html) operation was successful.
        public var failed: Swift.Bool?
        /// The fully qualified domain name of the issuing certificate for the presented end-entity certificate.
        public var issuer: Swift.String?
        /// The ISO-8601 time stamp of when the certificate was last used in a [CreateSession](https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html) operation.
        public var seenAt: ClientRuntime.Date?
        /// The serial number of the certificate.
        public var serialNumber: Swift.String?
        /// The PEM-encoded data of the certificate.
        public var x509CertificateData: Swift.String?

        public init (
            enabled: Swift.Bool? = nil,
            failed: Swift.Bool? = nil,
            issuer: Swift.String? = nil,
            seenAt: ClientRuntime.Date? = nil,
            serialNumber: Swift.String? = nil,
            x509CertificateData: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.failed = failed
            self.issuer = issuer
            self.seenAt = seenAt
            self.serialNumber = serialNumber
            self.x509CertificateData = x509CertificateData
        }
    }

}

extension RolesAnywhereClientTypes.CrlDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case crlArn
        case crlData
        case crlId
        case enabled
        case name
        case trustAnchorArn
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let crlArn = self.crlArn {
            try encodeContainer.encode(crlArn, forKey: .crlArn)
        }
        if let crlData = self.crlData {
            try encodeContainer.encode(crlData.base64EncodedString(), forKey: .crlData)
        }
        if let crlId = self.crlId {
            try encodeContainer.encode(crlId, forKey: .crlId)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let trustAnchorArn = self.trustAnchorArn {
            try encodeContainer.encode(trustAnchorArn, forKey: .trustAnchorArn)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .crlId)
        crlId = crlIdDecoded
        let crlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .crlArn)
        crlArn = crlArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let crlDataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .crlData)
        crlData = crlDataDecoded
        let trustAnchorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustAnchorArn)
        trustAnchorArn = trustAnchorArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    public struct CrlDetail: Swift.Equatable {
        /// The ISO-8601 timestamp when the certificate revocation list (CRL) was created.
        public var createdAt: ClientRuntime.Date?
        /// The ARN of the certificate revocation list (CRL).
        public var crlArn: Swift.String?
        /// The state of the certificate revocation list (CRL) after a read or write operation.
        public var crlData: ClientRuntime.Data?
        /// The unique identifier of the certificate revocation list (CRL).
        public var crlId: Swift.String?
        /// Indicates whether the certificate revocation list (CRL) is enabled.
        public var enabled: Swift.Bool?
        /// The name of the certificate revocation list (CRL).
        public var name: Swift.String?
        /// The ARN of the TrustAnchor the certificate revocation list (CRL) will provide revocation for.
        public var trustAnchorArn: Swift.String?
        /// The ISO-8601 timestamp when the certificate revocation list (CRL) was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            crlArn: Swift.String? = nil,
            crlData: ClientRuntime.Data? = nil,
            crlId: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            trustAnchorArn: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.crlArn = crlArn
            self.crlData = crlData
            self.crlId = crlId
            self.enabled = enabled
            self.name = name
            self.trustAnchorArn = trustAnchorArn
            self.updatedAt = updatedAt
        }
    }

}

extension DeleteCrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let crlId = crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())"
    }
}

public struct DeleteCrlInput: Swift.Equatable {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init (
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

struct DeleteCrlInputBody: Swift.Equatable {
}

extension DeleteCrlInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCrlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCrlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCrlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteCrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crl = output.crl
        } else {
            self.crl = nil
        }
    }
}

public struct DeleteCrlOutputResponse: Swift.Equatable {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init (
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

struct DeleteCrlOutputResponseBody: Swift.Equatable {
    let crl: RolesAnywhereClientTypes.CrlDetail?
}

extension DeleteCrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.CrlDetail.self, forKey: .crl)
        crl = crlDecoded
    }
}

extension DeleteProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileId = profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())"
    }
}

public struct DeleteProfileInput: Swift.Equatable {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init (
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct DeleteProfileInputBody: Swift.Equatable {
}

extension DeleteProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct DeleteProfileOutputResponse: Swift.Equatable {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init (
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

struct DeleteProfileOutputResponseBody: Swift.Equatable {
    let profile: RolesAnywhereClientTypes.ProfileDetail?
}

extension DeleteProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.ProfileDetail.self, forKey: .profile)
        profile = profileDecoded
    }
}

extension DeleteTrustAnchorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustAnchorId = trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())"
    }
}

public struct DeleteTrustAnchorInput: Swift.Equatable {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init (
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

struct DeleteTrustAnchorInputBody: Swift.Equatable {
}

extension DeleteTrustAnchorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTrustAnchorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTrustAnchorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTrustAnchorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTrustAnchorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteTrustAnchorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trustAnchor = output.trustAnchor
        } else {
            self.trustAnchor = nil
        }
    }
}

public struct DeleteTrustAnchorOutputResponse: Swift.Equatable {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init (
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

struct DeleteTrustAnchorOutputResponseBody: Swift.Equatable {
    let trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?
}

extension DeleteTrustAnchorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustAnchor
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorDetail.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

extension DisableCrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let crlId = crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())/disable"
    }
}

public struct DisableCrlInput: Swift.Equatable {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init (
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

struct DisableCrlInputBody: Swift.Equatable {
}

extension DisableCrlInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisableCrlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableCrlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableCrlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableCrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisableCrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crl = output.crl
        } else {
            self.crl = nil
        }
    }
}

public struct DisableCrlOutputResponse: Swift.Equatable {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init (
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

struct DisableCrlOutputResponseBody: Swift.Equatable {
    let crl: RolesAnywhereClientTypes.CrlDetail?
}

extension DisableCrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.CrlDetail.self, forKey: .crl)
        crl = crlDecoded
    }
}

extension DisableProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileId = profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())/disable"
    }
}

public struct DisableProfileInput: Swift.Equatable {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init (
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct DisableProfileInputBody: Swift.Equatable {
}

extension DisableProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisableProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisableProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct DisableProfileOutputResponse: Swift.Equatable {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init (
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

struct DisableProfileOutputResponseBody: Swift.Equatable {
    let profile: RolesAnywhereClientTypes.ProfileDetail?
}

extension DisableProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.ProfileDetail.self, forKey: .profile)
        profile = profileDecoded
    }
}

extension DisableTrustAnchorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustAnchorId = trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())/disable"
    }
}

public struct DisableTrustAnchorInput: Swift.Equatable {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init (
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

struct DisableTrustAnchorInputBody: Swift.Equatable {
}

extension DisableTrustAnchorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisableTrustAnchorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableTrustAnchorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableTrustAnchorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableTrustAnchorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisableTrustAnchorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trustAnchor = output.trustAnchor
        } else {
            self.trustAnchor = nil
        }
    }
}

public struct DisableTrustAnchorOutputResponse: Swift.Equatable {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init (
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

struct DisableTrustAnchorOutputResponseBody: Swift.Equatable {
    let trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?
}

extension DisableTrustAnchorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustAnchor
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorDetail.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

extension EnableCrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let crlId = crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())/enable"
    }
}

public struct EnableCrlInput: Swift.Equatable {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init (
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

struct EnableCrlInputBody: Swift.Equatable {
}

extension EnableCrlInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension EnableCrlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableCrlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableCrlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableCrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EnableCrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crl = output.crl
        } else {
            self.crl = nil
        }
    }
}

public struct EnableCrlOutputResponse: Swift.Equatable {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init (
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

struct EnableCrlOutputResponseBody: Swift.Equatable {
    let crl: RolesAnywhereClientTypes.CrlDetail?
}

extension EnableCrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.CrlDetail.self, forKey: .crl)
        crl = crlDecoded
    }
}

extension EnableProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileId = profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())/enable"
    }
}

public struct EnableProfileInput: Swift.Equatable {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init (
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct EnableProfileInputBody: Swift.Equatable {
}

extension EnableProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension EnableProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EnableProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct EnableProfileOutputResponse: Swift.Equatable {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init (
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

struct EnableProfileOutputResponseBody: Swift.Equatable {
    let profile: RolesAnywhereClientTypes.ProfileDetail?
}

extension EnableProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.ProfileDetail.self, forKey: .profile)
        profile = profileDecoded
    }
}

extension EnableTrustAnchorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustAnchorId = trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())/enable"
    }
}

public struct EnableTrustAnchorInput: Swift.Equatable {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init (
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

struct EnableTrustAnchorInputBody: Swift.Equatable {
}

extension EnableTrustAnchorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension EnableTrustAnchorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableTrustAnchorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableTrustAnchorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableTrustAnchorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EnableTrustAnchorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trustAnchor = output.trustAnchor
        } else {
            self.trustAnchor = nil
        }
    }
}

public struct EnableTrustAnchorOutputResponse: Swift.Equatable {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init (
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

struct EnableTrustAnchorOutputResponseBody: Swift.Equatable {
    let trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?
}

extension EnableTrustAnchorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustAnchor
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorDetail.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

extension GetCrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let crlId = crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())"
    }
}

public struct GetCrlInput: Swift.Equatable {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init (
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

struct GetCrlInputBody: Swift.Equatable {
}

extension GetCrlInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCrlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCrlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCrlOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crl = output.crl
        } else {
            self.crl = nil
        }
    }
}

public struct GetCrlOutputResponse: Swift.Equatable {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init (
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

struct GetCrlOutputResponseBody: Swift.Equatable {
    let crl: RolesAnywhereClientTypes.CrlDetail?
}

extension GetCrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.CrlDetail.self, forKey: .crl)
        crl = crlDecoded
    }
}

extension GetProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileId = profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())"
    }
}

public struct GetProfileInput: Swift.Equatable {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init (
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct GetProfileInputBody: Swift.Equatable {
}

extension GetProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct GetProfileOutputResponse: Swift.Equatable {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init (
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

struct GetProfileOutputResponseBody: Swift.Equatable {
    let profile: RolesAnywhereClientTypes.ProfileDetail?
}

extension GetProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.ProfileDetail.self, forKey: .profile)
        profile = profileDecoded
    }
}

extension GetSubjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subjectId = subjectId else {
            return nil
        }
        return "/subject/\(subjectId.urlPercentEncoding())"
    }
}

public struct GetSubjectInput: Swift.Equatable {
    /// The unique identifier of the subject.
    /// This member is required.
    public var subjectId: Swift.String?

    public init (
        subjectId: Swift.String? = nil
    )
    {
        self.subjectId = subjectId
    }
}

struct GetSubjectInputBody: Swift.Equatable {
}

extension GetSubjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSubjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSubjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSubjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSubjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSubjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subject = output.subject
        } else {
            self.subject = nil
        }
    }
}

public struct GetSubjectOutputResponse: Swift.Equatable {
    /// The state of the subject after a read or write operation.
    public var subject: RolesAnywhereClientTypes.SubjectDetail?

    public init (
        subject: RolesAnywhereClientTypes.SubjectDetail? = nil
    )
    {
        self.subject = subject
    }
}

struct GetSubjectOutputResponseBody: Swift.Equatable {
    let subject: RolesAnywhereClientTypes.SubjectDetail?
}

extension GetSubjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subject
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.SubjectDetail.self, forKey: .subject)
        subject = subjectDecoded
    }
}

extension GetTrustAnchorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustAnchorId = trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())"
    }
}

public struct GetTrustAnchorInput: Swift.Equatable {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init (
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

struct GetTrustAnchorInputBody: Swift.Equatable {
}

extension GetTrustAnchorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTrustAnchorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTrustAnchorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTrustAnchorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTrustAnchorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTrustAnchorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trustAnchor = output.trustAnchor
        } else {
            self.trustAnchor = nil
        }
    }
}

public struct GetTrustAnchorOutputResponse: Swift.Equatable {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init (
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

struct GetTrustAnchorOutputResponseBody: Swift.Equatable {
    let trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?
}

extension GetTrustAnchorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustAnchor
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorDetail.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

extension ImportCrlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crlData
        case enabled
        case name
        case tags
        case trustAnchorArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crlData = self.crlData {
            try encodeContainer.encode(crlData.base64EncodedString(), forKey: .crlData)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let trustAnchorArn = self.trustAnchorArn {
            try encodeContainer.encode(trustAnchorArn, forKey: .trustAnchorArn)
        }
    }
}

extension ImportCrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/crls"
    }
}

public struct ImportCrlInput: Swift.Equatable {
    /// The x509 v3 specified certificate revocation list
    /// This member is required.
    public var crlData: ClientRuntime.Data?
    /// Specifies whether the certificate revocation list (CRL) is enabled.
    public var enabled: Swift.Bool?
    /// The name of the certificate revocation list (CRL).
    /// This member is required.
    public var name: Swift.String?
    /// A list of tags to attach to the certificate revocation list (CRL).
    public var tags: [RolesAnywhereClientTypes.Tag]?
    /// The ARN of the TrustAnchor the certificate revocation list (CRL) will provide revocation for.
    /// This member is required.
    public var trustAnchorArn: Swift.String?

    public init (
        crlData: ClientRuntime.Data? = nil,
        enabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil,
        trustAnchorArn: Swift.String? = nil
    )
    {
        self.crlData = crlData
        self.enabled = enabled
        self.name = name
        self.tags = tags
        self.trustAnchorArn = trustAnchorArn
    }
}

struct ImportCrlInputBody: Swift.Equatable {
    let name: Swift.String?
    let crlData: ClientRuntime.Data?
    let enabled: Swift.Bool?
    let tags: [RolesAnywhereClientTypes.Tag]?
    let trustAnchorArn: Swift.String?
}

extension ImportCrlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crlData
        case enabled
        case name
        case tags
        case trustAnchorArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let crlDataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .crlData)
        crlData = crlDataDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RolesAnywhereClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RolesAnywhereClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let trustAnchorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustAnchorArn)
        trustAnchorArn = trustAnchorArnDecoded
    }
}

extension ImportCrlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportCrlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportCrlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportCrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportCrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crl = output.crl
        } else {
            self.crl = nil
        }
    }
}

public struct ImportCrlOutputResponse: Swift.Equatable {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init (
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

struct ImportCrlOutputResponseBody: Swift.Equatable {
    let crl: RolesAnywhereClientTypes.CrlDetail?
}

extension ImportCrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.CrlDetail.self, forKey: .crl)
        crl = crlDecoded
    }
}

extension RolesAnywhereClientTypes.InstanceProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failed
        case properties
        case seenAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failed = self.failed {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, instancePropertyMap0) in properties {
                try propertiesContainer.encode(instancePropertyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let seenAt = self.seenAt {
            try encodeContainer.encodeTimestamp(seenAt, format: .dateTime, forKey: .seenAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let seenAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .seenAt)
        seenAt = seenAtDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in propertiesContainer {
                if let string0 = string0 {
                    propertiesDecoded0?[key0] = string0
                }
            }
        }
        properties = propertiesDecoded0
        let failedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failed)
        failed = failedDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// A key-value pair you set that identifies a property of the authenticating instance.
    public struct InstanceProperty: Swift.Equatable {
        /// Indicates whether the [CreateSession](https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html) operation was successful.
        public var failed: Swift.Bool?
        /// A list of instanceProperty objects.
        public var properties: [Swift.String:Swift.String]?
        /// The ISO-8601 time stamp of when the certificate was last used in a [CreateSession](https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html) operation.
        public var seenAt: ClientRuntime.Date?

        public init (
            failed: Swift.Bool? = nil,
            properties: [Swift.String:Swift.String]? = nil,
            seenAt: ClientRuntime.Date? = nil
        )
        {
            self.failed = failed
            self.properties = properties
            self.seenAt = seenAt
        }
    }

}

extension ListCrlsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListCrlsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/crls"
    }
}

public struct ListCrlsInput: Swift.Equatable {
    /// A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init (
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListCrlsInputBody: Swift.Equatable {
}

extension ListCrlsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCrlsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCrlsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCrlsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCrlsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCrlsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crls = output.crls
            self.nextToken = output.nextToken
        } else {
            self.crls = nil
            self.nextToken = nil
        }
    }
}

public struct ListCrlsOutputResponse: Swift.Equatable {
    /// A list of certificate revocation lists (CRL).
    public var crls: [RolesAnywhereClientTypes.CrlDetail]?
    /// A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.
    public var nextToken: Swift.String?

    public init (
        crls: [RolesAnywhereClientTypes.CrlDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.crls = crls
        self.nextToken = nextToken
    }
}

struct ListCrlsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let crls: [RolesAnywhereClientTypes.CrlDetail]?
}

extension ListCrlsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crls
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let crlsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.CrlDetail?].self, forKey: .crls)
        var crlsDecoded0:[RolesAnywhereClientTypes.CrlDetail]? = nil
        if let crlsContainer = crlsContainer {
            crlsDecoded0 = [RolesAnywhereClientTypes.CrlDetail]()
            for structure0 in crlsContainer {
                if let structure0 = structure0 {
                    crlsDecoded0?.append(structure0)
                }
            }
        }
        crls = crlsDecoded0
    }
}

extension ListProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/profiles"
    }
}

public struct ListProfilesInput: Swift.Equatable {
    /// A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init (
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListProfilesInputBody: Swift.Equatable {
}

extension ListProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProfilesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.profiles = output.profiles
        } else {
            self.nextToken = nil
            self.profiles = nil
        }
    }
}

public struct ListProfilesOutputResponse: Swift.Equatable {
    /// A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.
    public var nextToken: Swift.String?
    /// A list of profiles.
    public var profiles: [RolesAnywhereClientTypes.ProfileDetail]?

    public init (
        nextToken: Swift.String? = nil,
        profiles: [RolesAnywhereClientTypes.ProfileDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
    }
}

struct ListProfilesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let profiles: [RolesAnywhereClientTypes.ProfileDetail]?
}

extension ListProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case profiles
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let profilesContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.ProfileDetail?].self, forKey: .profiles)
        var profilesDecoded0:[RolesAnywhereClientTypes.ProfileDetail]? = nil
        if let profilesContainer = profilesContainer {
            profilesDecoded0 = [RolesAnywhereClientTypes.ProfileDetail]()
            for structure0 in profilesContainer {
                if let structure0 = structure0 {
                    profilesDecoded0?.append(structure0)
                }
            }
        }
        profiles = profilesDecoded0
    }
}

extension ListSubjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListSubjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/subjects"
    }
}

public struct ListSubjectsInput: Swift.Equatable {
    /// A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init (
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListSubjectsInputBody: Swift.Equatable {
}

extension ListSubjectsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSubjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSubjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSubjectsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSubjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSubjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subjects = output.subjects
        } else {
            self.nextToken = nil
            self.subjects = nil
        }
    }
}

public struct ListSubjectsOutputResponse: Swift.Equatable {
    /// A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.
    public var nextToken: Swift.String?
    /// A list of subjects.
    public var subjects: [RolesAnywhereClientTypes.SubjectSummary]?

    public init (
        nextToken: Swift.String? = nil,
        subjects: [RolesAnywhereClientTypes.SubjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.subjects = subjects
    }
}

struct ListSubjectsOutputResponseBody: Swift.Equatable {
    let subjects: [RolesAnywhereClientTypes.SubjectSummary]?
    let nextToken: Swift.String?
}

extension ListSubjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case subjects
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.SubjectSummary?].self, forKey: .subjects)
        var subjectsDecoded0:[RolesAnywhereClientTypes.SubjectSummary]? = nil
        if let subjectsContainer = subjectsContainer {
            subjectsDecoded0 = [RolesAnywhereClientTypes.SubjectSummary]()
            for structure0 in subjectsContainer {
                if let structure0 = structure0 {
                    subjectsDecoded0?.append(structure0)
                }
            }
        }
        subjects = subjectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListTagsForResource"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of tags attached to the resource.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init (
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [RolesAnywhereClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RolesAnywhereClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RolesAnywhereClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTrustAnchorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListTrustAnchorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/trustanchors"
    }
}

public struct ListTrustAnchorsInput: Swift.Equatable {
    /// A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init (
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListTrustAnchorsInputBody: Swift.Equatable {
}

extension ListTrustAnchorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTrustAnchorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTrustAnchorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTrustAnchorsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTrustAnchorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTrustAnchorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.trustAnchors = output.trustAnchors
        } else {
            self.nextToken = nil
            self.trustAnchors = nil
        }
    }
}

public struct ListTrustAnchorsOutputResponse: Swift.Equatable {
    /// A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.
    public var nextToken: Swift.String?
    /// A list of trust anchors.
    public var trustAnchors: [RolesAnywhereClientTypes.TrustAnchorDetail]?

    public init (
        nextToken: Swift.String? = nil,
        trustAnchors: [RolesAnywhereClientTypes.TrustAnchorDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.trustAnchors = trustAnchors
    }
}

struct ListTrustAnchorsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let trustAnchors: [RolesAnywhereClientTypes.TrustAnchorDetail]?
}

extension ListTrustAnchorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case trustAnchors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let trustAnchorsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.TrustAnchorDetail?].self, forKey: .trustAnchors)
        var trustAnchorsDecoded0:[RolesAnywhereClientTypes.TrustAnchorDetail]? = nil
        if let trustAnchorsContainer = trustAnchorsContainer {
            trustAnchorsDecoded0 = [RolesAnywhereClientTypes.TrustAnchorDetail]()
            for structure0 in trustAnchorsContainer {
                if let structure0 = structure0 {
                    trustAnchorsDecoded0?.append(structure0)
                }
            }
        }
        trustAnchors = trustAnchorsDecoded0
    }
}

extension RolesAnywhereClientTypes.ProfileDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case durationSeconds
        case enabled
        case managedPolicyArns
        case name
        case profileArn
        case profileId
        case requireInstanceProperties
        case roleArns
        case sessionPolicy
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let managedPolicyArns = managedPolicyArns {
            var managedPolicyArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedPolicyArns)
            for string0 in managedPolicyArns {
                try managedPolicyArnsContainer.encode(string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let requireInstanceProperties = self.requireInstanceProperties {
            try encodeContainer.encode(requireInstanceProperties, forKey: .requireInstanceProperties)
        }
        if let roleArns = roleArns {
            var roleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roleArns)
            for rolearn0 in roleArns {
                try roleArnsContainer.encode(rolearn0)
            }
        }
        if let sessionPolicy = self.sessionPolicy {
            try encodeContainer.encode(sessionPolicy, forKey: .sessionPolicy)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requireInstancePropertiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireInstanceProperties)
        requireInstanceProperties = requireInstancePropertiesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let sessionPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionPolicy)
        sessionPolicy = sessionPolicyDecoded
        let roleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .roleArns)
        var roleArnsDecoded0:[Swift.String]? = nil
        if let roleArnsContainer = roleArnsContainer {
            roleArnsDecoded0 = [Swift.String]()
            for string0 in roleArnsContainer {
                if let string0 = string0 {
                    roleArnsDecoded0?.append(string0)
                }
            }
        }
        roleArns = roleArnsDecoded0
        let managedPolicyArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .managedPolicyArns)
        var managedPolicyArnsDecoded0:[Swift.String]? = nil
        if let managedPolicyArnsContainer = managedPolicyArnsContainer {
            managedPolicyArnsDecoded0 = [Swift.String]()
            for string0 in managedPolicyArnsContainer {
                if let string0 = string0 {
                    managedPolicyArnsDecoded0?.append(string0)
                }
            }
        }
        managedPolicyArns = managedPolicyArnsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// The state of the profile after a read or write operation.
    public struct ProfileDetail: Swift.Equatable {
        /// The ISO-8601 timestamp when the profile was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Web Services account that created the profile.
        public var createdBy: Swift.String?
        /// The number of seconds the vended session credentials are valid for.
        public var durationSeconds: Swift.Int?
        /// Indicates whether the profile is enabled.
        public var enabled: Swift.Bool?
        /// A list of managed policy ARNs that apply to the vended session credentials.
        public var managedPolicyArns: [Swift.String]?
        /// The name of the profile.
        public var name: Swift.String?
        /// The ARN of the profile.
        public var profileArn: Swift.String?
        /// The unique identifier of the profile.
        public var profileId: Swift.String?
        /// Specifies whether instance properties are required in [CreateSession](https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html) requests with this profile.
        public var requireInstanceProperties: Swift.Bool?
        /// A list of IAM roles that this profile can assume in a [CreateSession](https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html) operation.
        public var roleArns: [Swift.String]?
        /// A session policy that applies to the trust boundary of the vended session credentials.
        public var sessionPolicy: Swift.String?
        /// The ISO-8601 timestamp when the profile was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            durationSeconds: Swift.Int? = nil,
            enabled: Swift.Bool? = nil,
            managedPolicyArns: [Swift.String]? = nil,
            name: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileId: Swift.String? = nil,
            requireInstanceProperties: Swift.Bool? = nil,
            roleArns: [Swift.String]? = nil,
            sessionPolicy: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.durationSeconds = durationSeconds
            self.enabled = enabled
            self.managedPolicyArns = managedPolicyArns
            self.name = name
            self.profileArn = profileArn
            self.profileId = profileId
            self.requireInstanceProperties = requireInstanceProperties
            self.roleArns = roleArns
            self.sessionPolicy = sessionPolicy
            self.updatedAt = updatedAt
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RolesAnywhereClientTypes.Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceData
        case sourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceData = self.sourceData {
            try encodeContainer.encode(sourceData, forKey: .sourceData)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceDataDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.SourceData.self, forKey: .sourceData)
        sourceData = sourceDataDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// The trust anchor type and its related certificate data.
    public struct Source: Swift.Equatable {
        /// The data field of the trust anchor depending on its type.
        public var sourceData: RolesAnywhereClientTypes.SourceData?
        /// The type of the trust anchor.
        public var sourceType: RolesAnywhereClientTypes.TrustAnchorType?

        public init (
            sourceData: RolesAnywhereClientTypes.SourceData? = nil,
            sourceType: RolesAnywhereClientTypes.TrustAnchorType? = nil
        )
        {
            self.sourceData = sourceData
            self.sourceType = sourceType
        }
    }

}

extension RolesAnywhereClientTypes.SourceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acmpcaarn = "acmPcaArn"
        case sdkUnknown
        case x509certificatedata = "x509CertificateData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .acmpcaarn(acmpcaarn):
                try container.encode(acmpcaarn, forKey: .acmpcaarn)
            case let .x509certificatedata(x509certificatedata):
                try container.encode(x509certificatedata, forKey: .x509certificatedata)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let x509certificatedataDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .x509certificatedata)
        if let x509certificatedata = x509certificatedataDecoded {
            self = .x509certificatedata(x509certificatedata)
            return
        }
        let acmpcaarnDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .acmpcaarn)
        if let acmpcaarn = acmpcaarnDecoded {
            self = .acmpcaarn(acmpcaarn)
            return
        }
        self = .sdkUnknown("")
    }
}

extension RolesAnywhereClientTypes {
    /// The data field of the trust anchor depending on its type.
    public enum SourceData: Swift.Equatable, Swift.Hashable {
        /// The PEM-encoded data for the certificate anchor. Included for trust anchors of type CERTIFICATE_BUNDLE.
        case x509certificatedata(Swift.String)
        /// The root certificate of the Certificate Manager Private Certificate Authority specified by this ARN is used in trust validation for [CreateSession](https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html) operations. Included for trust anchors of type AWS_ACM_PCA.
        case acmpcaarn(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension RolesAnywhereClientTypes.SubjectDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case credentials
        case enabled
        case instanceProperties
        case lastSeenAt
        case subjectArn
        case subjectId
        case updatedAt
        case x509Subject
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let credentials = credentials {
            var credentialsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .credentials)
            for credentialsummary0 in credentials {
                try credentialsContainer.encode(credentialsummary0)
            }
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let instanceProperties = instanceProperties {
            var instancePropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceProperties)
            for instanceproperty0 in instanceProperties {
                try instancePropertiesContainer.encode(instanceproperty0)
            }
        }
        if let lastSeenAt = self.lastSeenAt {
            try encodeContainer.encodeTimestamp(lastSeenAt, format: .dateTime, forKey: .lastSeenAt)
        }
        if let subjectArn = self.subjectArn {
            try encodeContainer.encode(subjectArn, forKey: .subjectArn)
        }
        if let subjectId = self.subjectId {
            try encodeContainer.encode(subjectId, forKey: .subjectId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let x509Subject = self.x509Subject {
            try encodeContainer.encode(x509Subject, forKey: .x509Subject)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectArn)
        subjectArn = subjectArnDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let x509SubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .x509Subject)
        x509Subject = x509SubjectDecoded
        let lastSeenAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastSeenAt)
        lastSeenAt = lastSeenAtDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let credentialsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.CredentialSummary?].self, forKey: .credentials)
        var credentialsDecoded0:[RolesAnywhereClientTypes.CredentialSummary]? = nil
        if let credentialsContainer = credentialsContainer {
            credentialsDecoded0 = [RolesAnywhereClientTypes.CredentialSummary]()
            for structure0 in credentialsContainer {
                if let structure0 = structure0 {
                    credentialsDecoded0?.append(structure0)
                }
            }
        }
        credentials = credentialsDecoded0
        let instancePropertiesContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.InstanceProperty?].self, forKey: .instanceProperties)
        var instancePropertiesDecoded0:[RolesAnywhereClientTypes.InstanceProperty]? = nil
        if let instancePropertiesContainer = instancePropertiesContainer {
            instancePropertiesDecoded0 = [RolesAnywhereClientTypes.InstanceProperty]()
            for structure0 in instancePropertiesContainer {
                if let structure0 = structure0 {
                    instancePropertiesDecoded0?.append(structure0)
                }
            }
        }
        instanceProperties = instancePropertiesDecoded0
    }
}

extension RolesAnywhereClientTypes {
    /// The state of the subject after a read or write operation.
    public struct SubjectDetail: Swift.Equatable {
        /// The ISO-8601 timestamp when the subject was created.
        public var createdAt: ClientRuntime.Date?
        /// The temporary session credentials vended at the last authenticating call with this Subject.
        public var credentials: [RolesAnywhereClientTypes.CredentialSummary]?
        /// The enabled status of the subject.
        public var enabled: Swift.Bool?
        /// The specified instance properties associated with the request.
        public var instanceProperties: [RolesAnywhereClientTypes.InstanceProperty]?
        /// The ISO-8601 timestamp of the last time this Subject requested temporary session credentials.
        public var lastSeenAt: ClientRuntime.Date?
        /// The ARN of the resource.
        public var subjectArn: Swift.String?
        /// The id of the resource
        public var subjectId: Swift.String?
        /// The ISO-8601 timestamp when the subject was last updated.
        public var updatedAt: ClientRuntime.Date?
        /// The x509 principal identifier of the authenticating certificate.
        public var x509Subject: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            credentials: [RolesAnywhereClientTypes.CredentialSummary]? = nil,
            enabled: Swift.Bool? = nil,
            instanceProperties: [RolesAnywhereClientTypes.InstanceProperty]? = nil,
            lastSeenAt: ClientRuntime.Date? = nil,
            subjectArn: Swift.String? = nil,
            subjectId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            x509Subject: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.credentials = credentials
            self.enabled = enabled
            self.instanceProperties = instanceProperties
            self.lastSeenAt = lastSeenAt
            self.subjectArn = subjectArn
            self.subjectId = subjectId
            self.updatedAt = updatedAt
            self.x509Subject = x509Subject
        }
    }

}

extension RolesAnywhereClientTypes.SubjectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case enabled
        case lastSeenAt
        case subjectArn
        case subjectId
        case updatedAt
        case x509Subject
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let lastSeenAt = self.lastSeenAt {
            try encodeContainer.encodeTimestamp(lastSeenAt, format: .dateTime, forKey: .lastSeenAt)
        }
        if let subjectArn = self.subjectArn {
            try encodeContainer.encode(subjectArn, forKey: .subjectArn)
        }
        if let subjectId = self.subjectId {
            try encodeContainer.encode(subjectId, forKey: .subjectId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let x509Subject = self.x509Subject {
            try encodeContainer.encode(x509Subject, forKey: .x509Subject)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectArn)
        subjectArn = subjectArnDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let x509SubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .x509Subject)
        x509Subject = x509SubjectDecoded
        let lastSeenAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastSeenAt)
        lastSeenAt = lastSeenAtDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// A summary representation of Subject resources returned in read operations; primarily ListSubjects.
    public struct SubjectSummary: Swift.Equatable {
        /// The ISO-8601 time stamp of when the certificate was first used in a [CreateSession](https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html) operation.
        public var createdAt: ClientRuntime.Date?
        /// The enabled status of the Subject.
        public var enabled: Swift.Bool?
        /// The ISO-8601 time stamp of when the certificate was last used in a [CreateSession](https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html) operation.
        public var lastSeenAt: ClientRuntime.Date?
        /// The ARN of the resource.
        public var subjectArn: Swift.String?
        /// The id of the resource.
        public var subjectId: Swift.String?
        /// The ISO-8601 timestamp when the subject was last updated.
        public var updatedAt: ClientRuntime.Date?
        /// The x509 principal identifier of the authenticating certificate.
        public var x509Subject: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            enabled: Swift.Bool? = nil,
            lastSeenAt: ClientRuntime.Date? = nil,
            subjectArn: Swift.String? = nil,
            subjectId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            x509Subject: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.enabled = enabled
            self.lastSeenAt = lastSeenAt
            self.subjectArn = subjectArn
            self.subjectId = subjectId
            self.updatedAt = updatedAt
            self.x509Subject = x509Subject
        }
    }

}

extension RolesAnywhereClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RolesAnywhereClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension RolesAnywhereClientTypes {
    /// A label that consists of a key and value you define.
    public struct Tag: Swift.Equatable {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TagResource"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to attach to the resource.
    /// This member is required.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [RolesAnywhereClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RolesAnywhereClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RolesAnywhereClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Too many tags.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RolesAnywhereClientTypes.TrustAnchorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case enabled
        case name
        case source
        case trustAnchorArn
        case trustAnchorId
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let trustAnchorArn = self.trustAnchorArn {
            try encodeContainer.encode(trustAnchorArn, forKey: .trustAnchorArn)
        }
        if let trustAnchorId = self.trustAnchorId {
            try encodeContainer.encode(trustAnchorId, forKey: .trustAnchorId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustAnchorId)
        trustAnchorId = trustAnchorIdDecoded
        let trustAnchorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustAnchorArn)
        trustAnchorArn = trustAnchorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// The state of the trust anchor after a read or write operation.
    public struct TrustAnchorDetail: Swift.Equatable {
        /// The ISO-8601 timestamp when the trust anchor was created.
        public var createdAt: ClientRuntime.Date?
        /// Indicates whether the trust anchor is enabled.
        public var enabled: Swift.Bool?
        /// The name of the trust anchor.
        public var name: Swift.String?
        /// The trust anchor type and its related certificate data.
        public var source: RolesAnywhereClientTypes.Source?
        /// The ARN of the trust anchor.
        public var trustAnchorArn: Swift.String?
        /// The unique identifier of the trust anchor.
        public var trustAnchorId: Swift.String?
        /// The ISO-8601 timestamp when the trust anchor was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            enabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            source: RolesAnywhereClientTypes.Source? = nil,
            trustAnchorArn: Swift.String? = nil,
            trustAnchorId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.enabled = enabled
            self.name = name
            self.source = source
            self.trustAnchorArn = trustAnchorArn
            self.trustAnchorId = trustAnchorId
            self.updatedAt = updatedAt
        }
    }

}

extension RolesAnywhereClientTypes {
    public enum TrustAnchorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsAcmPca
        case certificateBundle
        case selfSignedRepository
        case sdkUnknown(Swift.String)

        public static var allCases: [TrustAnchorType] {
            return [
                .awsAcmPca,
                .certificateBundle,
                .selfSignedRepository,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsAcmPca: return "AWS_ACM_PCA"
            case .certificateBundle: return "CERTIFICATE_BUNDLE"
            case .selfSignedRepository: return "SELF_SIGNED_REPOSITORY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrustAnchorType(rawValue: rawValue) ?? TrustAnchorType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UntagResource"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys. Tag keys are the unique identifiers of tags.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateCrlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crlData
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crlData = self.crlData {
            try encodeContainer.encode(crlData.base64EncodedString(), forKey: .crlData)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateCrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let crlId = crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())"
    }
}

public struct UpdateCrlInput: Swift.Equatable {
    /// The x509 v3 specified certificate revocation list
    public var crlData: ClientRuntime.Data?
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?
    /// The name of the Crl.
    public var name: Swift.String?

    public init (
        crlData: ClientRuntime.Data? = nil,
        crlId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.crlData = crlData
        self.crlId = crlId
        self.name = name
    }
}

struct UpdateCrlInputBody: Swift.Equatable {
    let name: Swift.String?
    let crlData: ClientRuntime.Data?
}

extension UpdateCrlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crlData
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let crlDataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .crlData)
        crlData = crlDataDecoded
    }
}

extension UpdateCrlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCrlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateCrlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateCrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crl = output.crl
        } else {
            self.crl = nil
        }
    }
}

public struct UpdateCrlOutputResponse: Swift.Equatable {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init (
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

struct UpdateCrlOutputResponseBody: Swift.Equatable {
    let crl: RolesAnywhereClientTypes.CrlDetail?
}

extension UpdateCrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.CrlDetail.self, forKey: .crl)
        crl = crlDecoded
    }
}

extension UpdateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationSeconds
        case managedPolicyArns
        case name
        case roleArns
        case sessionPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let managedPolicyArns = managedPolicyArns {
            var managedPolicyArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedPolicyArns)
            for string0 in managedPolicyArns {
                try managedPolicyArnsContainer.encode(string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArns = roleArns {
            var roleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roleArns)
            for rolearn0 in roleArns {
                try roleArnsContainer.encode(rolearn0)
            }
        }
        if let sessionPolicy = self.sessionPolicy {
            try encodeContainer.encode(sessionPolicy, forKey: .sessionPolicy)
        }
    }
}

extension UpdateProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileId = profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())"
    }
}

public struct UpdateProfileInput: Swift.Equatable {
    /// The number of seconds the vended session credentials are valid for.
    public var durationSeconds: Swift.Int?
    /// A list of managed policy ARNs that apply to the vended session credentials.
    public var managedPolicyArns: [Swift.String]?
    /// The name of the profile.
    public var name: Swift.String?
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// A list of IAM roles that this profile can assume in a [CreateSession](https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html) operation.
    public var roleArns: [Swift.String]?
    /// A session policy that applies to the trust boundary of the vended session credentials.
    public var sessionPolicy: Swift.String?

    public init (
        durationSeconds: Swift.Int? = nil,
        managedPolicyArns: [Swift.String]? = nil,
        name: Swift.String? = nil,
        profileId: Swift.String? = nil,
        roleArns: [Swift.String]? = nil,
        sessionPolicy: Swift.String? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.managedPolicyArns = managedPolicyArns
        self.name = name
        self.profileId = profileId
        self.roleArns = roleArns
        self.sessionPolicy = sessionPolicy
    }
}

struct UpdateProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let sessionPolicy: Swift.String?
    let roleArns: [Swift.String]?
    let managedPolicyArns: [Swift.String]?
    let durationSeconds: Swift.Int?
}

extension UpdateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationSeconds
        case managedPolicyArns
        case name
        case roleArns
        case sessionPolicy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sessionPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionPolicy)
        sessionPolicy = sessionPolicyDecoded
        let roleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .roleArns)
        var roleArnsDecoded0:[Swift.String]? = nil
        if let roleArnsContainer = roleArnsContainer {
            roleArnsDecoded0 = [Swift.String]()
            for string0 in roleArnsContainer {
                if let string0 = string0 {
                    roleArnsDecoded0?.append(string0)
                }
            }
        }
        roleArns = roleArnsDecoded0
        let managedPolicyArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .managedPolicyArns)
        var managedPolicyArnsDecoded0:[Swift.String]? = nil
        if let managedPolicyArnsContainer = managedPolicyArnsContainer {
            managedPolicyArnsDecoded0 = [Swift.String]()
            for string0 in managedPolicyArnsContainer {
                if let string0 = string0 {
                    managedPolicyArnsDecoded0?.append(string0)
                }
            }
        }
        managedPolicyArns = managedPolicyArnsDecoded0
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
    }
}

extension UpdateProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct UpdateProfileOutputResponse: Swift.Equatable {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init (
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

struct UpdateProfileOutputResponseBody: Swift.Equatable {
    let profile: RolesAnywhereClientTypes.ProfileDetail?
}

extension UpdateProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.ProfileDetail.self, forKey: .profile)
        profile = profileDecoded
    }
}

extension UpdateTrustAnchorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }
}

extension UpdateTrustAnchorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustAnchorId = trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())"
    }
}

public struct UpdateTrustAnchorInput: Swift.Equatable {
    /// The name of the trust anchor.
    public var name: Swift.String?
    /// The trust anchor type and its related certificate data.
    public var source: RolesAnywhereClientTypes.Source?
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init (
        name: Swift.String? = nil,
        source: RolesAnywhereClientTypes.Source? = nil,
        trustAnchorId: Swift.String? = nil
    )
    {
        self.name = name
        self.source = source
        self.trustAnchorId = trustAnchorId
    }
}

struct UpdateTrustAnchorInputBody: Swift.Equatable {
    let name: Swift.String?
    let source: RolesAnywhereClientTypes.Source?
}

extension UpdateTrustAnchorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case source
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
    }
}

extension UpdateTrustAnchorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTrustAnchorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateTrustAnchorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTrustAnchorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateTrustAnchorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trustAnchor = output.trustAnchor
        } else {
            self.trustAnchor = nil
        }
    }
}

public struct UpdateTrustAnchorOutputResponse: Swift.Equatable {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init (
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

struct UpdateTrustAnchorOutputResponseBody: Swift.Equatable {
    let trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?
}

extension UpdateTrustAnchorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustAnchor
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorDetail.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Validation exception error.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
