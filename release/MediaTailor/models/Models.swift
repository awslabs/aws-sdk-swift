// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessType = "AccessType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessType = accessType {
            try encodeContainer.encode(accessType.rawValue, forKey: .accessType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTypeDecoded = try containerValues.decodeIfPresent(AccessType.self, forKey: .accessType)
        accessType = accessTypeDecoded
    }
}

extension AccessConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessConfiguration(accessType: \(String(describing: accessType)))"}
}

/// <p>Access configuration parameters.</p>
public struct AccessConfiguration: Equatable {
    /// <p>The type of authentication used to access content from HttpConfiguration::BaseUrl on your source location. Accepted value: S3_SIGV4.</p> <p>S3_SIGV4 - AWS Signature Version 4 authentication for Amazon S3 hosted virtual-style access. If your source location base URL is an Amazon S3 bucket, MediaTailor can use AWS Signature Version 4 (SigV4) authentication to access the bucket where your source content is stored. Your MediaTailor source location baseURL must follow the S3 virtual hosted-style request URL format. For example, https://bucket-name.s3.Region.amazonaws.com/key-name.</p> <p>Before you can use S3_SIGV4, you must meet these requirements:</p> <p>• You must allow MediaTailor to access your S3 bucket by granting mediatailor.amazonaws.com principal access in IAM. For information about configuring access in IAM, see Access management in the IAM User Guide.</p> <p>• The mediatailor.amazonaws.com service principal must have permissions to read all top level manifests referenced by the VodSource packaging configurations.</p> <p>• The caller of the API must have s3:GetObject IAM permissions to read all top level manifests referenced by your MediaTailor VodSource packaging configurations.</p>
    public let accessType: AccessType?

    public init (
        accessType: AccessType? = nil
    )
    {
        self.accessType = accessType
    }
}

public enum AccessType {
    case s3Sigv4
    case sdkUnknown(String)
}

extension AccessType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccessType] {
        return [
            .s3Sigv4,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .s3Sigv4: return "S3_SIGV4"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccessType(rawValue: rawValue) ?? AccessType.sdkUnknown(rawValue)
    }
}

extension AdBreak: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case messageType = "MessageType"
        case offsetMillis = "OffsetMillis"
        case slate = "Slate"
        case spliceInsertMessage = "SpliceInsertMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageType = messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if offsetMillis != 0 {
            try encodeContainer.encode(offsetMillis, forKey: .offsetMillis)
        }
        if let slate = slate {
            try encodeContainer.encode(slate, forKey: .slate)
        }
        if let spliceInsertMessage = spliceInsertMessage {
            try encodeContainer.encode(spliceInsertMessage, forKey: .spliceInsertMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageTypeDecoded = try containerValues.decodeIfPresent(MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let offsetMillisDecoded = try containerValues.decode(Int.self, forKey: .offsetMillis)
        offsetMillis = offsetMillisDecoded
        let slateDecoded = try containerValues.decodeIfPresent(SlateSource.self, forKey: .slate)
        slate = slateDecoded
        let spliceInsertMessageDecoded = try containerValues.decodeIfPresent(SpliceInsertMessage.self, forKey: .spliceInsertMessage)
        spliceInsertMessage = spliceInsertMessageDecoded
    }
}

extension AdBreak: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdBreak(messageType: \(String(describing: messageType)), offsetMillis: \(String(describing: offsetMillis)), slate: \(String(describing: slate)), spliceInsertMessage: \(String(describing: spliceInsertMessage)))"}
}

/// <p>Ad break configuration parameters.</p>
public struct AdBreak: Equatable {
    /// <p>The SCTE-35 ad insertion type. Accepted value: SPLICE_INSERT.</p>
    public let messageType: MessageType?
    /// <p>How long (in milliseconds) after the beginning of the program that an ad starts. This value must fall within 100ms of a segment boundary, otherwise the ad break will be skipped.</p>
    public let offsetMillis: Int
    /// <p>Ad break slate configuration.</p>
    public let slate: SlateSource?
    /// <p>This defines the SCTE-35 splice_insert() message inserted around the ad. For information about using splice_insert(), see the SCTE-35 specficiaiton, section 9.7.3.1.</p>
    public let spliceInsertMessage: SpliceInsertMessage?

    public init (
        messageType: MessageType? = nil,
        offsetMillis: Int = 0,
        slate: SlateSource? = nil,
        spliceInsertMessage: SpliceInsertMessage? = nil
    )
    {
        self.messageType = messageType
        self.offsetMillis = offsetMillis
        self.slate = slate
        self.spliceInsertMessage = spliceInsertMessage
    }
}

extension AdMarkerPassthrough: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AdMarkerPassthrough: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdMarkerPassthrough(enabled: \(String(describing: enabled)))"}
}

/// <p>For HLS, when set to true, MediaTailor passes through EXT-X-CUE-IN, EXT-X-CUE-OUT, and EXT-X-SPLICEPOINT-SCTE35 ad markers from the origin manifest to the MediaTailor personalized manifest.</p> <p>No logic is applied to these ad markers. For example, if EXT-X-CUE-OUT has a value of 60, but no ads are filled for that ad break, MediaTailor will not set the value to 0.</p>
public struct AdMarkerPassthrough: Equatable {
    /// <p>Enables ad marker passthrough for your configuration.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

extension AvailSuppression: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mode = "Mode"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(Mode.self, forKey: .mode)
        mode = modeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AvailSuppression: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AvailSuppression(mode: \(String(describing: mode)), value: \(String(describing: value)))"}
}

/// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
public struct AvailSuppression: Equatable {
    /// <p>Sets the ad suppression mode. By default, ad suppression is off and all ad breaks are filled with ads or slate. When Mode is set to BEHIND_LIVE_EDGE, ad suppression is active and MediaTailor won't fill ad breaks on or behind the ad suppression Value time in the manifest lookback window.</p>
    public let mode: Mode?
    /// <p>A live edge offset time in HH:MM:SS. MediaTailor won't fill ad breaks on or behind this time in the manifest lookback window. If Value is set to 00:00:00, it is in sync with the live edge, and MediaTailor won't fill any ad breaks on or behind the live edge. If you set a Value time, MediaTailor won't fill any ad breaks on or behind this time in the manifest lookback window. For example, if you set 00:45:00, then MediaTailor will fill ad breaks that occur within 45 minutes behind the live edge, but won't fill ad breaks on or behind 45 minutes behind the live edge.</p>
    public let value: String?

    public init (
        mode: Mode? = nil,
        value: String? = nil
    )
    {
        self.mode = mode
        self.value = value
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Invalid request parameters.
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Bumper: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endUrl = "EndUrl"
        case startUrl = "StartUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endUrl = endUrl {
            try encodeContainer.encode(endUrl, forKey: .endUrl)
        }
        if let startUrl = startUrl {
            try encodeContainer.encode(startUrl, forKey: .startUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endUrl)
        endUrl = endUrlDecoded
        let startUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startUrl)
        startUrl = startUrlDecoded
    }
}

extension Bumper: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Bumper(endUrl: \(String(describing: endUrl)), startUrl: \(String(describing: startUrl)))"}
}

/// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
public struct Bumper: Equatable {
    /// <p>The URL for the end bumper asset.</p>
    public let endUrl: String?
    /// <p>The URL for the start bumper asset.</p>
    public let startUrl: String?

    public init (
        endUrl: String? = nil,
        startUrl: String? = nil
    )
    {
        self.endUrl = endUrl
        self.startUrl = startUrl
    }
}

extension CdnConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adSegmentUrlPrefix = "AdSegmentUrlPrefix"
        case contentSegmentUrlPrefix = "ContentSegmentUrlPrefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adSegmentUrlPrefix = adSegmentUrlPrefix {
            try encodeContainer.encode(adSegmentUrlPrefix, forKey: .adSegmentUrlPrefix)
        }
        if let contentSegmentUrlPrefix = contentSegmentUrlPrefix {
            try encodeContainer.encode(contentSegmentUrlPrefix, forKey: .contentSegmentUrlPrefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adSegmentUrlPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adSegmentUrlPrefix)
        adSegmentUrlPrefix = adSegmentUrlPrefixDecoded
        let contentSegmentUrlPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentSegmentUrlPrefix)
        contentSegmentUrlPrefix = contentSegmentUrlPrefixDecoded
    }
}

extension CdnConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CdnConfiguration(adSegmentUrlPrefix: \(String(describing: adSegmentUrlPrefix)), contentSegmentUrlPrefix: \(String(describing: contentSegmentUrlPrefix)))"}
}

/// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
public struct CdnConfiguration: Equatable {
    /// <p>A non-default content delivery network (CDN) to serve ad segments. By default, AWS Elemental MediaTailor uses Amazon CloudFront with default cache settings as its CDN for ad segments. To set up an alternate CDN, create a rule in your CDN for the origin ads.mediatailor.&amp;lt;region&gt;.amazonaws.com. Then specify the rule's name in this AdSegmentUrlPrefix. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for ad segments.</p>
    public let adSegmentUrlPrefix: String?
    /// <p>A content delivery network (CDN) to cache content segments, so that content requests don’t always have to go to the origin server. First, create a rule in your CDN for the content segment origin server. Then specify the rule's name in this ContentSegmentUrlPrefix. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for content segments.</p>
    public let contentSegmentUrlPrefix: String?

    public init (
        adSegmentUrlPrefix: String? = nil,
        contentSegmentUrlPrefix: String? = nil
    )
    {
        self.adSegmentUrlPrefix = adSegmentUrlPrefix
        self.contentSegmentUrlPrefix = contentSegmentUrlPrefix
    }
}

extension Channel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case channelName = "ChannelName"
        case channelState = "ChannelState"
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelState = channelState {
            try encodeContainer.encode(channelState, forKey: .channelState)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for responseoutputs0 in outputs {
                try outputsContainer.encode(responseoutputs0)
            }
        }
        if let playbackMode = playbackMode {
            try encodeContainer.encode(playbackMode, forKey: .playbackMode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelState)
        channelState = channelStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ResponseOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[ResponseOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ResponseOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let playbackModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Channel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Channel(arn: \(String(describing: arn)), channelName: \(String(describing: channelName)), channelState: \(String(describing: channelState)), creationTime: \(String(describing: creationTime)), lastModifiedTime: \(String(describing: lastModifiedTime)), outputs: \(String(describing: outputs)), playbackMode: \(String(describing: playbackMode)), tags: \(String(describing: tags)))"}
}

/// <p>The configuration parameters for a channel.</p>
public struct Channel: Equatable {
    /// <p>The ARN of the channel.</p>
    public let arn: String?
    /// <p>The name of the channel.</p>
    public let channelName: String?
    /// <p>Returns the state whether the channel is running or not.</p>
    public let channelState: String?
    /// <p>The timestamp of when the channel was created.</p>
    public let creationTime: Date?
    /// <p>The timestamp of when the channel was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The channel's output properties.</p>
    public let outputs: [ResponseOutputItem]?
    /// <p>The type of playback mode for this channel. Possible values: ONCE or LOOP.</p>
    public let playbackMode: String?
    /// <p>The tags to assign to the channel.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        channelName: String? = nil,
        channelState: String? = nil,
        creationTime: Date? = nil,
        lastModifiedTime: Date? = nil,
        outputs: [ResponseOutputItem]? = nil,
        playbackMode: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.channelName = channelName
        self.channelState = channelState
        self.creationTime = creationTime
        self.lastModifiedTime = lastModifiedTime
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
    }
}

public enum ChannelState {
    case running
    case stopped
    case sdkUnknown(String)
}

extension ChannelState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChannelState] {
        return [
            .running,
            .stopped,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .running: return "RUNNING"
        case .stopped: return "STOPPED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChannelState(rawValue: rawValue) ?? ChannelState.sdkUnknown(rawValue)
    }
}

public struct CreateChannelInputBodyMiddleware: Middleware {
    public let id: String = "CreateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChannelInput>
    public typealias MOutput = OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChannelOutputError>
}

extension CreateChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateChannelInput(channelName: \(String(describing: channelName)), outputs: \(String(describing: outputs)), playbackMode: \(String(describing: playbackMode)), tags: \(String(describing: tags)))"}
}

extension CreateChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for requestoutputs0 in outputs {
                try outputsContainer.encode(requestoutputs0)
            }
        }
        if let playbackMode = playbackMode {
            try encodeContainer.encode(playbackMode.rawValue, forKey: .playbackMode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateChannelInputHeadersMiddleware: Middleware {
    public let id: String = "CreateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChannelInput>
    public typealias MOutput = OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChannelInput>
    public typealias MOutput = OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChannelOutputError>
}

public struct CreateChannelInput: Equatable {
    /// <p>The identifier for the channel you are working on.</p>
    public let channelName: String?
    /// <p>The channel's output properties.</p>
    public let outputs: [RequestOutputItem]?
    /// <p>The type of playback mode for this channel. The only supported value is LOOP.</p>
    public let playbackMode: PlaybackMode?
    /// <p>The tags to assign to the channel.</p>
    public let tags: [String:String]?

    public init (
        channelName: String? = nil,
        outputs: [RequestOutputItem]? = nil,
        playbackMode: PlaybackMode? = nil,
        tags: [String:String]? = nil
    )
    {
        self.channelName = channelName
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
    }
}

struct CreateChannelInputBody: Equatable {
    public let outputs: [RequestOutputItem]?
    public let playbackMode: PlaybackMode?
    public let tags: [String:String]?
}

extension CreateChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputsContainer = try containerValues.decodeIfPresent([RequestOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[RequestOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [RequestOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let playbackModeDecoded = try containerValues.decodeIfPresent(PlaybackMode.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateChannelOutputResponse(arn: \(String(describing: arn)), channelName: \(String(describing: channelName)), channelState: \(String(describing: channelState)), creationTime: \(String(describing: creationTime)), lastModifiedTime: \(String(describing: lastModifiedTime)), outputs: \(String(describing: outputs)), playbackMode: \(String(describing: playbackMode)), tags: \(String(describing: tags)))"}
}

extension CreateChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.channelName = output.channelName
            self.channelState = output.channelState
            self.creationTime = output.creationTime
            self.lastModifiedTime = output.lastModifiedTime
            self.outputs = output.outputs
            self.playbackMode = output.playbackMode
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelName = nil
            self.channelState = nil
            self.creationTime = nil
            self.lastModifiedTime = nil
            self.outputs = nil
            self.playbackMode = nil
            self.tags = nil
        }
    }
}

public struct CreateChannelOutputResponse: Equatable {
    /// <p>The ARN of the channel.</p>
    public let arn: String?
    /// <p>The name of the channel.</p>
    public let channelName: String?
    /// <p>Indicates whether the channel is in a running state or not.</p>
    public let channelState: ChannelState?
    /// <p>The timestamp of when the channel was created.</p>
    public let creationTime: Date?
    /// <p>The timestamp of when the channel was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The channel's output properties.</p>
    public let outputs: [ResponseOutputItem]?
    /// <p>The type of playback for this channel. The only supported value is LOOP.</p>
    public let playbackMode: String?
    /// <p>The tags assigned to the channel.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        channelName: String? = nil,
        channelState: ChannelState? = nil,
        creationTime: Date? = nil,
        lastModifiedTime: Date? = nil,
        outputs: [ResponseOutputItem]? = nil,
        playbackMode: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.channelName = channelName
        self.channelState = channelState
        self.creationTime = creationTime
        self.lastModifiedTime = lastModifiedTime
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
    }
}

struct CreateChannelOutputResponseBody: Equatable {
    public let arn: String?
    public let channelName: String?
    public let channelState: ChannelState?
    public let creationTime: Date?
    public let lastModifiedTime: Date?
    public let outputs: [ResponseOutputItem]?
    public let playbackMode: String?
    public let tags: [String:String]?
}

extension CreateChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case channelName = "ChannelName"
        case channelState = "ChannelState"
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStateDecoded = try containerValues.decodeIfPresent(ChannelState.self, forKey: .channelState)
        channelState = channelStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ResponseOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[ResponseOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ResponseOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let playbackModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateProgramInputBodyMiddleware: Middleware {
    public let id: String = "CreateProgramInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProgramInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProgramInput>
    public typealias MOutput = OperationOutput<CreateProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProgramOutputError>
}

extension CreateProgramInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProgramInput(adBreaks: \(String(describing: adBreaks)), channelName: \(String(describing: channelName)), programName: \(String(describing: programName)), scheduleConfiguration: \(String(describing: scheduleConfiguration)), sourceLocationName: \(String(describing: sourceLocationName)), vodSourceName: \(String(describing: vodSourceName)))"}
}

extension CreateProgramInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adBreaks = "AdBreaks"
        case scheduleConfiguration = "ScheduleConfiguration"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adBreaks = adBreaks {
            var adBreaksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adBreaks)
            for __listofadbreak0 in adBreaks {
                try adBreaksContainer.encode(__listofadbreak0)
            }
        }
        if let scheduleConfiguration = scheduleConfiguration {
            try encodeContainer.encode(scheduleConfiguration, forKey: .scheduleConfiguration)
        }
        if let sourceLocationName = sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let vodSourceName = vodSourceName {
            try encodeContainer.encode(vodSourceName, forKey: .vodSourceName)
        }
    }
}

public struct CreateProgramInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProgramInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProgramInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProgramInput>
    public typealias MOutput = OperationOutput<CreateProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProgramOutputError>
}

public struct CreateProgramInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProgramInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProgramInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProgramInput>
    public typealias MOutput = OperationOutput<CreateProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProgramOutputError>
}

public struct CreateProgramInput: Equatable {
    /// <p>The ad break configuration settings.</p>
    public let adBreaks: [AdBreak]?
    /// <p>The identifier for the channel you are working on.</p>
    public let channelName: String?
    /// <p>The identifier for the program you are working on.</p>
    public let programName: String?
    /// <p>The schedule configuration settings.</p>
    public let scheduleConfiguration: ScheduleConfiguration?
    /// <p>The name of the source location.</p>
    public let sourceLocationName: String?
    /// <p>The name that's used to refer to a VOD source.</p>
    public let vodSourceName: String?

    public init (
        adBreaks: [AdBreak]? = nil,
        channelName: String? = nil,
        programName: String? = nil,
        scheduleConfiguration: ScheduleConfiguration? = nil,
        sourceLocationName: String? = nil,
        vodSourceName: String? = nil
    )
    {
        self.adBreaks = adBreaks
        self.channelName = channelName
        self.programName = programName
        self.scheduleConfiguration = scheduleConfiguration
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct CreateProgramInputBody: Equatable {
    public let adBreaks: [AdBreak]?
    public let scheduleConfiguration: ScheduleConfiguration?
    public let sourceLocationName: String?
    public let vodSourceName: String?
}

extension CreateProgramInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adBreaks = "AdBreaks"
        case scheduleConfiguration = "ScheduleConfiguration"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adBreaksContainer = try containerValues.decodeIfPresent([AdBreak?].self, forKey: .adBreaks)
        var adBreaksDecoded0:[AdBreak]? = nil
        if let adBreaksContainer = adBreaksContainer {
            adBreaksDecoded0 = [AdBreak]()
            for structure0 in adBreaksContainer {
                if let structure0 = structure0 {
                    adBreaksDecoded0?.append(structure0)
                }
            }
        }
        adBreaks = adBreaksDecoded0
        let scheduleConfigurationDecoded = try containerValues.decodeIfPresent(ScheduleConfiguration.self, forKey: .scheduleConfiguration)
        scheduleConfiguration = scheduleConfigurationDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension CreateProgramOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProgramOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProgramOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProgramOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProgramOutputResponse(adBreaks: \(String(describing: adBreaks)), arn: \(String(describing: arn)), channelName: \(String(describing: channelName)), creationTime: \(String(describing: creationTime)), programName: \(String(describing: programName)), sourceLocationName: \(String(describing: sourceLocationName)), vodSourceName: \(String(describing: vodSourceName)))"}
}

extension CreateProgramOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProgramOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.adBreaks = output.adBreaks
            self.arn = output.arn
            self.channelName = output.channelName
            self.creationTime = output.creationTime
            self.programName = output.programName
            self.sourceLocationName = output.sourceLocationName
            self.vodSourceName = output.vodSourceName
        } else {
            self.adBreaks = nil
            self.arn = nil
            self.channelName = nil
            self.creationTime = nil
            self.programName = nil
            self.sourceLocationName = nil
            self.vodSourceName = nil
        }
    }
}

public struct CreateProgramOutputResponse: Equatable {
    /// <p>The ad break configuration settings.</p>
    public let adBreaks: [AdBreak]?
    /// <p>The ARN of the program.</p>
    public let arn: String?
    /// <p>The name of the channel that the program belongs to.</p>
    public let channelName: String?
    /// <p>The timestamp of when the program was created.</p>
    public let creationTime: Date?
    /// <p>The name of the program.</p>
    public let programName: String?
    /// <p>The source location name.</p>
    public let sourceLocationName: String?
    /// <p>The name that's used to refer to a VOD source.</p>
    public let vodSourceName: String?

    public init (
        adBreaks: [AdBreak]? = nil,
        arn: String? = nil,
        channelName: String? = nil,
        creationTime: Date? = nil,
        programName: String? = nil,
        sourceLocationName: String? = nil,
        vodSourceName: String? = nil
    )
    {
        self.adBreaks = adBreaks
        self.arn = arn
        self.channelName = channelName
        self.creationTime = creationTime
        self.programName = programName
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct CreateProgramOutputResponseBody: Equatable {
    public let adBreaks: [AdBreak]?
    public let arn: String?
    public let channelName: String?
    public let creationTime: Date?
    public let programName: String?
    public let sourceLocationName: String?
    public let vodSourceName: String?
}

extension CreateProgramOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adBreaks = "AdBreaks"
        case arn = "Arn"
        case channelName = "ChannelName"
        case creationTime = "CreationTime"
        case programName = "ProgramName"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adBreaksContainer = try containerValues.decodeIfPresent([AdBreak?].self, forKey: .adBreaks)
        var adBreaksDecoded0:[AdBreak]? = nil
        if let adBreaksContainer = adBreaksContainer {
            adBreaksDecoded0 = [AdBreak]()
            for structure0 in adBreaksContainer {
                if let structure0 = structure0 {
                    adBreaksDecoded0?.append(structure0)
                }
            }
        }
        adBreaks = adBreaksDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let programNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .programName)
        programName = programNameDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

public struct CreateSourceLocationInputBodyMiddleware: Middleware {
    public let id: String = "CreateSourceLocationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSourceLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSourceLocationInput>
    public typealias MOutput = OperationOutput<CreateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSourceLocationOutputError>
}

extension CreateSourceLocationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSourceLocationInput(accessConfiguration: \(String(describing: accessConfiguration)), defaultSegmentDeliveryConfiguration: \(String(describing: defaultSegmentDeliveryConfiguration)), httpConfiguration: \(String(describing: httpConfiguration)), sourceLocationName: \(String(describing: sourceLocationName)), tags: \(String(describing: tags)))"}
}

extension CreateSourceLocationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessConfiguration = accessConfiguration {
            try encodeContainer.encode(accessConfiguration, forKey: .accessConfiguration)
        }
        if let defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration {
            try encodeContainer.encode(defaultSegmentDeliveryConfiguration, forKey: .defaultSegmentDeliveryConfiguration)
        }
        if let httpConfiguration = httpConfiguration {
            try encodeContainer.encode(httpConfiguration, forKey: .httpConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateSourceLocationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSourceLocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSourceLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSourceLocationInput>
    public typealias MOutput = OperationOutput<CreateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSourceLocationOutputError>
}

public struct CreateSourceLocationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSourceLocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSourceLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSourceLocationInput>
    public typealias MOutput = OperationOutput<CreateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSourceLocationOutputError>
}

public struct CreateSourceLocationInput: Equatable {
    /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
    public let accessConfiguration: AccessConfiguration?
    /// <p>The optional configuration for the server that serves segments.</p>
    public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
    /// <p>The source's HTTP package configurations.</p>
    public let httpConfiguration: HttpConfiguration?
    /// <p>The identifier for the source location you are working on.</p>
    public let sourceLocationName: String?
    /// <p>The tags to assign to the source location.</p>
    public let tags: [String:String]?

    public init (
        accessConfiguration: AccessConfiguration? = nil,
        defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: HttpConfiguration? = nil,
        sourceLocationName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct CreateSourceLocationInputBody: Equatable {
    public let accessConfiguration: AccessConfiguration?
    public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
    public let httpConfiguration: HttpConfiguration?
    public let tags: [String:String]?
}

extension CreateSourceLocationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSourceLocationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSourceLocationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSourceLocationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSourceLocationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSourceLocationOutputResponse(accessConfiguration: \(String(describing: accessConfiguration)), arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), defaultSegmentDeliveryConfiguration: \(String(describing: defaultSegmentDeliveryConfiguration)), httpConfiguration: \(String(describing: httpConfiguration)), lastModifiedTime: \(String(describing: lastModifiedTime)), sourceLocationName: \(String(describing: sourceLocationName)), tags: \(String(describing: tags)))"}
}

extension CreateSourceLocationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSourceLocationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessConfiguration = output.accessConfiguration
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.defaultSegmentDeliveryConfiguration = output.defaultSegmentDeliveryConfiguration
            self.httpConfiguration = output.httpConfiguration
            self.lastModifiedTime = output.lastModifiedTime
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
        } else {
            self.accessConfiguration = nil
            self.arn = nil
            self.creationTime = nil
            self.defaultSegmentDeliveryConfiguration = nil
            self.httpConfiguration = nil
            self.lastModifiedTime = nil
            self.sourceLocationName = nil
            self.tags = nil
        }
    }
}

public struct CreateSourceLocationOutputResponse: Equatable {
    /// <p>The access configuration for the source location.</p>
    public let accessConfiguration: AccessConfiguration?
    /// <p>The ARN of the source location.</p>
    public let arn: String?
    /// <p>The timestamp that indicates when the source location was created.</p>
    public let creationTime: Date?
    /// <p>The default segment delivery configuration settings.</p>
    public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
    /// <p>The HTTP package configuration settings for the source location.</p>
    public let httpConfiguration: HttpConfiguration?
    /// <p>The timestamp that indicates when the source location was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The name of the source location.</p>
    public let sourceLocationName: String?
    /// <p>The tags assigned to the source location.</p>
    public let tags: [String:String]?

    public init (
        accessConfiguration: AccessConfiguration? = nil,
        arn: String? = nil,
        creationTime: Date? = nil,
        defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: HttpConfiguration? = nil,
        lastModifiedTime: Date? = nil,
        sourceLocationName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.arn = arn
        self.creationTime = creationTime
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct CreateSourceLocationOutputResponseBody: Equatable {
    public let accessConfiguration: AccessConfiguration?
    public let arn: String?
    public let creationTime: Date?
    public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
    public let httpConfiguration: HttpConfiguration?
    public let lastModifiedTime: Date?
    public let sourceLocationName: String?
    public let tags: [String:String]?
}

extension CreateSourceLocationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case arn = "Arn"
        case creationTime = "CreationTime"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateVodSourceInputBodyMiddleware: Middleware {
    public let id: String = "CreateVodSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVodSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVodSourceInput>
    public typealias MOutput = OperationOutput<CreateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVodSourceOutputError>
}

extension CreateVodSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVodSourceInput(httpPackageConfigurations: \(String(describing: httpPackageConfigurations)), sourceLocationName: \(String(describing: sourceLocationName)), tags: \(String(describing: tags)), vodSourceName: \(String(describing: vodSourceName)))"}
}

extension CreateVodSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpPackageConfigurations = httpPackageConfigurations {
            var httpPackageConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpPackageConfigurations)
            for httppackageconfigurations0 in httpPackageConfigurations {
                try httpPackageConfigurationsContainer.encode(httppackageconfigurations0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateVodSourceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateVodSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVodSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVodSourceInput>
    public typealias MOutput = OperationOutput<CreateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVodSourceOutputError>
}

public struct CreateVodSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateVodSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVodSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVodSourceInput>
    public typealias MOutput = OperationOutput<CreateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVodSourceOutputError>
}

public struct CreateVodSourceInput: Equatable {
    /// <p>An array of HTTP package configuration parameters for this VOD source.</p>
    public let httpPackageConfigurations: [HttpPackageConfiguration]?
    /// <p>The identifier for the source location you are working on.</p>
    public let sourceLocationName: String?
    /// <p>The tags to assign to the VOD source.</p>
    public let tags: [String:String]?
    /// <p>The identifier for the VOD source you are working on.</p>
    public let vodSourceName: String?

    public init (
        httpPackageConfigurations: [HttpPackageConfiguration]? = nil,
        sourceLocationName: String? = nil,
        tags: [String:String]? = nil,
        vodSourceName: String? = nil
    )
    {
        self.httpPackageConfigurations = httpPackageConfigurations
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

struct CreateVodSourceInputBody: Equatable {
    public let httpPackageConfigurations: [HttpPackageConfiguration]?
    public let tags: [String:String]?
}

extension CreateVodSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVodSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVodSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVodSourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVodSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVodSourceOutputResponse(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), httpPackageConfigurations: \(String(describing: httpPackageConfigurations)), lastModifiedTime: \(String(describing: lastModifiedTime)), sourceLocationName: \(String(describing: sourceLocationName)), tags: \(String(describing: tags)), vodSourceName: \(String(describing: vodSourceName)))"}
}

extension CreateVodSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateVodSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.httpPackageConfigurations = output.httpPackageConfigurations
            self.lastModifiedTime = output.lastModifiedTime
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
            self.vodSourceName = output.vodSourceName
        } else {
            self.arn = nil
            self.creationTime = nil
            self.httpPackageConfigurations = nil
            self.lastModifiedTime = nil
            self.sourceLocationName = nil
            self.tags = nil
            self.vodSourceName = nil
        }
    }
}

public struct CreateVodSourceOutputResponse: Equatable {
    /// <p>The ARN of the VOD source.</p>
    public let arn: String?
    /// <p>The timestamp that indicates when the VOD source was created.</p>
    public let creationTime: Date?
    /// <p>The HTTP package configurations.</p>
    public let httpPackageConfigurations: [HttpPackageConfiguration]?
    /// <p>The ARN for the VOD source.</p>
    public let lastModifiedTime: Date?
    /// <p>The name of the source location associated with the VOD source.</p>
    public let sourceLocationName: String?
    /// <p>The tags assigned to the VOD source.</p>
    public let tags: [String:String]?
    /// <p>The name of the VOD source.</p>
    public let vodSourceName: String?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        httpPackageConfigurations: [HttpPackageConfiguration]? = nil,
        lastModifiedTime: Date? = nil,
        sourceLocationName: String? = nil,
        tags: [String:String]? = nil,
        vodSourceName: String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

struct CreateVodSourceOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTime: Date?
    public let httpPackageConfigurations: [HttpPackageConfiguration]?
    public let lastModifiedTime: Date?
    public let sourceLocationName: String?
    public let tags: [String:String]?
    public let vodSourceName: String?
}

extension CreateVodSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension DashConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case manifestEndpointPrefix = "ManifestEndpointPrefix"
        case mpdLocation = "MpdLocation"
        case originManifestType = "OriginManifestType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestEndpointPrefix = manifestEndpointPrefix {
            try encodeContainer.encode(manifestEndpointPrefix, forKey: .manifestEndpointPrefix)
        }
        if let mpdLocation = mpdLocation {
            try encodeContainer.encode(mpdLocation, forKey: .mpdLocation)
        }
        if let originManifestType = originManifestType {
            try encodeContainer.encode(originManifestType.rawValue, forKey: .originManifestType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestEndpointPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestEndpointPrefix)
        manifestEndpointPrefix = manifestEndpointPrefixDecoded
        let mpdLocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mpdLocation)
        mpdLocation = mpdLocationDecoded
        let originManifestTypeDecoded = try containerValues.decodeIfPresent(OriginManifestType.self, forKey: .originManifestType)
        originManifestType = originManifestTypeDecoded
    }
}

extension DashConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashConfiguration(manifestEndpointPrefix: \(String(describing: manifestEndpointPrefix)), mpdLocation: \(String(describing: mpdLocation)), originManifestType: \(String(describing: originManifestType)))"}
}

/// <p>The configuration for DASH content.</p>
public struct DashConfiguration: Equatable {
    /// <p>The URL generated by MediaTailor to initiate a playback session. The session uses server-side reporting. This setting is ignored in PUT operations.</p>
    public let manifestEndpointPrefix: String?
    /// <p>The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are DISABLED and EMT_DEFAULT. The EMT_DEFAULT setting enables the inclusion of the tag and is the default value.</p>
    public let mpdLocation: String?
    /// <p>The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to SINGLE_PERIOD. The default setting is MULTI_PERIOD. For multi-period manifests, omit this setting or set it to MULTI_PERIOD.</p>
    public let originManifestType: OriginManifestType?

    public init (
        manifestEndpointPrefix: String? = nil,
        mpdLocation: String? = nil,
        originManifestType: OriginManifestType? = nil
    )
    {
        self.manifestEndpointPrefix = manifestEndpointPrefix
        self.mpdLocation = mpdLocation
        self.originManifestType = originManifestType
    }
}

extension DashConfigurationForPut: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mpdLocation = "MpdLocation"
        case originManifestType = "OriginManifestType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mpdLocation = mpdLocation {
            try encodeContainer.encode(mpdLocation, forKey: .mpdLocation)
        }
        if let originManifestType = originManifestType {
            try encodeContainer.encode(originManifestType.rawValue, forKey: .originManifestType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mpdLocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mpdLocation)
        mpdLocation = mpdLocationDecoded
        let originManifestTypeDecoded = try containerValues.decodeIfPresent(OriginManifestType.self, forKey: .originManifestType)
        originManifestType = originManifestTypeDecoded
    }
}

extension DashConfigurationForPut: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashConfigurationForPut(mpdLocation: \(String(describing: mpdLocation)), originManifestType: \(String(describing: originManifestType)))"}
}

/// <p>The configuration for DASH PUT operations.</p>
public struct DashConfigurationForPut: Equatable {
    /// <p>The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are DISABLED and EMT_DEFAULT. The EMT_DEFAULT setting enables the inclusion of the tag and is the default value.</p>
    public let mpdLocation: String?
    /// <p>The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to SINGLE_PERIOD. The default setting is MULTI_PERIOD. For multi-period manifests, omit this setting or set it to MULTI_PERIOD.</p>
    public let originManifestType: OriginManifestType?

    public init (
        mpdLocation: String? = nil,
        originManifestType: OriginManifestType? = nil
    )
    {
        self.mpdLocation = mpdLocation
        self.originManifestType = originManifestType
    }
}

extension DashPlaylistSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case manifestWindowSeconds = "ManifestWindowSeconds"
        case minBufferTimeSeconds = "MinBufferTimeSeconds"
        case minUpdatePeriodSeconds = "MinUpdatePeriodSeconds"
        case suggestedPresentationDelaySeconds = "SuggestedPresentationDelaySeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if manifestWindowSeconds != 0 {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if minBufferTimeSeconds != 0 {
            try encodeContainer.encode(minBufferTimeSeconds, forKey: .minBufferTimeSeconds)
        }
        if minUpdatePeriodSeconds != 0 {
            try encodeContainer.encode(minUpdatePeriodSeconds, forKey: .minUpdatePeriodSeconds)
        }
        if suggestedPresentationDelaySeconds != 0 {
            try encodeContainer.encode(suggestedPresentationDelaySeconds, forKey: .suggestedPresentationDelaySeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestWindowSecondsDecoded = try containerValues.decode(Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let minBufferTimeSecondsDecoded = try containerValues.decode(Int.self, forKey: .minBufferTimeSeconds)
        minBufferTimeSeconds = minBufferTimeSecondsDecoded
        let minUpdatePeriodSecondsDecoded = try containerValues.decode(Int.self, forKey: .minUpdatePeriodSeconds)
        minUpdatePeriodSeconds = minUpdatePeriodSecondsDecoded
        let suggestedPresentationDelaySecondsDecoded = try containerValues.decode(Int.self, forKey: .suggestedPresentationDelaySeconds)
        suggestedPresentationDelaySeconds = suggestedPresentationDelaySecondsDecoded
    }
}

extension DashPlaylistSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashPlaylistSettings(manifestWindowSeconds: \(String(describing: manifestWindowSeconds)), minBufferTimeSeconds: \(String(describing: minBufferTimeSeconds)), minUpdatePeriodSeconds: \(String(describing: minUpdatePeriodSeconds)), suggestedPresentationDelaySeconds: \(String(describing: suggestedPresentationDelaySeconds)))"}
}

/// <p>Dash manifest configuration parameters.</p>
public struct DashPlaylistSettings: Equatable {
    /// <p>The total duration (in seconds) of each manifest. Minimum value: 30 seconds. Maximum value: 3600 seconds.</p>
    public let manifestWindowSeconds: Int
    /// <p>Minimum amount of content (measured in seconds) that a player must keep available in the buffer. Minimum value: 2 seconds. Maximum value: 60 seconds.</p>
    public let minBufferTimeSeconds: Int
    /// <p>Minimum amount of time (in seconds) that the player should wait before requesting updates to the manifest. Minimum value: 2 seconds. Maximum value: 60 seconds.</p>
    public let minUpdatePeriodSeconds: Int
    /// <p>Amount of time (in seconds) that the player should be from the live point at the end of the manifest. Minimum value: 2 seconds. Maximum value: 60 seconds.</p>
    public let suggestedPresentationDelaySeconds: Int

    public init (
        manifestWindowSeconds: Int = 0,
        minBufferTimeSeconds: Int = 0,
        minUpdatePeriodSeconds: Int = 0,
        suggestedPresentationDelaySeconds: Int = 0
    )
    {
        self.manifestWindowSeconds = manifestWindowSeconds
        self.minBufferTimeSeconds = minBufferTimeSeconds
        self.minUpdatePeriodSeconds = minUpdatePeriodSeconds
        self.suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds
    }
}

extension DefaultSegmentDeliveryConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baseUrl = "BaseUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseUrl = baseUrl {
            try encodeContainer.encode(baseUrl, forKey: .baseUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseUrl)
        baseUrl = baseUrlDecoded
    }
}

extension DefaultSegmentDeliveryConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultSegmentDeliveryConfiguration(baseUrl: \(String(describing: baseUrl)))"}
}

/// <p>The optional configuration for a server that serves segments. Use this if you want the segment delivery server to be different from the source location server. For example, you can configure your source location server to be an origination server, such as MediaPackage, and the segment delivery server to be a content delivery network (CDN), such as CloudFront. If you don't specify a segment delivery server, then the source location server is used.</p>
public struct DefaultSegmentDeliveryConfiguration: Equatable {
    /// <p>The hostname of the server that will be used to serve segments. This string must include the protocol, such as <b>https://</b>.</p>
    public let baseUrl: String?

    public init (
        baseUrl: String? = nil
    )
    {
        self.baseUrl = baseUrl
    }
}

extension DeleteChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteChannelInput(channelName: \(String(describing: channelName)))"}
}

extension DeleteChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInput: Equatable {
    /// <p>The identifier for the channel you are working on.</p>
    public let channelName: String?

    public init (
        channelName: String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct DeleteChannelInputBody: Equatable {
}

extension DeleteChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteChannelOutputResponse()"}
}

extension DeleteChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelOutputResponse: Equatable {

    public init() {}
}

struct DeleteChannelOutputResponseBody: Equatable {
}

extension DeleteChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteChannelPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteChannelPolicyInput(channelName: \(String(describing: channelName)))"}
}

extension DeleteChannelPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteChannelPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteChannelPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChannelPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChannelPolicyInput>
    public typealias MOutput = OperationOutput<DeleteChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChannelPolicyOutputError>
}

public struct DeleteChannelPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteChannelPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChannelPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChannelPolicyInput>
    public typealias MOutput = OperationOutput<DeleteChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChannelPolicyOutputError>
}

public struct DeleteChannelPolicyInput: Equatable {
    /// <p>The identifier for the channel you are working on.</p>
    public let channelName: String?

    public init (
        channelName: String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct DeleteChannelPolicyInputBody: Equatable {
}

extension DeleteChannelPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteChannelPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelPolicyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteChannelPolicyOutputResponse()"}
}

extension DeleteChannelPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteChannelPolicyOutputResponseBody: Equatable {
}

extension DeleteChannelPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePlaybackConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePlaybackConfigurationInput(name: \(String(describing: name)))"}
}

extension DeletePlaybackConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeletePlaybackConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePlaybackConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePlaybackConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePlaybackConfigurationInput>
    public typealias MOutput = OperationOutput<DeletePlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePlaybackConfigurationOutputError>
}

public struct DeletePlaybackConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePlaybackConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePlaybackConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePlaybackConfigurationInput>
    public typealias MOutput = OperationOutput<DeletePlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePlaybackConfigurationOutputError>
}

public struct DeletePlaybackConfigurationInput: Equatable {
    /// <p>The identifier for the playback configuration.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeletePlaybackConfigurationInputBody: Equatable {
}

extension DeletePlaybackConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePlaybackConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePlaybackConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePlaybackConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePlaybackConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePlaybackConfigurationOutputResponse()"}
}

extension DeletePlaybackConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePlaybackConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeletePlaybackConfigurationOutputResponseBody: Equatable {
}

extension DeletePlaybackConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProgramInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProgramInput(channelName: \(String(describing: channelName)), programName: \(String(describing: programName)))"}
}

extension DeleteProgramInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteProgramInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProgramInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProgramInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProgramInput>
    public typealias MOutput = OperationOutput<DeleteProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProgramOutputError>
}

public struct DeleteProgramInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProgramInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProgramInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProgramInput>
    public typealias MOutput = OperationOutput<DeleteProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProgramOutputError>
}

public struct DeleteProgramInput: Equatable {
    /// <p>The identifier for the channel you are working on.</p>
    public let channelName: String?
    /// <p>The identifier for the program you are working on.</p>
    public let programName: String?

    public init (
        channelName: String? = nil,
        programName: String? = nil
    )
    {
        self.channelName = channelName
        self.programName = programName
    }
}

struct DeleteProgramInputBody: Equatable {
}

extension DeleteProgramInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProgramOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProgramOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProgramOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProgramOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProgramOutputResponse()"}
}

extension DeleteProgramOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProgramOutputResponse: Equatable {

    public init() {}
}

struct DeleteProgramOutputResponseBody: Equatable {
}

extension DeleteProgramOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSourceLocationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSourceLocationInput(sourceLocationName: \(String(describing: sourceLocationName)))"}
}

extension DeleteSourceLocationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSourceLocationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSourceLocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSourceLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSourceLocationInput>
    public typealias MOutput = OperationOutput<DeleteSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSourceLocationOutputError>
}

public struct DeleteSourceLocationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSourceLocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSourceLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSourceLocationInput>
    public typealias MOutput = OperationOutput<DeleteSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSourceLocationOutputError>
}

public struct DeleteSourceLocationInput: Equatable {
    /// <p>The identifier for the source location you are working on.</p>
    public let sourceLocationName: String?

    public init (
        sourceLocationName: String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
    }
}

struct DeleteSourceLocationInputBody: Equatable {
}

extension DeleteSourceLocationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSourceLocationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSourceLocationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSourceLocationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSourceLocationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSourceLocationOutputResponse()"}
}

extension DeleteSourceLocationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSourceLocationOutputResponse: Equatable {

    public init() {}
}

struct DeleteSourceLocationOutputResponseBody: Equatable {
}

extension DeleteSourceLocationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVodSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVodSourceInput(sourceLocationName: \(String(describing: sourceLocationName)), vodSourceName: \(String(describing: vodSourceName)))"}
}

extension DeleteVodSourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteVodSourceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVodSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVodSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVodSourceInput>
    public typealias MOutput = OperationOutput<DeleteVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVodSourceOutputError>
}

public struct DeleteVodSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVodSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVodSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVodSourceInput>
    public typealias MOutput = OperationOutput<DeleteVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVodSourceOutputError>
}

public struct DeleteVodSourceInput: Equatable {
    /// <p>The identifier for the source location you are working on.</p>
    public let sourceLocationName: String?
    /// <p>The identifier for the VOD source you are working on.</p>
    public let vodSourceName: String?

    public init (
        sourceLocationName: String? = nil,
        vodSourceName: String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct DeleteVodSourceInputBody: Equatable {
}

extension DeleteVodSourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVodSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVodSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVodSourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVodSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVodSourceOutputResponse()"}
}

extension DeleteVodSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVodSourceOutputResponse: Equatable {

    public init() {}
}

struct DeleteVodSourceOutputResponseBody: Equatable {
}

extension DeleteVodSourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeChannelInput(channelName: \(String(describing: channelName)))"}
}

extension DescribeChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInput: Equatable {
    /// <p>The identifier for the channel you are working on.</p>
    public let channelName: String?

    public init (
        channelName: String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct DescribeChannelInputBody: Equatable {
}

extension DescribeChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeChannelOutputResponse(arn: \(String(describing: arn)), channelName: \(String(describing: channelName)), channelState: \(String(describing: channelState)), creationTime: \(String(describing: creationTime)), lastModifiedTime: \(String(describing: lastModifiedTime)), outputs: \(String(describing: outputs)), playbackMode: \(String(describing: playbackMode)), tags: \(String(describing: tags)))"}
}

extension DescribeChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.channelName = output.channelName
            self.channelState = output.channelState
            self.creationTime = output.creationTime
            self.lastModifiedTime = output.lastModifiedTime
            self.outputs = output.outputs
            self.playbackMode = output.playbackMode
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelName = nil
            self.channelState = nil
            self.creationTime = nil
            self.lastModifiedTime = nil
            self.outputs = nil
            self.playbackMode = nil
            self.tags = nil
        }
    }
}

public struct DescribeChannelOutputResponse: Equatable {
    /// <p>The ARN of the channel.</p>
    public let arn: String?
    /// <p>The name of the channel.</p>
    public let channelName: String?
    /// <p>Indicates whether the channel is in a running state or not.</p>
    public let channelState: ChannelState?
    /// <p>The timestamp of when the channel was created.</p>
    public let creationTime: Date?
    /// <p>The timestamp of when the channel was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The channel's output properties.</p>
    public let outputs: [ResponseOutputItem]?
    /// <p>The type of playback for this channel. The only supported value is LOOP.</p>
    public let playbackMode: String?
    /// <p>The tags assigned to the channel.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        channelName: String? = nil,
        channelState: ChannelState? = nil,
        creationTime: Date? = nil,
        lastModifiedTime: Date? = nil,
        outputs: [ResponseOutputItem]? = nil,
        playbackMode: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.channelName = channelName
        self.channelState = channelState
        self.creationTime = creationTime
        self.lastModifiedTime = lastModifiedTime
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
    }
}

struct DescribeChannelOutputResponseBody: Equatable {
    public let arn: String?
    public let channelName: String?
    public let channelState: ChannelState?
    public let creationTime: Date?
    public let lastModifiedTime: Date?
    public let outputs: [ResponseOutputItem]?
    public let playbackMode: String?
    public let tags: [String:String]?
}

extension DescribeChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case channelName = "ChannelName"
        case channelState = "ChannelState"
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStateDecoded = try containerValues.decodeIfPresent(ChannelState.self, forKey: .channelState)
        channelState = channelStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ResponseOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[ResponseOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ResponseOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let playbackModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeProgramInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProgramInput(channelName: \(String(describing: channelName)), programName: \(String(describing: programName)))"}
}

extension DescribeProgramInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeProgramInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProgramInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProgramInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProgramInput>
    public typealias MOutput = OperationOutput<DescribeProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProgramOutputError>
}

public struct DescribeProgramInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProgramInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProgramInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProgramInput>
    public typealias MOutput = OperationOutput<DescribeProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProgramOutputError>
}

public struct DescribeProgramInput: Equatable {
    /// <p>The identifier for the channel you are working on.</p>
    public let channelName: String?
    /// <p>The identifier for the program you are working on.</p>
    public let programName: String?

    public init (
        channelName: String? = nil,
        programName: String? = nil
    )
    {
        self.channelName = channelName
        self.programName = programName
    }
}

struct DescribeProgramInputBody: Equatable {
}

extension DescribeProgramInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeProgramOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProgramOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProgramOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProgramOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProgramOutputResponse(adBreaks: \(String(describing: adBreaks)), arn: \(String(describing: arn)), channelName: \(String(describing: channelName)), creationTime: \(String(describing: creationTime)), programName: \(String(describing: programName)), sourceLocationName: \(String(describing: sourceLocationName)), vodSourceName: \(String(describing: vodSourceName)))"}
}

extension DescribeProgramOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProgramOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.adBreaks = output.adBreaks
            self.arn = output.arn
            self.channelName = output.channelName
            self.creationTime = output.creationTime
            self.programName = output.programName
            self.sourceLocationName = output.sourceLocationName
            self.vodSourceName = output.vodSourceName
        } else {
            self.adBreaks = nil
            self.arn = nil
            self.channelName = nil
            self.creationTime = nil
            self.programName = nil
            self.sourceLocationName = nil
            self.vodSourceName = nil
        }
    }
}

public struct DescribeProgramOutputResponse: Equatable {
    /// <p>The ad break configuration settings.</p>
    public let adBreaks: [AdBreak]?
    /// <p>The ARN of the program.</p>
    public let arn: String?
    /// <p>The name of the channel that the program belongs to.</p>
    public let channelName: String?
    /// <p>The timestamp of when the program was created.</p>
    public let creationTime: Date?
    /// <p>The name of the program.</p>
    public let programName: String?
    /// <p>The source location name.</p>
    public let sourceLocationName: String?
    /// <p>The name that's used to refer to a VOD source.</p>
    public let vodSourceName: String?

    public init (
        adBreaks: [AdBreak]? = nil,
        arn: String? = nil,
        channelName: String? = nil,
        creationTime: Date? = nil,
        programName: String? = nil,
        sourceLocationName: String? = nil,
        vodSourceName: String? = nil
    )
    {
        self.adBreaks = adBreaks
        self.arn = arn
        self.channelName = channelName
        self.creationTime = creationTime
        self.programName = programName
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct DescribeProgramOutputResponseBody: Equatable {
    public let adBreaks: [AdBreak]?
    public let arn: String?
    public let channelName: String?
    public let creationTime: Date?
    public let programName: String?
    public let sourceLocationName: String?
    public let vodSourceName: String?
}

extension DescribeProgramOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adBreaks = "AdBreaks"
        case arn = "Arn"
        case channelName = "ChannelName"
        case creationTime = "CreationTime"
        case programName = "ProgramName"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adBreaksContainer = try containerValues.decodeIfPresent([AdBreak?].self, forKey: .adBreaks)
        var adBreaksDecoded0:[AdBreak]? = nil
        if let adBreaksContainer = adBreaksContainer {
            adBreaksDecoded0 = [AdBreak]()
            for structure0 in adBreaksContainer {
                if let structure0 = structure0 {
                    adBreaksDecoded0?.append(structure0)
                }
            }
        }
        adBreaks = adBreaksDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let programNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .programName)
        programName = programNameDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension DescribeSourceLocationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSourceLocationInput(sourceLocationName: \(String(describing: sourceLocationName)))"}
}

extension DescribeSourceLocationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeSourceLocationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSourceLocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSourceLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSourceLocationInput>
    public typealias MOutput = OperationOutput<DescribeSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSourceLocationOutputError>
}

public struct DescribeSourceLocationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSourceLocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSourceLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSourceLocationInput>
    public typealias MOutput = OperationOutput<DescribeSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSourceLocationOutputError>
}

public struct DescribeSourceLocationInput: Equatable {
    /// <p>The identifier for the source location you are working on.</p>
    public let sourceLocationName: String?

    public init (
        sourceLocationName: String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
    }
}

struct DescribeSourceLocationInputBody: Equatable {
}

extension DescribeSourceLocationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeSourceLocationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSourceLocationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSourceLocationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSourceLocationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSourceLocationOutputResponse(accessConfiguration: \(String(describing: accessConfiguration)), arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), defaultSegmentDeliveryConfiguration: \(String(describing: defaultSegmentDeliveryConfiguration)), httpConfiguration: \(String(describing: httpConfiguration)), lastModifiedTime: \(String(describing: lastModifiedTime)), sourceLocationName: \(String(describing: sourceLocationName)), tags: \(String(describing: tags)))"}
}

extension DescribeSourceLocationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSourceLocationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessConfiguration = output.accessConfiguration
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.defaultSegmentDeliveryConfiguration = output.defaultSegmentDeliveryConfiguration
            self.httpConfiguration = output.httpConfiguration
            self.lastModifiedTime = output.lastModifiedTime
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
        } else {
            self.accessConfiguration = nil
            self.arn = nil
            self.creationTime = nil
            self.defaultSegmentDeliveryConfiguration = nil
            self.httpConfiguration = nil
            self.lastModifiedTime = nil
            self.sourceLocationName = nil
            self.tags = nil
        }
    }
}

public struct DescribeSourceLocationOutputResponse: Equatable {
    /// <p>The access configuration for the source location.</p>
    public let accessConfiguration: AccessConfiguration?
    /// <p>The ARN of the source location.</p>
    public let arn: String?
    /// <p>The timestamp that indicates when the source location was created.</p>
    public let creationTime: Date?
    /// <p>The default segment delivery configuration settings.</p>
    public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
    /// <p>The HTTP package configuration settings for the source location.</p>
    public let httpConfiguration: HttpConfiguration?
    /// <p>The timestamp that indicates when the source location was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The name of the source location.</p>
    public let sourceLocationName: String?
    /// <p>The tags assigned to the source location.</p>
    public let tags: [String:String]?

    public init (
        accessConfiguration: AccessConfiguration? = nil,
        arn: String? = nil,
        creationTime: Date? = nil,
        defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: HttpConfiguration? = nil,
        lastModifiedTime: Date? = nil,
        sourceLocationName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.arn = arn
        self.creationTime = creationTime
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct DescribeSourceLocationOutputResponseBody: Equatable {
    public let accessConfiguration: AccessConfiguration?
    public let arn: String?
    public let creationTime: Date?
    public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
    public let httpConfiguration: HttpConfiguration?
    public let lastModifiedTime: Date?
    public let sourceLocationName: String?
    public let tags: [String:String]?
}

extension DescribeSourceLocationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case arn = "Arn"
        case creationTime = "CreationTime"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeVodSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVodSourceInput(sourceLocationName: \(String(describing: sourceLocationName)), vodSourceName: \(String(describing: vodSourceName)))"}
}

extension DescribeVodSourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeVodSourceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeVodSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVodSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVodSourceInput>
    public typealias MOutput = OperationOutput<DescribeVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVodSourceOutputError>
}

public struct DescribeVodSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeVodSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVodSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVodSourceInput>
    public typealias MOutput = OperationOutput<DescribeVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVodSourceOutputError>
}

public struct DescribeVodSourceInput: Equatable {
    /// <p>The identifier for the source location you are working on.</p>
    public let sourceLocationName: String?
    /// <p>The identifier for the VOD source you are working on.</p>
    public let vodSourceName: String?

    public init (
        sourceLocationName: String? = nil,
        vodSourceName: String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct DescribeVodSourceInputBody: Equatable {
}

extension DescribeVodSourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeVodSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVodSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVodSourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVodSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVodSourceOutputResponse(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), httpPackageConfigurations: \(String(describing: httpPackageConfigurations)), lastModifiedTime: \(String(describing: lastModifiedTime)), sourceLocationName: \(String(describing: sourceLocationName)), tags: \(String(describing: tags)), vodSourceName: \(String(describing: vodSourceName)))"}
}

extension DescribeVodSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeVodSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.httpPackageConfigurations = output.httpPackageConfigurations
            self.lastModifiedTime = output.lastModifiedTime
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
            self.vodSourceName = output.vodSourceName
        } else {
            self.arn = nil
            self.creationTime = nil
            self.httpPackageConfigurations = nil
            self.lastModifiedTime = nil
            self.sourceLocationName = nil
            self.tags = nil
            self.vodSourceName = nil
        }
    }
}

public struct DescribeVodSourceOutputResponse: Equatable {
    /// <p>The ARN of the VOD source.</p>
    public let arn: String?
    /// <p>The timestamp that indicates when the VOD source was created.</p>
    public let creationTime: Date?
    /// <p>The HTTP package configurations.</p>
    public let httpPackageConfigurations: [HttpPackageConfiguration]?
    /// <p>The ARN for the VOD source.</p>
    public let lastModifiedTime: Date?
    /// <p>The name of the source location associated with the VOD source.</p>
    public let sourceLocationName: String?
    /// <p>The tags assigned to the VOD source.</p>
    public let tags: [String:String]?
    /// <p>The name of the VOD source.</p>
    public let vodSourceName: String?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        httpPackageConfigurations: [HttpPackageConfiguration]? = nil,
        lastModifiedTime: Date? = nil,
        sourceLocationName: String? = nil,
        tags: [String:String]? = nil,
        vodSourceName: String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

struct DescribeVodSourceOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTime: Date?
    public let httpPackageConfigurations: [HttpPackageConfiguration]?
    public let lastModifiedTime: Date?
    public let sourceLocationName: String?
    public let tags: [String:String]?
    public let vodSourceName: String?
}

extension DescribeVodSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension GetChannelPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetChannelPolicyInput(channelName: \(String(describing: channelName)))"}
}

extension GetChannelPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetChannelPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetChannelPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChannelPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChannelPolicyInput>
    public typealias MOutput = OperationOutput<GetChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChannelPolicyOutputError>
}

public struct GetChannelPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetChannelPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChannelPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChannelPolicyInput>
    public typealias MOutput = OperationOutput<GetChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChannelPolicyOutputError>
}

public struct GetChannelPolicyInput: Equatable {
    /// <p>The identifier for the channel you are working on.</p>
    public let channelName: String?

    public init (
        channelName: String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct GetChannelPolicyInputBody: Equatable {
}

extension GetChannelPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetChannelPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChannelPolicyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetChannelPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetChannelPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetChannelPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetChannelPolicyOutputResponse: Equatable {
    /// <p>The IAM policy for the channel.</p>
    public let policy: String?

    public init (
        policy: String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetChannelPolicyOutputResponseBody: Equatable {
    public let policy: String?
}

extension GetChannelPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetChannelScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetChannelScheduleInput(channelName: \(String(describing: channelName)), durationMinutes: \(String(describing: durationMinutes)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetChannelScheduleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetChannelScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "GetChannelScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChannelScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChannelScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChannelScheduleInput>
    public typealias MOutput = OperationOutput<GetChannelScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChannelScheduleOutputError>
}

public struct GetChannelScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "GetChannelScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChannelScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChannelScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let durationMinutes = input.operationInput.durationMinutes {
            let durationMinutesQueryItem = URLQueryItem(name: "durationMinutes".urlPercentEncoding(), value: String(durationMinutes).urlPercentEncoding())
            input.builder.withQueryItem(durationMinutesQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChannelScheduleInput>
    public typealias MOutput = OperationOutput<GetChannelScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChannelScheduleOutputError>
}

public struct GetChannelScheduleInput: Equatable {
    /// <p>The identifier for the channel you are working on.</p>
    public let channelName: String?
    /// <p>The schedule duration in minutes. The maximum duration is 4320 minutes (three days).</p>
    public let durationMinutes: String?
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    public let maxResults: Int
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    public let nextToken: String?

    public init (
        channelName: String? = nil,
        durationMinutes: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.channelName = channelName
        self.durationMinutes = durationMinutes
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetChannelScheduleInputBody: Equatable {
}

extension GetChannelScheduleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetChannelScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChannelScheduleOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetChannelScheduleOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension GetChannelScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetChannelScheduleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetChannelScheduleOutputResponse: Equatable {
    /// <p>An array of schedule entries for the channel.</p>
    public let items: [ScheduleEntry]?
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    public let nextToken: String?

    public init (
        items: [ScheduleEntry]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetChannelScheduleOutputResponseBody: Equatable {
    public let items: [ScheduleEntry]?
    public let nextToken: String?
}

extension GetChannelScheduleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ScheduleEntry?].self, forKey: .items)
        var itemsDecoded0:[ScheduleEntry]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ScheduleEntry]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetPlaybackConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPlaybackConfigurationInput(name: \(String(describing: name)))"}
}

extension GetPlaybackConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetPlaybackConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetPlaybackConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPlaybackConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPlaybackConfigurationInput>
    public typealias MOutput = OperationOutput<GetPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPlaybackConfigurationOutputError>
}

public struct GetPlaybackConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPlaybackConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPlaybackConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPlaybackConfigurationInput>
    public typealias MOutput = OperationOutput<GetPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPlaybackConfigurationOutputError>
}

public struct GetPlaybackConfigurationInput: Equatable {
    /// <p>The identifier for the playback configuration.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetPlaybackConfigurationInputBody: Equatable {
}

extension GetPlaybackConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetPlaybackConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPlaybackConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPlaybackConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPlaybackConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPlaybackConfigurationOutputResponse(adDecisionServerUrl: \(String(describing: adDecisionServerUrl)), availSuppression: \(String(describing: availSuppression)), bumper: \(String(describing: bumper)), cdnConfiguration: \(String(describing: cdnConfiguration)), configurationAliases: \(String(describing: configurationAliases)), dashConfiguration: \(String(describing: dashConfiguration)), hlsConfiguration: \(String(describing: hlsConfiguration)), livePreRollConfiguration: \(String(describing: livePreRollConfiguration)), manifestProcessingRules: \(String(describing: manifestProcessingRules)), name: \(String(describing: name)), personalizationThresholdSeconds: \(String(describing: personalizationThresholdSeconds)), playbackConfigurationArn: \(String(describing: playbackConfigurationArn)), playbackEndpointPrefix: \(String(describing: playbackEndpointPrefix)), sessionInitializationEndpointPrefix: \(String(describing: sessionInitializationEndpointPrefix)), slateAdUrl: \(String(describing: slateAdUrl)), tags: \(String(describing: tags)), transcodeProfileName: \(String(describing: transcodeProfileName)), videoContentSourceUrl: \(String(describing: videoContentSourceUrl)))"}
}

extension GetPlaybackConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPlaybackConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.adDecisionServerUrl = output.adDecisionServerUrl
            self.availSuppression = output.availSuppression
            self.bumper = output.bumper
            self.cdnConfiguration = output.cdnConfiguration
            self.configurationAliases = output.configurationAliases
            self.dashConfiguration = output.dashConfiguration
            self.hlsConfiguration = output.hlsConfiguration
            self.livePreRollConfiguration = output.livePreRollConfiguration
            self.manifestProcessingRules = output.manifestProcessingRules
            self.name = output.name
            self.personalizationThresholdSeconds = output.personalizationThresholdSeconds
            self.playbackConfigurationArn = output.playbackConfigurationArn
            self.playbackEndpointPrefix = output.playbackEndpointPrefix
            self.sessionInitializationEndpointPrefix = output.sessionInitializationEndpointPrefix
            self.slateAdUrl = output.slateAdUrl
            self.tags = output.tags
            self.transcodeProfileName = output.transcodeProfileName
            self.videoContentSourceUrl = output.videoContentSourceUrl
        } else {
            self.adDecisionServerUrl = nil
            self.availSuppression = nil
            self.bumper = nil
            self.cdnConfiguration = nil
            self.configurationAliases = nil
            self.dashConfiguration = nil
            self.hlsConfiguration = nil
            self.livePreRollConfiguration = nil
            self.manifestProcessingRules = nil
            self.name = nil
            self.personalizationThresholdSeconds = 0
            self.playbackConfigurationArn = nil
            self.playbackEndpointPrefix = nil
            self.sessionInitializationEndpointPrefix = nil
            self.slateAdUrl = nil
            self.tags = nil
            self.transcodeProfileName = nil
            self.videoContentSourceUrl = nil
        }
    }
}

public struct GetPlaybackConfigurationOutputResponse: Equatable {
    /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    public let adDecisionServerUrl: String?
    /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
    public let availSuppression: AvailSuppression?
    /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
    public let bumper: Bumper?
    /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
    public let cdnConfiguration: CdnConfiguration?
    /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
    public let configurationAliases: [String:[String:String]]?
    /// <p>The configuration for DASH content.</p>
    public let dashConfiguration: DashConfiguration?
    /// <p>The configuration for HLS content.</p>
    public let hlsConfiguration: HlsConfiguration?
    /// <p>The configuration for pre-roll ad insertion.</p>
    public let livePreRollConfiguration: LivePreRollConfiguration?
    /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
    public let manifestProcessingRules: ManifestProcessingRules?
    /// <p>The identifier for the playback configuration.</p>
    public let name: String?
    /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
    public let personalizationThresholdSeconds: Int
    /// <p>The Amazon Resource Name (ARN) for the playback configuration.</p>
    public let playbackConfigurationArn: String?
    /// <p>The URL that the player accesses to get a manifest from AWS Elemental MediaTailor. This session will use server-side reporting.</p>
    public let playbackEndpointPrefix: String?
    /// <p>The URL that the player uses to initialize a session that uses client-side reporting.</p>
    public let sessionInitializationEndpointPrefix: String?
    /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
    public let slateAdUrl: String?
    /// <p>The tags assigned to the playback configuration.</p>
    public let tags: [String:String]?
    /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
    public let transcodeProfileName: String?
    /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
    public let videoContentSourceUrl: String?

    public init (
        adDecisionServerUrl: String? = nil,
        availSuppression: AvailSuppression? = nil,
        bumper: Bumper? = nil,
        cdnConfiguration: CdnConfiguration? = nil,
        configurationAliases: [String:[String:String]]? = nil,
        dashConfiguration: DashConfiguration? = nil,
        hlsConfiguration: HlsConfiguration? = nil,
        livePreRollConfiguration: LivePreRollConfiguration? = nil,
        manifestProcessingRules: ManifestProcessingRules? = nil,
        name: String? = nil,
        personalizationThresholdSeconds: Int = 0,
        playbackConfigurationArn: String? = nil,
        playbackEndpointPrefix: String? = nil,
        sessionInitializationEndpointPrefix: String? = nil,
        slateAdUrl: String? = nil,
        tags: [String:String]? = nil,
        transcodeProfileName: String? = nil,
        videoContentSourceUrl: String? = nil
    )
    {
        self.adDecisionServerUrl = adDecisionServerUrl
        self.availSuppression = availSuppression
        self.bumper = bumper
        self.cdnConfiguration = cdnConfiguration
        self.configurationAliases = configurationAliases
        self.dashConfiguration = dashConfiguration
        self.hlsConfiguration = hlsConfiguration
        self.livePreRollConfiguration = livePreRollConfiguration
        self.manifestProcessingRules = manifestProcessingRules
        self.name = name
        self.personalizationThresholdSeconds = personalizationThresholdSeconds
        self.playbackConfigurationArn = playbackConfigurationArn
        self.playbackEndpointPrefix = playbackEndpointPrefix
        self.sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix
        self.slateAdUrl = slateAdUrl
        self.tags = tags
        self.transcodeProfileName = transcodeProfileName
        self.videoContentSourceUrl = videoContentSourceUrl
    }
}

struct GetPlaybackConfigurationOutputResponseBody: Equatable {
    public let adDecisionServerUrl: String?
    public let availSuppression: AvailSuppression?
    public let bumper: Bumper?
    public let cdnConfiguration: CdnConfiguration?
    public let configurationAliases: [String:[String:String]]?
    public let dashConfiguration: DashConfiguration?
    public let hlsConfiguration: HlsConfiguration?
    public let livePreRollConfiguration: LivePreRollConfiguration?
    public let manifestProcessingRules: ManifestProcessingRules?
    public let name: String?
    public let personalizationThresholdSeconds: Int
    public let playbackConfigurationArn: String?
    public let playbackEndpointPrefix: String?
    public let sessionInitializationEndpointPrefix: String?
    public let slateAdUrl: String?
    public let tags: [String:String]?
    public let transcodeProfileName: String?
    public let videoContentSourceUrl: String?
}

extension GetPlaybackConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case availSuppression = "AvailSuppression"
        case bumper = "Bumper"
        case cdnConfiguration = "CdnConfiguration"
        case configurationAliases = "ConfigurationAliases"
        case dashConfiguration = "DashConfiguration"
        case hlsConfiguration = "HlsConfiguration"
        case livePreRollConfiguration = "LivePreRollConfiguration"
        case manifestProcessingRules = "ManifestProcessingRules"
        case name = "Name"
        case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
        case playbackConfigurationArn = "PlaybackConfigurationArn"
        case playbackEndpointPrefix = "PlaybackEndpointPrefix"
        case sessionInitializationEndpointPrefix = "SessionInitializationEndpointPrefix"
        case slateAdUrl = "SlateAdUrl"
        case tags = "tags"
        case transcodeProfileName = "TranscodeProfileName"
        case videoContentSourceUrl = "VideoContentSourceUrl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adDecisionServerUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adDecisionServerUrl)
        adDecisionServerUrl = adDecisionServerUrlDecoded
        let availSuppressionDecoded = try containerValues.decodeIfPresent(AvailSuppression.self, forKey: .availSuppression)
        availSuppression = availSuppressionDecoded
        let bumperDecoded = try containerValues.decodeIfPresent(Bumper.self, forKey: .bumper)
        bumper = bumperDecoded
        let cdnConfigurationDecoded = try containerValues.decodeIfPresent(CdnConfiguration.self, forKey: .cdnConfiguration)
        cdnConfiguration = cdnConfigurationDecoded
        let configurationAliasesContainer = try containerValues.decodeIfPresent([String: [String: String?]?].self, forKey: .configurationAliases)
        var configurationAliasesDecoded0: [String:[String:String]]? = nil
        if let configurationAliasesContainer = configurationAliasesContainer {
            configurationAliasesDecoded0 = [String:[String:String]]()
            for (key0, __mapof__string0) in configurationAliasesContainer {
                var __mapof__string0Decoded0: [String: String]? = nil
                if let __mapof__string0 = __mapof__string0 {
                    __mapof__string0Decoded0 = [String: String]()
                    for (key1, __string1) in __mapof__string0 {
                        if let __string1 = __string1 {
                            __mapof__string0Decoded0?[key1] = __string1
                        }
                    }
                }
                configurationAliasesDecoded0?[key0] = __mapof__string0Decoded0
            }
        }
        configurationAliases = configurationAliasesDecoded0
        let dashConfigurationDecoded = try containerValues.decodeIfPresent(DashConfiguration.self, forKey: .dashConfiguration)
        dashConfiguration = dashConfigurationDecoded
        let hlsConfigurationDecoded = try containerValues.decodeIfPresent(HlsConfiguration.self, forKey: .hlsConfiguration)
        hlsConfiguration = hlsConfigurationDecoded
        let livePreRollConfigurationDecoded = try containerValues.decodeIfPresent(LivePreRollConfiguration.self, forKey: .livePreRollConfiguration)
        livePreRollConfiguration = livePreRollConfigurationDecoded
        let manifestProcessingRulesDecoded = try containerValues.decodeIfPresent(ManifestProcessingRules.self, forKey: .manifestProcessingRules)
        manifestProcessingRules = manifestProcessingRulesDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let personalizationThresholdSecondsDecoded = try containerValues.decode(Int.self, forKey: .personalizationThresholdSeconds)
        personalizationThresholdSeconds = personalizationThresholdSecondsDecoded
        let playbackConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .playbackConfigurationArn)
        playbackConfigurationArn = playbackConfigurationArnDecoded
        let playbackEndpointPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .playbackEndpointPrefix)
        playbackEndpointPrefix = playbackEndpointPrefixDecoded
        let sessionInitializationEndpointPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionInitializationEndpointPrefix)
        sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefixDecoded
        let slateAdUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slateAdUrl)
        slateAdUrl = slateAdUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let transcodeProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transcodeProfileName)
        transcodeProfileName = transcodeProfileNameDecoded
        let videoContentSourceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .videoContentSourceUrl)
        videoContentSourceUrl = videoContentSourceUrlDecoded
    }
}

extension HlsConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case manifestEndpointPrefix = "ManifestEndpointPrefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestEndpointPrefix = manifestEndpointPrefix {
            try encodeContainer.encode(manifestEndpointPrefix, forKey: .manifestEndpointPrefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestEndpointPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestEndpointPrefix)
        manifestEndpointPrefix = manifestEndpointPrefixDecoded
    }
}

extension HlsConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HlsConfiguration(manifestEndpointPrefix: \(String(describing: manifestEndpointPrefix)))"}
}

/// <p>The configuration for HLS content.</p>
public struct HlsConfiguration: Equatable {
    /// <p>The URL that is used to initiate a playback session for devices that support Apple HLS. The session uses server-side reporting.</p>
    public let manifestEndpointPrefix: String?

    public init (
        manifestEndpointPrefix: String? = nil
    )
    {
        self.manifestEndpointPrefix = manifestEndpointPrefix
    }
}

extension HlsPlaylistSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case manifestWindowSeconds = "ManifestWindowSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if manifestWindowSeconds != 0 {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestWindowSecondsDecoded = try containerValues.decode(Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
    }
}

extension HlsPlaylistSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HlsPlaylistSettings(manifestWindowSeconds: \(String(describing: manifestWindowSeconds)))"}
}

/// <p>HLS playlist configuration parameters.</p>
public struct HlsPlaylistSettings: Equatable {
    /// <p>The total duration (in seconds) of each manifest. Minimum value: 30 seconds. Maximum value: 3600 seconds.</p>
    public let manifestWindowSeconds: Int

    public init (
        manifestWindowSeconds: Int = 0
    )
    {
        self.manifestWindowSeconds = manifestWindowSeconds
    }
}

extension HttpConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baseUrl = "BaseUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseUrl = baseUrl {
            try encodeContainer.encode(baseUrl, forKey: .baseUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseUrl)
        baseUrl = baseUrlDecoded
    }
}

extension HttpConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpConfiguration(baseUrl: \(String(describing: baseUrl)))"}
}

/// <p>The HTTP configuration for the source location.</p>
public struct HttpConfiguration: Equatable {
    /// <p>The base URL for the source location host server. This string must include the protocol, such as <b>https://</b>.</p>
    public let baseUrl: String?

    public init (
        baseUrl: String? = nil
    )
    {
        self.baseUrl = baseUrl
    }
}

extension HttpPackageConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case path = "Path"
        case sourceGroup = "SourceGroup"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let sourceGroup = sourceGroup {
            try encodeContainer.encode(sourceGroup, forKey: .sourceGroup)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let sourceGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceGroup)
        sourceGroup = sourceGroupDecoded
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
    }
}

extension HttpPackageConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpPackageConfiguration(path: \(String(describing: path)), sourceGroup: \(String(describing: sourceGroup)), type: \(String(describing: type)))"}
}

/// <p>The HTTP package configuration properties for the requested VOD source.</p>
public struct HttpPackageConfiguration: Equatable {
    /// <p>The relative path to the URL for this VOD source. This is combined with SourceLocation::HttpConfiguration::BaseUrl to form a valid URL.</p>
    public let path: String?
    /// <p>The name of the source group. This has to match one of the Channel::Outputs::SourceGroup.</p>
    public let sourceGroup: String?
    /// <p>The streaming protocol for this package configuration. Supported values are HLS and DASH.</p>
    public let type: `Type`?

    public init (
        path: String? = nil,
        sourceGroup: String? = nil,
        type: `Type`? = nil
    )
    {
        self.path = path
        self.sourceGroup = sourceGroup
        self.type = type
    }
}

extension ListChannelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListChannelsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListChannelsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListChannelsInputHeadersMiddleware: Middleware {
    public let id: String = "ListChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChannelsInput>
    public typealias MOutput = OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChannelsInput>
    public typealias MOutput = OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChannelsOutputError>
}

public struct ListChannelsInput: Equatable {
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    public let maxResults: Int
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Equatable {
}

extension ListChannelsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListChannelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListChannelsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListChannelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Equatable {
    /// <p>An array of channels that are associated with this account.</p>
    public let items: [Channel]?
    /// <p>Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
    public let nextToken: String?

    public init (
        items: [Channel]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Equatable {
    public let items: [Channel]?
    public let nextToken: String?
}

extension ListChannelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Channel?].self, forKey: .items)
        var itemsDecoded0:[Channel]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Channel]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPlaybackConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPlaybackConfigurationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPlaybackConfigurationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPlaybackConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPlaybackConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlaybackConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlaybackConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlaybackConfigurationsInput>
    public typealias MOutput = OperationOutput<ListPlaybackConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlaybackConfigurationsOutputError>
}

public struct ListPlaybackConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPlaybackConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlaybackConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlaybackConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlaybackConfigurationsInput>
    public typealias MOutput = OperationOutput<ListPlaybackConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlaybackConfigurationsOutputError>
}

public struct ListPlaybackConfigurationsInput: Equatable {
    /// <p>Maximum number of records to return.</p>
    public let maxResults: Int
    /// <p>Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPlaybackConfigurationsInputBody: Equatable {
}

extension ListPlaybackConfigurationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPlaybackConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPlaybackConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPlaybackConfigurationsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPlaybackConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPlaybackConfigurationsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPlaybackConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPlaybackConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListPlaybackConfigurationsOutputResponse: Equatable {
    /// <p>Array of playback configurations. This might be all the available configurations or a subset, depending on the settings that you provide and the total number of configurations stored.</p>
    public let items: [PlaybackConfiguration]?
    /// <p>Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</p>
    public let nextToken: String?

    public init (
        items: [PlaybackConfiguration]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListPlaybackConfigurationsOutputResponseBody: Equatable {
    public let items: [PlaybackConfiguration]?
    public let nextToken: String?
}

extension ListPlaybackConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([PlaybackConfiguration?].self, forKey: .items)
        var itemsDecoded0:[PlaybackConfiguration]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [PlaybackConfiguration]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSourceLocationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSourceLocationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSourceLocationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSourceLocationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSourceLocationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSourceLocationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSourceLocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSourceLocationsInput>
    public typealias MOutput = OperationOutput<ListSourceLocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSourceLocationsOutputError>
}

public struct ListSourceLocationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSourceLocationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSourceLocationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSourceLocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSourceLocationsInput>
    public typealias MOutput = OperationOutput<ListSourceLocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSourceLocationsOutputError>
}

public struct ListSourceLocationsInput: Equatable {
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    public let maxResults: Int
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSourceLocationsInputBody: Equatable {
}

extension ListSourceLocationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSourceLocationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSourceLocationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSourceLocationsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSourceLocationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSourceLocationsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSourceLocationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSourceLocationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSourceLocationsOutputResponse: Equatable {
    /// <p>An array of source locations.</p>
    public let items: [SourceLocation]?
    /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
    public let nextToken: String?

    public init (
        items: [SourceLocation]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSourceLocationsOutputResponseBody: Equatable {
    public let items: [SourceLocation]?
    public let nextToken: String?
}

extension ListSourceLocationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([SourceLocation?].self, forKey: .items)
        var itemsDecoded0:[SourceLocation]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [SourceLocation]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A comma-separated list of tag key:value pairs.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVodSourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVodSourcesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sourceLocationName: \(String(describing: sourceLocationName)))"}
}

extension ListVodSourcesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListVodSourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListVodSourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVodSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVodSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVodSourcesInput>
    public typealias MOutput = OperationOutput<ListVodSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVodSourcesOutputError>
}

public struct ListVodSourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListVodSourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVodSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVodSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVodSourcesInput>
    public typealias MOutput = OperationOutput<ListVodSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVodSourcesOutputError>
}

public struct ListVodSourcesInput: Equatable {
    /// <p>Upper bound on number of records to return. The maximum number of results is 100.</p>
    public let maxResults: Int
    /// <p>Pagination token from the GET list request. Use the token to fetch the next page of results.</p>
    public let nextToken: String?
    /// <p>The identifier for the source location you are working on.</p>
    public let sourceLocationName: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        sourceLocationName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceLocationName = sourceLocationName
    }
}

struct ListVodSourcesInputBody: Equatable {
}

extension ListVodSourcesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListVodSourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVodSourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVodSourcesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVodSourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVodSourcesOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListVodSourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListVodSourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListVodSourcesOutputResponse: Equatable {
    /// <p>Lists the VOD sources.</p>
    public let items: [VodSource]?
    /// <p>Pagination token from the list request. Use the token to fetch the next page of results.</p>
    public let nextToken: String?

    public init (
        items: [VodSource]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListVodSourcesOutputResponseBody: Equatable {
    public let items: [VodSource]?
    public let nextToken: String?
}

extension ListVodSourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VodSource?].self, forKey: .items)
        var itemsDecoded0:[VodSource]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VodSource]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LivePreRollConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case maxDurationSeconds = "MaxDurationSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adDecisionServerUrl = adDecisionServerUrl {
            try encodeContainer.encode(adDecisionServerUrl, forKey: .adDecisionServerUrl)
        }
        if maxDurationSeconds != 0 {
            try encodeContainer.encode(maxDurationSeconds, forKey: .maxDurationSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adDecisionServerUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adDecisionServerUrl)
        adDecisionServerUrl = adDecisionServerUrlDecoded
        let maxDurationSecondsDecoded = try containerValues.decode(Int.self, forKey: .maxDurationSeconds)
        maxDurationSeconds = maxDurationSecondsDecoded
    }
}

extension LivePreRollConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LivePreRollConfiguration(adDecisionServerUrl: \(String(describing: adDecisionServerUrl)), maxDurationSeconds: \(String(describing: maxDurationSeconds)))"}
}

/// <p>The configuration for pre-roll ad insertion.</p>
public struct LivePreRollConfiguration: Equatable {
    /// <p>The URL for the ad decision server (ADS) for pre-roll ads. This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    public let adDecisionServerUrl: String?
    /// The maximum allowed duration for the pre-roll ad avail. AWS Elemental MediaTailor won't play pre-roll ads to exceed this duration, regardless of the total duration of ads that the ADS returns.
    public let maxDurationSeconds: Int

    public init (
        adDecisionServerUrl: String? = nil,
        maxDurationSeconds: Int = 0
    )
    {
        self.adDecisionServerUrl = adDecisionServerUrl
        self.maxDurationSeconds = maxDurationSeconds
    }
}

extension ManifestProcessingRules: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adMarkerPassthrough = "AdMarkerPassthrough"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkerPassthrough = adMarkerPassthrough {
            try encodeContainer.encode(adMarkerPassthrough, forKey: .adMarkerPassthrough)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkerPassthroughDecoded = try containerValues.decodeIfPresent(AdMarkerPassthrough.self, forKey: .adMarkerPassthrough)
        adMarkerPassthrough = adMarkerPassthroughDecoded
    }
}

extension ManifestProcessingRules: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ManifestProcessingRules(adMarkerPassthrough: \(String(describing: adMarkerPassthrough)))"}
}

/// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
public struct ManifestProcessingRules: Equatable {
    /// <p>For HLS, when set to true, MediaTailor passes through EXT-X-CUE-IN, EXT-X-CUE-OUT, and EXT-X-SPLICEPOINT-SCTE35 ad markers from the origin manifest to the MediaTailor personalized manifest.</p> <p>No logic is applied to these ad markers. For example, if EXT-X-CUE-OUT has a value of 60, but no ads are filled for that ad break, MediaTailor will not set the value to 0.</p>
    public let adMarkerPassthrough: AdMarkerPassthrough?

    public init (
        adMarkerPassthrough: AdMarkerPassthrough? = nil
    )
    {
        self.adMarkerPassthrough = adMarkerPassthrough
    }
}

public enum MessageType {
    case spliceInsert
    case sdkUnknown(String)
}

extension MessageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MessageType] {
        return [
            .spliceInsert,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .spliceInsert: return "SPLICE_INSERT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MessageType(rawValue: rawValue) ?? MessageType.sdkUnknown(rawValue)
    }
}

public enum Mode {
    case behindLiveEdge
    case off
    case sdkUnknown(String)
}

extension Mode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Mode] {
        return [
            .behindLiveEdge,
            .off,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .behindLiveEdge: return "BEHIND_LIVE_EDGE"
        case .off: return "OFF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Mode(rawValue: rawValue) ?? Mode.sdkUnknown(rawValue)
    }
}

public enum OriginManifestType {
    case multiPeriod
    case singlePeriod
    case sdkUnknown(String)
}

extension OriginManifestType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OriginManifestType] {
        return [
            .multiPeriod,
            .singlePeriod,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .multiPeriod: return "MULTI_PERIOD"
        case .singlePeriod: return "SINGLE_PERIOD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OriginManifestType(rawValue: rawValue) ?? OriginManifestType.sdkUnknown(rawValue)
    }
}

extension PlaybackConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case availSuppression = "AvailSuppression"
        case bumper = "Bumper"
        case cdnConfiguration = "CdnConfiguration"
        case configurationAliases = "ConfigurationAliases"
        case dashConfiguration = "DashConfiguration"
        case hlsConfiguration = "HlsConfiguration"
        case livePreRollConfiguration = "LivePreRollConfiguration"
        case manifestProcessingRules = "ManifestProcessingRules"
        case name = "Name"
        case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
        case playbackConfigurationArn = "PlaybackConfigurationArn"
        case playbackEndpointPrefix = "PlaybackEndpointPrefix"
        case sessionInitializationEndpointPrefix = "SessionInitializationEndpointPrefix"
        case slateAdUrl = "SlateAdUrl"
        case tags = "tags"
        case transcodeProfileName = "TranscodeProfileName"
        case videoContentSourceUrl = "VideoContentSourceUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adDecisionServerUrl = adDecisionServerUrl {
            try encodeContainer.encode(adDecisionServerUrl, forKey: .adDecisionServerUrl)
        }
        if let availSuppression = availSuppression {
            try encodeContainer.encode(availSuppression, forKey: .availSuppression)
        }
        if let bumper = bumper {
            try encodeContainer.encode(bumper, forKey: .bumper)
        }
        if let cdnConfiguration = cdnConfiguration {
            try encodeContainer.encode(cdnConfiguration, forKey: .cdnConfiguration)
        }
        if let configurationAliases = configurationAliases {
            var configurationAliasesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .configurationAliases)
            for (dictKey0, configurationaliasesresponse0) in configurationAliases {
                try configurationAliasesContainer.encode(configurationaliasesresponse0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let dashConfiguration = dashConfiguration {
            try encodeContainer.encode(dashConfiguration, forKey: .dashConfiguration)
        }
        if let hlsConfiguration = hlsConfiguration {
            try encodeContainer.encode(hlsConfiguration, forKey: .hlsConfiguration)
        }
        if let livePreRollConfiguration = livePreRollConfiguration {
            try encodeContainer.encode(livePreRollConfiguration, forKey: .livePreRollConfiguration)
        }
        if let manifestProcessingRules = manifestProcessingRules {
            try encodeContainer.encode(manifestProcessingRules, forKey: .manifestProcessingRules)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if personalizationThresholdSeconds != 0 {
            try encodeContainer.encode(personalizationThresholdSeconds, forKey: .personalizationThresholdSeconds)
        }
        if let playbackConfigurationArn = playbackConfigurationArn {
            try encodeContainer.encode(playbackConfigurationArn, forKey: .playbackConfigurationArn)
        }
        if let playbackEndpointPrefix = playbackEndpointPrefix {
            try encodeContainer.encode(playbackEndpointPrefix, forKey: .playbackEndpointPrefix)
        }
        if let sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix {
            try encodeContainer.encode(sessionInitializationEndpointPrefix, forKey: .sessionInitializationEndpointPrefix)
        }
        if let slateAdUrl = slateAdUrl {
            try encodeContainer.encode(slateAdUrl, forKey: .slateAdUrl)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let transcodeProfileName = transcodeProfileName {
            try encodeContainer.encode(transcodeProfileName, forKey: .transcodeProfileName)
        }
        if let videoContentSourceUrl = videoContentSourceUrl {
            try encodeContainer.encode(videoContentSourceUrl, forKey: .videoContentSourceUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adDecisionServerUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adDecisionServerUrl)
        adDecisionServerUrl = adDecisionServerUrlDecoded
        let availSuppressionDecoded = try containerValues.decodeIfPresent(AvailSuppression.self, forKey: .availSuppression)
        availSuppression = availSuppressionDecoded
        let bumperDecoded = try containerValues.decodeIfPresent(Bumper.self, forKey: .bumper)
        bumper = bumperDecoded
        let cdnConfigurationDecoded = try containerValues.decodeIfPresent(CdnConfiguration.self, forKey: .cdnConfiguration)
        cdnConfiguration = cdnConfigurationDecoded
        let configurationAliasesContainer = try containerValues.decodeIfPresent([String: [String: String?]?].self, forKey: .configurationAliases)
        var configurationAliasesDecoded0: [String:[String:String]]? = nil
        if let configurationAliasesContainer = configurationAliasesContainer {
            configurationAliasesDecoded0 = [String:[String:String]]()
            for (key0, __mapof__string0) in configurationAliasesContainer {
                var __mapof__string0Decoded0: [String: String]? = nil
                if let __mapof__string0 = __mapof__string0 {
                    __mapof__string0Decoded0 = [String: String]()
                    for (key1, __string1) in __mapof__string0 {
                        if let __string1 = __string1 {
                            __mapof__string0Decoded0?[key1] = __string1
                        }
                    }
                }
                configurationAliasesDecoded0?[key0] = __mapof__string0Decoded0
            }
        }
        configurationAliases = configurationAliasesDecoded0
        let dashConfigurationDecoded = try containerValues.decodeIfPresent(DashConfiguration.self, forKey: .dashConfiguration)
        dashConfiguration = dashConfigurationDecoded
        let hlsConfigurationDecoded = try containerValues.decodeIfPresent(HlsConfiguration.self, forKey: .hlsConfiguration)
        hlsConfiguration = hlsConfigurationDecoded
        let livePreRollConfigurationDecoded = try containerValues.decodeIfPresent(LivePreRollConfiguration.self, forKey: .livePreRollConfiguration)
        livePreRollConfiguration = livePreRollConfigurationDecoded
        let manifestProcessingRulesDecoded = try containerValues.decodeIfPresent(ManifestProcessingRules.self, forKey: .manifestProcessingRules)
        manifestProcessingRules = manifestProcessingRulesDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let personalizationThresholdSecondsDecoded = try containerValues.decode(Int.self, forKey: .personalizationThresholdSeconds)
        personalizationThresholdSeconds = personalizationThresholdSecondsDecoded
        let playbackConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .playbackConfigurationArn)
        playbackConfigurationArn = playbackConfigurationArnDecoded
        let playbackEndpointPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .playbackEndpointPrefix)
        playbackEndpointPrefix = playbackEndpointPrefixDecoded
        let sessionInitializationEndpointPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionInitializationEndpointPrefix)
        sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefixDecoded
        let slateAdUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slateAdUrl)
        slateAdUrl = slateAdUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let transcodeProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transcodeProfileName)
        transcodeProfileName = transcodeProfileNameDecoded
        let videoContentSourceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .videoContentSourceUrl)
        videoContentSourceUrl = videoContentSourceUrlDecoded
    }
}

extension PlaybackConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlaybackConfiguration(adDecisionServerUrl: \(String(describing: adDecisionServerUrl)), availSuppression: \(String(describing: availSuppression)), bumper: \(String(describing: bumper)), cdnConfiguration: \(String(describing: cdnConfiguration)), configurationAliases: \(String(describing: configurationAliases)), dashConfiguration: \(String(describing: dashConfiguration)), hlsConfiguration: \(String(describing: hlsConfiguration)), livePreRollConfiguration: \(String(describing: livePreRollConfiguration)), manifestProcessingRules: \(String(describing: manifestProcessingRules)), name: \(String(describing: name)), personalizationThresholdSeconds: \(String(describing: personalizationThresholdSeconds)), playbackConfigurationArn: \(String(describing: playbackConfigurationArn)), playbackEndpointPrefix: \(String(describing: playbackEndpointPrefix)), sessionInitializationEndpointPrefix: \(String(describing: sessionInitializationEndpointPrefix)), slateAdUrl: \(String(describing: slateAdUrl)), tags: \(String(describing: tags)), transcodeProfileName: \(String(describing: transcodeProfileName)), videoContentSourceUrl: \(String(describing: videoContentSourceUrl)))"}
}

/// <p>Creates a playback configuration. For information about MediaTailor configurations, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/configurations.html">Working with configurations in AWS Elemental MediaTailor</a>.</p>
public struct PlaybackConfiguration: Equatable {
    /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    public let adDecisionServerUrl: String?
    /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
    public let availSuppression: AvailSuppression?
    /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
    public let bumper: Bumper?
    /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
    public let cdnConfiguration: CdnConfiguration?
    /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
    public let configurationAliases: [String:[String:String]]?
    /// <p>The configuration for a DASH source.</p>
    public let dashConfiguration: DashConfiguration?
    /// <p>The configuration for HLS content.</p>
    public let hlsConfiguration: HlsConfiguration?
    /// <p>The configuration for pre-roll ad insertion.</p>
    public let livePreRollConfiguration: LivePreRollConfiguration?
    /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
    public let manifestProcessingRules: ManifestProcessingRules?
    /// <p>The identifier for the playback configuration.</p>
    public let name: String?
    /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
    public let personalizationThresholdSeconds: Int
    /// <p>The Amazon Resource Name (ARN) for the playback configuration.</p>
    public let playbackConfigurationArn: String?
    /// <p>The URL that the player accesses to get a manifest from AWS Elemental MediaTailor.</p>
    public let playbackEndpointPrefix: String?
    /// <p>The URL that the player uses to initialize a session that uses client-side reporting.</p>
    public let sessionInitializationEndpointPrefix: String?
    /// <p>The URL for a video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
    public let slateAdUrl: String?
    /// <p>The tags to assign to the playback configuration.</p>
    public let tags: [String:String]?
    /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
    public let transcodeProfileName: String?
    /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
    public let videoContentSourceUrl: String?

    public init (
        adDecisionServerUrl: String? = nil,
        availSuppression: AvailSuppression? = nil,
        bumper: Bumper? = nil,
        cdnConfiguration: CdnConfiguration? = nil,
        configurationAliases: [String:[String:String]]? = nil,
        dashConfiguration: DashConfiguration? = nil,
        hlsConfiguration: HlsConfiguration? = nil,
        livePreRollConfiguration: LivePreRollConfiguration? = nil,
        manifestProcessingRules: ManifestProcessingRules? = nil,
        name: String? = nil,
        personalizationThresholdSeconds: Int = 0,
        playbackConfigurationArn: String? = nil,
        playbackEndpointPrefix: String? = nil,
        sessionInitializationEndpointPrefix: String? = nil,
        slateAdUrl: String? = nil,
        tags: [String:String]? = nil,
        transcodeProfileName: String? = nil,
        videoContentSourceUrl: String? = nil
    )
    {
        self.adDecisionServerUrl = adDecisionServerUrl
        self.availSuppression = availSuppression
        self.bumper = bumper
        self.cdnConfiguration = cdnConfiguration
        self.configurationAliases = configurationAliases
        self.dashConfiguration = dashConfiguration
        self.hlsConfiguration = hlsConfiguration
        self.livePreRollConfiguration = livePreRollConfiguration
        self.manifestProcessingRules = manifestProcessingRules
        self.name = name
        self.personalizationThresholdSeconds = personalizationThresholdSeconds
        self.playbackConfigurationArn = playbackConfigurationArn
        self.playbackEndpointPrefix = playbackEndpointPrefix
        self.sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix
        self.slateAdUrl = slateAdUrl
        self.tags = tags
        self.transcodeProfileName = transcodeProfileName
        self.videoContentSourceUrl = videoContentSourceUrl
    }
}

public enum PlaybackMode {
    case loop
    case sdkUnknown(String)
}

extension PlaybackMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PlaybackMode] {
        return [
            .loop,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .loop: return "LOOP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PlaybackMode(rawValue: rawValue) ?? PlaybackMode.sdkUnknown(rawValue)
    }
}

public struct PutChannelPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutChannelPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutChannelPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutChannelPolicyInput>
    public typealias MOutput = OperationOutput<PutChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutChannelPolicyOutputError>
}

extension PutChannelPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutChannelPolicyInput(channelName: \(String(describing: channelName)), policy: \(String(describing: policy)))"}
}

extension PutChannelPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutChannelPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutChannelPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutChannelPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutChannelPolicyInput>
    public typealias MOutput = OperationOutput<PutChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutChannelPolicyOutputError>
}

public struct PutChannelPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutChannelPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutChannelPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutChannelPolicyInput>
    public typealias MOutput = OperationOutput<PutChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutChannelPolicyOutputError>
}

public struct PutChannelPolicyInput: Equatable {
    /// <p>The identifier for the channel you are working on.</p>
    public let channelName: String?
    /// <p>Adds an IAM role that determines the permissions of your channel.</p>
    public let policy: String?

    public init (
        channelName: String? = nil,
        policy: String? = nil
    )
    {
        self.channelName = channelName
        self.policy = policy
    }
}

struct PutChannelPolicyInputBody: Equatable {
    public let policy: String?
}

extension PutChannelPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutChannelPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutChannelPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutChannelPolicyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutChannelPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutChannelPolicyOutputResponse()"}
}

extension PutChannelPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutChannelPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutChannelPolicyOutputResponseBody: Equatable {
}

extension PutChannelPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutPlaybackConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutPlaybackConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPlaybackConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPlaybackConfigurationInput>
    public typealias MOutput = OperationOutput<PutPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPlaybackConfigurationOutputError>
}

extension PutPlaybackConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPlaybackConfigurationInput(adDecisionServerUrl: \(String(describing: adDecisionServerUrl)), availSuppression: \(String(describing: availSuppression)), bumper: \(String(describing: bumper)), cdnConfiguration: \(String(describing: cdnConfiguration)), configurationAliases: \(String(describing: configurationAliases)), dashConfiguration: \(String(describing: dashConfiguration)), livePreRollConfiguration: \(String(describing: livePreRollConfiguration)), manifestProcessingRules: \(String(describing: manifestProcessingRules)), name: \(String(describing: name)), personalizationThresholdSeconds: \(String(describing: personalizationThresholdSeconds)), slateAdUrl: \(String(describing: slateAdUrl)), tags: \(String(describing: tags)), transcodeProfileName: \(String(describing: transcodeProfileName)), videoContentSourceUrl: \(String(describing: videoContentSourceUrl)))"}
}

extension PutPlaybackConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case availSuppression = "AvailSuppression"
        case bumper = "Bumper"
        case cdnConfiguration = "CdnConfiguration"
        case configurationAliases = "ConfigurationAliases"
        case dashConfiguration = "DashConfiguration"
        case livePreRollConfiguration = "LivePreRollConfiguration"
        case manifestProcessingRules = "ManifestProcessingRules"
        case name = "Name"
        case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
        case slateAdUrl = "SlateAdUrl"
        case tags = "tags"
        case transcodeProfileName = "TranscodeProfileName"
        case videoContentSourceUrl = "VideoContentSourceUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adDecisionServerUrl = adDecisionServerUrl {
            try encodeContainer.encode(adDecisionServerUrl, forKey: .adDecisionServerUrl)
        }
        if let availSuppression = availSuppression {
            try encodeContainer.encode(availSuppression, forKey: .availSuppression)
        }
        if let bumper = bumper {
            try encodeContainer.encode(bumper, forKey: .bumper)
        }
        if let cdnConfiguration = cdnConfiguration {
            try encodeContainer.encode(cdnConfiguration, forKey: .cdnConfiguration)
        }
        if let configurationAliases = configurationAliases {
            var configurationAliasesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .configurationAliases)
            for (dictKey0, configurationaliasesrequest0) in configurationAliases {
                try configurationAliasesContainer.encode(configurationaliasesrequest0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let dashConfiguration = dashConfiguration {
            try encodeContainer.encode(dashConfiguration, forKey: .dashConfiguration)
        }
        if let livePreRollConfiguration = livePreRollConfiguration {
            try encodeContainer.encode(livePreRollConfiguration, forKey: .livePreRollConfiguration)
        }
        if let manifestProcessingRules = manifestProcessingRules {
            try encodeContainer.encode(manifestProcessingRules, forKey: .manifestProcessingRules)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if personalizationThresholdSeconds != 0 {
            try encodeContainer.encode(personalizationThresholdSeconds, forKey: .personalizationThresholdSeconds)
        }
        if let slateAdUrl = slateAdUrl {
            try encodeContainer.encode(slateAdUrl, forKey: .slateAdUrl)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let transcodeProfileName = transcodeProfileName {
            try encodeContainer.encode(transcodeProfileName, forKey: .transcodeProfileName)
        }
        if let videoContentSourceUrl = videoContentSourceUrl {
            try encodeContainer.encode(videoContentSourceUrl, forKey: .videoContentSourceUrl)
        }
    }
}

public struct PutPlaybackConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutPlaybackConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPlaybackConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPlaybackConfigurationInput>
    public typealias MOutput = OperationOutput<PutPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPlaybackConfigurationOutputError>
}

public struct PutPlaybackConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutPlaybackConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPlaybackConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPlaybackConfigurationInput>
    public typealias MOutput = OperationOutput<PutPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPlaybackConfigurationOutputError>
}

public struct PutPlaybackConfigurationInput: Equatable {
    /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    public let adDecisionServerUrl: String?
    /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
    public let availSuppression: AvailSuppression?
    /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
    public let bumper: Bumper?
    /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
    public let cdnConfiguration: CdnConfiguration?
    /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
    public let configurationAliases: [String:[String:String]]?
    /// <p>The configuration for DASH content.</p>
    public let dashConfiguration: DashConfigurationForPut?
    /// <p>The configuration for pre-roll ad insertion.</p>
    public let livePreRollConfiguration: LivePreRollConfiguration?
    /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
    public let manifestProcessingRules: ManifestProcessingRules?
    /// <p>The identifier for the playback configuration.</p>
    public let name: String?
    /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
    public let personalizationThresholdSeconds: Int
    /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
    public let slateAdUrl: String?
    /// <p>The tags to assign to the playback configuration.</p>
    public let tags: [String:String]?
    /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
    public let transcodeProfileName: String?
    /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
    public let videoContentSourceUrl: String?

    public init (
        adDecisionServerUrl: String? = nil,
        availSuppression: AvailSuppression? = nil,
        bumper: Bumper? = nil,
        cdnConfiguration: CdnConfiguration? = nil,
        configurationAliases: [String:[String:String]]? = nil,
        dashConfiguration: DashConfigurationForPut? = nil,
        livePreRollConfiguration: LivePreRollConfiguration? = nil,
        manifestProcessingRules: ManifestProcessingRules? = nil,
        name: String? = nil,
        personalizationThresholdSeconds: Int = 0,
        slateAdUrl: String? = nil,
        tags: [String:String]? = nil,
        transcodeProfileName: String? = nil,
        videoContentSourceUrl: String? = nil
    )
    {
        self.adDecisionServerUrl = adDecisionServerUrl
        self.availSuppression = availSuppression
        self.bumper = bumper
        self.cdnConfiguration = cdnConfiguration
        self.configurationAliases = configurationAliases
        self.dashConfiguration = dashConfiguration
        self.livePreRollConfiguration = livePreRollConfiguration
        self.manifestProcessingRules = manifestProcessingRules
        self.name = name
        self.personalizationThresholdSeconds = personalizationThresholdSeconds
        self.slateAdUrl = slateAdUrl
        self.tags = tags
        self.transcodeProfileName = transcodeProfileName
        self.videoContentSourceUrl = videoContentSourceUrl
    }
}

struct PutPlaybackConfigurationInputBody: Equatable {
    public let adDecisionServerUrl: String?
    public let availSuppression: AvailSuppression?
    public let bumper: Bumper?
    public let cdnConfiguration: CdnConfiguration?
    public let configurationAliases: [String:[String:String]]?
    public let dashConfiguration: DashConfigurationForPut?
    public let livePreRollConfiguration: LivePreRollConfiguration?
    public let manifestProcessingRules: ManifestProcessingRules?
    public let name: String?
    public let personalizationThresholdSeconds: Int
    public let slateAdUrl: String?
    public let tags: [String:String]?
    public let transcodeProfileName: String?
    public let videoContentSourceUrl: String?
}

extension PutPlaybackConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case availSuppression = "AvailSuppression"
        case bumper = "Bumper"
        case cdnConfiguration = "CdnConfiguration"
        case configurationAliases = "ConfigurationAliases"
        case dashConfiguration = "DashConfiguration"
        case livePreRollConfiguration = "LivePreRollConfiguration"
        case manifestProcessingRules = "ManifestProcessingRules"
        case name = "Name"
        case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
        case slateAdUrl = "SlateAdUrl"
        case tags = "tags"
        case transcodeProfileName = "TranscodeProfileName"
        case videoContentSourceUrl = "VideoContentSourceUrl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adDecisionServerUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adDecisionServerUrl)
        adDecisionServerUrl = adDecisionServerUrlDecoded
        let availSuppressionDecoded = try containerValues.decodeIfPresent(AvailSuppression.self, forKey: .availSuppression)
        availSuppression = availSuppressionDecoded
        let bumperDecoded = try containerValues.decodeIfPresent(Bumper.self, forKey: .bumper)
        bumper = bumperDecoded
        let cdnConfigurationDecoded = try containerValues.decodeIfPresent(CdnConfiguration.self, forKey: .cdnConfiguration)
        cdnConfiguration = cdnConfigurationDecoded
        let configurationAliasesContainer = try containerValues.decodeIfPresent([String: [String: String?]?].self, forKey: .configurationAliases)
        var configurationAliasesDecoded0: [String:[String:String]]? = nil
        if let configurationAliasesContainer = configurationAliasesContainer {
            configurationAliasesDecoded0 = [String:[String:String]]()
            for (key0, __mapof__string0) in configurationAliasesContainer {
                var __mapof__string0Decoded0: [String: String]? = nil
                if let __mapof__string0 = __mapof__string0 {
                    __mapof__string0Decoded0 = [String: String]()
                    for (key1, __string1) in __mapof__string0 {
                        if let __string1 = __string1 {
                            __mapof__string0Decoded0?[key1] = __string1
                        }
                    }
                }
                configurationAliasesDecoded0?[key0] = __mapof__string0Decoded0
            }
        }
        configurationAliases = configurationAliasesDecoded0
        let dashConfigurationDecoded = try containerValues.decodeIfPresent(DashConfigurationForPut.self, forKey: .dashConfiguration)
        dashConfiguration = dashConfigurationDecoded
        let livePreRollConfigurationDecoded = try containerValues.decodeIfPresent(LivePreRollConfiguration.self, forKey: .livePreRollConfiguration)
        livePreRollConfiguration = livePreRollConfigurationDecoded
        let manifestProcessingRulesDecoded = try containerValues.decodeIfPresent(ManifestProcessingRules.self, forKey: .manifestProcessingRules)
        manifestProcessingRules = manifestProcessingRulesDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let personalizationThresholdSecondsDecoded = try containerValues.decode(Int.self, forKey: .personalizationThresholdSeconds)
        personalizationThresholdSeconds = personalizationThresholdSecondsDecoded
        let slateAdUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slateAdUrl)
        slateAdUrl = slateAdUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let transcodeProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transcodeProfileName)
        transcodeProfileName = transcodeProfileNameDecoded
        let videoContentSourceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .videoContentSourceUrl)
        videoContentSourceUrl = videoContentSourceUrlDecoded
    }
}

extension PutPlaybackConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPlaybackConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPlaybackConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPlaybackConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPlaybackConfigurationOutputResponse(adDecisionServerUrl: \(String(describing: adDecisionServerUrl)), availSuppression: \(String(describing: availSuppression)), bumper: \(String(describing: bumper)), cdnConfiguration: \(String(describing: cdnConfiguration)), configurationAliases: \(String(describing: configurationAliases)), dashConfiguration: \(String(describing: dashConfiguration)), hlsConfiguration: \(String(describing: hlsConfiguration)), livePreRollConfiguration: \(String(describing: livePreRollConfiguration)), manifestProcessingRules: \(String(describing: manifestProcessingRules)), name: \(String(describing: name)), personalizationThresholdSeconds: \(String(describing: personalizationThresholdSeconds)), playbackConfigurationArn: \(String(describing: playbackConfigurationArn)), playbackEndpointPrefix: \(String(describing: playbackEndpointPrefix)), sessionInitializationEndpointPrefix: \(String(describing: sessionInitializationEndpointPrefix)), slateAdUrl: \(String(describing: slateAdUrl)), tags: \(String(describing: tags)), transcodeProfileName: \(String(describing: transcodeProfileName)), videoContentSourceUrl: \(String(describing: videoContentSourceUrl)))"}
}

extension PutPlaybackConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutPlaybackConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.adDecisionServerUrl = output.adDecisionServerUrl
            self.availSuppression = output.availSuppression
            self.bumper = output.bumper
            self.cdnConfiguration = output.cdnConfiguration
            self.configurationAliases = output.configurationAliases
            self.dashConfiguration = output.dashConfiguration
            self.hlsConfiguration = output.hlsConfiguration
            self.livePreRollConfiguration = output.livePreRollConfiguration
            self.manifestProcessingRules = output.manifestProcessingRules
            self.name = output.name
            self.personalizationThresholdSeconds = output.personalizationThresholdSeconds
            self.playbackConfigurationArn = output.playbackConfigurationArn
            self.playbackEndpointPrefix = output.playbackEndpointPrefix
            self.sessionInitializationEndpointPrefix = output.sessionInitializationEndpointPrefix
            self.slateAdUrl = output.slateAdUrl
            self.tags = output.tags
            self.transcodeProfileName = output.transcodeProfileName
            self.videoContentSourceUrl = output.videoContentSourceUrl
        } else {
            self.adDecisionServerUrl = nil
            self.availSuppression = nil
            self.bumper = nil
            self.cdnConfiguration = nil
            self.configurationAliases = nil
            self.dashConfiguration = nil
            self.hlsConfiguration = nil
            self.livePreRollConfiguration = nil
            self.manifestProcessingRules = nil
            self.name = nil
            self.personalizationThresholdSeconds = 0
            self.playbackConfigurationArn = nil
            self.playbackEndpointPrefix = nil
            self.sessionInitializationEndpointPrefix = nil
            self.slateAdUrl = nil
            self.tags = nil
            self.transcodeProfileName = nil
            self.videoContentSourceUrl = nil
        }
    }
}

public struct PutPlaybackConfigurationOutputResponse: Equatable {
    /// <p>The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.</p>
    public let adDecisionServerUrl: String?
    /// <p>The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.</p>
    public let availSuppression: AvailSuppression?
    /// <p>The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.</p>
    public let bumper: Bumper?
    /// <p>The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.</p>
    public let cdnConfiguration: CdnConfiguration?
    /// <p>The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables</a>.</p>
    public let configurationAliases: [String:[String:String]]?
    /// <p>The configuration for DASH content.</p>
    public let dashConfiguration: DashConfiguration?
    /// <p>The configuration for HLS content.</p>
    public let hlsConfiguration: HlsConfiguration?
    /// <p>The configuration for pre-roll ad insertion.</p>
    public let livePreRollConfiguration: LivePreRollConfiguration?
    /// <p>The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.</p>
    public let manifestProcessingRules: ManifestProcessingRules?
    /// <p>The identifier for the playback configuration.</p>
    public let name: String?
    /// <p>Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.</p>
    public let personalizationThresholdSeconds: Int
    /// <p>The Amazon Resource Name (ARN) for the playback configuration.</p>
    public let playbackConfigurationArn: String?
    /// <p>The URL that the player accesses to get a manifest from AWS Elemental MediaTailor. This session will use server-side reporting.</p>
    public let playbackEndpointPrefix: String?
    /// <p>The URL that the player uses to initialize a session that uses client-side reporting.</p>
    public let sessionInitializationEndpointPrefix: String?
    /// <p>The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.</p>
    public let slateAdUrl: String?
    /// <p>The tags assigned to the playback configuration.</p>
    public let tags: [String:String]?
    /// <p>The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.</p>
    public let transcodeProfileName: String?
    /// <p>The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.</p>
    public let videoContentSourceUrl: String?

    public init (
        adDecisionServerUrl: String? = nil,
        availSuppression: AvailSuppression? = nil,
        bumper: Bumper? = nil,
        cdnConfiguration: CdnConfiguration? = nil,
        configurationAliases: [String:[String:String]]? = nil,
        dashConfiguration: DashConfiguration? = nil,
        hlsConfiguration: HlsConfiguration? = nil,
        livePreRollConfiguration: LivePreRollConfiguration? = nil,
        manifestProcessingRules: ManifestProcessingRules? = nil,
        name: String? = nil,
        personalizationThresholdSeconds: Int = 0,
        playbackConfigurationArn: String? = nil,
        playbackEndpointPrefix: String? = nil,
        sessionInitializationEndpointPrefix: String? = nil,
        slateAdUrl: String? = nil,
        tags: [String:String]? = nil,
        transcodeProfileName: String? = nil,
        videoContentSourceUrl: String? = nil
    )
    {
        self.adDecisionServerUrl = adDecisionServerUrl
        self.availSuppression = availSuppression
        self.bumper = bumper
        self.cdnConfiguration = cdnConfiguration
        self.configurationAliases = configurationAliases
        self.dashConfiguration = dashConfiguration
        self.hlsConfiguration = hlsConfiguration
        self.livePreRollConfiguration = livePreRollConfiguration
        self.manifestProcessingRules = manifestProcessingRules
        self.name = name
        self.personalizationThresholdSeconds = personalizationThresholdSeconds
        self.playbackConfigurationArn = playbackConfigurationArn
        self.playbackEndpointPrefix = playbackEndpointPrefix
        self.sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix
        self.slateAdUrl = slateAdUrl
        self.tags = tags
        self.transcodeProfileName = transcodeProfileName
        self.videoContentSourceUrl = videoContentSourceUrl
    }
}

struct PutPlaybackConfigurationOutputResponseBody: Equatable {
    public let adDecisionServerUrl: String?
    public let availSuppression: AvailSuppression?
    public let bumper: Bumper?
    public let cdnConfiguration: CdnConfiguration?
    public let configurationAliases: [String:[String:String]]?
    public let dashConfiguration: DashConfiguration?
    public let hlsConfiguration: HlsConfiguration?
    public let livePreRollConfiguration: LivePreRollConfiguration?
    public let manifestProcessingRules: ManifestProcessingRules?
    public let name: String?
    public let personalizationThresholdSeconds: Int
    public let playbackConfigurationArn: String?
    public let playbackEndpointPrefix: String?
    public let sessionInitializationEndpointPrefix: String?
    public let slateAdUrl: String?
    public let tags: [String:String]?
    public let transcodeProfileName: String?
    public let videoContentSourceUrl: String?
}

extension PutPlaybackConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case availSuppression = "AvailSuppression"
        case bumper = "Bumper"
        case cdnConfiguration = "CdnConfiguration"
        case configurationAliases = "ConfigurationAliases"
        case dashConfiguration = "DashConfiguration"
        case hlsConfiguration = "HlsConfiguration"
        case livePreRollConfiguration = "LivePreRollConfiguration"
        case manifestProcessingRules = "ManifestProcessingRules"
        case name = "Name"
        case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
        case playbackConfigurationArn = "PlaybackConfigurationArn"
        case playbackEndpointPrefix = "PlaybackEndpointPrefix"
        case sessionInitializationEndpointPrefix = "SessionInitializationEndpointPrefix"
        case slateAdUrl = "SlateAdUrl"
        case tags = "tags"
        case transcodeProfileName = "TranscodeProfileName"
        case videoContentSourceUrl = "VideoContentSourceUrl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adDecisionServerUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adDecisionServerUrl)
        adDecisionServerUrl = adDecisionServerUrlDecoded
        let availSuppressionDecoded = try containerValues.decodeIfPresent(AvailSuppression.self, forKey: .availSuppression)
        availSuppression = availSuppressionDecoded
        let bumperDecoded = try containerValues.decodeIfPresent(Bumper.self, forKey: .bumper)
        bumper = bumperDecoded
        let cdnConfigurationDecoded = try containerValues.decodeIfPresent(CdnConfiguration.self, forKey: .cdnConfiguration)
        cdnConfiguration = cdnConfigurationDecoded
        let configurationAliasesContainer = try containerValues.decodeIfPresent([String: [String: String?]?].self, forKey: .configurationAliases)
        var configurationAliasesDecoded0: [String:[String:String]]? = nil
        if let configurationAliasesContainer = configurationAliasesContainer {
            configurationAliasesDecoded0 = [String:[String:String]]()
            for (key0, __mapof__string0) in configurationAliasesContainer {
                var __mapof__string0Decoded0: [String: String]? = nil
                if let __mapof__string0 = __mapof__string0 {
                    __mapof__string0Decoded0 = [String: String]()
                    for (key1, __string1) in __mapof__string0 {
                        if let __string1 = __string1 {
                            __mapof__string0Decoded0?[key1] = __string1
                        }
                    }
                }
                configurationAliasesDecoded0?[key0] = __mapof__string0Decoded0
            }
        }
        configurationAliases = configurationAliasesDecoded0
        let dashConfigurationDecoded = try containerValues.decodeIfPresent(DashConfiguration.self, forKey: .dashConfiguration)
        dashConfiguration = dashConfigurationDecoded
        let hlsConfigurationDecoded = try containerValues.decodeIfPresent(HlsConfiguration.self, forKey: .hlsConfiguration)
        hlsConfiguration = hlsConfigurationDecoded
        let livePreRollConfigurationDecoded = try containerValues.decodeIfPresent(LivePreRollConfiguration.self, forKey: .livePreRollConfiguration)
        livePreRollConfiguration = livePreRollConfigurationDecoded
        let manifestProcessingRulesDecoded = try containerValues.decodeIfPresent(ManifestProcessingRules.self, forKey: .manifestProcessingRules)
        manifestProcessingRules = manifestProcessingRulesDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let personalizationThresholdSecondsDecoded = try containerValues.decode(Int.self, forKey: .personalizationThresholdSeconds)
        personalizationThresholdSeconds = personalizationThresholdSecondsDecoded
        let playbackConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .playbackConfigurationArn)
        playbackConfigurationArn = playbackConfigurationArnDecoded
        let playbackEndpointPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .playbackEndpointPrefix)
        playbackEndpointPrefix = playbackEndpointPrefixDecoded
        let sessionInitializationEndpointPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionInitializationEndpointPrefix)
        sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefixDecoded
        let slateAdUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slateAdUrl)
        slateAdUrl = slateAdUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let transcodeProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transcodeProfileName)
        transcodeProfileName = transcodeProfileNameDecoded
        let videoContentSourceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .videoContentSourceUrl)
        videoContentSourceUrl = videoContentSourceUrlDecoded
    }
}

public enum RelativePosition {
    case afterProgram
    case beforeProgram
    case sdkUnknown(String)
}

extension RelativePosition : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RelativePosition] {
        return [
            .afterProgram,
            .beforeProgram,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .afterProgram: return "AFTER_PROGRAM"
        case .beforeProgram: return "BEFORE_PROGRAM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RelativePosition(rawValue: rawValue) ?? RelativePosition.sdkUnknown(rawValue)
    }
}

extension RequestOutputItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dashPlaylistSettings = "DashPlaylistSettings"
        case hlsPlaylistSettings = "HlsPlaylistSettings"
        case manifestName = "ManifestName"
        case sourceGroup = "SourceGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashPlaylistSettings = dashPlaylistSettings {
            try encodeContainer.encode(dashPlaylistSettings, forKey: .dashPlaylistSettings)
        }
        if let hlsPlaylistSettings = hlsPlaylistSettings {
            try encodeContainer.encode(hlsPlaylistSettings, forKey: .hlsPlaylistSettings)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let sourceGroup = sourceGroup {
            try encodeContainer.encode(sourceGroup, forKey: .sourceGroup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashPlaylistSettingsDecoded = try containerValues.decodeIfPresent(DashPlaylistSettings.self, forKey: .dashPlaylistSettings)
        dashPlaylistSettings = dashPlaylistSettingsDecoded
        let hlsPlaylistSettingsDecoded = try containerValues.decodeIfPresent(HlsPlaylistSettings.self, forKey: .hlsPlaylistSettings)
        hlsPlaylistSettings = hlsPlaylistSettingsDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let sourceGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceGroup)
        sourceGroup = sourceGroupDecoded
    }
}

extension RequestOutputItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestOutputItem(dashPlaylistSettings: \(String(describing: dashPlaylistSettings)), hlsPlaylistSettings: \(String(describing: hlsPlaylistSettings)), manifestName: \(String(describing: manifestName)), sourceGroup: \(String(describing: sourceGroup)))"}
}

/// <p>The ouput configuration for this channel.</p>
public struct RequestOutputItem: Equatable {
    /// <p>DASH manifest configuration parameters.</p>
    public let dashPlaylistSettings: DashPlaylistSettings?
    /// <p>HLS playlist configuration parameters.</p>
    public let hlsPlaylistSettings: HlsPlaylistSettings?
    /// <p>The name of the manifest for the channel. The name appears in the PlaybackUrl.</p>
    public let manifestName: String?
    /// <p>A string used to match which HttpPackageConfiguration is used for each VodSource.</p>
    public let sourceGroup: String?

    public init (
        dashPlaylistSettings: DashPlaylistSettings? = nil,
        hlsPlaylistSettings: HlsPlaylistSettings? = nil,
        manifestName: String? = nil,
        sourceGroup: String? = nil
    )
    {
        self.dashPlaylistSettings = dashPlaylistSettings
        self.hlsPlaylistSettings = hlsPlaylistSettings
        self.manifestName = manifestName
        self.sourceGroup = sourceGroup
    }
}

extension ResponseOutputItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dashPlaylistSettings = "DashPlaylistSettings"
        case hlsPlaylistSettings = "HlsPlaylistSettings"
        case manifestName = "ManifestName"
        case playbackUrl = "PlaybackUrl"
        case sourceGroup = "SourceGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashPlaylistSettings = dashPlaylistSettings {
            try encodeContainer.encode(dashPlaylistSettings, forKey: .dashPlaylistSettings)
        }
        if let hlsPlaylistSettings = hlsPlaylistSettings {
            try encodeContainer.encode(hlsPlaylistSettings, forKey: .hlsPlaylistSettings)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let playbackUrl = playbackUrl {
            try encodeContainer.encode(playbackUrl, forKey: .playbackUrl)
        }
        if let sourceGroup = sourceGroup {
            try encodeContainer.encode(sourceGroup, forKey: .sourceGroup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashPlaylistSettingsDecoded = try containerValues.decodeIfPresent(DashPlaylistSettings.self, forKey: .dashPlaylistSettings)
        dashPlaylistSettings = dashPlaylistSettingsDecoded
        let hlsPlaylistSettingsDecoded = try containerValues.decodeIfPresent(HlsPlaylistSettings.self, forKey: .hlsPlaylistSettings)
        hlsPlaylistSettings = hlsPlaylistSettingsDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let playbackUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .playbackUrl)
        playbackUrl = playbackUrlDecoded
        let sourceGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceGroup)
        sourceGroup = sourceGroupDecoded
    }
}

extension ResponseOutputItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResponseOutputItem(dashPlaylistSettings: \(String(describing: dashPlaylistSettings)), hlsPlaylistSettings: \(String(describing: hlsPlaylistSettings)), manifestName: \(String(describing: manifestName)), playbackUrl: \(String(describing: playbackUrl)), sourceGroup: \(String(describing: sourceGroup)))"}
}

/// <p>This response includes only the "property" : "type" property.</p>
public struct ResponseOutputItem: Equatable {
    /// <p>DASH manifest configuration settings.</p>
    public let dashPlaylistSettings: DashPlaylistSettings?
    /// <p>HLS manifest configuration settings.</p>
    public let hlsPlaylistSettings: HlsPlaylistSettings?
    /// <p>The name of the manifest for the channel that will appear in the channel output's playback URL.</p>
    public let manifestName: String?
    /// <p>The URL used for playback by content players.</p>
    public let playbackUrl: String?
    /// <p>A string used to associate a package configuration source group with a channel output.</p>
    public let sourceGroup: String?

    public init (
        dashPlaylistSettings: DashPlaylistSettings? = nil,
        hlsPlaylistSettings: HlsPlaylistSettings? = nil,
        manifestName: String? = nil,
        playbackUrl: String? = nil,
        sourceGroup: String? = nil
    )
    {
        self.dashPlaylistSettings = dashPlaylistSettings
        self.hlsPlaylistSettings = hlsPlaylistSettings
        self.manifestName = manifestName
        self.playbackUrl = playbackUrl
        self.sourceGroup = sourceGroup
    }
}

extension ScheduleConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case transition = "Transition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transition = transition {
            try encodeContainer.encode(transition, forKey: .transition)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitionDecoded = try containerValues.decodeIfPresent(Transition.self, forKey: .transition)
        transition = transitionDecoded
    }
}

extension ScheduleConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduleConfiguration(transition: \(String(describing: transition)))"}
}

/// <p>Schedule configuration parameters. A channel must be stopped before changes can be made to the schedule.</p>
public struct ScheduleConfiguration: Equatable {
    /// <p>Program transition configurations.</p>
    public let transition: Transition?

    public init (
        transition: Transition? = nil
    )
    {
        self.transition = transition
    }
}

extension ScheduleEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approximateDurationSeconds = "ApproximateDurationSeconds"
        case approximateStartTime = "ApproximateStartTime"
        case arn = "Arn"
        case channelName = "ChannelName"
        case programName = "ProgramName"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if approximateDurationSeconds != 0 {
            try encodeContainer.encode(approximateDurationSeconds, forKey: .approximateDurationSeconds)
        }
        if let approximateStartTime = approximateStartTime {
            try encodeContainer.encode(approximateStartTime.timeIntervalSince1970, forKey: .approximateStartTime)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let programName = programName {
            try encodeContainer.encode(programName, forKey: .programName)
        }
        if let sourceLocationName = sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let vodSourceName = vodSourceName {
            try encodeContainer.encode(vodSourceName, forKey: .vodSourceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approximateDurationSecondsDecoded = try containerValues.decode(Int.self, forKey: .approximateDurationSeconds)
        approximateDurationSeconds = approximateDurationSecondsDecoded
        let approximateStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .approximateStartTime)
        approximateStartTime = approximateStartTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let programNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .programName)
        programName = programNameDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension ScheduleEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduleEntry(approximateDurationSeconds: \(String(describing: approximateDurationSeconds)), approximateStartTime: \(String(describing: approximateStartTime)), arn: \(String(describing: arn)), channelName: \(String(describing: channelName)), programName: \(String(describing: programName)), sourceLocationName: \(String(describing: sourceLocationName)), vodSourceName: \(String(describing: vodSourceName)))"}
}

/// <p>The properties for a schedule.</p>
public struct ScheduleEntry: Equatable {
    /// <p>The approximate duration of this program, in seconds.</p>
    public let approximateDurationSeconds: Int
    /// <p>The approximate time that the program will start playing.</p>
    public let approximateStartTime: Date?
    /// <p>The ARN of the program.</p>
    public let arn: String?
    /// <p>The name of the channel that uses this schedule.</p>
    public let channelName: String?
    /// <p>The name of the program.</p>
    public let programName: String?
    /// <p>The name of the source location.</p>
    public let sourceLocationName: String?
    /// <p>The name of the VOD source.</p>
    public let vodSourceName: String?

    public init (
        approximateDurationSeconds: Int = 0,
        approximateStartTime: Date? = nil,
        arn: String? = nil,
        channelName: String? = nil,
        programName: String? = nil,
        sourceLocationName: String? = nil,
        vodSourceName: String? = nil
    )
    {
        self.approximateDurationSeconds = approximateDurationSeconds
        self.approximateStartTime = approximateStartTime
        self.arn = arn
        self.channelName = channelName
        self.programName = programName
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

extension SlateSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceLocationName = sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let vodSourceName = vodSourceName {
            try encodeContainer.encode(vodSourceName, forKey: .vodSourceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension SlateSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlateSource(sourceLocationName: \(String(describing: sourceLocationName)), vodSourceName: \(String(describing: vodSourceName)))"}
}

/// <p>Slate VOD source configuration.</p>
public struct SlateSource: Equatable {
    /// <p>The name of the source location where the slate VOD source is stored.</p>
    public let sourceLocationName: String?
    /// <p>The slate VOD source name. The VOD source must already exist in a source location before it can be used for slate.</p>
    public let vodSourceName: String?

    public init (
        sourceLocationName: String? = nil,
        vodSourceName: String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

extension SourceLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case arn = "Arn"
        case creationTime = "CreationTime"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessConfiguration = accessConfiguration {
            try encodeContainer.encode(accessConfiguration, forKey: .accessConfiguration)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration {
            try encodeContainer.encode(defaultSegmentDeliveryConfiguration, forKey: .defaultSegmentDeliveryConfiguration)
        }
        if let httpConfiguration = httpConfiguration {
            try encodeContainer.encode(httpConfiguration, forKey: .httpConfiguration)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let sourceLocationName = sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SourceLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceLocation(accessConfiguration: \(String(describing: accessConfiguration)), arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), defaultSegmentDeliveryConfiguration: \(String(describing: defaultSegmentDeliveryConfiguration)), httpConfiguration: \(String(describing: httpConfiguration)), lastModifiedTime: \(String(describing: lastModifiedTime)), sourceLocationName: \(String(describing: sourceLocationName)), tags: \(String(describing: tags)))"}
}

/// <p>This response includes only the "type" : "object" property.</p>
public struct SourceLocation: Equatable {
    /// <p>The access configuration for the source location.</p>
    public let accessConfiguration: AccessConfiguration?
    /// <p>The ARN of the SourceLocation.</p>
    public let arn: String?
    /// <p>The timestamp that indicates when the source location was created.</p>
    public let creationTime: Date?
    /// <p>The default segment delivery configuration.</p>
    public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
    /// <p>The HTTP configuration for the source location.</p>
    public let httpConfiguration: HttpConfiguration?
    /// <p>The timestamp that indicates when the source location was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The name of the source location.</p>
    public let sourceLocationName: String?
    /// <p>The tags assigned to the source location.</p>
    public let tags: [String:String]?

    public init (
        accessConfiguration: AccessConfiguration? = nil,
        arn: String? = nil,
        creationTime: Date? = nil,
        defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: HttpConfiguration? = nil,
        lastModifiedTime: Date? = nil,
        sourceLocationName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.arn = arn
        self.creationTime = creationTime
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

extension SpliceInsertMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availNum = "AvailNum"
        case availsExpected = "AvailsExpected"
        case spliceEventId = "SpliceEventId"
        case uniqueProgramId = "UniqueProgramId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if availNum != 0 {
            try encodeContainer.encode(availNum, forKey: .availNum)
        }
        if availsExpected != 0 {
            try encodeContainer.encode(availsExpected, forKey: .availsExpected)
        }
        if spliceEventId != 0 {
            try encodeContainer.encode(spliceEventId, forKey: .spliceEventId)
        }
        if uniqueProgramId != 0 {
            try encodeContainer.encode(uniqueProgramId, forKey: .uniqueProgramId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availNumDecoded = try containerValues.decode(Int.self, forKey: .availNum)
        availNum = availNumDecoded
        let availsExpectedDecoded = try containerValues.decode(Int.self, forKey: .availsExpected)
        availsExpected = availsExpectedDecoded
        let spliceEventIdDecoded = try containerValues.decode(Int.self, forKey: .spliceEventId)
        spliceEventId = spliceEventIdDecoded
        let uniqueProgramIdDecoded = try containerValues.decode(Int.self, forKey: .uniqueProgramId)
        uniqueProgramId = uniqueProgramIdDecoded
    }
}

extension SpliceInsertMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SpliceInsertMessage(availNum: \(String(describing: availNum)), availsExpected: \(String(describing: availsExpected)), spliceEventId: \(String(describing: spliceEventId)), uniqueProgramId: \(String(describing: uniqueProgramId)))"}
}

/// <p>Splice insert message configuration.</p>
public struct SpliceInsertMessage: Equatable {
    /// <p>This is written to splice_insert.avail_num, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 0. Values must be between 0 and 256, inclusive.</p>
    public let availNum: Int
    /// <p>This is written to splice_insert.avails_expected, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 0. Values must be between 0 and 256, inclusive.</p>
    public let availsExpected: Int
    /// <p>This is written to splice_insert.splice_event_id, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 1.</p>
    public let spliceEventId: Int
    /// <p>This is written to splice_insert.unique_program_id, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 0. Values must be between 0 and 256, inclusive.</p>
    public let uniqueProgramId: Int

    public init (
        availNum: Int = 0,
        availsExpected: Int = 0,
        spliceEventId: Int = 0,
        uniqueProgramId: Int = 0
    )
    {
        self.availNum = availNum
        self.availsExpected = availsExpected
        self.spliceEventId = spliceEventId
        self.uniqueProgramId = uniqueProgramId
    }
}

extension StartChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartChannelInput(channelName: \(String(describing: channelName)))"}
}

extension StartChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StartChannelInputHeadersMiddleware: Middleware {
    public let id: String = "StartChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<StartChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartChannelInput>
    public typealias MOutput = OperationOutput<StartChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartChannelOutputError>
}

public struct StartChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "StartChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<StartChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartChannelInput>
    public typealias MOutput = OperationOutput<StartChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartChannelOutputError>
}

public struct StartChannelInput: Equatable {
    /// <p>The identifier for the channel you are working on.</p>
    public let channelName: String?

    public init (
        channelName: String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct StartChannelInputBody: Equatable {
}

extension StartChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StartChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartChannelOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension StartChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartChannelOutputResponse()"}
}

extension StartChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartChannelOutputResponse: Equatable {

    public init() {}
}

struct StartChannelOutputResponseBody: Equatable {
}

extension StartChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopChannelInput(channelName: \(String(describing: channelName)))"}
}

extension StopChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StopChannelInputHeadersMiddleware: Middleware {
    public let id: String = "StopChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<StopChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopChannelInput>
    public typealias MOutput = OperationOutput<StopChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopChannelOutputError>
}

public struct StopChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "StopChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<StopChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopChannelInput>
    public typealias MOutput = OperationOutput<StopChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopChannelOutputError>
}

public struct StopChannelInput: Equatable {
    /// <p>The identifier for the channel you are working on.</p>
    public let channelName: String?

    public init (
        channelName: String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct StopChannelInputBody: Equatable {
}

extension StopChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopChannelOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension StopChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopChannelOutputResponse()"}
}

extension StopChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopChannelOutputResponse: Equatable {

    public init() {}
}

struct StopChannelOutputResponseBody: Equatable {
}

extension StopChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
    public let resourceArn: String?
    /// <p>A comma-separated list of tag key:value pairs.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Transition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case relativePosition = "RelativePosition"
        case relativeProgram = "RelativeProgram"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relativePosition = relativePosition {
            try encodeContainer.encode(relativePosition.rawValue, forKey: .relativePosition)
        }
        if let relativeProgram = relativeProgram {
            try encodeContainer.encode(relativeProgram, forKey: .relativeProgram)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relativePositionDecoded = try containerValues.decodeIfPresent(RelativePosition.self, forKey: .relativePosition)
        relativePosition = relativePositionDecoded
        let relativeProgramDecoded = try containerValues.decodeIfPresent(String.self, forKey: .relativeProgram)
        relativeProgram = relativeProgramDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension Transition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Transition(relativePosition: \(String(describing: relativePosition)), relativeProgram: \(String(describing: relativeProgram)), type: \(String(describing: type)))"}
}

/// <p>Program transition configuration.</p>
public struct Transition: Equatable {
    /// <p>The position where this program will be inserted relative to the RelativeProgram. Possible values are: AFTER_PROGRAM, and BEFORE_PROGRAM.</p>
    public let relativePosition: RelativePosition?
    /// <p>The name of the program that this program will be inserted next to, as defined by RelativePosition.</p>
    public let relativeProgram: String?
    /// <p>When the program should be played. RELATIVE means that programs will be played back-to-back.</p>
    public let type: String?

    public init (
        relativePosition: RelativePosition? = nil,
        relativeProgram: String? = nil,
        type: String? = nil
    )
    {
        self.relativePosition = relativePosition
        self.relativeProgram = relativeProgram
        self.type = type
    }
}

public enum `Type` {
    case dash
    case hls
    case sdkUnknown(String)
}

extension `Type` : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [`Type`] {
        return [
            .dash,
            .hls,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dash: return "DASH"
        case .hls: return "HLS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = `Type`(rawValue: rawValue) ?? `Type`.sdkUnknown(rawValue)
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.</p>
    public let resourceArn: String?
    /// <p>A comma-separated list of the tag keys to remove from the playback configuration.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateChannelOutputError>
}

extension UpdateChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateChannelInput(channelName: \(String(describing: channelName)), outputs: \(String(describing: outputs)))"}
}

extension UpdateChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case outputs = "Outputs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for requestoutputs0 in outputs {
                try outputsContainer.encode(requestoutputs0)
            }
        }
    }
}

public struct UpdateChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInput: Equatable {
    /// <p>The identifier for the channel you are working on.</p>
    public let channelName: String?
    /// <p>The channel's output properties.</p>
    public let outputs: [RequestOutputItem]?

    public init (
        channelName: String? = nil,
        outputs: [RequestOutputItem]? = nil
    )
    {
        self.channelName = channelName
        self.outputs = outputs
    }
}

struct UpdateChannelInputBody: Equatable {
    public let outputs: [RequestOutputItem]?
}

extension UpdateChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case outputs = "Outputs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputsContainer = try containerValues.decodeIfPresent([RequestOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[RequestOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [RequestOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

extension UpdateChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateChannelOutputResponse(arn: \(String(describing: arn)), channelName: \(String(describing: channelName)), channelState: \(String(describing: channelState)), creationTime: \(String(describing: creationTime)), lastModifiedTime: \(String(describing: lastModifiedTime)), outputs: \(String(describing: outputs)), playbackMode: \(String(describing: playbackMode)), tags: \(String(describing: tags)))"}
}

extension UpdateChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.channelName = output.channelName
            self.channelState = output.channelState
            self.creationTime = output.creationTime
            self.lastModifiedTime = output.lastModifiedTime
            self.outputs = output.outputs
            self.playbackMode = output.playbackMode
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelName = nil
            self.channelState = nil
            self.creationTime = nil
            self.lastModifiedTime = nil
            self.outputs = nil
            self.playbackMode = nil
            self.tags = nil
        }
    }
}

public struct UpdateChannelOutputResponse: Equatable {
    /// <p>The ARN of the channel.</p>
    public let arn: String?
    /// <p>The name of the channel.</p>
    public let channelName: String?
    /// <p>Indicates whether the channel is in a running state or not.</p>
    public let channelState: ChannelState?
    /// <p>The timestamp of when the channel was created.</p>
    public let creationTime: Date?
    /// <p>The timestamp of when the channel was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The channel's output properties.</p>
    public let outputs: [ResponseOutputItem]?
    /// <p>The type of playback for this channel. The only supported value is LOOP.</p>
    public let playbackMode: String?
    /// <p>The tags assigned to the channel.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        channelName: String? = nil,
        channelState: ChannelState? = nil,
        creationTime: Date? = nil,
        lastModifiedTime: Date? = nil,
        outputs: [ResponseOutputItem]? = nil,
        playbackMode: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.channelName = channelName
        self.channelState = channelState
        self.creationTime = creationTime
        self.lastModifiedTime = lastModifiedTime
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
    }
}

struct UpdateChannelOutputResponseBody: Equatable {
    public let arn: String?
    public let channelName: String?
    public let channelState: ChannelState?
    public let creationTime: Date?
    public let lastModifiedTime: Date?
    public let outputs: [ResponseOutputItem]?
    public let playbackMode: String?
    public let tags: [String:String]?
}

extension UpdateChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case channelName = "ChannelName"
        case channelState = "ChannelState"
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStateDecoded = try containerValues.decodeIfPresent(ChannelState.self, forKey: .channelState)
        channelState = channelStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ResponseOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[ResponseOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ResponseOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let playbackModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateSourceLocationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSourceLocationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSourceLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSourceLocationInput>
    public typealias MOutput = OperationOutput<UpdateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSourceLocationOutputError>
}

extension UpdateSourceLocationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSourceLocationInput(accessConfiguration: \(String(describing: accessConfiguration)), defaultSegmentDeliveryConfiguration: \(String(describing: defaultSegmentDeliveryConfiguration)), httpConfiguration: \(String(describing: httpConfiguration)), sourceLocationName: \(String(describing: sourceLocationName)))"}
}

extension UpdateSourceLocationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessConfiguration = accessConfiguration {
            try encodeContainer.encode(accessConfiguration, forKey: .accessConfiguration)
        }
        if let defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration {
            try encodeContainer.encode(defaultSegmentDeliveryConfiguration, forKey: .defaultSegmentDeliveryConfiguration)
        }
        if let httpConfiguration = httpConfiguration {
            try encodeContainer.encode(httpConfiguration, forKey: .httpConfiguration)
        }
    }
}

public struct UpdateSourceLocationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSourceLocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSourceLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSourceLocationInput>
    public typealias MOutput = OperationOutput<UpdateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSourceLocationOutputError>
}

public struct UpdateSourceLocationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSourceLocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSourceLocationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSourceLocationInput>
    public typealias MOutput = OperationOutput<UpdateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSourceLocationOutputError>
}

public struct UpdateSourceLocationInput: Equatable {
    /// <p>Access configuration parameters. Configures the type of authentication used to access content from your source location.</p>
    public let accessConfiguration: AccessConfiguration?
    /// <p>The optional configuration for the host server that serves segments.</p>
    public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
    /// <p>The HTTP configuration for the source location.</p>
    public let httpConfiguration: HttpConfiguration?
    /// <p>The identifier for the source location you are working on.</p>
    public let sourceLocationName: String?

    public init (
        accessConfiguration: AccessConfiguration? = nil,
        defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: HttpConfiguration? = nil,
        sourceLocationName: String? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.sourceLocationName = sourceLocationName
    }
}

struct UpdateSourceLocationInputBody: Equatable {
    public let accessConfiguration: AccessConfiguration?
    public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
    public let httpConfiguration: HttpConfiguration?
}

extension UpdateSourceLocationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
    }
}

extension UpdateSourceLocationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSourceLocationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSourceLocationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSourceLocationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSourceLocationOutputResponse(accessConfiguration: \(String(describing: accessConfiguration)), arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), defaultSegmentDeliveryConfiguration: \(String(describing: defaultSegmentDeliveryConfiguration)), httpConfiguration: \(String(describing: httpConfiguration)), lastModifiedTime: \(String(describing: lastModifiedTime)), sourceLocationName: \(String(describing: sourceLocationName)), tags: \(String(describing: tags)))"}
}

extension UpdateSourceLocationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSourceLocationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessConfiguration = output.accessConfiguration
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.defaultSegmentDeliveryConfiguration = output.defaultSegmentDeliveryConfiguration
            self.httpConfiguration = output.httpConfiguration
            self.lastModifiedTime = output.lastModifiedTime
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
        } else {
            self.accessConfiguration = nil
            self.arn = nil
            self.creationTime = nil
            self.defaultSegmentDeliveryConfiguration = nil
            self.httpConfiguration = nil
            self.lastModifiedTime = nil
            self.sourceLocationName = nil
            self.tags = nil
        }
    }
}

public struct UpdateSourceLocationOutputResponse: Equatable {
    /// <p>The access configuration for the source location.</p>
    public let accessConfiguration: AccessConfiguration?
    /// <p>The ARN of the source location.</p>
    public let arn: String?
    /// <p>The timestamp that indicates when the source location was created.</p>
    public let creationTime: Date?
    /// <p>The default segment delivery configuration settings.</p>
    public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
    /// <p>The HTTP package configuration settings for the source location.</p>
    public let httpConfiguration: HttpConfiguration?
    /// <p>The timestamp that indicates when the source location was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The name of the source location.</p>
    public let sourceLocationName: String?
    /// <p>The tags assigned to the source location.</p>
    public let tags: [String:String]?

    public init (
        accessConfiguration: AccessConfiguration? = nil,
        arn: String? = nil,
        creationTime: Date? = nil,
        defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: HttpConfiguration? = nil,
        lastModifiedTime: Date? = nil,
        sourceLocationName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.arn = arn
        self.creationTime = creationTime
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct UpdateSourceLocationOutputResponseBody: Equatable {
    public let accessConfiguration: AccessConfiguration?
    public let arn: String?
    public let creationTime: Date?
    public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
    public let httpConfiguration: HttpConfiguration?
    public let lastModifiedTime: Date?
    public let sourceLocationName: String?
    public let tags: [String:String]?
}

extension UpdateSourceLocationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case arn = "Arn"
        case creationTime = "CreationTime"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateVodSourceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateVodSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVodSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVodSourceInput>
    public typealias MOutput = OperationOutput<UpdateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVodSourceOutputError>
}

extension UpdateVodSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVodSourceInput(httpPackageConfigurations: \(String(describing: httpPackageConfigurations)), sourceLocationName: \(String(describing: sourceLocationName)), vodSourceName: \(String(describing: vodSourceName)))"}
}

extension UpdateVodSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpPackageConfigurations = httpPackageConfigurations {
            var httpPackageConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpPackageConfigurations)
            for httppackageconfigurations0 in httpPackageConfigurations {
                try httpPackageConfigurationsContainer.encode(httppackageconfigurations0)
            }
        }
    }
}

public struct UpdateVodSourceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateVodSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVodSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVodSourceInput>
    public typealias MOutput = OperationOutput<UpdateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVodSourceOutputError>
}

public struct UpdateVodSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateVodSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVodSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVodSourceInput>
    public typealias MOutput = OperationOutput<UpdateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVodSourceOutputError>
}

public struct UpdateVodSourceInput: Equatable {
    /// <p>An array of HTTP package configurations for the VOD source on this account.</p>
    public let httpPackageConfigurations: [HttpPackageConfiguration]?
    /// <p>The identifier for the source location you are working on.</p>
    public let sourceLocationName: String?
    /// <p>The identifier for the VOD source you are working on.</p>
    public let vodSourceName: String?

    public init (
        httpPackageConfigurations: [HttpPackageConfiguration]? = nil,
        sourceLocationName: String? = nil,
        vodSourceName: String? = nil
    )
    {
        self.httpPackageConfigurations = httpPackageConfigurations
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct UpdateVodSourceInputBody: Equatable {
    public let httpPackageConfigurations: [HttpPackageConfiguration]?
}

extension UpdateVodSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
    }
}

extension UpdateVodSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVodSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVodSourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVodSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVodSourceOutputResponse(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), httpPackageConfigurations: \(String(describing: httpPackageConfigurations)), lastModifiedTime: \(String(describing: lastModifiedTime)), sourceLocationName: \(String(describing: sourceLocationName)), tags: \(String(describing: tags)), vodSourceName: \(String(describing: vodSourceName)))"}
}

extension UpdateVodSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateVodSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.httpPackageConfigurations = output.httpPackageConfigurations
            self.lastModifiedTime = output.lastModifiedTime
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
            self.vodSourceName = output.vodSourceName
        } else {
            self.arn = nil
            self.creationTime = nil
            self.httpPackageConfigurations = nil
            self.lastModifiedTime = nil
            self.sourceLocationName = nil
            self.tags = nil
            self.vodSourceName = nil
        }
    }
}

public struct UpdateVodSourceOutputResponse: Equatable {
    /// <p>The ARN of the VOD source.</p>
    public let arn: String?
    /// <p>The timestamp that indicates when the VOD source was created.</p>
    public let creationTime: Date?
    /// <p>The HTTP package configurations.</p>
    public let httpPackageConfigurations: [HttpPackageConfiguration]?
    /// <p>The ARN for the VOD source.</p>
    public let lastModifiedTime: Date?
    /// <p>The name of the source location associated with the VOD source.</p>
    public let sourceLocationName: String?
    /// <p>The tags assigned to the VOD source.</p>
    public let tags: [String:String]?
    /// <p>The name of the VOD source.</p>
    public let vodSourceName: String?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        httpPackageConfigurations: [HttpPackageConfiguration]? = nil,
        lastModifiedTime: Date? = nil,
        sourceLocationName: String? = nil,
        tags: [String:String]? = nil,
        vodSourceName: String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

struct UpdateVodSourceOutputResponseBody: Equatable {
    public let arn: String?
    public let creationTime: Date?
    public let httpPackageConfigurations: [HttpPackageConfiguration]?
    public let lastModifiedTime: Date?
    public let sourceLocationName: String?
    public let tags: [String:String]?
    public let vodSourceName: String?
}

extension UpdateVodSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension VodSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
        case vodSourceName = "VodSourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let httpPackageConfigurations = httpPackageConfigurations {
            var httpPackageConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpPackageConfigurations)
            for httppackageconfigurations0 in httpPackageConfigurations {
                try httpPackageConfigurationsContainer.encode(httppackageconfigurations0)
            }
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let sourceLocationName = sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let vodSourceName = vodSourceName {
            try encodeContainer.encode(vodSourceName, forKey: .vodSourceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension VodSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VodSource(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), httpPackageConfigurations: \(String(describing: httpPackageConfigurations)), lastModifiedTime: \(String(describing: lastModifiedTime)), sourceLocationName: \(String(describing: sourceLocationName)), tags: \(String(describing: tags)), vodSourceName: \(String(describing: vodSourceName)))"}
}

/// <p>VOD source configuration parameters.</p>
public struct VodSource: Equatable {
    /// <p>The ARN for the VOD source.</p>
    public let arn: String?
    /// <p>The timestamp that indicates when the VOD source was created.</p>
    public let creationTime: Date?
    /// <p>The HTTP package configurations for the VOD source.</p>
    public let httpPackageConfigurations: [HttpPackageConfiguration]?
    /// <p>The timestamp that indicates when the VOD source was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The name of the source location that the VOD source is associated with.</p>
    public let sourceLocationName: String?
    /// <p>The tags assigned to the VOD source.</p>
    public let tags: [String:String]?
    /// <p>The name of the VOD source.</p>
    public let vodSourceName: String?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        httpPackageConfigurations: [HttpPackageConfiguration]? = nil,
        lastModifiedTime: Date? = nil,
        sourceLocationName: String? = nil,
        tags: [String:String]? = nil,
        vodSourceName: String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}
