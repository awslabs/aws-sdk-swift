// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension FmsClientTypes {
    public enum AccountRoleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case deleted
        case deleting
        case pendingdeletion
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountRoleStatus] {
            return [
                .creating,
                .deleted,
                .deleting,
                .pendingdeletion,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pendingdeletion: return "PENDING_DELETION"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountRoleStatus(rawValue: rawValue) ?? AccountRoleStatus.sdkUnknown(rawValue)
        }
    }
}

extension FmsClientTypes.ActionTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension FmsClientTypes {
    /// Describes a remediation action target.
    public struct ActionTarget: Swift.Equatable {
        /// A description of the remediation action target.
        public var description: Swift.String?
        /// The ID of the remediation target.
        public var resourceId: Swift.String?

        public init (
            description: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.description = description
            self.resourceId = resourceId
        }
    }

}

extension FmsClientTypes.App: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appName = "AppName"
        case port = "Port"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appName = appName {
            try encodeContainer.encode(appName, forKey: .appName)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appName)
        appName = appNameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension FmsClientTypes {
    /// An individual Firewall Manager application.
    public struct App: Swift.Equatable {
        /// The application's name.
        /// This member is required.
        public var appName: Swift.String?
        /// The application's port number, for example 80.
        /// This member is required.
        public var port: Swift.Int?
        /// The IP protocol name or number. The name can be one of tcp, udp, or icmp. For information on possible numbers, see [Protocol Numbers](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        /// This member is required.
        public var `protocol`: Swift.String?

        public init (
            appName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: Swift.String? = nil
        )
        {
            self.appName = appName
            self.port = port
            self.`protocol` = `protocol`
        }
    }

}

extension FmsClientTypes.AppsListData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsList = "AppsList"
        case createTime = "CreateTime"
        case lastUpdateTime = "LastUpdateTime"
        case listId = "ListId"
        case listName = "ListName"
        case listUpdateToken = "ListUpdateToken"
        case previousAppsList = "PreviousAppsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appsList = appsList {
            var appsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appsList)
            for appslist0 in appsList {
                try appsListContainer.encode(appslist0)
            }
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
        if let listName = listName {
            try encodeContainer.encode(listName, forKey: .listName)
        }
        if let listUpdateToken = listUpdateToken {
            try encodeContainer.encode(listUpdateToken, forKey: .listUpdateToken)
        }
        if let previousAppsList = previousAppsList {
            var previousAppsListContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .previousAppsList)
            for (dictKey0, previousappslist0) in previousAppsList {
                try previousAppsListContainer.encode(previousappslist0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
        let listNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listName)
        listName = listNameDecoded
        let listUpdateTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listUpdateToken)
        listUpdateToken = listUpdateTokenDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let appsListContainer = try containerValues.decodeIfPresent([FmsClientTypes.App?].self, forKey: .appsList)
        var appsListDecoded0:[FmsClientTypes.App]? = nil
        if let appsListContainer = appsListContainer {
            appsListDecoded0 = [FmsClientTypes.App]()
            for structure0 in appsListContainer {
                if let structure0 = structure0 {
                    appsListDecoded0?.append(structure0)
                }
            }
        }
        appsList = appsListDecoded0
        let previousAppsListContainer = try containerValues.decodeIfPresent([Swift.String: [FmsClientTypes.App?]?].self, forKey: .previousAppsList)
        var previousAppsListDecoded0: [Swift.String:[FmsClientTypes.App]]? = nil
        if let previousAppsListContainer = previousAppsListContainer {
            previousAppsListDecoded0 = [Swift.String:[FmsClientTypes.App]]()
            for (key0, appslist0) in previousAppsListContainer {
                var appslist0Decoded0: [FmsClientTypes.App]? = nil
                if let appslist0 = appslist0 {
                    appslist0Decoded0 = [FmsClientTypes.App]()
                    for structure1 in appslist0 {
                        if let structure1 = structure1 {
                            appslist0Decoded0?.append(structure1)
                        }
                    }
                }
                previousAppsListDecoded0?[key0] = appslist0Decoded0
            }
        }
        previousAppsList = previousAppsListDecoded0
    }
}

extension FmsClientTypes {
    /// An Firewall Manager applications list.
    public struct AppsListData: Swift.Equatable {
        /// An array of applications in the Firewall Manager applications list.
        /// This member is required.
        public var appsList: [FmsClientTypes.App]?
        /// The time that the Firewall Manager applications list was created.
        public var createTime: ClientRuntime.Date?
        /// The time that the Firewall Manager applications list was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The ID of the Firewall Manager applications list.
        public var listId: Swift.String?
        /// The name of the Firewall Manager applications list.
        /// This member is required.
        public var listName: Swift.String?
        /// A unique identifier for each update to the list. When you update the list, the update token must match the token of the current version of the application list. You can retrieve the update token by getting the list.
        public var listUpdateToken: Swift.String?
        /// A map of previous version numbers to their corresponding App object arrays.
        public var previousAppsList: [Swift.String:[FmsClientTypes.App]]?

        public init (
            appsList: [FmsClientTypes.App]? = nil,
            createTime: ClientRuntime.Date? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            listId: Swift.String? = nil,
            listName: Swift.String? = nil,
            listUpdateToken: Swift.String? = nil,
            previousAppsList: [Swift.String:[FmsClientTypes.App]]? = nil
        )
        {
            self.appsList = appsList
            self.createTime = createTime
            self.lastUpdateTime = lastUpdateTime
            self.listId = listId
            self.listName = listName
            self.listUpdateToken = listUpdateToken
            self.previousAppsList = previousAppsList
        }
    }

}

extension FmsClientTypes.AppsListDataSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsList = "AppsList"
        case listArn = "ListArn"
        case listId = "ListId"
        case listName = "ListName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appsList = appsList {
            var appsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appsList)
            for appslist0 in appsList {
                try appsListContainer.encode(appslist0)
            }
        }
        if let listArn = listArn {
            try encodeContainer.encode(listArn, forKey: .listArn)
        }
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
        if let listName = listName {
            try encodeContainer.encode(listName, forKey: .listName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listArn)
        listArn = listArnDecoded
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
        let listNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listName)
        listName = listNameDecoded
        let appsListContainer = try containerValues.decodeIfPresent([FmsClientTypes.App?].self, forKey: .appsList)
        var appsListDecoded0:[FmsClientTypes.App]? = nil
        if let appsListContainer = appsListContainer {
            appsListDecoded0 = [FmsClientTypes.App]()
            for structure0 in appsListContainer {
                if let structure0 = structure0 {
                    appsListDecoded0?.append(structure0)
                }
            }
        }
        appsList = appsListDecoded0
    }
}

extension FmsClientTypes {
    /// Details of the Firewall Manager applications list.
    public struct AppsListDataSummary: Swift.Equatable {
        /// An array of App objects in the Firewall Manager applications list.
        public var appsList: [FmsClientTypes.App]?
        /// The Amazon Resource Name (ARN) of the applications list.
        public var listArn: Swift.String?
        /// The ID of the applications list.
        public var listId: Swift.String?
        /// The name of the applications list.
        public var listName: Swift.String?

        public init (
            appsList: [FmsClientTypes.App]? = nil,
            listArn: Swift.String? = nil,
            listId: Swift.String? = nil,
            listName: Swift.String? = nil
        )
        {
            self.appsList = appsList
            self.listArn = listArn
            self.listId = listId
            self.listName = listName
        }
    }

}

extension AssociateAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccount = "AdminAccount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccount = adminAccount {
            try encodeContainer.encode(adminAccount, forKey: .adminAccount)
        }
    }
}

extension AssociateAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateAdminAccountInput: Swift.Equatable {
    /// The Amazon Web Services account ID to associate with Firewall Manager as the Firewall Manager administrator account. This must be an Organizations member account. For more information about Organizations, see [Managing the Amazon Web Services Accounts in Your Organization](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_accounts.html).
    /// This member is required.
    public var adminAccount: Swift.String?

    public init (
        adminAccount: Swift.String? = nil
    )
    {
        self.adminAccount = adminAccount
    }
}

struct AssociateAdminAccountInputBody: Swift.Equatable {
    let adminAccount: Swift.String?
}

extension AssociateAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccount = "AdminAccount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccount)
        adminAccount = adminAccountDecoded
    }
}

extension AssociateAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateAdminAccountOutputResponse: Swift.Equatable {

}

extension FmsClientTypes.AwsEc2InstanceViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsEc2NetworkInterfaceViolations = "AwsEc2NetworkInterfaceViolations"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsEc2NetworkInterfaceViolations = awsEc2NetworkInterfaceViolations {
            var awsEc2NetworkInterfaceViolationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsEc2NetworkInterfaceViolations)
            for awsec2networkinterfaceviolations0 in awsEc2NetworkInterfaceViolations {
                try awsEc2NetworkInterfaceViolationsContainer.encode(awsec2networkinterfaceviolations0)
            }
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let awsEc2NetworkInterfaceViolationsContainer = try containerValues.decodeIfPresent([FmsClientTypes.AwsEc2NetworkInterfaceViolation?].self, forKey: .awsEc2NetworkInterfaceViolations)
        var awsEc2NetworkInterfaceViolationsDecoded0:[FmsClientTypes.AwsEc2NetworkInterfaceViolation]? = nil
        if let awsEc2NetworkInterfaceViolationsContainer = awsEc2NetworkInterfaceViolationsContainer {
            awsEc2NetworkInterfaceViolationsDecoded0 = [FmsClientTypes.AwsEc2NetworkInterfaceViolation]()
            for structure0 in awsEc2NetworkInterfaceViolationsContainer {
                if let structure0 = structure0 {
                    awsEc2NetworkInterfaceViolationsDecoded0?.append(structure0)
                }
            }
        }
        awsEc2NetworkInterfaceViolations = awsEc2NetworkInterfaceViolationsDecoded0
    }
}

extension FmsClientTypes {
    /// Violation detail for an EC2 instance resource.
    public struct AwsEc2InstanceViolation: Swift.Equatable {
        /// Violation detail for network interfaces associated with the EC2 instance.
        public var awsEc2NetworkInterfaceViolations: [FmsClientTypes.AwsEc2NetworkInterfaceViolation]?
        /// The resource ID of the EC2 instance.
        public var violationTarget: Swift.String?

        public init (
            awsEc2NetworkInterfaceViolations: [FmsClientTypes.AwsEc2NetworkInterfaceViolation]? = nil,
            violationTarget: Swift.String? = nil
        )
        {
            self.awsEc2NetworkInterfaceViolations = awsEc2NetworkInterfaceViolations
            self.violationTarget = violationTarget
        }
    }

}

extension FmsClientTypes.AwsEc2NetworkInterfaceViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case violatingSecurityGroups = "ViolatingSecurityGroups"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let violatingSecurityGroups = violatingSecurityGroups {
            var violatingSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violatingSecurityGroups)
            for resourceidlist0 in violatingSecurityGroups {
                try violatingSecurityGroupsContainer.encode(resourceidlist0)
            }
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let violatingSecurityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .violatingSecurityGroups)
        var violatingSecurityGroupsDecoded0:[Swift.String]? = nil
        if let violatingSecurityGroupsContainer = violatingSecurityGroupsContainer {
            violatingSecurityGroupsDecoded0 = [Swift.String]()
            for string0 in violatingSecurityGroupsContainer {
                if let string0 = string0 {
                    violatingSecurityGroupsDecoded0?.append(string0)
                }
            }
        }
        violatingSecurityGroups = violatingSecurityGroupsDecoded0
    }
}

extension FmsClientTypes {
    /// Violation detail for network interfaces associated with an EC2 instance.
    public struct AwsEc2NetworkInterfaceViolation: Swift.Equatable {
        /// List of security groups that violate the rules specified in the primary security group of the Firewall Manager policy.
        public var violatingSecurityGroups: [Swift.String]?
        /// The resource ID of the network interface.
        public var violationTarget: Swift.String?

        public init (
            violatingSecurityGroups: [Swift.String]? = nil,
            violationTarget: Swift.String? = nil
        )
        {
            self.violatingSecurityGroups = violatingSecurityGroups
            self.violationTarget = violationTarget
        }
    }

}

extension FmsClientTypes.AwsVPCSecurityGroupViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case partialMatches = "PartialMatches"
        case possibleSecurityGroupRemediationActions = "PossibleSecurityGroupRemediationActions"
        case violationTarget = "ViolationTarget"
        case violationTargetDescription = "ViolationTargetDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let partialMatches = partialMatches {
            var partialMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partialMatches)
            for partialmatches0 in partialMatches {
                try partialMatchesContainer.encode(partialmatches0)
            }
        }
        if let possibleSecurityGroupRemediationActions = possibleSecurityGroupRemediationActions {
            var possibleSecurityGroupRemediationActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .possibleSecurityGroupRemediationActions)
            for securitygroupremediationactions0 in possibleSecurityGroupRemediationActions {
                try possibleSecurityGroupRemediationActionsContainer.encode(securitygroupremediationactions0)
            }
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let violationTargetDescription = violationTargetDescription {
            try encodeContainer.encode(violationTargetDescription, forKey: .violationTargetDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let violationTargetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTargetDescription)
        violationTargetDescription = violationTargetDescriptionDecoded
        let partialMatchesContainer = try containerValues.decodeIfPresent([FmsClientTypes.PartialMatch?].self, forKey: .partialMatches)
        var partialMatchesDecoded0:[FmsClientTypes.PartialMatch]? = nil
        if let partialMatchesContainer = partialMatchesContainer {
            partialMatchesDecoded0 = [FmsClientTypes.PartialMatch]()
            for structure0 in partialMatchesContainer {
                if let structure0 = structure0 {
                    partialMatchesDecoded0?.append(structure0)
                }
            }
        }
        partialMatches = partialMatchesDecoded0
        let possibleSecurityGroupRemediationActionsContainer = try containerValues.decodeIfPresent([FmsClientTypes.SecurityGroupRemediationAction?].self, forKey: .possibleSecurityGroupRemediationActions)
        var possibleSecurityGroupRemediationActionsDecoded0:[FmsClientTypes.SecurityGroupRemediationAction]? = nil
        if let possibleSecurityGroupRemediationActionsContainer = possibleSecurityGroupRemediationActionsContainer {
            possibleSecurityGroupRemediationActionsDecoded0 = [FmsClientTypes.SecurityGroupRemediationAction]()
            for structure0 in possibleSecurityGroupRemediationActionsContainer {
                if let structure0 = structure0 {
                    possibleSecurityGroupRemediationActionsDecoded0?.append(structure0)
                }
            }
        }
        possibleSecurityGroupRemediationActions = possibleSecurityGroupRemediationActionsDecoded0
    }
}

extension FmsClientTypes {
    /// Violation detail for the rule violation in a security group when compared to the primary security group of the Firewall Manager policy.
    public struct AwsVPCSecurityGroupViolation: Swift.Equatable {
        /// List of rules specified in the security group of the Firewall Manager policy that partially match the ViolationTarget rule.
        public var partialMatches: [FmsClientTypes.PartialMatch]?
        /// Remediation options for the rule specified in the ViolationTarget.
        public var possibleSecurityGroupRemediationActions: [FmsClientTypes.SecurityGroupRemediationAction]?
        /// The security group rule that is being evaluated.
        public var violationTarget: Swift.String?
        /// A description of the security group that violates the policy.
        public var violationTargetDescription: Swift.String?

        public init (
            partialMatches: [FmsClientTypes.PartialMatch]? = nil,
            possibleSecurityGroupRemediationActions: [FmsClientTypes.SecurityGroupRemediationAction]? = nil,
            violationTarget: Swift.String? = nil,
            violationTargetDescription: Swift.String? = nil
        )
        {
            self.partialMatches = partialMatches
            self.possibleSecurityGroupRemediationActions = possibleSecurityGroupRemediationActions
            self.violationTarget = violationTarget
            self.violationTargetDescription = violationTargetDescription
        }
    }

}

extension FmsClientTypes.ComplianceViolator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case violationReason = "ViolationReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let violationReason = violationReason {
            try encodeContainer.encode(violationReason.rawValue, forKey: .violationReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let violationReasonDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ViolationReason.self, forKey: .violationReason)
        violationReason = violationReasonDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension FmsClientTypes {
    /// Details of the resource that is not protected by the policy.
    public struct ComplianceViolator: Swift.Equatable {
        /// The resource ID.
        public var resourceId: Swift.String?
        /// The resource type. This is in the format shown in the [Amazon Web Services Resource Types Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html). For example: AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::CloudFront::Distribution, or AWS::NetworkFirewall::FirewallPolicy.
        public var resourceType: Swift.String?
        /// The reason that the resource is not protected by the policy.
        public var violationReason: FmsClientTypes.ViolationReason?

        public init (
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            violationReason: FmsClientTypes.ViolationReason? = nil
        )
        {
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.violationReason = violationReason
        }
    }

}

extension FmsClientTypes {
    public enum CustomerPolicyScopeIdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case orgUnit
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomerPolicyScopeIdType] {
            return [
                .account,
                .orgUnit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .orgUnit: return "ORG_UNIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomerPolicyScopeIdType(rawValue: rawValue) ?? CustomerPolicyScopeIdType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAppsListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listId = "ListId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
    }
}

extension DeleteAppsListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAppsListInput: Swift.Equatable {
    /// The ID of the applications list that you want to delete. You can retrieve this ID from PutAppsList, ListAppsLists, and GetAppsList.
    /// This member is required.
    public var listId: Swift.String?

    public init (
        listId: Swift.String? = nil
    )
    {
        self.listId = listId
    }
}

struct DeleteAppsListInputBody: Swift.Equatable {
    let listId: Swift.String?
}

extension DeleteAppsListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listId = "ListId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
    }
}

extension DeleteAppsListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppsListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppsListOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppsListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppsListOutputResponse: Swift.Equatable {

}

extension DeleteNotificationChannelInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteNotificationChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteNotificationChannelInput: Swift.Equatable {

}

struct DeleteNotificationChannelInputBody: Swift.Equatable {
}

extension DeleteNotificationChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNotificationChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNotificationChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNotificationChannelOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNotificationChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNotificationChannelOutputResponse: Swift.Equatable {

}

extension DeletePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAllPolicyResources = "DeleteAllPolicyResources"
        case policyId = "PolicyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteAllPolicyResources != false {
            try encodeContainer.encode(deleteAllPolicyResources, forKey: .deleteAllPolicyResources)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
    }
}

extension DeletePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePolicyInput: Swift.Equatable {
    /// If True, the request performs cleanup according to the policy type. For WAF and Shield Advanced policies, the cleanup does the following:
    ///
    /// * Deletes rule groups created by Firewall Manager
    ///
    /// * Removes web ACLs from in-scope resources
    ///
    /// * Deletes web ACLs that contain no rules or rule groups
    ///
    ///
    /// For security group policies, the cleanup does the following for each security group in the policy:
    ///
    /// * Disassociates the security group from in-scope resources
    ///
    /// * Deletes the security group if it was created through Firewall Manager and if it's no longer associated with any resources through another policy
    ///
    ///
    /// After the cleanup, in-scope resources are no longer protected by web ACLs in this policy. Protection of out-of-scope resources remains unchanged. Scope is determined by tags that you create and accounts that you associate with the policy. When creating the policy, if you specify that only resources in specific accounts or with specific tags are in scope of the policy, those accounts and resources are handled by the policy. All others are out of scope. If you don't specify tags or accounts, all resources are in scope.
    public var deleteAllPolicyResources: Swift.Bool
    /// The ID of the policy that you want to delete. You can retrieve this ID from PutPolicy and ListPolicies.
    /// This member is required.
    public var policyId: Swift.String?

    public init (
        deleteAllPolicyResources: Swift.Bool = false,
        policyId: Swift.String? = nil
    )
    {
        self.deleteAllPolicyResources = deleteAllPolicyResources
        self.policyId = policyId
    }
}

struct DeletePolicyInputBody: Swift.Equatable {
    let policyId: Swift.String?
    let deleteAllPolicyResources: Swift.Bool
}

extension DeletePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAllPolicyResources = "DeleteAllPolicyResources"
        case policyId = "PolicyId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let deleteAllPolicyResourcesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .deleteAllPolicyResources)
        deleteAllPolicyResources = deleteAllPolicyResourcesDecoded
    }
}

extension DeletePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePolicyOutputResponse: Swift.Equatable {

}

extension DeleteProtocolsListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listId = "ListId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
    }
}

extension DeleteProtocolsListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProtocolsListInput: Swift.Equatable {
    /// The ID of the protocols list that you want to delete. You can retrieve this ID from PutProtocolsList, ListProtocolsLists, and GetProtocolsLost.
    /// This member is required.
    public var listId: Swift.String?

    public init (
        listId: Swift.String? = nil
    )
    {
        self.listId = listId
    }
}

struct DeleteProtocolsListInputBody: Swift.Equatable {
    let listId: Swift.String?
}

extension DeleteProtocolsListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listId = "ListId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
    }
}

extension DeleteProtocolsListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProtocolsListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProtocolsListOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProtocolsListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProtocolsListOutputResponse: Swift.Equatable {

}

extension FmsClientTypes {
    public enum DependentServiceName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsconfig
        case awsshieldadvanced
        case awsvirtualprivatecloud
        case awswaf
        case sdkUnknown(Swift.String)

        public static var allCases: [DependentServiceName] {
            return [
                .awsconfig,
                .awsshieldadvanced,
                .awsvirtualprivatecloud,
                .awswaf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsconfig: return "AWSCONFIG"
            case .awsshieldadvanced: return "AWSSHIELD_ADVANCED"
            case .awsvirtualprivatecloud: return "AWSVPC"
            case .awswaf: return "AWSWAF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DependentServiceName(rawValue: rawValue) ?? DependentServiceName.sdkUnknown(rawValue)
        }
    }
}

extension FmsClientTypes {
    public enum DestinationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ipv4
        case ipv6
        case prefixlist
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationType] {
            return [
                .ipv4,
                .ipv6,
                .prefixlist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "IPV4"
            case .ipv6: return "IPV6"
            case .prefixlist: return "PREFIX_LIST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DestinationType(rawValue: rawValue) ?? DestinationType.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateAdminAccountInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DisassociateAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateAdminAccountInput: Swift.Equatable {

}

struct DisassociateAdminAccountInputBody: Swift.Equatable {
}

extension DisassociateAdminAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateAdminAccountOutputResponse: Swift.Equatable {

}

extension FmsClientTypes.DnsDuplicateRuleGroupViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case violationTarget = "ViolationTarget"
        case violationTargetDescription = "ViolationTargetDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let violationTargetDescription = violationTargetDescription {
            try encodeContainer.encode(violationTargetDescription, forKey: .violationTargetDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let violationTargetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTargetDescription)
        violationTargetDescription = violationTargetDescriptionDecoded
    }
}

extension FmsClientTypes {
    /// A DNS Firewall rule group that Firewall Manager tried to associate with a VPC is already associated with the VPC and can't be associated again.
    public struct DnsDuplicateRuleGroupViolation: Swift.Equatable {
        /// Information about the VPC ID.
        public var violationTarget: Swift.String?
        /// A description of the violation that specifies the rule group and VPC.
        public var violationTargetDescription: Swift.String?

        public init (
            violationTarget: Swift.String? = nil,
            violationTargetDescription: Swift.String? = nil
        )
        {
            self.violationTarget = violationTarget
            self.violationTargetDescription = violationTargetDescription
        }
    }

}

extension FmsClientTypes.DnsRuleGroupLimitExceededViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfRuleGroupsAlreadyAssociated = "NumberOfRuleGroupsAlreadyAssociated"
        case violationTarget = "ViolationTarget"
        case violationTargetDescription = "ViolationTargetDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if numberOfRuleGroupsAlreadyAssociated != 0 {
            try encodeContainer.encode(numberOfRuleGroupsAlreadyAssociated, forKey: .numberOfRuleGroupsAlreadyAssociated)
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let violationTargetDescription = violationTargetDescription {
            try encodeContainer.encode(violationTargetDescription, forKey: .violationTargetDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let violationTargetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTargetDescription)
        violationTargetDescription = violationTargetDescriptionDecoded
        let numberOfRuleGroupsAlreadyAssociatedDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfRuleGroupsAlreadyAssociated)
        numberOfRuleGroupsAlreadyAssociated = numberOfRuleGroupsAlreadyAssociatedDecoded
    }
}

extension FmsClientTypes {
    /// The VPC that Firewall Manager was applying a DNS Fireall policy to reached the limit for associated DNS Firewall rule groups. Firewall Manager tried to associate another rule group with the VPC and failed due to the limit.
    public struct DnsRuleGroupLimitExceededViolation: Swift.Equatable {
        /// The number of rule groups currently associated with the VPC.
        public var numberOfRuleGroupsAlreadyAssociated: Swift.Int
        /// Information about the VPC ID.
        public var violationTarget: Swift.String?
        /// A description of the violation that specifies the rule group and VPC.
        public var violationTargetDescription: Swift.String?

        public init (
            numberOfRuleGroupsAlreadyAssociated: Swift.Int = 0,
            violationTarget: Swift.String? = nil,
            violationTargetDescription: Swift.String? = nil
        )
        {
            self.numberOfRuleGroupsAlreadyAssociated = numberOfRuleGroupsAlreadyAssociated
            self.violationTarget = violationTarget
            self.violationTargetDescription = violationTargetDescription
        }
    }

}

extension FmsClientTypes.DnsRuleGroupPriorityConflictViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictingPolicyId = "ConflictingPolicyId"
        case conflictingPriority = "ConflictingPriority"
        case unavailablePriorities = "UnavailablePriorities"
        case violationTarget = "ViolationTarget"
        case violationTargetDescription = "ViolationTargetDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictingPolicyId = conflictingPolicyId {
            try encodeContainer.encode(conflictingPolicyId, forKey: .conflictingPolicyId)
        }
        if conflictingPriority != 0 {
            try encodeContainer.encode(conflictingPriority, forKey: .conflictingPriority)
        }
        if let unavailablePriorities = unavailablePriorities {
            var unavailablePrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .unavailablePriorities)
            for dnsrulegrouppriorities0 in unavailablePriorities {
                try unavailablePrioritiesContainer.encode(dnsrulegrouppriorities0)
            }
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let violationTargetDescription = violationTargetDescription {
            try encodeContainer.encode(violationTargetDescription, forKey: .violationTargetDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let violationTargetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTargetDescription)
        violationTargetDescription = violationTargetDescriptionDecoded
        let conflictingPriorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .conflictingPriority)
        conflictingPriority = conflictingPriorityDecoded
        let conflictingPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conflictingPolicyId)
        conflictingPolicyId = conflictingPolicyIdDecoded
        let unavailablePrioritiesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .unavailablePriorities)
        var unavailablePrioritiesDecoded0:[Swift.Int]? = nil
        if let unavailablePrioritiesContainer = unavailablePrioritiesContainer {
            unavailablePrioritiesDecoded0 = [Swift.Int]()
            for integer0 in unavailablePrioritiesContainer {
                if let integer0 = integer0 {
                    unavailablePrioritiesDecoded0?.append(integer0)
                }
            }
        }
        unavailablePriorities = unavailablePrioritiesDecoded0
    }
}

extension FmsClientTypes {
    /// A rule group that Firewall Manager tried to associate with a VPC has the same priority as a rule group that's already associated.
    public struct DnsRuleGroupPriorityConflictViolation: Swift.Equatable {
        /// The ID of the Firewall Manager DNS Firewall policy that was already applied to the VPC. This policy contains the rule group that's already associated with the VPC.
        public var conflictingPolicyId: Swift.String?
        /// The priority setting of the two conflicting rule groups.
        public var conflictingPriority: Swift.Int
        /// The priorities of rule groups that are already associated with the VPC. To retry your operation, choose priority settings that aren't in this list for the rule groups in your new DNS Firewall policy.
        public var unavailablePriorities: [Swift.Int]?
        /// Information about the VPC ID.
        public var violationTarget: Swift.String?
        /// A description of the violation that specifies the VPC and the rule group that's already associated with it.
        public var violationTargetDescription: Swift.String?

        public init (
            conflictingPolicyId: Swift.String? = nil,
            conflictingPriority: Swift.Int = 0,
            unavailablePriorities: [Swift.Int]? = nil,
            violationTarget: Swift.String? = nil,
            violationTargetDescription: Swift.String? = nil
        )
        {
            self.conflictingPolicyId = conflictingPolicyId
            self.conflictingPriority = conflictingPriority
            self.unavailablePriorities = unavailablePriorities
            self.violationTarget = violationTarget
            self.violationTargetDescription = violationTargetDescription
        }
    }

}

extension FmsClientTypes.EC2AssociateRouteTableAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case gatewayId = "GatewayId"
        case routeTableId = "RouteTableId"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gatewayId = gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let routeTableId = routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ActionTarget.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ActionTarget.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ActionTarget.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
    }
}

extension FmsClientTypes {
    /// The action of associating an EC2 resource, such as a subnet or internet gateway, with a route table.
    public struct EC2AssociateRouteTableAction: Swift.Equatable {
        /// A description of the EC2 route table that is associated with the remediation action.
        public var description: Swift.String?
        /// The ID of the gateway to be used with the EC2 route table that is associated with the remediation action.
        public var gatewayId: FmsClientTypes.ActionTarget?
        /// The ID of the EC2 route table that is associated with the remediation action.
        /// This member is required.
        public var routeTableId: FmsClientTypes.ActionTarget?
        /// The ID of the subnet for the EC2 route table that is associated with the remediation action.
        public var subnetId: FmsClientTypes.ActionTarget?

        public init (
            description: Swift.String? = nil,
            gatewayId: FmsClientTypes.ActionTarget? = nil,
            routeTableId: FmsClientTypes.ActionTarget? = nil,
            subnetId: FmsClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
            self.subnetId = subnetId
        }
    }

}

extension FmsClientTypes.EC2CopyRouteTableAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case routeTableId = "RouteTableId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routeTableId = routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ActionTarget.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ActionTarget.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
    }
}

extension FmsClientTypes {
    /// An action that copies the EC2 route table for use in remediation.
    public struct EC2CopyRouteTableAction: Swift.Equatable {
        /// A description of the copied EC2 route table that is associated with the remediation action.
        public var description: Swift.String?
        /// The ID of the copied EC2 route table that is associated with the remediation action.
        /// This member is required.
        public var routeTableId: FmsClientTypes.ActionTarget?
        /// The VPC ID of the copied EC2 route table that is associated with the remediation action.
        /// This member is required.
        public var vpcId: FmsClientTypes.ActionTarget?

        public init (
            description: Swift.String? = nil,
            routeTableId: FmsClientTypes.ActionTarget? = nil,
            vpcId: FmsClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.routeTableId = routeTableId
            self.vpcId = vpcId
        }
    }

}

extension FmsClientTypes.EC2CreateRouteAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destinationCidrBlock = "DestinationCidrBlock"
        case destinationIpv6CidrBlock = "DestinationIpv6CidrBlock"
        case destinationPrefixListId = "DestinationPrefixListId"
        case gatewayId = "GatewayId"
        case routeTableId = "RouteTableId"
        case vpcEndpointId = "VpcEndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationCidrBlock = destinationCidrBlock {
            try encodeContainer.encode(destinationCidrBlock, forKey: .destinationCidrBlock)
        }
        if let destinationIpv6CidrBlock = destinationIpv6CidrBlock {
            try encodeContainer.encode(destinationIpv6CidrBlock, forKey: .destinationIpv6CidrBlock)
        }
        if let destinationPrefixListId = destinationPrefixListId {
            try encodeContainer.encode(destinationPrefixListId, forKey: .destinationPrefixListId)
        }
        if let gatewayId = gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let routeTableId = routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let vpcEndpointId = vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationCidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCidrBlock)
        destinationCidrBlock = destinationCidrBlockDecoded
        let destinationPrefixListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPrefixListId)
        destinationPrefixListId = destinationPrefixListIdDecoded
        let destinationIpv6CidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationIpv6CidrBlock)
        destinationIpv6CidrBlock = destinationIpv6CidrBlockDecoded
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ActionTarget.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ActionTarget.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ActionTarget.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
    }
}

extension FmsClientTypes {
    /// Information about the CreateRoute action in Amazon EC2.
    public struct EC2CreateRouteAction: Swift.Equatable {
        /// A description of CreateRoute action in Amazon EC2.
        public var description: Swift.String?
        /// Information about the IPv4 CIDR address block used for the destination match.
        public var destinationCidrBlock: Swift.String?
        /// Information about the IPv6 CIDR block destination.
        public var destinationIpv6CidrBlock: Swift.String?
        /// Information about the ID of a prefix list used for the destination match.
        public var destinationPrefixListId: Swift.String?
        /// Information about the ID of an internet gateway or virtual private gateway attached to your VPC.
        public var gatewayId: FmsClientTypes.ActionTarget?
        /// Information about the ID of the route table for the route.
        /// This member is required.
        public var routeTableId: FmsClientTypes.ActionTarget?
        /// Information about the ID of a VPC endpoint. Supported for Gateway Load Balancer endpoints only.
        public var vpcEndpointId: FmsClientTypes.ActionTarget?

        public init (
            description: Swift.String? = nil,
            destinationCidrBlock: Swift.String? = nil,
            destinationIpv6CidrBlock: Swift.String? = nil,
            destinationPrefixListId: Swift.String? = nil,
            gatewayId: FmsClientTypes.ActionTarget? = nil,
            routeTableId: FmsClientTypes.ActionTarget? = nil,
            vpcEndpointId: FmsClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.destinationCidrBlock = destinationCidrBlock
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.destinationPrefixListId = destinationPrefixListId
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
            self.vpcEndpointId = vpcEndpointId
        }
    }

}

extension FmsClientTypes.EC2CreateRouteTableAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ActionTarget.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension FmsClientTypes {
    /// Information about the CreateRouteTable action in Amazon EC2.
    public struct EC2CreateRouteTableAction: Swift.Equatable {
        /// A description of the CreateRouteTable action.
        public var description: Swift.String?
        /// Information about the ID of a VPC.
        /// This member is required.
        public var vpcId: FmsClientTypes.ActionTarget?

        public init (
            description: Swift.String? = nil,
            vpcId: FmsClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.vpcId = vpcId
        }
    }

}

extension FmsClientTypes.EC2DeleteRouteAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destinationCidrBlock = "DestinationCidrBlock"
        case destinationIpv6CidrBlock = "DestinationIpv6CidrBlock"
        case destinationPrefixListId = "DestinationPrefixListId"
        case routeTableId = "RouteTableId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationCidrBlock = destinationCidrBlock {
            try encodeContainer.encode(destinationCidrBlock, forKey: .destinationCidrBlock)
        }
        if let destinationIpv6CidrBlock = destinationIpv6CidrBlock {
            try encodeContainer.encode(destinationIpv6CidrBlock, forKey: .destinationIpv6CidrBlock)
        }
        if let destinationPrefixListId = destinationPrefixListId {
            try encodeContainer.encode(destinationPrefixListId, forKey: .destinationPrefixListId)
        }
        if let routeTableId = routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationCidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCidrBlock)
        destinationCidrBlock = destinationCidrBlockDecoded
        let destinationPrefixListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPrefixListId)
        destinationPrefixListId = destinationPrefixListIdDecoded
        let destinationIpv6CidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationIpv6CidrBlock)
        destinationIpv6CidrBlock = destinationIpv6CidrBlockDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ActionTarget.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
    }
}

extension FmsClientTypes {
    /// Information about the DeleteRoute action in Amazon EC2.
    public struct EC2DeleteRouteAction: Swift.Equatable {
        /// A description of the DeleteRoute action.
        public var description: Swift.String?
        /// Information about the IPv4 CIDR range for the route. The value you specify must match the CIDR for the route exactly.
        public var destinationCidrBlock: Swift.String?
        /// Information about the IPv6 CIDR range for the route. The value you specify must match the CIDR for the route exactly.
        public var destinationIpv6CidrBlock: Swift.String?
        /// Information about the ID of the prefix list for the route.
        public var destinationPrefixListId: Swift.String?
        /// Information about the ID of the route table.
        /// This member is required.
        public var routeTableId: FmsClientTypes.ActionTarget?

        public init (
            description: Swift.String? = nil,
            destinationCidrBlock: Swift.String? = nil,
            destinationIpv6CidrBlock: Swift.String? = nil,
            destinationPrefixListId: Swift.String? = nil,
            routeTableId: FmsClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.destinationCidrBlock = destinationCidrBlock
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.destinationPrefixListId = destinationPrefixListId
            self.routeTableId = routeTableId
        }
    }

}

extension FmsClientTypes.EC2ReplaceRouteAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destinationCidrBlock = "DestinationCidrBlock"
        case destinationIpv6CidrBlock = "DestinationIpv6CidrBlock"
        case destinationPrefixListId = "DestinationPrefixListId"
        case gatewayId = "GatewayId"
        case routeTableId = "RouteTableId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationCidrBlock = destinationCidrBlock {
            try encodeContainer.encode(destinationCidrBlock, forKey: .destinationCidrBlock)
        }
        if let destinationIpv6CidrBlock = destinationIpv6CidrBlock {
            try encodeContainer.encode(destinationIpv6CidrBlock, forKey: .destinationIpv6CidrBlock)
        }
        if let destinationPrefixListId = destinationPrefixListId {
            try encodeContainer.encode(destinationPrefixListId, forKey: .destinationPrefixListId)
        }
        if let gatewayId = gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let routeTableId = routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationCidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCidrBlock)
        destinationCidrBlock = destinationCidrBlockDecoded
        let destinationPrefixListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPrefixListId)
        destinationPrefixListId = destinationPrefixListIdDecoded
        let destinationIpv6CidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationIpv6CidrBlock)
        destinationIpv6CidrBlock = destinationIpv6CidrBlockDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ActionTarget.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ActionTarget.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
    }
}

extension FmsClientTypes {
    /// Information about the ReplaceRoute action in Amazon EC2.
    public struct EC2ReplaceRouteAction: Swift.Equatable {
        /// A description of the ReplaceRoute action in Amazon EC2.
        public var description: Swift.String?
        /// Information about the IPv4 CIDR address block used for the destination match. The value that you provide must match the CIDR of an existing route in the table.
        public var destinationCidrBlock: Swift.String?
        /// Information about the IPv6 CIDR address block used for the destination match. The value that you provide must match the CIDR of an existing route in the table.
        public var destinationIpv6CidrBlock: Swift.String?
        /// Information about the ID of the prefix list for the route.
        public var destinationPrefixListId: Swift.String?
        /// Information about the ID of an internet gateway or virtual private gateway.
        public var gatewayId: FmsClientTypes.ActionTarget?
        /// Information about the ID of the route table.
        /// This member is required.
        public var routeTableId: FmsClientTypes.ActionTarget?

        public init (
            description: Swift.String? = nil,
            destinationCidrBlock: Swift.String? = nil,
            destinationIpv6CidrBlock: Swift.String? = nil,
            destinationPrefixListId: Swift.String? = nil,
            gatewayId: FmsClientTypes.ActionTarget? = nil,
            routeTableId: FmsClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.destinationCidrBlock = destinationCidrBlock
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.destinationPrefixListId = destinationPrefixListId
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
        }
    }

}

extension FmsClientTypes.EC2ReplaceRouteTableAssociationAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case description = "Description"
        case routeTableId = "RouteTableId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routeTableId = routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ActionTarget.self, forKey: .associationId)
        associationId = associationIdDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ActionTarget.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
    }
}

extension FmsClientTypes {
    /// Information about the ReplaceRouteTableAssociation action in Amazon EC2.
    public struct EC2ReplaceRouteTableAssociationAction: Swift.Equatable {
        /// Information about the association ID.
        /// This member is required.
        public var associationId: FmsClientTypes.ActionTarget?
        /// A description of the ReplaceRouteTableAssociation action in Amazon EC2.
        public var description: Swift.String?
        /// Information about the ID of the new route table to associate with the subnet.
        /// This member is required.
        public var routeTableId: FmsClientTypes.ActionTarget?

        public init (
            associationId: FmsClientTypes.ActionTarget? = nil,
            description: Swift.String? = nil,
            routeTableId: FmsClientTypes.ActionTarget? = nil
        )
        {
            self.associationId = associationId
            self.description = description
            self.routeTableId = routeTableId
        }
    }

}

extension FmsClientTypes.EvaluationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceStatus = "ComplianceStatus"
        case evaluationLimitExceeded = "EvaluationLimitExceeded"
        case violatorCount = "ViolatorCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceStatus = complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if evaluationLimitExceeded != false {
            try encodeContainer.encode(evaluationLimitExceeded, forKey: .evaluationLimitExceeded)
        }
        if violatorCount != 0 {
            try encodeContainer.encode(violatorCount, forKey: .violatorCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceStatusDecoded = try containerValues.decodeIfPresent(FmsClientTypes.PolicyComplianceStatusType.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let violatorCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .violatorCount)
        violatorCount = violatorCountDecoded
        let evaluationLimitExceededDecoded = try containerValues.decode(Swift.Bool.self, forKey: .evaluationLimitExceeded)
        evaluationLimitExceeded = evaluationLimitExceededDecoded
    }
}

extension FmsClientTypes {
    /// Describes the compliance status for the account. An account is considered noncompliant if it includes resources that are not protected by the specified policy or that don't comply with the policy.
    public struct EvaluationResult: Swift.Equatable {
        /// Describes an Amazon Web Services account's compliance with the Firewall Manager policy.
        public var complianceStatus: FmsClientTypes.PolicyComplianceStatusType?
        /// Indicates that over 100 resources are noncompliant with the Firewall Manager policy.
        public var evaluationLimitExceeded: Swift.Bool
        /// The number of resources that are noncompliant with the specified policy. For WAF and Shield Advanced policies, a resource is considered noncompliant if it is not associated with the policy. For security group policies, a resource is considered noncompliant if it doesn't comply with the rules of the policy and remediation is disabled or not possible.
        public var violatorCount: Swift.Int

        public init (
            complianceStatus: FmsClientTypes.PolicyComplianceStatusType? = nil,
            evaluationLimitExceeded: Swift.Bool = false,
            violatorCount: Swift.Int = 0
        )
        {
            self.complianceStatus = complianceStatus
            self.evaluationLimitExceeded = evaluationLimitExceeded
            self.violatorCount = violatorCount
        }
    }

}

extension FmsClientTypes.ExpectedRoute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedTargets = "AllowedTargets"
        case contributingSubnets = "ContributingSubnets"
        case ipV4Cidr = "IpV4Cidr"
        case ipV6Cidr = "IpV6Cidr"
        case prefixListId = "PrefixListId"
        case routeTableId = "RouteTableId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedTargets = allowedTargets {
            var allowedTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedTargets)
            for lengthboundedstringlist0 in allowedTargets {
                try allowedTargetsContainer.encode(lengthboundedstringlist0)
            }
        }
        if let contributingSubnets = contributingSubnets {
            var contributingSubnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contributingSubnets)
            for resourceidlist0 in contributingSubnets {
                try contributingSubnetsContainer.encode(resourceidlist0)
            }
        }
        if let ipV4Cidr = ipV4Cidr {
            try encodeContainer.encode(ipV4Cidr, forKey: .ipV4Cidr)
        }
        if let ipV6Cidr = ipV6Cidr {
            try encodeContainer.encode(ipV6Cidr, forKey: .ipV6Cidr)
        }
        if let prefixListId = prefixListId {
            try encodeContainer.encode(prefixListId, forKey: .prefixListId)
        }
        if let routeTableId = routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipV4CidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipV4Cidr)
        ipV4Cidr = ipV4CidrDecoded
        let prefixListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefixListId)
        prefixListId = prefixListIdDecoded
        let ipV6CidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipV6Cidr)
        ipV6Cidr = ipV6CidrDecoded
        let contributingSubnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .contributingSubnets)
        var contributingSubnetsDecoded0:[Swift.String]? = nil
        if let contributingSubnetsContainer = contributingSubnetsContainer {
            contributingSubnetsDecoded0 = [Swift.String]()
            for string0 in contributingSubnetsContainer {
                if let string0 = string0 {
                    contributingSubnetsDecoded0?.append(string0)
                }
            }
        }
        contributingSubnets = contributingSubnetsDecoded0
        let allowedTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedTargets)
        var allowedTargetsDecoded0:[Swift.String]? = nil
        if let allowedTargetsContainer = allowedTargetsContainer {
            allowedTargetsDecoded0 = [Swift.String]()
            for string0 in allowedTargetsContainer {
                if let string0 = string0 {
                    allowedTargetsDecoded0?.append(string0)
                }
            }
        }
        allowedTargets = allowedTargetsDecoded0
        let routeTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
    }
}

extension FmsClientTypes {
    /// Information about the expected route in the route table.
    public struct ExpectedRoute: Swift.Equatable {
        /// Information about the allowed targets.
        public var allowedTargets: [Swift.String]?
        /// Information about the contributing subnets.
        public var contributingSubnets: [Swift.String]?
        /// Information about the IPv4 CIDR block.
        public var ipV4Cidr: Swift.String?
        /// Information about the IPv6 CIDR block.
        public var ipV6Cidr: Swift.String?
        /// Information about the ID of the prefix list for the route.
        public var prefixListId: Swift.String?
        /// Information about the route table ID.
        public var routeTableId: Swift.String?

        public init (
            allowedTargets: [Swift.String]? = nil,
            contributingSubnets: [Swift.String]? = nil,
            ipV4Cidr: Swift.String? = nil,
            ipV6Cidr: Swift.String? = nil,
            prefixListId: Swift.String? = nil,
            routeTableId: Swift.String? = nil
        )
        {
            self.allowedTargets = allowedTargets
            self.contributingSubnets = contributingSubnets
            self.ipV4Cidr = ipV4Cidr
            self.ipV6Cidr = ipV6Cidr
            self.prefixListId = prefixListId
            self.routeTableId = routeTableId
        }
    }

}

extension GetAdminAccountInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAdminAccountInput: Swift.Equatable {

}

struct GetAdminAccountInputBody: Swift.Equatable {
}

extension GetAdminAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAdminAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adminAccount = output.adminAccount
            self.roleStatus = output.roleStatus
        } else {
            self.adminAccount = nil
            self.roleStatus = nil
        }
    }
}

public struct GetAdminAccountOutputResponse: Swift.Equatable {
    /// The Amazon Web Services account that is set as the Firewall Manager administrator.
    public var adminAccount: Swift.String?
    /// The status of the Amazon Web Services account that you set as the Firewall Manager administrator.
    public var roleStatus: FmsClientTypes.AccountRoleStatus?

    public init (
        adminAccount: Swift.String? = nil,
        roleStatus: FmsClientTypes.AccountRoleStatus? = nil
    )
    {
        self.adminAccount = adminAccount
        self.roleStatus = roleStatus
    }
}

struct GetAdminAccountOutputResponseBody: Swift.Equatable {
    let adminAccount: Swift.String?
    let roleStatus: FmsClientTypes.AccountRoleStatus?
}

extension GetAdminAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccount = "AdminAccount"
        case roleStatus = "RoleStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccount)
        adminAccount = adminAccountDecoded
        let roleStatusDecoded = try containerValues.decodeIfPresent(FmsClientTypes.AccountRoleStatus.self, forKey: .roleStatus)
        roleStatus = roleStatusDecoded
    }
}

extension GetAppsListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultList = "DefaultList"
        case listId = "ListId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultList != false {
            try encodeContainer.encode(defaultList, forKey: .defaultList)
        }
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
    }
}

extension GetAppsListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAppsListInput: Swift.Equatable {
    /// Specifies whether the list to retrieve is a default list owned by Firewall Manager.
    public var defaultList: Swift.Bool
    /// The ID of the Firewall Manager applications list that you want the details for.
    /// This member is required.
    public var listId: Swift.String?

    public init (
        defaultList: Swift.Bool = false,
        listId: Swift.String? = nil
    )
    {
        self.defaultList = defaultList
        self.listId = listId
    }
}

struct GetAppsListInputBody: Swift.Equatable {
    let listId: Swift.String?
    let defaultList: Swift.Bool
}

extension GetAppsListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultList = "DefaultList"
        case listId = "ListId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
        let defaultListDecoded = try containerValues.decode(Swift.Bool.self, forKey: .defaultList)
        defaultList = defaultListDecoded
    }
}

extension GetAppsListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppsListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppsListOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppsListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAppsListOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appsList = output.appsList
            self.appsListArn = output.appsListArn
        } else {
            self.appsList = nil
            self.appsListArn = nil
        }
    }
}

public struct GetAppsListOutputResponse: Swift.Equatable {
    /// Information about the specified Firewall Manager applications list.
    public var appsList: FmsClientTypes.AppsListData?
    /// The Amazon Resource Name (ARN) of the applications list.
    public var appsListArn: Swift.String?

    public init (
        appsList: FmsClientTypes.AppsListData? = nil,
        appsListArn: Swift.String? = nil
    )
    {
        self.appsList = appsList
        self.appsListArn = appsListArn
    }
}

struct GetAppsListOutputResponseBody: Swift.Equatable {
    let appsList: FmsClientTypes.AppsListData?
    let appsListArn: Swift.String?
}

extension GetAppsListOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsList = "AppsList"
        case appsListArn = "AppsListArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsListDecoded = try containerValues.decodeIfPresent(FmsClientTypes.AppsListData.self, forKey: .appsList)
        appsList = appsListDecoded
        let appsListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appsListArn)
        appsListArn = appsListArnDecoded
    }
}

extension GetComplianceDetailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccount = memberAccount {
            try encodeContainer.encode(memberAccount, forKey: .memberAccount)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
    }
}

extension GetComplianceDetailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetComplianceDetailInput: Swift.Equatable {
    /// The Amazon Web Services account that owns the resources that you want to get the details for.
    /// This member is required.
    public var memberAccount: Swift.String?
    /// The ID of the policy that you want to get the details for. PolicyId is returned by PutPolicy and by ListPolicies.
    /// This member is required.
    public var policyId: Swift.String?

    public init (
        memberAccount: Swift.String? = nil,
        policyId: Swift.String? = nil
    )
    {
        self.memberAccount = memberAccount
        self.policyId = policyId
    }
}

struct GetComplianceDetailInputBody: Swift.Equatable {
    let policyId: Swift.String?
    let memberAccount: Swift.String?
}

extension GetComplianceDetailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let memberAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccount)
        memberAccount = memberAccountDecoded
    }
}

extension GetComplianceDetailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComplianceDetailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComplianceDetailOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComplianceDetailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetComplianceDetailOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyComplianceDetail = output.policyComplianceDetail
        } else {
            self.policyComplianceDetail = nil
        }
    }
}

public struct GetComplianceDetailOutputResponse: Swift.Equatable {
    /// Information about the resources and the policy that you specified in the GetComplianceDetail request.
    public var policyComplianceDetail: FmsClientTypes.PolicyComplianceDetail?

    public init (
        policyComplianceDetail: FmsClientTypes.PolicyComplianceDetail? = nil
    )
    {
        self.policyComplianceDetail = policyComplianceDetail
    }
}

struct GetComplianceDetailOutputResponseBody: Swift.Equatable {
    let policyComplianceDetail: FmsClientTypes.PolicyComplianceDetail?
}

extension GetComplianceDetailOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyComplianceDetail = "PolicyComplianceDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyComplianceDetailDecoded = try containerValues.decodeIfPresent(FmsClientTypes.PolicyComplianceDetail.self, forKey: .policyComplianceDetail)
        policyComplianceDetail = policyComplianceDetailDecoded
    }
}

extension GetNotificationChannelInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetNotificationChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetNotificationChannelInput: Swift.Equatable {

}

struct GetNotificationChannelInputBody: Swift.Equatable {
}

extension GetNotificationChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNotificationChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNotificationChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNotificationChannelOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNotificationChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNotificationChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snsRoleName = output.snsRoleName
            self.snsTopicArn = output.snsTopicArn
        } else {
            self.snsRoleName = nil
            self.snsTopicArn = nil
        }
    }
}

public struct GetNotificationChannelOutputResponse: Swift.Equatable {
    /// The IAM role that is used by Firewall Manager to record activity to SNS.
    public var snsRoleName: Swift.String?
    /// The SNS topic that records Firewall Manager activity.
    public var snsTopicArn: Swift.String?

    public init (
        snsRoleName: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.snsRoleName = snsRoleName
        self.snsTopicArn = snsTopicArn
    }
}

struct GetNotificationChannelOutputResponseBody: Swift.Equatable {
    let snsTopicArn: Swift.String?
    let snsRoleName: Swift.String?
}

extension GetNotificationChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snsRoleName = "SnsRoleName"
        case snsTopicArn = "SnsTopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let snsRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsRoleName)
        snsRoleName = snsRoleNameDecoded
    }
}

extension GetPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId = "PolicyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
    }
}

extension GetPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPolicyInput: Swift.Equatable {
    /// The ID of the Firewall Manager policy that you want the details for.
    /// This member is required.
    public var policyId: Swift.String?

    public init (
        policyId: Swift.String? = nil
    )
    {
        self.policyId = policyId
    }
}

struct GetPolicyInputBody: Swift.Equatable {
    let policyId: Swift.String?
}

extension GetPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId = "PolicyId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
    }
}

extension GetPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidTypeException(InvalidTypeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.policyArn = output.policyArn
        } else {
            self.policy = nil
            self.policyArn = nil
        }
    }
}

public struct GetPolicyOutputResponse: Swift.Equatable {
    /// Information about the specified Firewall Manager policy.
    public var policy: FmsClientTypes.Policy?
    /// The Amazon Resource Name (ARN) of the specified policy.
    public var policyArn: Swift.String?

    public init (
        policy: FmsClientTypes.Policy? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.policyArn = policyArn
    }
}

struct GetPolicyOutputResponseBody: Swift.Equatable {
    let policy: FmsClientTypes.Policy?
    let policyArn: Swift.String?
}

extension GetPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(FmsClientTypes.Policy.self, forKey: .policy)
        policy = policyDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension GetProtectionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case memberAccountId = "MemberAccountId"
        case nextToken = "NextToken"
        case policyId = "PolicyId"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let memberAccountId = memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

extension GetProtectionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetProtectionStatusInput: Swift.Equatable {
    /// The end of the time period to query for the attacks. This is a timestamp type. The request syntax listing indicates a number type because the default used by Firewall Manager is Unix time in seconds. However, any valid timestamp format is allowed.
    public var endTime: ClientRuntime.Date?
    /// Specifies the number of objects that you want Firewall Manager to return for this request. If you have more objects than the number that you specify for MaxResults, the response includes a NextToken value that you can use to get another batch of objects.
    public var maxResults: Swift.Int?
    /// The Amazon Web Services account that is in scope of the policy that you want to get the details for.
    public var memberAccountId: Swift.String?
    /// If you specify a value for MaxResults and you have more objects than the number that you specify for MaxResults, Firewall Manager returns a NextToken value in the response, which you can use to retrieve another group of objects. For the second and subsequent GetProtectionStatus requests, specify the value of NextToken from the previous response to get information about another batch of objects.
    public var nextToken: Swift.String?
    /// The ID of the policy for which you want to get the attack information.
    /// This member is required.
    public var policyId: Swift.String?
    /// The start of the time period to query for the attacks. This is a timestamp type. The request syntax listing indicates a number type because the default used by Firewall Manager is Unix time in seconds. However, any valid timestamp format is allowed.
    public var startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        memberAccountId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        policyId: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.memberAccountId = memberAccountId
        self.nextToken = nextToken
        self.policyId = policyId
        self.startTime = startTime
    }
}

struct GetProtectionStatusInputBody: Swift.Equatable {
    let policyId: Swift.String?
    let memberAccountId: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetProtectionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case memberAccountId = "MemberAccountId"
        case nextToken = "NextToken"
        case policyId = "PolicyId"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetProtectionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProtectionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProtectionStatusOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProtectionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetProtectionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adminAccountId = output.adminAccountId
            self.data = output.data
            self.nextToken = output.nextToken
            self.serviceType = output.serviceType
        } else {
            self.adminAccountId = nil
            self.data = nil
            self.nextToken = nil
            self.serviceType = nil
        }
    }
}

public struct GetProtectionStatusOutputResponse: Swift.Equatable {
    /// The ID of the Firewall Manager administrator account for this policy.
    public var adminAccountId: Swift.String?
    /// Details about the attack, including the following:
    ///
    /// * Attack type
    ///
    /// * Account ID
    ///
    /// * ARN of the resource attacked
    ///
    /// * Start time of the attack
    ///
    /// * End time of the attack (ongoing attacks will not have an end time)
    ///
    ///
    /// The details are in JSON format.
    public var data: Swift.String?
    /// If you have more objects than the number that you specified for MaxResults in the request, the response includes a NextToken value. To list more objects, submit another GetProtectionStatus request, and specify the NextToken value from the response in the NextToken value in the next request. Amazon Web Services SDKs provide auto-pagination that identify NextToken in a response and make subsequent request calls automatically on your behalf. However, this feature is not supported by GetProtectionStatus. You must submit subsequent requests with NextToken using your own processes.
    public var nextToken: Swift.String?
    /// The service type that is protected by the policy. Currently, this is always SHIELD_ADVANCED.
    public var serviceType: FmsClientTypes.SecurityServiceType?

    public init (
        adminAccountId: Swift.String? = nil,
        data: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        serviceType: FmsClientTypes.SecurityServiceType? = nil
    )
    {
        self.adminAccountId = adminAccountId
        self.data = data
        self.nextToken = nextToken
        self.serviceType = serviceType
    }
}

struct GetProtectionStatusOutputResponseBody: Swift.Equatable {
    let adminAccountId: Swift.String?
    let serviceType: FmsClientTypes.SecurityServiceType?
    let data: Swift.String?
    let nextToken: Swift.String?
}

extension GetProtectionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "AdminAccountId"
        case data = "Data"
        case nextToken = "NextToken"
        case serviceType = "ServiceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
        let serviceTypeDecoded = try containerValues.decodeIfPresent(FmsClientTypes.SecurityServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetProtocolsListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultList = "DefaultList"
        case listId = "ListId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultList != false {
            try encodeContainer.encode(defaultList, forKey: .defaultList)
        }
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
    }
}

extension GetProtocolsListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetProtocolsListInput: Swift.Equatable {
    /// Specifies whether the list to retrieve is a default list owned by Firewall Manager.
    public var defaultList: Swift.Bool
    /// The ID of the Firewall Manager protocols list that you want the details for.
    /// This member is required.
    public var listId: Swift.String?

    public init (
        defaultList: Swift.Bool = false,
        listId: Swift.String? = nil
    )
    {
        self.defaultList = defaultList
        self.listId = listId
    }
}

struct GetProtocolsListInputBody: Swift.Equatable {
    let listId: Swift.String?
    let defaultList: Swift.Bool
}

extension GetProtocolsListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultList = "DefaultList"
        case listId = "ListId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
        let defaultListDecoded = try containerValues.decode(Swift.Bool.self, forKey: .defaultList)
        defaultList = defaultListDecoded
    }
}

extension GetProtocolsListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProtocolsListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProtocolsListOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProtocolsListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetProtocolsListOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.protocolsList = output.protocolsList
            self.protocolsListArn = output.protocolsListArn
        } else {
            self.protocolsList = nil
            self.protocolsListArn = nil
        }
    }
}

public struct GetProtocolsListOutputResponse: Swift.Equatable {
    /// Information about the specified Firewall Manager protocols list.
    public var protocolsList: FmsClientTypes.ProtocolsListData?
    /// The Amazon Resource Name (ARN) of the specified protocols list.
    public var protocolsListArn: Swift.String?

    public init (
        protocolsList: FmsClientTypes.ProtocolsListData? = nil,
        protocolsListArn: Swift.String? = nil
    )
    {
        self.protocolsList = protocolsList
        self.protocolsListArn = protocolsListArn
    }
}

struct GetProtocolsListOutputResponseBody: Swift.Equatable {
    let protocolsList: FmsClientTypes.ProtocolsListData?
    let protocolsListArn: Swift.String?
}

extension GetProtocolsListOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protocolsList = "ProtocolsList"
        case protocolsListArn = "ProtocolsListArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsListDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ProtocolsListData.self, forKey: .protocolsList)
        protocolsList = protocolsListDecoded
        let protocolsListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocolsListArn)
        protocolsListArn = protocolsListArnDecoded
    }
}

extension GetViolationDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccount = memberAccount {
            try encodeContainer.encode(memberAccount, forKey: .memberAccount)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension GetViolationDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetViolationDetailsInput: Swift.Equatable {
    /// The Amazon Web Services account ID that you want the details for.
    /// This member is required.
    public var memberAccount: Swift.String?
    /// The ID of the Firewall Manager policy that you want the details for. This currently only supports security group content audit policies.
    /// This member is required.
    public var policyId: Swift.String?
    /// The ID of the resource that has violations.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type. This is in the format shown in the [Amazon Web Services Resource Types Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html). Supported resource types are: AWS::EC2::Instance, AWS::EC2::NetworkInterface, AWS::EC2::SecurityGroup, AWS::NetworkFirewall::FirewallPolicy, and AWS::EC2::Subnet.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        memberAccount: Swift.String? = nil,
        policyId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.memberAccount = memberAccount
        self.policyId = policyId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct GetViolationDetailsInputBody: Swift.Equatable {
    let policyId: Swift.String?
    let memberAccount: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension GetViolationDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let memberAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccount)
        memberAccount = memberAccountDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension GetViolationDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetViolationDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetViolationDetailsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetViolationDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetViolationDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.violationDetail = output.violationDetail
        } else {
            self.violationDetail = nil
        }
    }
}

public struct GetViolationDetailsOutputResponse: Swift.Equatable {
    /// Violation detail for a resource.
    public var violationDetail: FmsClientTypes.ViolationDetail?

    public init (
        violationDetail: FmsClientTypes.ViolationDetail? = nil
    )
    {
        self.violationDetail = violationDetail
    }
}

struct GetViolationDetailsOutputResponseBody: Swift.Equatable {
    let violationDetail: FmsClientTypes.ViolationDetail?
}

extension GetViolationDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case violationDetail = "ViolationDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationDetailDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ViolationDetail.self, forKey: .violationDetail)
        violationDetail = violationDetailDecoded
    }
}

extension InternalErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed because of a system problem, even though the request was valid. Retry your request.
public struct InternalErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameters of the request were invalid.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed because there was nothing to do or the operation wasn't possible. For example, you might have submitted an AssociateAdminAccount request for an account ID that was already set as the Firewall Manager administrator. Or you might have tried to access a Region that's disabled by default, and that you need to enable for the Firewall Manager administrator account and for Organizations before you can access it.
public struct InvalidOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value of the Type parameter is invalid.
public struct InvalidTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation exceeds a resource limit, for example, the maximum number of policy objects that you can create for an Amazon Web Services account. For more information, see [Firewall Manager Limits](https://docs.aws.amazon.com/waf/latest/developerguide/fms-limits.html) in the WAF Developer Guide.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAppsListsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLists = "DefaultLists"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultLists != false {
            try encodeContainer.encode(defaultLists, forKey: .defaultLists)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAppsListsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAppsListsInput: Swift.Equatable {
    /// Specifies whether the lists to retrieve are default lists owned by Firewall Manager.
    public var defaultLists: Swift.Bool
    /// The maximum number of objects that you want Firewall Manager to return for this request. If more objects are available, in the response, Firewall Manager provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify this, Firewall Manager returns all available objects.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// If you specify a value for MaxResults in your list request, and you have more objects than the maximum, Firewall Manager returns this token in the response. For all but the first request, you provide the token returned by the prior request in the request parameters, to retrieve the next batch of objects.
    public var nextToken: Swift.String?

    public init (
        defaultLists: Swift.Bool = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.defaultLists = defaultLists
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppsListsInputBody: Swift.Equatable {
    let defaultLists: Swift.Bool
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAppsListsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLists = "DefaultLists"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultListsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .defaultLists)
        defaultLists = defaultListsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppsListsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppsListsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppsListsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppsListsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppsListsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appsLists = output.appsLists
            self.nextToken = output.nextToken
        } else {
            self.appsLists = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppsListsOutputResponse: Swift.Equatable {
    /// An array of AppsListDataSummary objects.
    public var appsLists: [FmsClientTypes.AppsListDataSummary]?
    /// If you specify a value for MaxResults in your list request, and you have more objects than the maximum, Firewall Manager returns this token in the response. You can use this token in subsequent requests to retrieve the next batch of objects.
    public var nextToken: Swift.String?

    public init (
        appsLists: [FmsClientTypes.AppsListDataSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appsLists = appsLists
        self.nextToken = nextToken
    }
}

struct ListAppsListsOutputResponseBody: Swift.Equatable {
    let appsLists: [FmsClientTypes.AppsListDataSummary]?
    let nextToken: Swift.String?
}

extension ListAppsListsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsLists = "AppsLists"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsListsContainer = try containerValues.decodeIfPresent([FmsClientTypes.AppsListDataSummary?].self, forKey: .appsLists)
        var appsListsDecoded0:[FmsClientTypes.AppsListDataSummary]? = nil
        if let appsListsContainer = appsListsContainer {
            appsListsDecoded0 = [FmsClientTypes.AppsListDataSummary]()
            for structure0 in appsListsContainer {
                if let structure0 = structure0 {
                    appsListsDecoded0?.append(structure0)
                }
            }
        }
        appsLists = appsListsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComplianceStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyId = "PolicyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
    }
}

extension ListComplianceStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListComplianceStatusInput: Swift.Equatable {
    /// Specifies the number of PolicyComplianceStatus objects that you want Firewall Manager to return for this request. If you have more PolicyComplianceStatus objects than the number that you specify for MaxResults, the response includes a NextToken value that you can use to get another batch of PolicyComplianceStatus objects.
    public var maxResults: Swift.Int?
    /// If you specify a value for MaxResults and you have more PolicyComplianceStatus objects than the number that you specify for MaxResults, Firewall Manager returns a NextToken value in the response that allows you to list another group of PolicyComplianceStatus objects. For the second and subsequent ListComplianceStatus requests, specify the value of NextToken from the previous response to get information about another batch of PolicyComplianceStatus objects.
    public var nextToken: Swift.String?
    /// The ID of the Firewall Manager policy that you want the details for.
    /// This member is required.
    public var policyId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyId = policyId
    }
}

struct ListComplianceStatusInputBody: Swift.Equatable {
    let policyId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListComplianceStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyId = "PolicyId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListComplianceStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComplianceStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComplianceStatusOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComplianceStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListComplianceStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.policyComplianceStatusList = output.policyComplianceStatusList
        } else {
            self.nextToken = nil
            self.policyComplianceStatusList = nil
        }
    }
}

public struct ListComplianceStatusOutputResponse: Swift.Equatable {
    /// If you have more PolicyComplianceStatus objects than the number that you specified for MaxResults in the request, the response includes a NextToken value. To list more PolicyComplianceStatus objects, submit another ListComplianceStatus request, and specify the NextToken value from the response in the NextToken value in the next request.
    public var nextToken: Swift.String?
    /// An array of PolicyComplianceStatus objects.
    public var policyComplianceStatusList: [FmsClientTypes.PolicyComplianceStatus]?

    public init (
        nextToken: Swift.String? = nil,
        policyComplianceStatusList: [FmsClientTypes.PolicyComplianceStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyComplianceStatusList = policyComplianceStatusList
    }
}

struct ListComplianceStatusOutputResponseBody: Swift.Equatable {
    let policyComplianceStatusList: [FmsClientTypes.PolicyComplianceStatus]?
    let nextToken: Swift.String?
}

extension ListComplianceStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case policyComplianceStatusList = "PolicyComplianceStatusList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyComplianceStatusListContainer = try containerValues.decodeIfPresent([FmsClientTypes.PolicyComplianceStatus?].self, forKey: .policyComplianceStatusList)
        var policyComplianceStatusListDecoded0:[FmsClientTypes.PolicyComplianceStatus]? = nil
        if let policyComplianceStatusListContainer = policyComplianceStatusListContainer {
            policyComplianceStatusListDecoded0 = [FmsClientTypes.PolicyComplianceStatus]()
            for structure0 in policyComplianceStatusListContainer {
                if let structure0 = structure0 {
                    policyComplianceStatusListDecoded0?.append(structure0)
                }
            }
        }
        policyComplianceStatusList = policyComplianceStatusListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMemberAccountsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMemberAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMemberAccountsInput: Swift.Equatable {
    /// Specifies the number of member account IDs that you want Firewall Manager to return for this request. If you have more IDs than the number that you specify for MaxResults, the response includes a NextToken value that you can use to get another batch of member account IDs.
    public var maxResults: Swift.Int?
    /// If you specify a value for MaxResults and you have more account IDs than the number that you specify for MaxResults, Firewall Manager returns a NextToken value in the response that allows you to list another group of IDs. For the second and subsequent ListMemberAccountsRequest requests, specify the value of NextToken from the previous response to get information about another batch of member account IDs.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMemberAccountsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMemberAccountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMemberAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMemberAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMemberAccountsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMemberAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMemberAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.memberAccounts = output.memberAccounts
            self.nextToken = output.nextToken
        } else {
            self.memberAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListMemberAccountsOutputResponse: Swift.Equatable {
    /// An array of account IDs.
    public var memberAccounts: [Swift.String]?
    /// If you have more member account IDs than the number that you specified for MaxResults in the request, the response includes a NextToken value. To list more IDs, submit another ListMemberAccounts request, and specify the NextToken value from the response in the NextToken value in the next request.
    public var nextToken: Swift.String?

    public init (
        memberAccounts: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.memberAccounts = memberAccounts
        self.nextToken = nextToken
    }
}

struct ListMemberAccountsOutputResponseBody: Swift.Equatable {
    let memberAccounts: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListMemberAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccounts = "MemberAccounts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .memberAccounts)
        var memberAccountsDecoded0:[Swift.String]? = nil
        if let memberAccountsContainer = memberAccountsContainer {
            memberAccountsDecoded0 = [Swift.String]()
            for string0 in memberAccountsContainer {
                if let string0 = string0 {
                    memberAccountsDecoded0?.append(string0)
                }
            }
        }
        memberAccounts = memberAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPoliciesInput: Swift.Equatable {
    /// Specifies the number of PolicySummary objects that you want Firewall Manager to return for this request. If you have more PolicySummary objects than the number that you specify for MaxResults, the response includes a NextToken value that you can use to get another batch of PolicySummary objects.
    public var maxResults: Swift.Int?
    /// If you specify a value for MaxResults and you have more PolicySummary objects than the number that you specify for MaxResults, Firewall Manager returns a NextToken value in the response that allows you to list another group of PolicySummary objects. For the second and subsequent ListPolicies requests, specify the value of NextToken from the previous response to get information about another batch of PolicySummary objects.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPoliciesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPoliciesOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.policyList = output.policyList
        } else {
            self.nextToken = nil
            self.policyList = nil
        }
    }
}

public struct ListPoliciesOutputResponse: Swift.Equatable {
    /// If you have more PolicySummary objects than the number that you specified for MaxResults in the request, the response includes a NextToken value. To list more PolicySummary objects, submit another ListPolicies request, and specify the NextToken value from the response in the NextToken value in the next request.
    public var nextToken: Swift.String?
    /// An array of PolicySummary objects.
    public var policyList: [FmsClientTypes.PolicySummary]?

    public init (
        nextToken: Swift.String? = nil,
        policyList: [FmsClientTypes.PolicySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyList = policyList
    }
}

struct ListPoliciesOutputResponseBody: Swift.Equatable {
    let policyList: [FmsClientTypes.PolicySummary]?
    let nextToken: Swift.String?
}

extension ListPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case policyList = "PolicyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyListContainer = try containerValues.decodeIfPresent([FmsClientTypes.PolicySummary?].self, forKey: .policyList)
        var policyListDecoded0:[FmsClientTypes.PolicySummary]? = nil
        if let policyListContainer = policyListContainer {
            policyListDecoded0 = [FmsClientTypes.PolicySummary]()
            for structure0 in policyListContainer {
                if let structure0 = structure0 {
                    policyListDecoded0?.append(structure0)
                }
            }
        }
        policyList = policyListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProtocolsListsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLists = "DefaultLists"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultLists != false {
            try encodeContainer.encode(defaultLists, forKey: .defaultLists)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListProtocolsListsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProtocolsListsInput: Swift.Equatable {
    /// Specifies whether the lists to retrieve are default lists owned by Firewall Manager.
    public var defaultLists: Swift.Bool
    /// The maximum number of objects that you want Firewall Manager to return for this request. If more objects are available, in the response, Firewall Manager provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify this, Firewall Manager returns all available objects.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// If you specify a value for MaxResults in your list request, and you have more objects than the maximum, Firewall Manager returns this token in the response. For all but the first request, you provide the token returned by the prior request in the request parameters, to retrieve the next batch of objects.
    public var nextToken: Swift.String?

    public init (
        defaultLists: Swift.Bool = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.defaultLists = defaultLists
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProtocolsListsInputBody: Swift.Equatable {
    let defaultLists: Swift.Bool
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListProtocolsListsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLists = "DefaultLists"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultListsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .defaultLists)
        defaultLists = defaultListsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListProtocolsListsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProtocolsListsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProtocolsListsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProtocolsListsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProtocolsListsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.protocolsLists = output.protocolsLists
        } else {
            self.nextToken = nil
            self.protocolsLists = nil
        }
    }
}

public struct ListProtocolsListsOutputResponse: Swift.Equatable {
    /// If you specify a value for MaxResults in your list request, and you have more objects than the maximum, Firewall Manager returns this token in the response. You can use this token in subsequent requests to retrieve the next batch of objects.
    public var nextToken: Swift.String?
    /// An array of ProtocolsListDataSummary objects.
    public var protocolsLists: [FmsClientTypes.ProtocolsListDataSummary]?

    public init (
        nextToken: Swift.String? = nil,
        protocolsLists: [FmsClientTypes.ProtocolsListDataSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.protocolsLists = protocolsLists
    }
}

struct ListProtocolsListsOutputResponseBody: Swift.Equatable {
    let protocolsLists: [FmsClientTypes.ProtocolsListDataSummary]?
    let nextToken: Swift.String?
}

extension ListProtocolsListsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case protocolsLists = "ProtocolsLists"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsListsContainer = try containerValues.decodeIfPresent([FmsClientTypes.ProtocolsListDataSummary?].self, forKey: .protocolsLists)
        var protocolsListsDecoded0:[FmsClientTypes.ProtocolsListDataSummary]? = nil
        if let protocolsListsContainer = protocolsListsContainer {
            protocolsListsDecoded0 = [FmsClientTypes.ProtocolsListDataSummary]()
            for structure0 in protocolsListsContainer {
                if let structure0 = structure0 {
                    protocolsListsDecoded0?.append(structure0)
                }
            }
        }
        protocolsLists = protocolsListsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to return tags for. The Firewall Manager resources that support tagging are policies, applications lists, and protocols lists.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags associated with the resource.
    public var tagList: [FmsClientTypes.Tag]?

    public init (
        tagList: [FmsClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tagList: [FmsClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([FmsClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[FmsClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [FmsClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension FmsClientTypes.NetworkFirewallBlackHoleRouteDetectedViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routeTableId = "RouteTableId"
        case violatingRoutes = "ViolatingRoutes"
        case violationTarget = "ViolationTarget"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let routeTableId = routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let violatingRoutes = violatingRoutes {
            var violatingRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violatingRoutes)
            for routes0 in violatingRoutes {
                try violatingRoutesContainer.encode(routes0)
            }
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let violatingRoutesContainer = try containerValues.decodeIfPresent([FmsClientTypes.Route?].self, forKey: .violatingRoutes)
        var violatingRoutesDecoded0:[FmsClientTypes.Route]? = nil
        if let violatingRoutesContainer = violatingRoutesContainer {
            violatingRoutesDecoded0 = [FmsClientTypes.Route]()
            for structure0 in violatingRoutesContainer {
                if let structure0 = structure0 {
                    violatingRoutesDecoded0?.append(structure0)
                }
            }
        }
        violatingRoutes = violatingRoutesDecoded0
    }
}

extension FmsClientTypes {
    /// Violation detail for an internet gateway route with an inactive state in the customer subnet route table or Network Firewall subnet route table.
    public struct NetworkFirewallBlackHoleRouteDetectedViolation: Swift.Equatable {
        /// Information about the route table ID.
        public var routeTableId: Swift.String?
        /// Information about the route or routes that are in violation.
        public var violatingRoutes: [FmsClientTypes.Route]?
        /// The subnet that has an inactive state.
        public var violationTarget: Swift.String?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init (
            routeTableId: Swift.String? = nil,
            violatingRoutes: [FmsClientTypes.Route]? = nil,
            violationTarget: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.routeTableId = routeTableId
            self.violatingRoutes = violatingRoutes
            self.violationTarget = violationTarget
            self.vpcId = vpcId
        }
    }

}

extension FmsClientTypes.NetworkFirewallInternetTrafficNotInspectedViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualFirewallSubnetRoutes = "ActualFirewallSubnetRoutes"
        case actualInternetGatewayRoutes = "ActualInternetGatewayRoutes"
        case currentFirewallSubnetRouteTable = "CurrentFirewallSubnetRouteTable"
        case currentInternetGatewayRouteTable = "CurrentInternetGatewayRouteTable"
        case expectedFirewallEndpoint = "ExpectedFirewallEndpoint"
        case expectedFirewallSubnetRoutes = "ExpectedFirewallSubnetRoutes"
        case expectedInternetGatewayRoutes = "ExpectedInternetGatewayRoutes"
        case firewallSubnetId = "FirewallSubnetId"
        case internetGatewayId = "InternetGatewayId"
        case isRouteTableUsedInDifferentAZ = "IsRouteTableUsedInDifferentAZ"
        case routeTableId = "RouteTableId"
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetId = "SubnetId"
        case violatingRoutes = "ViolatingRoutes"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualFirewallSubnetRoutes = actualFirewallSubnetRoutes {
            var actualFirewallSubnetRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actualFirewallSubnetRoutes)
            for routes0 in actualFirewallSubnetRoutes {
                try actualFirewallSubnetRoutesContainer.encode(routes0)
            }
        }
        if let actualInternetGatewayRoutes = actualInternetGatewayRoutes {
            var actualInternetGatewayRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actualInternetGatewayRoutes)
            for routes0 in actualInternetGatewayRoutes {
                try actualInternetGatewayRoutesContainer.encode(routes0)
            }
        }
        if let currentFirewallSubnetRouteTable = currentFirewallSubnetRouteTable {
            try encodeContainer.encode(currentFirewallSubnetRouteTable, forKey: .currentFirewallSubnetRouteTable)
        }
        if let currentInternetGatewayRouteTable = currentInternetGatewayRouteTable {
            try encodeContainer.encode(currentInternetGatewayRouteTable, forKey: .currentInternetGatewayRouteTable)
        }
        if let expectedFirewallEndpoint = expectedFirewallEndpoint {
            try encodeContainer.encode(expectedFirewallEndpoint, forKey: .expectedFirewallEndpoint)
        }
        if let expectedFirewallSubnetRoutes = expectedFirewallSubnetRoutes {
            var expectedFirewallSubnetRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expectedFirewallSubnetRoutes)
            for expectedroutes0 in expectedFirewallSubnetRoutes {
                try expectedFirewallSubnetRoutesContainer.encode(expectedroutes0)
            }
        }
        if let expectedInternetGatewayRoutes = expectedInternetGatewayRoutes {
            var expectedInternetGatewayRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expectedInternetGatewayRoutes)
            for expectedroutes0 in expectedInternetGatewayRoutes {
                try expectedInternetGatewayRoutesContainer.encode(expectedroutes0)
            }
        }
        if let firewallSubnetId = firewallSubnetId {
            try encodeContainer.encode(firewallSubnetId, forKey: .firewallSubnetId)
        }
        if let internetGatewayId = internetGatewayId {
            try encodeContainer.encode(internetGatewayId, forKey: .internetGatewayId)
        }
        if isRouteTableUsedInDifferentAZ != false {
            try encodeContainer.encode(isRouteTableUsedInDifferentAZ, forKey: .isRouteTableUsedInDifferentAZ)
        }
        if let routeTableId = routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let subnetAvailabilityZone = subnetAvailabilityZone {
            try encodeContainer.encode(subnetAvailabilityZone, forKey: .subnetAvailabilityZone)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let violatingRoutes = violatingRoutes {
            var violatingRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violatingRoutes)
            for routes0 in violatingRoutes {
                try violatingRoutesContainer.encode(routes0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
        let violatingRoutesContainer = try containerValues.decodeIfPresent([FmsClientTypes.Route?].self, forKey: .violatingRoutes)
        var violatingRoutesDecoded0:[FmsClientTypes.Route]? = nil
        if let violatingRoutesContainer = violatingRoutesContainer {
            violatingRoutesDecoded0 = [FmsClientTypes.Route]()
            for structure0 in violatingRoutesContainer {
                if let structure0 = structure0 {
                    violatingRoutesDecoded0?.append(structure0)
                }
            }
        }
        violatingRoutes = violatingRoutesDecoded0
        let isRouteTableUsedInDifferentAZDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isRouteTableUsedInDifferentAZ)
        isRouteTableUsedInDifferentAZ = isRouteTableUsedInDifferentAZDecoded
        let currentFirewallSubnetRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentFirewallSubnetRouteTable)
        currentFirewallSubnetRouteTable = currentFirewallSubnetRouteTableDecoded
        let expectedFirewallEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedFirewallEndpoint)
        expectedFirewallEndpoint = expectedFirewallEndpointDecoded
        let firewallSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallSubnetId)
        firewallSubnetId = firewallSubnetIdDecoded
        let expectedFirewallSubnetRoutesContainer = try containerValues.decodeIfPresent([FmsClientTypes.ExpectedRoute?].self, forKey: .expectedFirewallSubnetRoutes)
        var expectedFirewallSubnetRoutesDecoded0:[FmsClientTypes.ExpectedRoute]? = nil
        if let expectedFirewallSubnetRoutesContainer = expectedFirewallSubnetRoutesContainer {
            expectedFirewallSubnetRoutesDecoded0 = [FmsClientTypes.ExpectedRoute]()
            for structure0 in expectedFirewallSubnetRoutesContainer {
                if let structure0 = structure0 {
                    expectedFirewallSubnetRoutesDecoded0?.append(structure0)
                }
            }
        }
        expectedFirewallSubnetRoutes = expectedFirewallSubnetRoutesDecoded0
        let actualFirewallSubnetRoutesContainer = try containerValues.decodeIfPresent([FmsClientTypes.Route?].self, forKey: .actualFirewallSubnetRoutes)
        var actualFirewallSubnetRoutesDecoded0:[FmsClientTypes.Route]? = nil
        if let actualFirewallSubnetRoutesContainer = actualFirewallSubnetRoutesContainer {
            actualFirewallSubnetRoutesDecoded0 = [FmsClientTypes.Route]()
            for structure0 in actualFirewallSubnetRoutesContainer {
                if let structure0 = structure0 {
                    actualFirewallSubnetRoutesDecoded0?.append(structure0)
                }
            }
        }
        actualFirewallSubnetRoutes = actualFirewallSubnetRoutesDecoded0
        let internetGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .internetGatewayId)
        internetGatewayId = internetGatewayIdDecoded
        let currentInternetGatewayRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentInternetGatewayRouteTable)
        currentInternetGatewayRouteTable = currentInternetGatewayRouteTableDecoded
        let expectedInternetGatewayRoutesContainer = try containerValues.decodeIfPresent([FmsClientTypes.ExpectedRoute?].self, forKey: .expectedInternetGatewayRoutes)
        var expectedInternetGatewayRoutesDecoded0:[FmsClientTypes.ExpectedRoute]? = nil
        if let expectedInternetGatewayRoutesContainer = expectedInternetGatewayRoutesContainer {
            expectedInternetGatewayRoutesDecoded0 = [FmsClientTypes.ExpectedRoute]()
            for structure0 in expectedInternetGatewayRoutesContainer {
                if let structure0 = structure0 {
                    expectedInternetGatewayRoutesDecoded0?.append(structure0)
                }
            }
        }
        expectedInternetGatewayRoutes = expectedInternetGatewayRoutesDecoded0
        let actualInternetGatewayRoutesContainer = try containerValues.decodeIfPresent([FmsClientTypes.Route?].self, forKey: .actualInternetGatewayRoutes)
        var actualInternetGatewayRoutesDecoded0:[FmsClientTypes.Route]? = nil
        if let actualInternetGatewayRoutesContainer = actualInternetGatewayRoutesContainer {
            actualInternetGatewayRoutesDecoded0 = [FmsClientTypes.Route]()
            for structure0 in actualInternetGatewayRoutesContainer {
                if let structure0 = structure0 {
                    actualInternetGatewayRoutesDecoded0?.append(structure0)
                }
            }
        }
        actualInternetGatewayRoutes = actualInternetGatewayRoutesDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension FmsClientTypes {
    /// Violation detail for the subnet for which internet traffic that hasn't been inspected.
    public struct NetworkFirewallInternetTrafficNotInspectedViolation: Swift.Equatable {
        /// The actual firewall subnet routes.
        public var actualFirewallSubnetRoutes: [FmsClientTypes.Route]?
        /// The actual internet gateway routes.
        public var actualInternetGatewayRoutes: [FmsClientTypes.Route]?
        /// Information about the subnet route table for the current firewall.
        public var currentFirewallSubnetRouteTable: Swift.String?
        /// The current route table for the internet gateway.
        public var currentInternetGatewayRouteTable: Swift.String?
        /// The expected endpoint for the current firewall.
        public var expectedFirewallEndpoint: Swift.String?
        /// The firewall subnet routes that are expected.
        public var expectedFirewallSubnetRoutes: [FmsClientTypes.ExpectedRoute]?
        /// The internet gateway routes that are expected.
        public var expectedInternetGatewayRoutes: [FmsClientTypes.ExpectedRoute]?
        /// The firewall subnet ID.
        public var firewallSubnetId: Swift.String?
        /// The internet gateway ID.
        public var internetGatewayId: Swift.String?
        /// Information about whether the route table is used in another Availability Zone.
        public var isRouteTableUsedInDifferentAZ: Swift.Bool
        /// Information about the route table ID.
        public var routeTableId: Swift.String?
        /// The subnet Availability Zone.
        public var subnetAvailabilityZone: Swift.String?
        /// The subnet ID.
        public var subnetId: Swift.String?
        /// The route or routes that are in violation.
        public var violatingRoutes: [FmsClientTypes.Route]?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init (
            actualFirewallSubnetRoutes: [FmsClientTypes.Route]? = nil,
            actualInternetGatewayRoutes: [FmsClientTypes.Route]? = nil,
            currentFirewallSubnetRouteTable: Swift.String? = nil,
            currentInternetGatewayRouteTable: Swift.String? = nil,
            expectedFirewallEndpoint: Swift.String? = nil,
            expectedFirewallSubnetRoutes: [FmsClientTypes.ExpectedRoute]? = nil,
            expectedInternetGatewayRoutes: [FmsClientTypes.ExpectedRoute]? = nil,
            firewallSubnetId: Swift.String? = nil,
            internetGatewayId: Swift.String? = nil,
            isRouteTableUsedInDifferentAZ: Swift.Bool = false,
            routeTableId: Swift.String? = nil,
            subnetAvailabilityZone: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            violatingRoutes: [FmsClientTypes.Route]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.actualFirewallSubnetRoutes = actualFirewallSubnetRoutes
            self.actualInternetGatewayRoutes = actualInternetGatewayRoutes
            self.currentFirewallSubnetRouteTable = currentFirewallSubnetRouteTable
            self.currentInternetGatewayRouteTable = currentInternetGatewayRouteTable
            self.expectedFirewallEndpoint = expectedFirewallEndpoint
            self.expectedFirewallSubnetRoutes = expectedFirewallSubnetRoutes
            self.expectedInternetGatewayRoutes = expectedInternetGatewayRoutes
            self.firewallSubnetId = firewallSubnetId
            self.internetGatewayId = internetGatewayId
            self.isRouteTableUsedInDifferentAZ = isRouteTableUsedInDifferentAZ
            self.routeTableId = routeTableId
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetId = subnetId
            self.violatingRoutes = violatingRoutes
            self.vpcId = vpcId
        }
    }

}

extension FmsClientTypes.NetworkFirewallInvalidRouteConfigurationViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualFirewallEndpoint = "ActualFirewallEndpoint"
        case actualFirewallSubnetId = "ActualFirewallSubnetId"
        case actualFirewallSubnetRoutes = "ActualFirewallSubnetRoutes"
        case actualInternetGatewayRoutes = "ActualInternetGatewayRoutes"
        case affectedSubnets = "AffectedSubnets"
        case currentFirewallSubnetRouteTable = "CurrentFirewallSubnetRouteTable"
        case currentInternetGatewayRouteTable = "CurrentInternetGatewayRouteTable"
        case expectedFirewallEndpoint = "ExpectedFirewallEndpoint"
        case expectedFirewallSubnetId = "ExpectedFirewallSubnetId"
        case expectedFirewallSubnetRoutes = "ExpectedFirewallSubnetRoutes"
        case expectedInternetGatewayRoutes = "ExpectedInternetGatewayRoutes"
        case internetGatewayId = "InternetGatewayId"
        case isRouteTableUsedInDifferentAZ = "IsRouteTableUsedInDifferentAZ"
        case routeTableId = "RouteTableId"
        case violatingRoute = "ViolatingRoute"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualFirewallEndpoint = actualFirewallEndpoint {
            try encodeContainer.encode(actualFirewallEndpoint, forKey: .actualFirewallEndpoint)
        }
        if let actualFirewallSubnetId = actualFirewallSubnetId {
            try encodeContainer.encode(actualFirewallSubnetId, forKey: .actualFirewallSubnetId)
        }
        if let actualFirewallSubnetRoutes = actualFirewallSubnetRoutes {
            var actualFirewallSubnetRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actualFirewallSubnetRoutes)
            for routes0 in actualFirewallSubnetRoutes {
                try actualFirewallSubnetRoutesContainer.encode(routes0)
            }
        }
        if let actualInternetGatewayRoutes = actualInternetGatewayRoutes {
            var actualInternetGatewayRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actualInternetGatewayRoutes)
            for routes0 in actualInternetGatewayRoutes {
                try actualInternetGatewayRoutesContainer.encode(routes0)
            }
        }
        if let affectedSubnets = affectedSubnets {
            var affectedSubnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .affectedSubnets)
            for resourceidlist0 in affectedSubnets {
                try affectedSubnetsContainer.encode(resourceidlist0)
            }
        }
        if let currentFirewallSubnetRouteTable = currentFirewallSubnetRouteTable {
            try encodeContainer.encode(currentFirewallSubnetRouteTable, forKey: .currentFirewallSubnetRouteTable)
        }
        if let currentInternetGatewayRouteTable = currentInternetGatewayRouteTable {
            try encodeContainer.encode(currentInternetGatewayRouteTable, forKey: .currentInternetGatewayRouteTable)
        }
        if let expectedFirewallEndpoint = expectedFirewallEndpoint {
            try encodeContainer.encode(expectedFirewallEndpoint, forKey: .expectedFirewallEndpoint)
        }
        if let expectedFirewallSubnetId = expectedFirewallSubnetId {
            try encodeContainer.encode(expectedFirewallSubnetId, forKey: .expectedFirewallSubnetId)
        }
        if let expectedFirewallSubnetRoutes = expectedFirewallSubnetRoutes {
            var expectedFirewallSubnetRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expectedFirewallSubnetRoutes)
            for expectedroutes0 in expectedFirewallSubnetRoutes {
                try expectedFirewallSubnetRoutesContainer.encode(expectedroutes0)
            }
        }
        if let expectedInternetGatewayRoutes = expectedInternetGatewayRoutes {
            var expectedInternetGatewayRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expectedInternetGatewayRoutes)
            for expectedroutes0 in expectedInternetGatewayRoutes {
                try expectedInternetGatewayRoutesContainer.encode(expectedroutes0)
            }
        }
        if let internetGatewayId = internetGatewayId {
            try encodeContainer.encode(internetGatewayId, forKey: .internetGatewayId)
        }
        if isRouteTableUsedInDifferentAZ != false {
            try encodeContainer.encode(isRouteTableUsedInDifferentAZ, forKey: .isRouteTableUsedInDifferentAZ)
        }
        if let routeTableId = routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let violatingRoute = violatingRoute {
            try encodeContainer.encode(violatingRoute, forKey: .violatingRoute)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let affectedSubnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .affectedSubnets)
        var affectedSubnetsDecoded0:[Swift.String]? = nil
        if let affectedSubnetsContainer = affectedSubnetsContainer {
            affectedSubnetsDecoded0 = [Swift.String]()
            for string0 in affectedSubnetsContainer {
                if let string0 = string0 {
                    affectedSubnetsDecoded0?.append(string0)
                }
            }
        }
        affectedSubnets = affectedSubnetsDecoded0
        let routeTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
        let isRouteTableUsedInDifferentAZDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isRouteTableUsedInDifferentAZ)
        isRouteTableUsedInDifferentAZ = isRouteTableUsedInDifferentAZDecoded
        let violatingRouteDecoded = try containerValues.decodeIfPresent(FmsClientTypes.Route.self, forKey: .violatingRoute)
        violatingRoute = violatingRouteDecoded
        let currentFirewallSubnetRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentFirewallSubnetRouteTable)
        currentFirewallSubnetRouteTable = currentFirewallSubnetRouteTableDecoded
        let expectedFirewallEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedFirewallEndpoint)
        expectedFirewallEndpoint = expectedFirewallEndpointDecoded
        let actualFirewallEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actualFirewallEndpoint)
        actualFirewallEndpoint = actualFirewallEndpointDecoded
        let expectedFirewallSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedFirewallSubnetId)
        expectedFirewallSubnetId = expectedFirewallSubnetIdDecoded
        let actualFirewallSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actualFirewallSubnetId)
        actualFirewallSubnetId = actualFirewallSubnetIdDecoded
        let expectedFirewallSubnetRoutesContainer = try containerValues.decodeIfPresent([FmsClientTypes.ExpectedRoute?].self, forKey: .expectedFirewallSubnetRoutes)
        var expectedFirewallSubnetRoutesDecoded0:[FmsClientTypes.ExpectedRoute]? = nil
        if let expectedFirewallSubnetRoutesContainer = expectedFirewallSubnetRoutesContainer {
            expectedFirewallSubnetRoutesDecoded0 = [FmsClientTypes.ExpectedRoute]()
            for structure0 in expectedFirewallSubnetRoutesContainer {
                if let structure0 = structure0 {
                    expectedFirewallSubnetRoutesDecoded0?.append(structure0)
                }
            }
        }
        expectedFirewallSubnetRoutes = expectedFirewallSubnetRoutesDecoded0
        let actualFirewallSubnetRoutesContainer = try containerValues.decodeIfPresent([FmsClientTypes.Route?].self, forKey: .actualFirewallSubnetRoutes)
        var actualFirewallSubnetRoutesDecoded0:[FmsClientTypes.Route]? = nil
        if let actualFirewallSubnetRoutesContainer = actualFirewallSubnetRoutesContainer {
            actualFirewallSubnetRoutesDecoded0 = [FmsClientTypes.Route]()
            for structure0 in actualFirewallSubnetRoutesContainer {
                if let structure0 = structure0 {
                    actualFirewallSubnetRoutesDecoded0?.append(structure0)
                }
            }
        }
        actualFirewallSubnetRoutes = actualFirewallSubnetRoutesDecoded0
        let internetGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .internetGatewayId)
        internetGatewayId = internetGatewayIdDecoded
        let currentInternetGatewayRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentInternetGatewayRouteTable)
        currentInternetGatewayRouteTable = currentInternetGatewayRouteTableDecoded
        let expectedInternetGatewayRoutesContainer = try containerValues.decodeIfPresent([FmsClientTypes.ExpectedRoute?].self, forKey: .expectedInternetGatewayRoutes)
        var expectedInternetGatewayRoutesDecoded0:[FmsClientTypes.ExpectedRoute]? = nil
        if let expectedInternetGatewayRoutesContainer = expectedInternetGatewayRoutesContainer {
            expectedInternetGatewayRoutesDecoded0 = [FmsClientTypes.ExpectedRoute]()
            for structure0 in expectedInternetGatewayRoutesContainer {
                if let structure0 = structure0 {
                    expectedInternetGatewayRoutesDecoded0?.append(structure0)
                }
            }
        }
        expectedInternetGatewayRoutes = expectedInternetGatewayRoutesDecoded0
        let actualInternetGatewayRoutesContainer = try containerValues.decodeIfPresent([FmsClientTypes.Route?].self, forKey: .actualInternetGatewayRoutes)
        var actualInternetGatewayRoutesDecoded0:[FmsClientTypes.Route]? = nil
        if let actualInternetGatewayRoutesContainer = actualInternetGatewayRoutesContainer {
            actualInternetGatewayRoutesDecoded0 = [FmsClientTypes.Route]()
            for structure0 in actualInternetGatewayRoutesContainer {
                if let structure0 = structure0 {
                    actualInternetGatewayRoutesDecoded0?.append(structure0)
                }
            }
        }
        actualInternetGatewayRoutes = actualInternetGatewayRoutesDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension FmsClientTypes {
    /// Violation detail for the improperly configured subnet route. It's possible there is a missing route table route, or a configuration that causes traffic to cross an Availability Zone boundary.
    public struct NetworkFirewallInvalidRouteConfigurationViolation: Swift.Equatable {
        /// The actual firewall endpoint.
        public var actualFirewallEndpoint: Swift.String?
        /// The actual subnet ID for the firewall.
        public var actualFirewallSubnetId: Swift.String?
        /// The actual firewall subnet routes that are expected.
        public var actualFirewallSubnetRoutes: [FmsClientTypes.Route]?
        /// The actual internet gateway routes.
        public var actualInternetGatewayRoutes: [FmsClientTypes.Route]?
        /// The subnets that are affected.
        public var affectedSubnets: [Swift.String]?
        /// The subnet route table for the current firewall.
        public var currentFirewallSubnetRouteTable: Swift.String?
        /// The route table for the current internet gateway.
        public var currentInternetGatewayRouteTable: Swift.String?
        /// The firewall endpoint that's expected.
        public var expectedFirewallEndpoint: Swift.String?
        /// The expected subnet ID for the firewall.
        public var expectedFirewallSubnetId: Swift.String?
        /// The firewall subnet routes that are expected.
        public var expectedFirewallSubnetRoutes: [FmsClientTypes.ExpectedRoute]?
        /// The expected routes for the internet gateway.
        public var expectedInternetGatewayRoutes: [FmsClientTypes.ExpectedRoute]?
        /// The internet gateway ID.
        public var internetGatewayId: Swift.String?
        /// Information about whether the route table is used in another Availability Zone.
        public var isRouteTableUsedInDifferentAZ: Swift.Bool
        /// The route table ID.
        public var routeTableId: Swift.String?
        /// The route that's in violation.
        public var violatingRoute: FmsClientTypes.Route?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init (
            actualFirewallEndpoint: Swift.String? = nil,
            actualFirewallSubnetId: Swift.String? = nil,
            actualFirewallSubnetRoutes: [FmsClientTypes.Route]? = nil,
            actualInternetGatewayRoutes: [FmsClientTypes.Route]? = nil,
            affectedSubnets: [Swift.String]? = nil,
            currentFirewallSubnetRouteTable: Swift.String? = nil,
            currentInternetGatewayRouteTable: Swift.String? = nil,
            expectedFirewallEndpoint: Swift.String? = nil,
            expectedFirewallSubnetId: Swift.String? = nil,
            expectedFirewallSubnetRoutes: [FmsClientTypes.ExpectedRoute]? = nil,
            expectedInternetGatewayRoutes: [FmsClientTypes.ExpectedRoute]? = nil,
            internetGatewayId: Swift.String? = nil,
            isRouteTableUsedInDifferentAZ: Swift.Bool = false,
            routeTableId: Swift.String? = nil,
            violatingRoute: FmsClientTypes.Route? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.actualFirewallEndpoint = actualFirewallEndpoint
            self.actualFirewallSubnetId = actualFirewallSubnetId
            self.actualFirewallSubnetRoutes = actualFirewallSubnetRoutes
            self.actualInternetGatewayRoutes = actualInternetGatewayRoutes
            self.affectedSubnets = affectedSubnets
            self.currentFirewallSubnetRouteTable = currentFirewallSubnetRouteTable
            self.currentInternetGatewayRouteTable = currentInternetGatewayRouteTable
            self.expectedFirewallEndpoint = expectedFirewallEndpoint
            self.expectedFirewallSubnetId = expectedFirewallSubnetId
            self.expectedFirewallSubnetRoutes = expectedFirewallSubnetRoutes
            self.expectedInternetGatewayRoutes = expectedInternetGatewayRoutes
            self.internetGatewayId = internetGatewayId
            self.isRouteTableUsedInDifferentAZ = isRouteTableUsedInDifferentAZ
            self.routeTableId = routeTableId
            self.violatingRoute = violatingRoute
            self.vpcId = vpcId
        }
    }

}

extension FmsClientTypes.NetworkFirewallMissingExpectedRTViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case currentRouteTable = "CurrentRouteTable"
        case expectedRouteTable = "ExpectedRouteTable"
        case vPC = "VPC"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let currentRouteTable = currentRouteTable {
            try encodeContainer.encode(currentRouteTable, forKey: .currentRouteTable)
        }
        if let expectedRouteTable = expectedRouteTable {
            try encodeContainer.encode(expectedRouteTable, forKey: .expectedRouteTable)
        }
        if let vPC = vPC {
            try encodeContainer.encode(vPC, forKey: .vPC)
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let vPCDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vPC)
        vPC = vPCDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let currentRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentRouteTable)
        currentRouteTable = currentRouteTableDecoded
        let expectedRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedRouteTable)
        expectedRouteTable = expectedRouteTableDecoded
    }
}

extension FmsClientTypes {
    /// Violation detail for Network Firewall for a subnet that's not associated to the expected Firewall Manager managed route table.
    public struct NetworkFirewallMissingExpectedRTViolation: Swift.Equatable {
        /// The Availability Zone of a violating subnet.
        public var availabilityZone: Swift.String?
        /// The resource ID of the current route table that's associated with the subnet, if one is available.
        public var currentRouteTable: Swift.String?
        /// The resource ID of the route table that should be associated with the subnet.
        public var expectedRouteTable: Swift.String?
        /// The resource ID of the VPC associated with a violating subnet.
        public var vPC: Swift.String?
        /// The ID of the Network Firewall or VPC resource that's in violation.
        public var violationTarget: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            currentRouteTable: Swift.String? = nil,
            expectedRouteTable: Swift.String? = nil,
            vPC: Swift.String? = nil,
            violationTarget: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.currentRouteTable = currentRouteTable
            self.expectedRouteTable = expectedRouteTable
            self.vPC = vPC
            self.violationTarget = violationTarget
        }
    }

}

extension FmsClientTypes.NetworkFirewallMissingExpectedRoutesViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedRoutes = "ExpectedRoutes"
        case violationTarget = "ViolationTarget"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedRoutes = expectedRoutes {
            var expectedRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expectedRoutes)
            for expectedroutes0 in expectedRoutes {
                try expectedRoutesContainer.encode(expectedroutes0)
            }
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let expectedRoutesContainer = try containerValues.decodeIfPresent([FmsClientTypes.ExpectedRoute?].self, forKey: .expectedRoutes)
        var expectedRoutesDecoded0:[FmsClientTypes.ExpectedRoute]? = nil
        if let expectedRoutesContainer = expectedRoutesContainer {
            expectedRoutesDecoded0 = [FmsClientTypes.ExpectedRoute]()
            for structure0 in expectedRoutesContainer {
                if let structure0 = structure0 {
                    expectedRoutesDecoded0?.append(structure0)
                }
            }
        }
        expectedRoutes = expectedRoutesDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension FmsClientTypes {
    /// Violation detail for an expected route missing in Network Firewall.
    public struct NetworkFirewallMissingExpectedRoutesViolation: Swift.Equatable {
        /// The expected routes.
        public var expectedRoutes: [FmsClientTypes.ExpectedRoute]?
        /// The target of the violation.
        public var violationTarget: Swift.String?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init (
            expectedRoutes: [FmsClientTypes.ExpectedRoute]? = nil,
            violationTarget: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.expectedRoutes = expectedRoutes
            self.violationTarget = violationTarget
            self.vpcId = vpcId
        }
    }

}

extension FmsClientTypes.NetworkFirewallMissingFirewallViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case targetViolationReason = "TargetViolationReason"
        case vPC = "VPC"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let targetViolationReason = targetViolationReason {
            try encodeContainer.encode(targetViolationReason, forKey: .targetViolationReason)
        }
        if let vPC = vPC {
            try encodeContainer.encode(vPC, forKey: .vPC)
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let vPCDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vPC)
        vPC = vPCDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let targetViolationReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetViolationReason)
        targetViolationReason = targetViolationReasonDecoded
    }
}

extension FmsClientTypes {
    /// Violation detail for Network Firewall for a subnet that doesn't have a Firewall Manager managed firewall in its VPC.
    public struct NetworkFirewallMissingFirewallViolation: Swift.Equatable {
        /// The Availability Zone of a violating subnet.
        public var availabilityZone: Swift.String?
        /// The reason the resource has this violation, if one is available.
        public var targetViolationReason: Swift.String?
        /// The resource ID of the VPC associated with a violating subnet.
        public var vPC: Swift.String?
        /// The ID of the Network Firewall or VPC resource that's in violation.
        public var violationTarget: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            targetViolationReason: Swift.String? = nil,
            vPC: Swift.String? = nil,
            violationTarget: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.targetViolationReason = targetViolationReason
            self.vPC = vPC
            self.violationTarget = violationTarget
        }
    }

}

extension FmsClientTypes.NetworkFirewallMissingSubnetViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case targetViolationReason = "TargetViolationReason"
        case vPC = "VPC"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let targetViolationReason = targetViolationReason {
            try encodeContainer.encode(targetViolationReason, forKey: .targetViolationReason)
        }
        if let vPC = vPC {
            try encodeContainer.encode(vPC, forKey: .vPC)
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let vPCDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vPC)
        vPC = vPCDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let targetViolationReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetViolationReason)
        targetViolationReason = targetViolationReasonDecoded
    }
}

extension FmsClientTypes {
    /// Violation detail for Network Firewall for an Availability Zone that's missing the expected Firewall Manager managed subnet.
    public struct NetworkFirewallMissingSubnetViolation: Swift.Equatable {
        /// The Availability Zone of a violating subnet.
        public var availabilityZone: Swift.String?
        /// The reason the resource has this violation, if one is available.
        public var targetViolationReason: Swift.String?
        /// The resource ID of the VPC associated with a violating subnet.
        public var vPC: Swift.String?
        /// The ID of the Network Firewall or VPC resource that's in violation.
        public var violationTarget: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            targetViolationReason: Swift.String? = nil,
            vPC: Swift.String? = nil,
            violationTarget: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.targetViolationReason = targetViolationReason
            self.vPC = vPC
            self.violationTarget = violationTarget
        }
    }

}

extension FmsClientTypes.NetworkFirewallPolicyDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statefulRuleGroups = "StatefulRuleGroups"
        case statelessCustomActions = "StatelessCustomActions"
        case statelessDefaultActions = "StatelessDefaultActions"
        case statelessFragmentDefaultActions = "StatelessFragmentDefaultActions"
        case statelessRuleGroups = "StatelessRuleGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statefulRuleGroups = statefulRuleGroups {
            var statefulRuleGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statefulRuleGroups)
            for statefulrulegrouplist0 in statefulRuleGroups {
                try statefulRuleGroupsContainer.encode(statefulrulegrouplist0)
            }
        }
        if let statelessCustomActions = statelessCustomActions {
            var statelessCustomActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessCustomActions)
            for networkfirewallactionlist0 in statelessCustomActions {
                try statelessCustomActionsContainer.encode(networkfirewallactionlist0)
            }
        }
        if let statelessDefaultActions = statelessDefaultActions {
            var statelessDefaultActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessDefaultActions)
            for networkfirewallactionlist0 in statelessDefaultActions {
                try statelessDefaultActionsContainer.encode(networkfirewallactionlist0)
            }
        }
        if let statelessFragmentDefaultActions = statelessFragmentDefaultActions {
            var statelessFragmentDefaultActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessFragmentDefaultActions)
            for networkfirewallactionlist0 in statelessFragmentDefaultActions {
                try statelessFragmentDefaultActionsContainer.encode(networkfirewallactionlist0)
            }
        }
        if let statelessRuleGroups = statelessRuleGroups {
            var statelessRuleGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessRuleGroups)
            for statelessrulegrouplist0 in statelessRuleGroups {
                try statelessRuleGroupsContainer.encode(statelessrulegrouplist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statelessRuleGroupsContainer = try containerValues.decodeIfPresent([FmsClientTypes.StatelessRuleGroup?].self, forKey: .statelessRuleGroups)
        var statelessRuleGroupsDecoded0:[FmsClientTypes.StatelessRuleGroup]? = nil
        if let statelessRuleGroupsContainer = statelessRuleGroupsContainer {
            statelessRuleGroupsDecoded0 = [FmsClientTypes.StatelessRuleGroup]()
            for structure0 in statelessRuleGroupsContainer {
                if let structure0 = structure0 {
                    statelessRuleGroupsDecoded0?.append(structure0)
                }
            }
        }
        statelessRuleGroups = statelessRuleGroupsDecoded0
        let statelessDefaultActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .statelessDefaultActions)
        var statelessDefaultActionsDecoded0:[Swift.String]? = nil
        if let statelessDefaultActionsContainer = statelessDefaultActionsContainer {
            statelessDefaultActionsDecoded0 = [Swift.String]()
            for string0 in statelessDefaultActionsContainer {
                if let string0 = string0 {
                    statelessDefaultActionsDecoded0?.append(string0)
                }
            }
        }
        statelessDefaultActions = statelessDefaultActionsDecoded0
        let statelessFragmentDefaultActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .statelessFragmentDefaultActions)
        var statelessFragmentDefaultActionsDecoded0:[Swift.String]? = nil
        if let statelessFragmentDefaultActionsContainer = statelessFragmentDefaultActionsContainer {
            statelessFragmentDefaultActionsDecoded0 = [Swift.String]()
            for string0 in statelessFragmentDefaultActionsContainer {
                if let string0 = string0 {
                    statelessFragmentDefaultActionsDecoded0?.append(string0)
                }
            }
        }
        statelessFragmentDefaultActions = statelessFragmentDefaultActionsDecoded0
        let statelessCustomActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .statelessCustomActions)
        var statelessCustomActionsDecoded0:[Swift.String]? = nil
        if let statelessCustomActionsContainer = statelessCustomActionsContainer {
            statelessCustomActionsDecoded0 = [Swift.String]()
            for string0 in statelessCustomActionsContainer {
                if let string0 = string0 {
                    statelessCustomActionsDecoded0?.append(string0)
                }
            }
        }
        statelessCustomActions = statelessCustomActionsDecoded0
        let statefulRuleGroupsContainer = try containerValues.decodeIfPresent([FmsClientTypes.StatefulRuleGroup?].self, forKey: .statefulRuleGroups)
        var statefulRuleGroupsDecoded0:[FmsClientTypes.StatefulRuleGroup]? = nil
        if let statefulRuleGroupsContainer = statefulRuleGroupsContainer {
            statefulRuleGroupsDecoded0 = [FmsClientTypes.StatefulRuleGroup]()
            for structure0 in statefulRuleGroupsContainer {
                if let structure0 = structure0 {
                    statefulRuleGroupsDecoded0?.append(structure0)
                }
            }
        }
        statefulRuleGroups = statefulRuleGroupsDecoded0
    }
}

extension FmsClientTypes {
    /// The definition of the Network Firewall firewall policy.
    public struct NetworkFirewallPolicyDescription: Swift.Equatable {
        /// The stateful rule groups that are used in the Network Firewall firewall policy.
        public var statefulRuleGroups: [FmsClientTypes.StatefulRuleGroup]?
        /// Names of custom actions that are available for use in the stateless default actions settings.
        public var statelessCustomActions: [Swift.String]?
        /// The actions to take on packets that don't match any of the stateless rule groups.
        public var statelessDefaultActions: [Swift.String]?
        /// The actions to take on packet fragments that don't match any of the stateless rule groups.
        public var statelessFragmentDefaultActions: [Swift.String]?
        /// The stateless rule groups that are used in the Network Firewall firewall policy.
        public var statelessRuleGroups: [FmsClientTypes.StatelessRuleGroup]?

        public init (
            statefulRuleGroups: [FmsClientTypes.StatefulRuleGroup]? = nil,
            statelessCustomActions: [Swift.String]? = nil,
            statelessDefaultActions: [Swift.String]? = nil,
            statelessFragmentDefaultActions: [Swift.String]? = nil,
            statelessRuleGroups: [FmsClientTypes.StatelessRuleGroup]? = nil
        )
        {
            self.statefulRuleGroups = statefulRuleGroups
            self.statelessCustomActions = statelessCustomActions
            self.statelessDefaultActions = statelessDefaultActions
            self.statelessFragmentDefaultActions = statelessFragmentDefaultActions
            self.statelessRuleGroups = statelessRuleGroups
        }
    }

}

extension FmsClientTypes.NetworkFirewallPolicyModifiedViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentPolicyDescription = "CurrentPolicyDescription"
        case expectedPolicyDescription = "ExpectedPolicyDescription"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentPolicyDescription = currentPolicyDescription {
            try encodeContainer.encode(currentPolicyDescription, forKey: .currentPolicyDescription)
        }
        if let expectedPolicyDescription = expectedPolicyDescription {
            try encodeContainer.encode(expectedPolicyDescription, forKey: .expectedPolicyDescription)
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let currentPolicyDescriptionDecoded = try containerValues.decodeIfPresent(FmsClientTypes.NetworkFirewallPolicyDescription.self, forKey: .currentPolicyDescription)
        currentPolicyDescription = currentPolicyDescriptionDecoded
        let expectedPolicyDescriptionDecoded = try containerValues.decodeIfPresent(FmsClientTypes.NetworkFirewallPolicyDescription.self, forKey: .expectedPolicyDescription)
        expectedPolicyDescription = expectedPolicyDescriptionDecoded
    }
}

extension FmsClientTypes {
    /// Violation detail for Network Firewall for a firewall policy that has a different [NetworkFirewallPolicyDescription] than is required by the Firewall Manager policy.
    public struct NetworkFirewallPolicyModifiedViolation: Swift.Equatable {
        /// The policy that's currently in use in the individual account.
        public var currentPolicyDescription: FmsClientTypes.NetworkFirewallPolicyDescription?
        /// The policy that should be in use in the individual account in order to be compliant.
        public var expectedPolicyDescription: FmsClientTypes.NetworkFirewallPolicyDescription?
        /// The ID of the Network Firewall or VPC resource that's in violation.
        public var violationTarget: Swift.String?

        public init (
            currentPolicyDescription: FmsClientTypes.NetworkFirewallPolicyDescription? = nil,
            expectedPolicyDescription: FmsClientTypes.NetworkFirewallPolicyDescription? = nil,
            violationTarget: Swift.String? = nil
        )
        {
            self.currentPolicyDescription = currentPolicyDescription
            self.expectedPolicyDescription = expectedPolicyDescription
            self.violationTarget = violationTarget
        }
    }

}

extension FmsClientTypes.NetworkFirewallUnexpectedFirewallRoutesViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallEndpoint = "FirewallEndpoint"
        case firewallSubnetId = "FirewallSubnetId"
        case routeTableId = "RouteTableId"
        case violatingRoutes = "ViolatingRoutes"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallEndpoint = firewallEndpoint {
            try encodeContainer.encode(firewallEndpoint, forKey: .firewallEndpoint)
        }
        if let firewallSubnetId = firewallSubnetId {
            try encodeContainer.encode(firewallSubnetId, forKey: .firewallSubnetId)
        }
        if let routeTableId = routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let violatingRoutes = violatingRoutes {
            var violatingRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violatingRoutes)
            for routes0 in violatingRoutes {
                try violatingRoutesContainer.encode(routes0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallSubnetId)
        firewallSubnetId = firewallSubnetIdDecoded
        let violatingRoutesContainer = try containerValues.decodeIfPresent([FmsClientTypes.Route?].self, forKey: .violatingRoutes)
        var violatingRoutesDecoded0:[FmsClientTypes.Route]? = nil
        if let violatingRoutesContainer = violatingRoutesContainer {
            violatingRoutesDecoded0 = [FmsClientTypes.Route]()
            for structure0 in violatingRoutesContainer {
                if let structure0 = structure0 {
                    violatingRoutesDecoded0?.append(structure0)
                }
            }
        }
        violatingRoutes = violatingRoutesDecoded0
        let routeTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
        let firewallEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallEndpoint)
        firewallEndpoint = firewallEndpointDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension FmsClientTypes {
    /// Violation detail for an unexpected route that's present in a route table.
    public struct NetworkFirewallUnexpectedFirewallRoutesViolation: Swift.Equatable {
        /// The endpoint of the firewall.
        public var firewallEndpoint: Swift.String?
        /// The subnet ID for the firewall.
        public var firewallSubnetId: Swift.String?
        /// The ID of the route table.
        public var routeTableId: Swift.String?
        /// The routes that are in violation.
        public var violatingRoutes: [FmsClientTypes.Route]?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init (
            firewallEndpoint: Swift.String? = nil,
            firewallSubnetId: Swift.String? = nil,
            routeTableId: Swift.String? = nil,
            violatingRoutes: [FmsClientTypes.Route]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.firewallEndpoint = firewallEndpoint
            self.firewallSubnetId = firewallSubnetId
            self.routeTableId = routeTableId
            self.violatingRoutes = violatingRoutes
            self.vpcId = vpcId
        }
    }

}

extension FmsClientTypes.NetworkFirewallUnexpectedGatewayRoutesViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayId = "GatewayId"
        case routeTableId = "RouteTableId"
        case violatingRoutes = "ViolatingRoutes"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayId = gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let routeTableId = routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let violatingRoutes = violatingRoutes {
            var violatingRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violatingRoutes)
            for routes0 in violatingRoutes {
                try violatingRoutesContainer.encode(routes0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let violatingRoutesContainer = try containerValues.decodeIfPresent([FmsClientTypes.Route?].self, forKey: .violatingRoutes)
        var violatingRoutesDecoded0:[FmsClientTypes.Route]? = nil
        if let violatingRoutesContainer = violatingRoutesContainer {
            violatingRoutesDecoded0 = [FmsClientTypes.Route]()
            for structure0 in violatingRoutesContainer {
                if let structure0 = structure0 {
                    violatingRoutesDecoded0?.append(structure0)
                }
            }
        }
        violatingRoutes = violatingRoutesDecoded0
        let routeTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension FmsClientTypes {
    /// Violation detail for an unexpected gateway route thats present in a route table.
    public struct NetworkFirewallUnexpectedGatewayRoutesViolation: Swift.Equatable {
        /// Information about the gateway ID.
        public var gatewayId: Swift.String?
        /// Information about the route table.
        public var routeTableId: Swift.String?
        /// The routes that are in violation.
        public var violatingRoutes: [FmsClientTypes.Route]?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init (
            gatewayId: Swift.String? = nil,
            routeTableId: Swift.String? = nil,
            violatingRoutes: [FmsClientTypes.Route]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
            self.violatingRoutes = violatingRoutes
            self.vpcId = vpcId
        }
    }

}

extension FmsClientTypes.PartialMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reference = "Reference"
        case targetViolationReasons = "TargetViolationReasons"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reference = reference {
            try encodeContainer.encode(reference, forKey: .reference)
        }
        if let targetViolationReasons = targetViolationReasons {
            var targetViolationReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetViolationReasons)
            for targetviolationreasons0 in targetViolationReasons {
                try targetViolationReasonsContainer.encode(targetviolationreasons0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reference)
        reference = referenceDecoded
        let targetViolationReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetViolationReasons)
        var targetViolationReasonsDecoded0:[Swift.String]? = nil
        if let targetViolationReasonsContainer = targetViolationReasonsContainer {
            targetViolationReasonsDecoded0 = [Swift.String]()
            for string0 in targetViolationReasonsContainer {
                if let string0 = string0 {
                    targetViolationReasonsDecoded0?.append(string0)
                }
            }
        }
        targetViolationReasons = targetViolationReasonsDecoded0
    }
}

extension FmsClientTypes {
    /// The reference rule that partially matches the ViolationTarget rule and violation reason.
    public struct PartialMatch: Swift.Equatable {
        /// The reference rule from the primary security group of the Firewall Manager policy.
        public var reference: Swift.String?
        /// The violation reason.
        public var targetViolationReasons: [Swift.String]?

        public init (
            reference: Swift.String? = nil,
            targetViolationReasons: [Swift.String]? = nil
        )
        {
            self.reference = reference
            self.targetViolationReasons = targetViolationReasons
        }
    }

}

extension FmsClientTypes.Policy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteUnusedFMManagedResources = "DeleteUnusedFMManagedResources"
        case excludeMap = "ExcludeMap"
        case excludeResourceTags = "ExcludeResourceTags"
        case includeMap = "IncludeMap"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case policyUpdateToken = "PolicyUpdateToken"
        case remediationEnabled = "RemediationEnabled"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case resourceTypeList = "ResourceTypeList"
        case securityServicePolicyData = "SecurityServicePolicyData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteUnusedFMManagedResources != false {
            try encodeContainer.encode(deleteUnusedFMManagedResources, forKey: .deleteUnusedFMManagedResources)
        }
        if let excludeMap = excludeMap {
            var excludeMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .excludeMap)
            for (dictKey0, customerpolicyscopemap0) in excludeMap {
                try excludeMapContainer.encode(customerpolicyscopemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if excludeResourceTags != false {
            try encodeContainer.encode(excludeResourceTags, forKey: .excludeResourceTags)
        }
        if let includeMap = includeMap {
            var includeMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .includeMap)
            for (dictKey0, customerpolicyscopemap0) in includeMap {
                try includeMapContainer.encode(customerpolicyscopemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let policyUpdateToken = policyUpdateToken {
            try encodeContainer.encode(policyUpdateToken, forKey: .policyUpdateToken)
        }
        if remediationEnabled != false {
            try encodeContainer.encode(remediationEnabled, forKey: .remediationEnabled)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetags0 in resourceTags {
                try resourceTagsContainer.encode(resourcetags0)
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let resourceTypeList = resourceTypeList {
            var resourceTypeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypeList)
            for resourcetypelist0 in resourceTypeList {
                try resourceTypeListContainer.encode(resourcetypelist0)
            }
        }
        if let securityServicePolicyData = securityServicePolicyData {
            try encodeContainer.encode(securityServicePolicyData, forKey: .securityServicePolicyData)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyUpdateTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyUpdateToken)
        policyUpdateToken = policyUpdateTokenDecoded
        let securityServicePolicyDataDecoded = try containerValues.decodeIfPresent(FmsClientTypes.SecurityServicePolicyData.self, forKey: .securityServicePolicyData)
        securityServicePolicyData = securityServicePolicyDataDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTypeListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypeList)
        var resourceTypeListDecoded0:[Swift.String]? = nil
        if let resourceTypeListContainer = resourceTypeListContainer {
            resourceTypeListDecoded0 = [Swift.String]()
            for string0 in resourceTypeListContainer {
                if let string0 = string0 {
                    resourceTypeListDecoded0?.append(string0)
                }
            }
        }
        resourceTypeList = resourceTypeListDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([FmsClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[FmsClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [FmsClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let excludeResourceTagsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .excludeResourceTags)
        excludeResourceTags = excludeResourceTagsDecoded
        let remediationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .remediationEnabled)
        remediationEnabled = remediationEnabledDecoded
        let deleteUnusedFMManagedResourcesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .deleteUnusedFMManagedResources)
        deleteUnusedFMManagedResources = deleteUnusedFMManagedResourcesDecoded
        let includeMapContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .includeMap)
        var includeMapDecoded0: [Swift.String:[Swift.String]]? = nil
        if let includeMapContainer = includeMapContainer {
            includeMapDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, customerpolicyscopeidlist0) in includeMapContainer {
                var customerpolicyscopeidlist0Decoded0: [Swift.String]? = nil
                if let customerpolicyscopeidlist0 = customerpolicyscopeidlist0 {
                    customerpolicyscopeidlist0Decoded0 = [Swift.String]()
                    for string1 in customerpolicyscopeidlist0 {
                        if let string1 = string1 {
                            customerpolicyscopeidlist0Decoded0?.append(string1)
                        }
                    }
                }
                includeMapDecoded0?[key0] = customerpolicyscopeidlist0Decoded0
            }
        }
        includeMap = includeMapDecoded0
        let excludeMapContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .excludeMap)
        var excludeMapDecoded0: [Swift.String:[Swift.String]]? = nil
        if let excludeMapContainer = excludeMapContainer {
            excludeMapDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, customerpolicyscopeidlist0) in excludeMapContainer {
                var customerpolicyscopeidlist0Decoded0: [Swift.String]? = nil
                if let customerpolicyscopeidlist0 = customerpolicyscopeidlist0 {
                    customerpolicyscopeidlist0Decoded0 = [Swift.String]()
                    for string1 in customerpolicyscopeidlist0 {
                        if let string1 = string1 {
                            customerpolicyscopeidlist0Decoded0?.append(string1)
                        }
                    }
                }
                excludeMapDecoded0?[key0] = customerpolicyscopeidlist0Decoded0
            }
        }
        excludeMap = excludeMapDecoded0
    }
}

extension FmsClientTypes {
    /// An Firewall Manager policy.
    public struct Policy: Swift.Equatable {
        /// Indicates whether Firewall Manager should delete Firewall Manager managed resources, such as web ACLs and security groups, when they are not in use by the Firewall Manager policy. By default, Firewall Manager doesn't delete unused Firewall Manager managed resources. This option is not available for Shield Advanced or WAF Classic policies.
        public var deleteUnusedFMManagedResources: Swift.Bool
        /// Specifies the Amazon Web Services account IDs and Organizations organizational units (OUs) to exclude from the policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time. You can specify inclusions or exclusions, but not both. If you specify an IncludeMap, Firewall Manager applies the policy to all accounts specified by the IncludeMap, and does not evaluate any ExcludeMap specifications. If you do not specify an IncludeMap, then Firewall Manager applies the policy to all accounts except for those specified by the ExcludeMap. You can specify account IDs, OUs, or a combination:
        ///
        /// * Specify account IDs by setting the key to ACCOUNT. For example, the following is a valid map: {ACCOUNT : [accountID1, accountID2]}.
        ///
        /// * Specify OUs by setting the key to ORG_UNIT. For example, the following is a valid map: {ORG_UNIT : [ouid111, ouid112]}.
        ///
        /// * Specify accounts and OUs together in a single map, separated with a comma. For example, the following is a valid map: {ACCOUNT : [accountID1, accountID2], ORG_UNIT : [ouid111, ouid112]}.
        public var excludeMap: [Swift.String:[Swift.String]]?
        /// If set to True, resources with the tags that are specified in the ResourceTag array are not in scope of the policy. If set to False, and the ResourceTag array is not null, only resources with the specified tags are in scope of the policy.
        /// This member is required.
        public var excludeResourceTags: Swift.Bool
        /// Specifies the Amazon Web Services account IDs and Organizations organizational units (OUs) to include in the policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time. You can specify inclusions or exclusions, but not both. If you specify an IncludeMap, Firewall Manager applies the policy to all accounts specified by the IncludeMap, and does not evaluate any ExcludeMap specifications. If you do not specify an IncludeMap, then Firewall Manager applies the policy to all accounts except for those specified by the ExcludeMap. You can specify account IDs, OUs, or a combination:
        ///
        /// * Specify account IDs by setting the key to ACCOUNT. For example, the following is a valid map: {ACCOUNT : [accountID1, accountID2]}.
        ///
        /// * Specify OUs by setting the key to ORG_UNIT. For example, the following is a valid map: {ORG_UNIT : [ouid111, ouid112]}.
        ///
        /// * Specify accounts and OUs together in a single map, separated with a comma. For example, the following is a valid map: {ACCOUNT : [accountID1, accountID2], ORG_UNIT : [ouid111, ouid112]}.
        public var includeMap: [Swift.String:[Swift.String]]?
        /// The ID of the Firewall Manager policy.
        public var policyId: Swift.String?
        /// The name of the Firewall Manager policy.
        /// This member is required.
        public var policyName: Swift.String?
        /// A unique identifier for each update to the policy. When issuing a PutPolicy request, the PolicyUpdateToken in the request must match the PolicyUpdateToken of the current policy version. To get the PolicyUpdateToken of the current policy version, use a GetPolicy request.
        public var policyUpdateToken: Swift.String?
        /// Indicates if the policy should be automatically applied to new resources.
        /// This member is required.
        public var remediationEnabled: Swift.Bool
        /// An array of ResourceTag objects.
        public var resourceTags: [FmsClientTypes.ResourceTag]?
        /// The type of resource protected by or in scope of the policy. This is in the format shown in the [Amazon Web Services Resource Types Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html). To apply this policy to multiple resource types, specify a resource type of ResourceTypeList and then specify the resource types in a ResourceTypeList. For WAF and Shield Advanced, example resource types include AWS::ElasticLoadBalancingV2::LoadBalancer and AWS::CloudFront::Distribution. For a security group common policy, valid values are AWS::EC2::NetworkInterface and AWS::EC2::Instance. For a security group content audit policy, valid values are AWS::EC2::SecurityGroup, AWS::EC2::NetworkInterface, and AWS::EC2::Instance. For a security group usage audit policy, the value is AWS::EC2::SecurityGroup. For an Network Firewall policy or DNS Firewall policy, the value is AWS::EC2::VPC.
        /// This member is required.
        public var resourceType: Swift.String?
        /// An array of ResourceType objects. Use this only to specify multiple resource types. To specify a single resource type, use ResourceType.
        public var resourceTypeList: [Swift.String]?
        /// Details about the security service that is being used to protect the resources.
        /// This member is required.
        public var securityServicePolicyData: FmsClientTypes.SecurityServicePolicyData?

        public init (
            deleteUnusedFMManagedResources: Swift.Bool = false,
            excludeMap: [Swift.String:[Swift.String]]? = nil,
            excludeResourceTags: Swift.Bool = false,
            includeMap: [Swift.String:[Swift.String]]? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyUpdateToken: Swift.String? = nil,
            remediationEnabled: Swift.Bool = false,
            resourceTags: [FmsClientTypes.ResourceTag]? = nil,
            resourceType: Swift.String? = nil,
            resourceTypeList: [Swift.String]? = nil,
            securityServicePolicyData: FmsClientTypes.SecurityServicePolicyData? = nil
        )
        {
            self.deleteUnusedFMManagedResources = deleteUnusedFMManagedResources
            self.excludeMap = excludeMap
            self.excludeResourceTags = excludeResourceTags
            self.includeMap = includeMap
            self.policyId = policyId
            self.policyName = policyName
            self.policyUpdateToken = policyUpdateToken
            self.remediationEnabled = remediationEnabled
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.resourceTypeList = resourceTypeList
            self.securityServicePolicyData = securityServicePolicyData
        }
    }

}

extension FmsClientTypes.PolicyComplianceDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationLimitExceeded = "EvaluationLimitExceeded"
        case expiredAt = "ExpiredAt"
        case issueInfoMap = "IssueInfoMap"
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
        case policyOwner = "PolicyOwner"
        case violators = "Violators"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if evaluationLimitExceeded != false {
            try encodeContainer.encode(evaluationLimitExceeded, forKey: .evaluationLimitExceeded)
        }
        if let expiredAt = expiredAt {
            try encodeContainer.encode(expiredAt.timeIntervalSince1970, forKey: .expiredAt)
        }
        if let issueInfoMap = issueInfoMap {
            var issueInfoMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .issueInfoMap)
            for (dictKey0, issueinfomap0) in issueInfoMap {
                try issueInfoMapContainer.encode(issueinfomap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let memberAccount = memberAccount {
            try encodeContainer.encode(memberAccount, forKey: .memberAccount)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyOwner = policyOwner {
            try encodeContainer.encode(policyOwner, forKey: .policyOwner)
        }
        if let violators = violators {
            var violatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violators)
            for complianceviolators0 in violators {
                try violatorsContainer.encode(complianceviolators0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyOwner)
        policyOwner = policyOwnerDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let memberAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccount)
        memberAccount = memberAccountDecoded
        let violatorsContainer = try containerValues.decodeIfPresent([FmsClientTypes.ComplianceViolator?].self, forKey: .violators)
        var violatorsDecoded0:[FmsClientTypes.ComplianceViolator]? = nil
        if let violatorsContainer = violatorsContainer {
            violatorsDecoded0 = [FmsClientTypes.ComplianceViolator]()
            for structure0 in violatorsContainer {
                if let structure0 = structure0 {
                    violatorsDecoded0?.append(structure0)
                }
            }
        }
        violators = violatorsDecoded0
        let evaluationLimitExceededDecoded = try containerValues.decode(Swift.Bool.self, forKey: .evaluationLimitExceeded)
        evaluationLimitExceeded = evaluationLimitExceededDecoded
        let expiredAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expiredAt)
        expiredAt = expiredAtDecoded
        let issueInfoMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .issueInfoMap)
        var issueInfoMapDecoded0: [Swift.String:Swift.String]? = nil
        if let issueInfoMapContainer = issueInfoMapContainer {
            issueInfoMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, detailedinfo0) in issueInfoMapContainer {
                if let detailedinfo0 = detailedinfo0 {
                    issueInfoMapDecoded0?[key0] = detailedinfo0
                }
            }
        }
        issueInfoMap = issueInfoMapDecoded0
    }
}

extension FmsClientTypes {
    /// Describes the noncompliant resources in a member account for a specific Firewall Manager policy. A maximum of 100 entries are displayed. If more than 100 resources are noncompliant, EvaluationLimitExceeded is set to True.
    public struct PolicyComplianceDetail: Swift.Equatable {
        /// Indicates if over 100 resources are noncompliant with the Firewall Manager policy.
        public var evaluationLimitExceeded: Swift.Bool
        /// A timestamp that indicates when the returned information should be considered out of date.
        public var expiredAt: ClientRuntime.Date?
        /// Details about problems with dependent services, such as WAF or Config, and the error message received that indicates the problem with the service.
        public var issueInfoMap: [Swift.String:Swift.String]?
        /// The Amazon Web Services account ID.
        public var memberAccount: Swift.String?
        /// The ID of the Firewall Manager policy.
        public var policyId: Swift.String?
        /// The Amazon Web Services account that created the Firewall Manager policy.
        public var policyOwner: Swift.String?
        /// An array of resources that aren't protected by the WAF or Shield Advanced policy or that aren't in compliance with the security group policy.
        public var violators: [FmsClientTypes.ComplianceViolator]?

        public init (
            evaluationLimitExceeded: Swift.Bool = false,
            expiredAt: ClientRuntime.Date? = nil,
            issueInfoMap: [Swift.String:Swift.String]? = nil,
            memberAccount: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyOwner: Swift.String? = nil,
            violators: [FmsClientTypes.ComplianceViolator]? = nil
        )
        {
            self.evaluationLimitExceeded = evaluationLimitExceeded
            self.expiredAt = expiredAt
            self.issueInfoMap = issueInfoMap
            self.memberAccount = memberAccount
            self.policyId = policyId
            self.policyOwner = policyOwner
            self.violators = violators
        }
    }

}

extension FmsClientTypes.PolicyComplianceStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationResults = "EvaluationResults"
        case issueInfoMap = "IssueInfoMap"
        case lastUpdated = "LastUpdated"
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case policyOwner = "PolicyOwner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationResults = evaluationResults {
            var evaluationResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evaluationResults)
            for evaluationresults0 in evaluationResults {
                try evaluationResultsContainer.encode(evaluationresults0)
            }
        }
        if let issueInfoMap = issueInfoMap {
            var issueInfoMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .issueInfoMap)
            for (dictKey0, issueinfomap0) in issueInfoMap {
                try issueInfoMapContainer.encode(issueinfomap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if let memberAccount = memberAccount {
            try encodeContainer.encode(memberAccount, forKey: .memberAccount)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let policyOwner = policyOwner {
            try encodeContainer.encode(policyOwner, forKey: .policyOwner)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyOwner)
        policyOwner = policyOwnerDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let memberAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccount)
        memberAccount = memberAccountDecoded
        let evaluationResultsContainer = try containerValues.decodeIfPresent([FmsClientTypes.EvaluationResult?].self, forKey: .evaluationResults)
        var evaluationResultsDecoded0:[FmsClientTypes.EvaluationResult]? = nil
        if let evaluationResultsContainer = evaluationResultsContainer {
            evaluationResultsDecoded0 = [FmsClientTypes.EvaluationResult]()
            for structure0 in evaluationResultsContainer {
                if let structure0 = structure0 {
                    evaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        evaluationResults = evaluationResultsDecoded0
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let issueInfoMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .issueInfoMap)
        var issueInfoMapDecoded0: [Swift.String:Swift.String]? = nil
        if let issueInfoMapContainer = issueInfoMapContainer {
            issueInfoMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, detailedinfo0) in issueInfoMapContainer {
                if let detailedinfo0 = detailedinfo0 {
                    issueInfoMapDecoded0?[key0] = detailedinfo0
                }
            }
        }
        issueInfoMap = issueInfoMapDecoded0
    }
}

extension FmsClientTypes {
    /// Indicates whether the account is compliant with the specified policy. An account is considered noncompliant if it includes resources that are not protected by the policy, for WAF and Shield Advanced policies, or that are noncompliant with the policy, for security group policies.
    public struct PolicyComplianceStatus: Swift.Equatable {
        /// An array of EvaluationResult objects.
        public var evaluationResults: [FmsClientTypes.EvaluationResult]?
        /// Details about problems with dependent services, such as WAF or Config, and the error message received that indicates the problem with the service.
        public var issueInfoMap: [Swift.String:Swift.String]?
        /// Timestamp of the last update to the EvaluationResult objects.
        public var lastUpdated: ClientRuntime.Date?
        /// The member account ID.
        public var memberAccount: Swift.String?
        /// The ID of the Firewall Manager policy.
        public var policyId: Swift.String?
        /// The name of the Firewall Manager policy.
        public var policyName: Swift.String?
        /// The Amazon Web Services account that created the Firewall Manager policy.
        public var policyOwner: Swift.String?

        public init (
            evaluationResults: [FmsClientTypes.EvaluationResult]? = nil,
            issueInfoMap: [Swift.String:Swift.String]? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            memberAccount: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyOwner: Swift.String? = nil
        )
        {
            self.evaluationResults = evaluationResults
            self.issueInfoMap = issueInfoMap
            self.lastUpdated = lastUpdated
            self.memberAccount = memberAccount
            self.policyId = policyId
            self.policyName = policyName
            self.policyOwner = policyOwner
        }
    }

}

extension FmsClientTypes {
    public enum PolicyComplianceStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliant
        case noncompliant
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyComplianceStatusType] {
            return [
                .compliant,
                .noncompliant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliant: return "COMPLIANT"
            case .noncompliant: return "NON_COMPLIANT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyComplianceStatusType(rawValue: rawValue) ?? PolicyComplianceStatusType.sdkUnknown(rawValue)
        }
    }
}

extension FmsClientTypes.PolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteUnusedFMManagedResources = "DeleteUnusedFMManagedResources"
        case policyArn = "PolicyArn"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case remediationEnabled = "RemediationEnabled"
        case resourceType = "ResourceType"
        case securityServiceType = "SecurityServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteUnusedFMManagedResources != false {
            try encodeContainer.encode(deleteUnusedFMManagedResources, forKey: .deleteUnusedFMManagedResources)
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if remediationEnabled != false {
            try encodeContainer.encode(remediationEnabled, forKey: .remediationEnabled)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let securityServiceType = securityServiceType {
            try encodeContainer.encode(securityServiceType.rawValue, forKey: .securityServiceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let securityServiceTypeDecoded = try containerValues.decodeIfPresent(FmsClientTypes.SecurityServiceType.self, forKey: .securityServiceType)
        securityServiceType = securityServiceTypeDecoded
        let remediationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .remediationEnabled)
        remediationEnabled = remediationEnabledDecoded
        let deleteUnusedFMManagedResourcesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .deleteUnusedFMManagedResources)
        deleteUnusedFMManagedResources = deleteUnusedFMManagedResourcesDecoded
    }
}

extension FmsClientTypes {
    /// Details of the Firewall Manager policy.
    public struct PolicySummary: Swift.Equatable {
        /// Indicates whether Firewall Manager should delete Firewall Manager managed resources, such as web ACLs and security groups, when they are not in use by the Firewall Manager policy. By default, Firewall Manager doesn't delete unused Firewall Manager managed resources. This option is not available for Shield Advanced or WAF Classic policies.
        public var deleteUnusedFMManagedResources: Swift.Bool
        /// The Amazon Resource Name (ARN) of the specified policy.
        public var policyArn: Swift.String?
        /// The ID of the specified policy.
        public var policyId: Swift.String?
        /// The name of the specified policy.
        public var policyName: Swift.String?
        /// Indicates if the policy should be automatically applied to new resources.
        public var remediationEnabled: Swift.Bool
        /// The type of resource protected by or in scope of the policy. This is in the format shown in the [Amazon Web Services Resource Types Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html). For WAF and Shield Advanced, examples include AWS::ElasticLoadBalancingV2::LoadBalancer and AWS::CloudFront::Distribution. For a security group common policy, valid values are AWS::EC2::NetworkInterface and AWS::EC2::Instance. For a security group content audit policy, valid values are AWS::EC2::SecurityGroup, AWS::EC2::NetworkInterface, and AWS::EC2::Instance. For a security group usage audit policy, the value is AWS::EC2::SecurityGroup. For an Network Firewall policy or DNS Firewall policy, the value is AWS::EC2::VPC.
        public var resourceType: Swift.String?
        /// The service that the policy is using to protect the resources. This specifies the type of policy that is created, either an WAF policy, a Shield Advanced policy, or a security group policy.
        public var securityServiceType: FmsClientTypes.SecurityServiceType?

        public init (
            deleteUnusedFMManagedResources: Swift.Bool = false,
            policyArn: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            remediationEnabled: Swift.Bool = false,
            resourceType: Swift.String? = nil,
            securityServiceType: FmsClientTypes.SecurityServiceType? = nil
        )
        {
            self.deleteUnusedFMManagedResources = deleteUnusedFMManagedResources
            self.policyArn = policyArn
            self.policyId = policyId
            self.policyName = policyName
            self.remediationEnabled = remediationEnabled
            self.resourceType = resourceType
            self.securityServiceType = securityServiceType
        }
    }

}

extension FmsClientTypes.PossibleRemediationAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case isDefaultAction = "IsDefaultAction"
        case orderedRemediationActions = "OrderedRemediationActions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isDefaultAction != false {
            try encodeContainer.encode(isDefaultAction, forKey: .isDefaultAction)
        }
        if let orderedRemediationActions = orderedRemediationActions {
            var orderedRemediationActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderedRemediationActions)
            for orderedremediationactions0 in orderedRemediationActions {
                try orderedRemediationActionsContainer.encode(orderedremediationactions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let orderedRemediationActionsContainer = try containerValues.decodeIfPresent([FmsClientTypes.RemediationActionWithOrder?].self, forKey: .orderedRemediationActions)
        var orderedRemediationActionsDecoded0:[FmsClientTypes.RemediationActionWithOrder]? = nil
        if let orderedRemediationActionsContainer = orderedRemediationActionsContainer {
            orderedRemediationActionsDecoded0 = [FmsClientTypes.RemediationActionWithOrder]()
            for structure0 in orderedRemediationActionsContainer {
                if let structure0 = structure0 {
                    orderedRemediationActionsDecoded0?.append(structure0)
                }
            }
        }
        orderedRemediationActions = orderedRemediationActionsDecoded0
        let isDefaultActionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isDefaultAction)
        isDefaultAction = isDefaultActionDecoded
    }
}

extension FmsClientTypes {
    /// A list of remediation actions.
    public struct PossibleRemediationAction: Swift.Equatable {
        /// A description of the list of remediation actions.
        public var description: Swift.String?
        /// Information about whether an action is taken by default.
        public var isDefaultAction: Swift.Bool
        /// The ordered list of remediation actions.
        /// This member is required.
        public var orderedRemediationActions: [FmsClientTypes.RemediationActionWithOrder]?

        public init (
            description: Swift.String? = nil,
            isDefaultAction: Swift.Bool = false,
            orderedRemediationActions: [FmsClientTypes.RemediationActionWithOrder]? = nil
        )
        {
            self.description = description
            self.isDefaultAction = isDefaultAction
            self.orderedRemediationActions = orderedRemediationActions
        }
    }

}

extension FmsClientTypes.PossibleRemediationActions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for possibleremediationactionlist0 in actions {
                try actionsContainer.encode(possibleremediationactionlist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([FmsClientTypes.PossibleRemediationAction?].self, forKey: .actions)
        var actionsDecoded0:[FmsClientTypes.PossibleRemediationAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [FmsClientTypes.PossibleRemediationAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension FmsClientTypes {
    /// A list of possible remediation action lists. Each individual possible remediation action is a list of individual remediation actions.
    public struct PossibleRemediationActions: Swift.Equatable {
        /// Information about the actions.
        public var actions: [FmsClientTypes.PossibleRemediationAction]?
        /// A description of the possible remediation actions list.
        public var description: Swift.String?

        public init (
            actions: [FmsClientTypes.PossibleRemediationAction]? = nil,
            description: Swift.String? = nil
        )
        {
            self.actions = actions
            self.description = description
        }
    }

}

extension FmsClientTypes.ProtocolsListData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case lastUpdateTime = "LastUpdateTime"
        case listId = "ListId"
        case listName = "ListName"
        case listUpdateToken = "ListUpdateToken"
        case previousProtocolsList = "PreviousProtocolsList"
        case protocolsList = "ProtocolsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
        if let listName = listName {
            try encodeContainer.encode(listName, forKey: .listName)
        }
        if let listUpdateToken = listUpdateToken {
            try encodeContainer.encode(listUpdateToken, forKey: .listUpdateToken)
        }
        if let previousProtocolsList = previousProtocolsList {
            var previousProtocolsListContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .previousProtocolsList)
            for (dictKey0, previousprotocolslist0) in previousProtocolsList {
                try previousProtocolsListContainer.encode(previousprotocolslist0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let protocolsList = protocolsList {
            var protocolsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocolsList)
            for protocolslist0 in protocolsList {
                try protocolsListContainer.encode(protocolslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
        let listNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listName)
        listName = listNameDecoded
        let listUpdateTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listUpdateToken)
        listUpdateToken = listUpdateTokenDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let protocolsListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .protocolsList)
        var protocolsListDecoded0:[Swift.String]? = nil
        if let protocolsListContainer = protocolsListContainer {
            protocolsListDecoded0 = [Swift.String]()
            for string0 in protocolsListContainer {
                if let string0 = string0 {
                    protocolsListDecoded0?.append(string0)
                }
            }
        }
        protocolsList = protocolsListDecoded0
        let previousProtocolsListContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .previousProtocolsList)
        var previousProtocolsListDecoded0: [Swift.String:[Swift.String]]? = nil
        if let previousProtocolsListContainer = previousProtocolsListContainer {
            previousProtocolsListDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, protocolslist0) in previousProtocolsListContainer {
                var protocolslist0Decoded0: [Swift.String]? = nil
                if let protocolslist0 = protocolslist0 {
                    protocolslist0Decoded0 = [Swift.String]()
                    for string1 in protocolslist0 {
                        if let string1 = string1 {
                            protocolslist0Decoded0?.append(string1)
                        }
                    }
                }
                previousProtocolsListDecoded0?[key0] = protocolslist0Decoded0
            }
        }
        previousProtocolsList = previousProtocolsListDecoded0
    }
}

extension FmsClientTypes {
    /// An Firewall Manager protocols list.
    public struct ProtocolsListData: Swift.Equatable {
        /// The time that the Firewall Manager protocols list was created.
        public var createTime: ClientRuntime.Date?
        /// The time that the Firewall Manager protocols list was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The ID of the Firewall Manager protocols list.
        public var listId: Swift.String?
        /// The name of the Firewall Manager protocols list.
        /// This member is required.
        public var listName: Swift.String?
        /// A unique identifier for each update to the list. When you update the list, the update token must match the token of the current version of the application list. You can retrieve the update token by getting the list.
        public var listUpdateToken: Swift.String?
        /// A map of previous version numbers to their corresponding protocol arrays.
        public var previousProtocolsList: [Swift.String:[Swift.String]]?
        /// An array of protocols in the Firewall Manager protocols list.
        /// This member is required.
        public var protocolsList: [Swift.String]?

        public init (
            createTime: ClientRuntime.Date? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            listId: Swift.String? = nil,
            listName: Swift.String? = nil,
            listUpdateToken: Swift.String? = nil,
            previousProtocolsList: [Swift.String:[Swift.String]]? = nil,
            protocolsList: [Swift.String]? = nil
        )
        {
            self.createTime = createTime
            self.lastUpdateTime = lastUpdateTime
            self.listId = listId
            self.listName = listName
            self.listUpdateToken = listUpdateToken
            self.previousProtocolsList = previousProtocolsList
            self.protocolsList = protocolsList
        }
    }

}

extension FmsClientTypes.ProtocolsListDataSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listArn = "ListArn"
        case listId = "ListId"
        case listName = "ListName"
        case protocolsList = "ProtocolsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listArn = listArn {
            try encodeContainer.encode(listArn, forKey: .listArn)
        }
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
        if let listName = listName {
            try encodeContainer.encode(listName, forKey: .listName)
        }
        if let protocolsList = protocolsList {
            var protocolsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocolsList)
            for protocolslist0 in protocolsList {
                try protocolsListContainer.encode(protocolslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listArn)
        listArn = listArnDecoded
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
        let listNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listName)
        listName = listNameDecoded
        let protocolsListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .protocolsList)
        var protocolsListDecoded0:[Swift.String]? = nil
        if let protocolsListContainer = protocolsListContainer {
            protocolsListDecoded0 = [Swift.String]()
            for string0 in protocolsListContainer {
                if let string0 = string0 {
                    protocolsListDecoded0?.append(string0)
                }
            }
        }
        protocolsList = protocolsListDecoded0
    }
}

extension FmsClientTypes {
    /// Details of the Firewall Manager protocols list.
    public struct ProtocolsListDataSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the specified protocols list.
        public var listArn: Swift.String?
        /// The ID of the specified protocols list.
        public var listId: Swift.String?
        /// The name of the specified protocols list.
        public var listName: Swift.String?
        /// An array of protocols in the Firewall Manager protocols list.
        public var protocolsList: [Swift.String]?

        public init (
            listArn: Swift.String? = nil,
            listId: Swift.String? = nil,
            listName: Swift.String? = nil,
            protocolsList: [Swift.String]? = nil
        )
        {
            self.listArn = listArn
            self.listId = listId
            self.listName = listName
            self.protocolsList = protocolsList
        }
    }

}

extension PutAppsListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsList = "AppsList"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appsList = appsList {
            try encodeContainer.encode(appsList, forKey: .appsList)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }
}

extension PutAppsListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutAppsListInput: Swift.Equatable {
    /// The details of the Firewall Manager applications list to be created.
    /// This member is required.
    public var appsList: FmsClientTypes.AppsListData?
    /// The tags associated with the resource.
    public var tagList: [FmsClientTypes.Tag]?

    public init (
        appsList: FmsClientTypes.AppsListData? = nil,
        tagList: [FmsClientTypes.Tag]? = nil
    )
    {
        self.appsList = appsList
        self.tagList = tagList
    }
}

struct PutAppsListInputBody: Swift.Equatable {
    let appsList: FmsClientTypes.AppsListData?
    let tagList: [FmsClientTypes.Tag]?
}

extension PutAppsListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsList = "AppsList"
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsListDecoded = try containerValues.decodeIfPresent(FmsClientTypes.AppsListData.self, forKey: .appsList)
        appsList = appsListDecoded
        let tagListContainer = try containerValues.decodeIfPresent([FmsClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[FmsClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [FmsClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension PutAppsListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAppsListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAppsListOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAppsListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutAppsListOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appsList = output.appsList
            self.appsListArn = output.appsListArn
        } else {
            self.appsList = nil
            self.appsListArn = nil
        }
    }
}

public struct PutAppsListOutputResponse: Swift.Equatable {
    /// The details of the Firewall Manager applications list.
    public var appsList: FmsClientTypes.AppsListData?
    /// The Amazon Resource Name (ARN) of the applications list.
    public var appsListArn: Swift.String?

    public init (
        appsList: FmsClientTypes.AppsListData? = nil,
        appsListArn: Swift.String? = nil
    )
    {
        self.appsList = appsList
        self.appsListArn = appsListArn
    }
}

struct PutAppsListOutputResponseBody: Swift.Equatable {
    let appsList: FmsClientTypes.AppsListData?
    let appsListArn: Swift.String?
}

extension PutAppsListOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsList = "AppsList"
        case appsListArn = "AppsListArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsListDecoded = try containerValues.decodeIfPresent(FmsClientTypes.AppsListData.self, forKey: .appsList)
        appsList = appsListDecoded
        let appsListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appsListArn)
        appsListArn = appsListArnDecoded
    }
}

extension PutNotificationChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snsRoleName = "SnsRoleName"
        case snsTopicArn = "SnsTopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snsRoleName = snsRoleName {
            try encodeContainer.encode(snsRoleName, forKey: .snsRoleName)
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }
}

extension PutNotificationChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutNotificationChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM role that allows Amazon SNS to record Firewall Manager activity.
    /// This member is required.
    public var snsRoleName: Swift.String?
    /// The Amazon Resource Name (ARN) of the SNS topic that collects notifications from Firewall Manager.
    /// This member is required.
    public var snsTopicArn: Swift.String?

    public init (
        snsRoleName: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.snsRoleName = snsRoleName
        self.snsTopicArn = snsTopicArn
    }
}

struct PutNotificationChannelInputBody: Swift.Equatable {
    let snsTopicArn: Swift.String?
    let snsRoleName: Swift.String?
}

extension PutNotificationChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snsRoleName = "SnsRoleName"
        case snsTopicArn = "SnsTopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let snsRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsRoleName)
        snsRoleName = snsRoleNameDecoded
    }
}

extension PutNotificationChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutNotificationChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutNotificationChannelOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutNotificationChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutNotificationChannelOutputResponse: Swift.Equatable {

}

extension PutPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }
}

extension PutPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutPolicyInput: Swift.Equatable {
    /// The details of the Firewall Manager policy to be created.
    /// This member is required.
    public var policy: FmsClientTypes.Policy?
    /// The tags to add to the Amazon Web Services resource.
    public var tagList: [FmsClientTypes.Tag]?

    public init (
        policy: FmsClientTypes.Policy? = nil,
        tagList: [FmsClientTypes.Tag]? = nil
    )
    {
        self.policy = policy
        self.tagList = tagList
    }
}

struct PutPolicyInputBody: Swift.Equatable {
    let policy: FmsClientTypes.Policy?
    let tagList: [FmsClientTypes.Tag]?
}

extension PutPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(FmsClientTypes.Policy.self, forKey: .policy)
        policy = policyDecoded
        let tagListContainer = try containerValues.decodeIfPresent([FmsClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[FmsClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [FmsClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension PutPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.policyArn = output.policyArn
        } else {
            self.policy = nil
            self.policyArn = nil
        }
    }
}

public struct PutPolicyOutputResponse: Swift.Equatable {
    /// The details of the Firewall Manager policy.
    public var policy: FmsClientTypes.Policy?
    /// The Amazon Resource Name (ARN) of the policy.
    public var policyArn: Swift.String?

    public init (
        policy: FmsClientTypes.Policy? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.policyArn = policyArn
    }
}

struct PutPolicyOutputResponseBody: Swift.Equatable {
    let policy: FmsClientTypes.Policy?
    let policyArn: Swift.String?
}

extension PutPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(FmsClientTypes.Policy.self, forKey: .policy)
        policy = policyDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension PutProtocolsListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protocolsList = "ProtocolsList"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protocolsList = protocolsList {
            try encodeContainer.encode(protocolsList, forKey: .protocolsList)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }
}

extension PutProtocolsListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutProtocolsListInput: Swift.Equatable {
    /// The details of the Firewall Manager protocols list to be created.
    /// This member is required.
    public var protocolsList: FmsClientTypes.ProtocolsListData?
    /// The tags associated with the resource.
    public var tagList: [FmsClientTypes.Tag]?

    public init (
        protocolsList: FmsClientTypes.ProtocolsListData? = nil,
        tagList: [FmsClientTypes.Tag]? = nil
    )
    {
        self.protocolsList = protocolsList
        self.tagList = tagList
    }
}

struct PutProtocolsListInputBody: Swift.Equatable {
    let protocolsList: FmsClientTypes.ProtocolsListData?
    let tagList: [FmsClientTypes.Tag]?
}

extension PutProtocolsListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protocolsList = "ProtocolsList"
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsListDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ProtocolsListData.self, forKey: .protocolsList)
        protocolsList = protocolsListDecoded
        let tagListContainer = try containerValues.decodeIfPresent([FmsClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[FmsClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [FmsClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension PutProtocolsListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutProtocolsListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutProtocolsListOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutProtocolsListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutProtocolsListOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.protocolsList = output.protocolsList
            self.protocolsListArn = output.protocolsListArn
        } else {
            self.protocolsList = nil
            self.protocolsListArn = nil
        }
    }
}

public struct PutProtocolsListOutputResponse: Swift.Equatable {
    /// The details of the Firewall Manager protocols list.
    public var protocolsList: FmsClientTypes.ProtocolsListData?
    /// The Amazon Resource Name (ARN) of the protocols list.
    public var protocolsListArn: Swift.String?

    public init (
        protocolsList: FmsClientTypes.ProtocolsListData? = nil,
        protocolsListArn: Swift.String? = nil
    )
    {
        self.protocolsList = protocolsList
        self.protocolsListArn = protocolsListArn
    }
}

struct PutProtocolsListOutputResponseBody: Swift.Equatable {
    let protocolsList: FmsClientTypes.ProtocolsListData?
    let protocolsListArn: Swift.String?
}

extension PutProtocolsListOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protocolsList = "ProtocolsList"
        case protocolsListArn = "ProtocolsListArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsListDecoded = try containerValues.decodeIfPresent(FmsClientTypes.ProtocolsListData.self, forKey: .protocolsList)
        protocolsList = protocolsListDecoded
        let protocolsListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocolsListArn)
        protocolsListArn = protocolsListArnDecoded
    }
}

extension FmsClientTypes.RemediationAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eC2AssociateRouteTableAction = "EC2AssociateRouteTableAction"
        case eC2CopyRouteTableAction = "EC2CopyRouteTableAction"
        case eC2CreateRouteAction = "EC2CreateRouteAction"
        case eC2CreateRouteTableAction = "EC2CreateRouteTableAction"
        case eC2DeleteRouteAction = "EC2DeleteRouteAction"
        case eC2ReplaceRouteAction = "EC2ReplaceRouteAction"
        case eC2ReplaceRouteTableAssociationAction = "EC2ReplaceRouteTableAssociationAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eC2AssociateRouteTableAction = eC2AssociateRouteTableAction {
            try encodeContainer.encode(eC2AssociateRouteTableAction, forKey: .eC2AssociateRouteTableAction)
        }
        if let eC2CopyRouteTableAction = eC2CopyRouteTableAction {
            try encodeContainer.encode(eC2CopyRouteTableAction, forKey: .eC2CopyRouteTableAction)
        }
        if let eC2CreateRouteAction = eC2CreateRouteAction {
            try encodeContainer.encode(eC2CreateRouteAction, forKey: .eC2CreateRouteAction)
        }
        if let eC2CreateRouteTableAction = eC2CreateRouteTableAction {
            try encodeContainer.encode(eC2CreateRouteTableAction, forKey: .eC2CreateRouteTableAction)
        }
        if let eC2DeleteRouteAction = eC2DeleteRouteAction {
            try encodeContainer.encode(eC2DeleteRouteAction, forKey: .eC2DeleteRouteAction)
        }
        if let eC2ReplaceRouteAction = eC2ReplaceRouteAction {
            try encodeContainer.encode(eC2ReplaceRouteAction, forKey: .eC2ReplaceRouteAction)
        }
        if let eC2ReplaceRouteTableAssociationAction = eC2ReplaceRouteTableAssociationAction {
            try encodeContainer.encode(eC2ReplaceRouteTableAssociationAction, forKey: .eC2ReplaceRouteTableAssociationAction)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eC2CreateRouteActionDecoded = try containerValues.decodeIfPresent(FmsClientTypes.EC2CreateRouteAction.self, forKey: .eC2CreateRouteAction)
        eC2CreateRouteAction = eC2CreateRouteActionDecoded
        let eC2ReplaceRouteActionDecoded = try containerValues.decodeIfPresent(FmsClientTypes.EC2ReplaceRouteAction.self, forKey: .eC2ReplaceRouteAction)
        eC2ReplaceRouteAction = eC2ReplaceRouteActionDecoded
        let eC2DeleteRouteActionDecoded = try containerValues.decodeIfPresent(FmsClientTypes.EC2DeleteRouteAction.self, forKey: .eC2DeleteRouteAction)
        eC2DeleteRouteAction = eC2DeleteRouteActionDecoded
        let eC2CopyRouteTableActionDecoded = try containerValues.decodeIfPresent(FmsClientTypes.EC2CopyRouteTableAction.self, forKey: .eC2CopyRouteTableAction)
        eC2CopyRouteTableAction = eC2CopyRouteTableActionDecoded
        let eC2ReplaceRouteTableAssociationActionDecoded = try containerValues.decodeIfPresent(FmsClientTypes.EC2ReplaceRouteTableAssociationAction.self, forKey: .eC2ReplaceRouteTableAssociationAction)
        eC2ReplaceRouteTableAssociationAction = eC2ReplaceRouteTableAssociationActionDecoded
        let eC2AssociateRouteTableActionDecoded = try containerValues.decodeIfPresent(FmsClientTypes.EC2AssociateRouteTableAction.self, forKey: .eC2AssociateRouteTableAction)
        eC2AssociateRouteTableAction = eC2AssociateRouteTableActionDecoded
        let eC2CreateRouteTableActionDecoded = try containerValues.decodeIfPresent(FmsClientTypes.EC2CreateRouteTableAction.self, forKey: .eC2CreateRouteTableAction)
        eC2CreateRouteTableAction = eC2CreateRouteTableActionDecoded
    }
}

extension FmsClientTypes {
    /// Information about an individual action you can take to remediate a violation.
    public struct RemediationAction: Swift.Equatable {
        /// A description of a remediation action.
        public var description: Swift.String?
        /// Information about the AssociateRouteTable action in the Amazon EC2 API.
        public var eC2AssociateRouteTableAction: FmsClientTypes.EC2AssociateRouteTableAction?
        /// Information about the CopyRouteTable action in the Amazon EC2 API.
        public var eC2CopyRouteTableAction: FmsClientTypes.EC2CopyRouteTableAction?
        /// Information about the CreateRoute action in the Amazon EC2 API.
        public var eC2CreateRouteAction: FmsClientTypes.EC2CreateRouteAction?
        /// Information about the CreateRouteTable action in the Amazon EC2 API.
        public var eC2CreateRouteTableAction: FmsClientTypes.EC2CreateRouteTableAction?
        /// Information about the DeleteRoute action in the Amazon EC2 API.
        public var eC2DeleteRouteAction: FmsClientTypes.EC2DeleteRouteAction?
        /// Information about the ReplaceRoute action in the Amazon EC2 API.
        public var eC2ReplaceRouteAction: FmsClientTypes.EC2ReplaceRouteAction?
        /// Information about the ReplaceRouteTableAssociation action in the Amazon EC2 API.
        public var eC2ReplaceRouteTableAssociationAction: FmsClientTypes.EC2ReplaceRouteTableAssociationAction?

        public init (
            description: Swift.String? = nil,
            eC2AssociateRouteTableAction: FmsClientTypes.EC2AssociateRouteTableAction? = nil,
            eC2CopyRouteTableAction: FmsClientTypes.EC2CopyRouteTableAction? = nil,
            eC2CreateRouteAction: FmsClientTypes.EC2CreateRouteAction? = nil,
            eC2CreateRouteTableAction: FmsClientTypes.EC2CreateRouteTableAction? = nil,
            eC2DeleteRouteAction: FmsClientTypes.EC2DeleteRouteAction? = nil,
            eC2ReplaceRouteAction: FmsClientTypes.EC2ReplaceRouteAction? = nil,
            eC2ReplaceRouteTableAssociationAction: FmsClientTypes.EC2ReplaceRouteTableAssociationAction? = nil
        )
        {
            self.description = description
            self.eC2AssociateRouteTableAction = eC2AssociateRouteTableAction
            self.eC2CopyRouteTableAction = eC2CopyRouteTableAction
            self.eC2CreateRouteAction = eC2CreateRouteAction
            self.eC2CreateRouteTableAction = eC2CreateRouteTableAction
            self.eC2DeleteRouteAction = eC2DeleteRouteAction
            self.eC2ReplaceRouteAction = eC2ReplaceRouteAction
            self.eC2ReplaceRouteTableAssociationAction = eC2ReplaceRouteTableAssociationAction
        }
    }

}

extension FmsClientTypes {
    public enum RemediationActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case modify
        case remove
        case sdkUnknown(Swift.String)

        public static var allCases: [RemediationActionType] {
            return [
                .modify,
                .remove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .modify: return "MODIFY"
            case .remove: return "REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RemediationActionType(rawValue: rawValue) ?? RemediationActionType.sdkUnknown(rawValue)
        }
    }
}

extension FmsClientTypes.RemediationActionWithOrder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case order = "Order"
        case remediationAction = "RemediationAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if order != 0 {
            try encodeContainer.encode(order, forKey: .order)
        }
        if let remediationAction = remediationAction {
            try encodeContainer.encode(remediationAction, forKey: .remediationAction)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remediationActionDecoded = try containerValues.decodeIfPresent(FmsClientTypes.RemediationAction.self, forKey: .remediationAction)
        remediationAction = remediationActionDecoded
        let orderDecoded = try containerValues.decode(Swift.Int.self, forKey: .order)
        order = orderDecoded
    }
}

extension FmsClientTypes {
    /// An ordered list of actions you can take to remediate a violation.
    public struct RemediationActionWithOrder: Swift.Equatable {
        /// The order of the remediation actions in the list.
        public var order: Swift.Int
        /// Information about an action you can take to remediate a violation.
        public var remediationAction: FmsClientTypes.RemediationAction?

        public init (
            order: Swift.Int = 0,
            remediationAction: FmsClientTypes.RemediationAction? = nil
        )
        {
            self.order = order
            self.remediationAction = remediationAction
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FmsClientTypes.ResourceTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FmsClientTypes {
    /// The resource tags that Firewall Manager uses to determine if a particular resource should be included or excluded from the Firewall Manager policy. Tags enable you to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. Each tag consists of a key and an optional value. Firewall Manager combines the tags with "AND" so that, if you add more than one tag to a policy scope, a resource must have all the specified tags to be included or excluded. For more information, see [Working with Tag Editor](https://docs.aws.amazon.com/awsconsolehelpdocs/latest/gsg/tag-editor.html).
    public struct ResourceTag: Swift.Equatable {
        /// The resource tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The resource tag value.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension FmsClientTypes.ResourceViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsEc2InstanceViolation = "AwsEc2InstanceViolation"
        case awsEc2NetworkInterfaceViolation = "AwsEc2NetworkInterfaceViolation"
        case awsVPCSecurityGroupViolation = "AwsVPCSecurityGroupViolation"
        case dnsDuplicateRuleGroupViolation = "DnsDuplicateRuleGroupViolation"
        case dnsRuleGroupLimitExceededViolation = "DnsRuleGroupLimitExceededViolation"
        case dnsRuleGroupPriorityConflictViolation = "DnsRuleGroupPriorityConflictViolation"
        case networkFirewallBlackHoleRouteDetectedViolation = "NetworkFirewallBlackHoleRouteDetectedViolation"
        case networkFirewallInternetTrafficNotInspectedViolation = "NetworkFirewallInternetTrafficNotInspectedViolation"
        case networkFirewallInvalidRouteConfigurationViolation = "NetworkFirewallInvalidRouteConfigurationViolation"
        case networkFirewallMissingExpectedRTViolation = "NetworkFirewallMissingExpectedRTViolation"
        case networkFirewallMissingExpectedRoutesViolation = "NetworkFirewallMissingExpectedRoutesViolation"
        case networkFirewallMissingFirewallViolation = "NetworkFirewallMissingFirewallViolation"
        case networkFirewallMissingSubnetViolation = "NetworkFirewallMissingSubnetViolation"
        case networkFirewallPolicyModifiedViolation = "NetworkFirewallPolicyModifiedViolation"
        case networkFirewallUnexpectedFirewallRoutesViolation = "NetworkFirewallUnexpectedFirewallRoutesViolation"
        case networkFirewallUnexpectedGatewayRoutesViolation = "NetworkFirewallUnexpectedGatewayRoutesViolation"
        case possibleRemediationActions = "PossibleRemediationActions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsEc2InstanceViolation = awsEc2InstanceViolation {
            try encodeContainer.encode(awsEc2InstanceViolation, forKey: .awsEc2InstanceViolation)
        }
        if let awsEc2NetworkInterfaceViolation = awsEc2NetworkInterfaceViolation {
            try encodeContainer.encode(awsEc2NetworkInterfaceViolation, forKey: .awsEc2NetworkInterfaceViolation)
        }
        if let awsVPCSecurityGroupViolation = awsVPCSecurityGroupViolation {
            try encodeContainer.encode(awsVPCSecurityGroupViolation, forKey: .awsVPCSecurityGroupViolation)
        }
        if let dnsDuplicateRuleGroupViolation = dnsDuplicateRuleGroupViolation {
            try encodeContainer.encode(dnsDuplicateRuleGroupViolation, forKey: .dnsDuplicateRuleGroupViolation)
        }
        if let dnsRuleGroupLimitExceededViolation = dnsRuleGroupLimitExceededViolation {
            try encodeContainer.encode(dnsRuleGroupLimitExceededViolation, forKey: .dnsRuleGroupLimitExceededViolation)
        }
        if let dnsRuleGroupPriorityConflictViolation = dnsRuleGroupPriorityConflictViolation {
            try encodeContainer.encode(dnsRuleGroupPriorityConflictViolation, forKey: .dnsRuleGroupPriorityConflictViolation)
        }
        if let networkFirewallBlackHoleRouteDetectedViolation = networkFirewallBlackHoleRouteDetectedViolation {
            try encodeContainer.encode(networkFirewallBlackHoleRouteDetectedViolation, forKey: .networkFirewallBlackHoleRouteDetectedViolation)
        }
        if let networkFirewallInternetTrafficNotInspectedViolation = networkFirewallInternetTrafficNotInspectedViolation {
            try encodeContainer.encode(networkFirewallInternetTrafficNotInspectedViolation, forKey: .networkFirewallInternetTrafficNotInspectedViolation)
        }
        if let networkFirewallInvalidRouteConfigurationViolation = networkFirewallInvalidRouteConfigurationViolation {
            try encodeContainer.encode(networkFirewallInvalidRouteConfigurationViolation, forKey: .networkFirewallInvalidRouteConfigurationViolation)
        }
        if let networkFirewallMissingExpectedRTViolation = networkFirewallMissingExpectedRTViolation {
            try encodeContainer.encode(networkFirewallMissingExpectedRTViolation, forKey: .networkFirewallMissingExpectedRTViolation)
        }
        if let networkFirewallMissingExpectedRoutesViolation = networkFirewallMissingExpectedRoutesViolation {
            try encodeContainer.encode(networkFirewallMissingExpectedRoutesViolation, forKey: .networkFirewallMissingExpectedRoutesViolation)
        }
        if let networkFirewallMissingFirewallViolation = networkFirewallMissingFirewallViolation {
            try encodeContainer.encode(networkFirewallMissingFirewallViolation, forKey: .networkFirewallMissingFirewallViolation)
        }
        if let networkFirewallMissingSubnetViolation = networkFirewallMissingSubnetViolation {
            try encodeContainer.encode(networkFirewallMissingSubnetViolation, forKey: .networkFirewallMissingSubnetViolation)
        }
        if let networkFirewallPolicyModifiedViolation = networkFirewallPolicyModifiedViolation {
            try encodeContainer.encode(networkFirewallPolicyModifiedViolation, forKey: .networkFirewallPolicyModifiedViolation)
        }
        if let networkFirewallUnexpectedFirewallRoutesViolation = networkFirewallUnexpectedFirewallRoutesViolation {
            try encodeContainer.encode(networkFirewallUnexpectedFirewallRoutesViolation, forKey: .networkFirewallUnexpectedFirewallRoutesViolation)
        }
        if let networkFirewallUnexpectedGatewayRoutesViolation = networkFirewallUnexpectedGatewayRoutesViolation {
            try encodeContainer.encode(networkFirewallUnexpectedGatewayRoutesViolation, forKey: .networkFirewallUnexpectedGatewayRoutesViolation)
        }
        if let possibleRemediationActions = possibleRemediationActions {
            try encodeContainer.encode(possibleRemediationActions, forKey: .possibleRemediationActions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsVPCSecurityGroupViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.AwsVPCSecurityGroupViolation.self, forKey: .awsVPCSecurityGroupViolation)
        awsVPCSecurityGroupViolation = awsVPCSecurityGroupViolationDecoded
        let awsEc2NetworkInterfaceViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.AwsEc2NetworkInterfaceViolation.self, forKey: .awsEc2NetworkInterfaceViolation)
        awsEc2NetworkInterfaceViolation = awsEc2NetworkInterfaceViolationDecoded
        let awsEc2InstanceViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.AwsEc2InstanceViolation.self, forKey: .awsEc2InstanceViolation)
        awsEc2InstanceViolation = awsEc2InstanceViolationDecoded
        let networkFirewallMissingFirewallViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.NetworkFirewallMissingFirewallViolation.self, forKey: .networkFirewallMissingFirewallViolation)
        networkFirewallMissingFirewallViolation = networkFirewallMissingFirewallViolationDecoded
        let networkFirewallMissingSubnetViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.NetworkFirewallMissingSubnetViolation.self, forKey: .networkFirewallMissingSubnetViolation)
        networkFirewallMissingSubnetViolation = networkFirewallMissingSubnetViolationDecoded
        let networkFirewallMissingExpectedRTViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.NetworkFirewallMissingExpectedRTViolation.self, forKey: .networkFirewallMissingExpectedRTViolation)
        networkFirewallMissingExpectedRTViolation = networkFirewallMissingExpectedRTViolationDecoded
        let networkFirewallPolicyModifiedViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.NetworkFirewallPolicyModifiedViolation.self, forKey: .networkFirewallPolicyModifiedViolation)
        networkFirewallPolicyModifiedViolation = networkFirewallPolicyModifiedViolationDecoded
        let networkFirewallInternetTrafficNotInspectedViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.NetworkFirewallInternetTrafficNotInspectedViolation.self, forKey: .networkFirewallInternetTrafficNotInspectedViolation)
        networkFirewallInternetTrafficNotInspectedViolation = networkFirewallInternetTrafficNotInspectedViolationDecoded
        let networkFirewallInvalidRouteConfigurationViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.NetworkFirewallInvalidRouteConfigurationViolation.self, forKey: .networkFirewallInvalidRouteConfigurationViolation)
        networkFirewallInvalidRouteConfigurationViolation = networkFirewallInvalidRouteConfigurationViolationDecoded
        let networkFirewallBlackHoleRouteDetectedViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.NetworkFirewallBlackHoleRouteDetectedViolation.self, forKey: .networkFirewallBlackHoleRouteDetectedViolation)
        networkFirewallBlackHoleRouteDetectedViolation = networkFirewallBlackHoleRouteDetectedViolationDecoded
        let networkFirewallUnexpectedFirewallRoutesViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.NetworkFirewallUnexpectedFirewallRoutesViolation.self, forKey: .networkFirewallUnexpectedFirewallRoutesViolation)
        networkFirewallUnexpectedFirewallRoutesViolation = networkFirewallUnexpectedFirewallRoutesViolationDecoded
        let networkFirewallUnexpectedGatewayRoutesViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.NetworkFirewallUnexpectedGatewayRoutesViolation.self, forKey: .networkFirewallUnexpectedGatewayRoutesViolation)
        networkFirewallUnexpectedGatewayRoutesViolation = networkFirewallUnexpectedGatewayRoutesViolationDecoded
        let networkFirewallMissingExpectedRoutesViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.NetworkFirewallMissingExpectedRoutesViolation.self, forKey: .networkFirewallMissingExpectedRoutesViolation)
        networkFirewallMissingExpectedRoutesViolation = networkFirewallMissingExpectedRoutesViolationDecoded
        let dnsRuleGroupPriorityConflictViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.DnsRuleGroupPriorityConflictViolation.self, forKey: .dnsRuleGroupPriorityConflictViolation)
        dnsRuleGroupPriorityConflictViolation = dnsRuleGroupPriorityConflictViolationDecoded
        let dnsDuplicateRuleGroupViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.DnsDuplicateRuleGroupViolation.self, forKey: .dnsDuplicateRuleGroupViolation)
        dnsDuplicateRuleGroupViolation = dnsDuplicateRuleGroupViolationDecoded
        let dnsRuleGroupLimitExceededViolationDecoded = try containerValues.decodeIfPresent(FmsClientTypes.DnsRuleGroupLimitExceededViolation.self, forKey: .dnsRuleGroupLimitExceededViolation)
        dnsRuleGroupLimitExceededViolation = dnsRuleGroupLimitExceededViolationDecoded
        let possibleRemediationActionsDecoded = try containerValues.decodeIfPresent(FmsClientTypes.PossibleRemediationActions.self, forKey: .possibleRemediationActions)
        possibleRemediationActions = possibleRemediationActionsDecoded
    }
}

extension FmsClientTypes {
    /// Violation detail based on resource type.
    public struct ResourceViolation: Swift.Equatable {
        /// Violation detail for an EC2 instance.
        public var awsEc2InstanceViolation: FmsClientTypes.AwsEc2InstanceViolation?
        /// Violation detail for a network interface.
        public var awsEc2NetworkInterfaceViolation: FmsClientTypes.AwsEc2NetworkInterfaceViolation?
        /// Violation detail for security groups.
        public var awsVPCSecurityGroupViolation: FmsClientTypes.AwsVPCSecurityGroupViolation?
        /// Violation detail for a DNS Firewall policy that indicates that a rule group that Firewall Manager tried to associate with a VPC is already associated with the VPC and can't be associated again.
        public var dnsDuplicateRuleGroupViolation: FmsClientTypes.DnsDuplicateRuleGroupViolation?
        /// Violation detail for a DNS Firewall policy that indicates that the VPC reached the limit for associated DNS Firewall rule groups. Firewall Manager tried to associate another rule group with the VPC and failed.
        public var dnsRuleGroupLimitExceededViolation: FmsClientTypes.DnsRuleGroupLimitExceededViolation?
        /// Violation detail for a DNS Firewall policy that indicates that a rule group that Firewall Manager tried to associate with a VPC has the same priority as a rule group that's already associated.
        public var dnsRuleGroupPriorityConflictViolation: FmsClientTypes.DnsRuleGroupPriorityConflictViolation?
        /// Violation detail for an internet gateway route with an inactive state in the customer subnet route table or Network Firewall subnet route table.
        public var networkFirewallBlackHoleRouteDetectedViolation: FmsClientTypes.NetworkFirewallBlackHoleRouteDetectedViolation?
        /// Violation detail for the subnet for which internet traffic hasn't been inspected.
        public var networkFirewallInternetTrafficNotInspectedViolation: FmsClientTypes.NetworkFirewallInternetTrafficNotInspectedViolation?
        /// The route configuration is invalid.
        public var networkFirewallInvalidRouteConfigurationViolation: FmsClientTypes.NetworkFirewallInvalidRouteConfigurationViolation?
        /// Violation detail for an Network Firewall policy that indicates that a subnet is not associated with the expected Firewall Manager managed route table.
        public var networkFirewallMissingExpectedRTViolation: FmsClientTypes.NetworkFirewallMissingExpectedRTViolation?
        /// Expected routes are missing from Network Firewall.
        public var networkFirewallMissingExpectedRoutesViolation: FmsClientTypes.NetworkFirewallMissingExpectedRoutesViolation?
        /// Violation detail for an Network Firewall policy that indicates that a subnet has no Firewall Manager managed firewall in its VPC.
        public var networkFirewallMissingFirewallViolation: FmsClientTypes.NetworkFirewallMissingFirewallViolation?
        /// Violation detail for an Network Firewall policy that indicates that an Availability Zone is missing the expected Firewall Manager managed subnet.
        public var networkFirewallMissingSubnetViolation: FmsClientTypes.NetworkFirewallMissingSubnetViolation?
        /// Violation detail for an Network Firewall policy that indicates that a firewall policy in an individual account has been modified in a way that makes it noncompliant. For example, the individual account owner might have deleted a rule group, changed the priority of a stateless rule group, or changed a policy default action.
        public var networkFirewallPolicyModifiedViolation: FmsClientTypes.NetworkFirewallPolicyModifiedViolation?
        /// There's an unexpected firewall route.
        public var networkFirewallUnexpectedFirewallRoutesViolation: FmsClientTypes.NetworkFirewallUnexpectedFirewallRoutesViolation?
        /// There's an unexpected gateway route.
        public var networkFirewallUnexpectedGatewayRoutesViolation: FmsClientTypes.NetworkFirewallUnexpectedGatewayRoutesViolation?
        /// A list of possible remediation action lists. Each individual possible remediation action is a list of individual remediation actions.
        public var possibleRemediationActions: FmsClientTypes.PossibleRemediationActions?

        public init (
            awsEc2InstanceViolation: FmsClientTypes.AwsEc2InstanceViolation? = nil,
            awsEc2NetworkInterfaceViolation: FmsClientTypes.AwsEc2NetworkInterfaceViolation? = nil,
            awsVPCSecurityGroupViolation: FmsClientTypes.AwsVPCSecurityGroupViolation? = nil,
            dnsDuplicateRuleGroupViolation: FmsClientTypes.DnsDuplicateRuleGroupViolation? = nil,
            dnsRuleGroupLimitExceededViolation: FmsClientTypes.DnsRuleGroupLimitExceededViolation? = nil,
            dnsRuleGroupPriorityConflictViolation: FmsClientTypes.DnsRuleGroupPriorityConflictViolation? = nil,
            networkFirewallBlackHoleRouteDetectedViolation: FmsClientTypes.NetworkFirewallBlackHoleRouteDetectedViolation? = nil,
            networkFirewallInternetTrafficNotInspectedViolation: FmsClientTypes.NetworkFirewallInternetTrafficNotInspectedViolation? = nil,
            networkFirewallInvalidRouteConfigurationViolation: FmsClientTypes.NetworkFirewallInvalidRouteConfigurationViolation? = nil,
            networkFirewallMissingExpectedRTViolation: FmsClientTypes.NetworkFirewallMissingExpectedRTViolation? = nil,
            networkFirewallMissingExpectedRoutesViolation: FmsClientTypes.NetworkFirewallMissingExpectedRoutesViolation? = nil,
            networkFirewallMissingFirewallViolation: FmsClientTypes.NetworkFirewallMissingFirewallViolation? = nil,
            networkFirewallMissingSubnetViolation: FmsClientTypes.NetworkFirewallMissingSubnetViolation? = nil,
            networkFirewallPolicyModifiedViolation: FmsClientTypes.NetworkFirewallPolicyModifiedViolation? = nil,
            networkFirewallUnexpectedFirewallRoutesViolation: FmsClientTypes.NetworkFirewallUnexpectedFirewallRoutesViolation? = nil,
            networkFirewallUnexpectedGatewayRoutesViolation: FmsClientTypes.NetworkFirewallUnexpectedGatewayRoutesViolation? = nil,
            possibleRemediationActions: FmsClientTypes.PossibleRemediationActions? = nil
        )
        {
            self.awsEc2InstanceViolation = awsEc2InstanceViolation
            self.awsEc2NetworkInterfaceViolation = awsEc2NetworkInterfaceViolation
            self.awsVPCSecurityGroupViolation = awsVPCSecurityGroupViolation
            self.dnsDuplicateRuleGroupViolation = dnsDuplicateRuleGroupViolation
            self.dnsRuleGroupLimitExceededViolation = dnsRuleGroupLimitExceededViolation
            self.dnsRuleGroupPriorityConflictViolation = dnsRuleGroupPriorityConflictViolation
            self.networkFirewallBlackHoleRouteDetectedViolation = networkFirewallBlackHoleRouteDetectedViolation
            self.networkFirewallInternetTrafficNotInspectedViolation = networkFirewallInternetTrafficNotInspectedViolation
            self.networkFirewallInvalidRouteConfigurationViolation = networkFirewallInvalidRouteConfigurationViolation
            self.networkFirewallMissingExpectedRTViolation = networkFirewallMissingExpectedRTViolation
            self.networkFirewallMissingExpectedRoutesViolation = networkFirewallMissingExpectedRoutesViolation
            self.networkFirewallMissingFirewallViolation = networkFirewallMissingFirewallViolation
            self.networkFirewallMissingSubnetViolation = networkFirewallMissingSubnetViolation
            self.networkFirewallPolicyModifiedViolation = networkFirewallPolicyModifiedViolation
            self.networkFirewallUnexpectedFirewallRoutesViolation = networkFirewallUnexpectedFirewallRoutesViolation
            self.networkFirewallUnexpectedGatewayRoutesViolation = networkFirewallUnexpectedGatewayRoutesViolation
            self.possibleRemediationActions = possibleRemediationActions
        }
    }

}

extension FmsClientTypes.Route: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case destinationType = "DestinationType"
        case target = "Target"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let destinationType = destinationType {
            try encodeContainer.encode(destinationType.rawValue, forKey: .destinationType)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationTypeDecoded = try containerValues.decodeIfPresent(FmsClientTypes.DestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(FmsClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension FmsClientTypes {
    /// Describes a route in a route table.
    public struct Route: Swift.Equatable {
        /// The destination of the route.
        public var destination: Swift.String?
        /// The type of destination for the route.
        public var destinationType: FmsClientTypes.DestinationType?
        /// The route's target.
        public var target: Swift.String?
        /// The type of target for the route.
        public var targetType: FmsClientTypes.TargetType?

        public init (
            destination: Swift.String? = nil,
            destinationType: FmsClientTypes.DestinationType? = nil,
            target: Swift.String? = nil,
            targetType: FmsClientTypes.TargetType? = nil
        )
        {
            self.destination = destination
            self.destinationType = destinationType
            self.target = target
            self.targetType = targetType
        }
    }

}

extension FmsClientTypes.SecurityGroupRemediationAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case isDefaultAction = "IsDefaultAction"
        case remediationActionType = "RemediationActionType"
        case remediationResult = "RemediationResult"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isDefaultAction != false {
            try encodeContainer.encode(isDefaultAction, forKey: .isDefaultAction)
        }
        if let remediationActionType = remediationActionType {
            try encodeContainer.encode(remediationActionType.rawValue, forKey: .remediationActionType)
        }
        if let remediationResult = remediationResult {
            try encodeContainer.encode(remediationResult, forKey: .remediationResult)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remediationActionTypeDecoded = try containerValues.decodeIfPresent(FmsClientTypes.RemediationActionType.self, forKey: .remediationActionType)
        remediationActionType = remediationActionTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let remediationResultDecoded = try containerValues.decodeIfPresent(FmsClientTypes.SecurityGroupRuleDescription.self, forKey: .remediationResult)
        remediationResult = remediationResultDecoded
        let isDefaultActionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isDefaultAction)
        isDefaultAction = isDefaultActionDecoded
    }
}

extension FmsClientTypes {
    /// Remediation option for the rule specified in the ViolationTarget.
    public struct SecurityGroupRemediationAction: Swift.Equatable {
        /// Brief description of the action that will be performed.
        public var description: Swift.String?
        /// Indicates if the current action is the default action.
        public var isDefaultAction: Swift.Bool
        /// The remediation action that will be performed.
        public var remediationActionType: FmsClientTypes.RemediationActionType?
        /// The final state of the rule specified in the ViolationTarget after it is remediated.
        public var remediationResult: FmsClientTypes.SecurityGroupRuleDescription?

        public init (
            description: Swift.String? = nil,
            isDefaultAction: Swift.Bool = false,
            remediationActionType: FmsClientTypes.RemediationActionType? = nil,
            remediationResult: FmsClientTypes.SecurityGroupRuleDescription? = nil
        )
        {
            self.description = description
            self.isDefaultAction = isDefaultAction
            self.remediationActionType = remediationActionType
            self.remediationResult = remediationResult
        }
    }

}

extension FmsClientTypes.SecurityGroupRuleDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPort = "FromPort"
        case iPV4Range = "IPV4Range"
        case iPV6Range = "IPV6Range"
        case prefixListId = "PrefixListId"
        case `protocol` = "Protocol"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPort = fromPort {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let iPV4Range = iPV4Range {
            try encodeContainer.encode(iPV4Range, forKey: .iPV4Range)
        }
        if let iPV6Range = iPV6Range {
            try encodeContainer.encode(iPV6Range, forKey: .iPV6Range)
        }
        if let prefixListId = prefixListId {
            try encodeContainer.encode(prefixListId, forKey: .prefixListId)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let toPort = toPort {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iPV4RangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iPV4Range)
        iPV4Range = iPV4RangeDecoded
        let iPV6RangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iPV6Range)
        iPV6Range = iPV6RangeDecoded
        let prefixListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefixListId)
        prefixListId = prefixListIdDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let fromPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .toPort)
        toPort = toPortDecoded
    }
}

extension FmsClientTypes {
    /// Describes a set of permissions for a security group rule.
    public struct SecurityGroupRuleDescription: Swift.Equatable {
        /// The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types.
        public var fromPort: Swift.Int?
        /// The IPv4 ranges for the security group rule.
        public var iPV4Range: Swift.String?
        /// The IPv6 ranges for the security group rule.
        public var iPV6Range: Swift.String?
        /// The ID of the prefix list for the security group rule.
        public var prefixListId: Swift.String?
        /// The IP protocol name (tcp, udp, icmp, icmpv6) or number.
        public var `protocol`: Swift.String?
        /// The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes.
        public var toPort: Swift.Int?

        public init (
            fromPort: Swift.Int? = nil,
            iPV4Range: Swift.String? = nil,
            iPV6Range: Swift.String? = nil,
            prefixListId: Swift.String? = nil,
            `protocol`: Swift.String? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.iPV4Range = iPV4Range
            self.iPV6Range = iPV6Range
            self.prefixListId = prefixListId
            self.`protocol` = `protocol`
            self.toPort = toPort
        }
    }

}

extension FmsClientTypes.SecurityServicePolicyData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managedServiceData = "ManagedServiceData"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let managedServiceData = managedServiceData {
            try encodeContainer.encode(managedServiceData, forKey: .managedServiceData)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(FmsClientTypes.SecurityServiceType.self, forKey: .type)
        type = typeDecoded
        let managedServiceDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedServiceData)
        managedServiceData = managedServiceDataDecoded
    }
}

extension FmsClientTypes {
    /// Details about the security service that is being used to protect the resources.
    public struct SecurityServicePolicyData: Swift.Equatable {
        /// Details about the service that are specific to the service type, in JSON format. For service type SHIELD_ADVANCED, this is an empty string.
        ///
        /// * Example: DNS_FIREWALL"{\"type\":\"DNS_FIREWALL\",\"preProcessRuleGroups\":[{\"ruleGroupId\":\"rslvr-frg-1\",\"priority\":10}],\"postProcessRuleGroups\":[{\"ruleGroupId\":\"rslvr-frg-2\",\"priority\":9911}]}" Valid values for preProcessRuleGroups are between 1 and 99. Valid values for postProcessRuleGroups are between 9901 and 10000.
        ///
        /// * Example: NETWORK_FIREWALL"{\"type\":\"NETWORK_FIREWALL\",\"networkFirewallStatelessRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-west-1:1234567891011:stateless-rulegroup/rulegroup2\",\"priority\":10}],\"networkFirewallStatelessDefaultActions\":[\"aws:pass\",\"custom1\"],\"networkFirewallStatelessFragmentDefaultActions\":[\"custom2\",\"aws:pass\"],\"networkFirewallStatelessCustomActions\":[{\"actionName\":\"custom1\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"dimension1\"}]}}},{\"actionName\":\"custom2\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"dimension2\"}]}}}],\"networkFirewallStatefulRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-west-1:1234567891011:stateful-rulegroup/rulegroup1\"}],\"networkFirewallOrchestrationConfig\":{\"singleFirewallEndpointPerVPC\":true,\"allowedIPV4CidrList\":[\"10.24.34.0/28\"]} }"
        ///
        /// * Example: WAFV2"{\"type\":\"WAFV2\",\"preProcessRuleGroups\":[{\"ruleGroupArn\":null,\"overrideAction\":{\"type\":\"NONE\"},\"managedRuleGroupIdentifier\":{\"version\":null,\"vendorName\":\"AWS\",\"managedRuleGroupName\":\"AWSManagedRulesAmazonIpReputationList\"},\"ruleGroupType\":\"ManagedRuleGroup\",\"excludeRules\":[{\"name\":\"NoUserAgent_HEADER\"}]}],\"postProcessRuleGroups\":[],\"defaultAction\":{\"type\":\"ALLOW\"},\"overrideCustomerWebACLAssociation\":false,\"loggingConfiguration\":{\"logDestinationConfigs\":[\"arn:aws:firehose:us-west-2:12345678912:deliverystream/aws-waf-logs-fms-admin-destination\"],\"redactedFields\":[{\"redactedFieldType\":\"SingleHeader\",\"redactedFieldValue\":\"Cookies\"},{\"redactedFieldType\":\"Method\"}]}}" In the loggingConfiguration, you can specify one logDestinationConfigs, you can optionally provide up to 20 redactedFields, and the RedactedFieldType must be one of URI, QUERY_STRING, HEADER, or METHOD.
        ///
        /// * Example: WAF Classic"{\"type\": \"WAF\", \"ruleGroups\": [{\"id\":\"12345678-1bcd-9012-efga-0987654321ab\", \"overrideAction\" : {\"type\": \"COUNT\"}}], \"defaultAction\": {\"type\": \"BLOCK\"}}"
        ///
        /// * Example: SECURITY_GROUPS_COMMON"{\"type\":\"SECURITY_GROUPS_COMMON\",\"revertManualSecurityGroupChanges\":false,\"exclusiveResourceSecurityGroupManagement\":false, \"applyToAllEC2InstanceENIs\":false,\"securityGroups\":[{\"id\":\" sg-000e55995d61a06bd\"}]}"
        ///
        /// * Example: Shared VPCs. Apply the preceding policy to resources in shared VPCs as well as to those in VPCs that the account owns "{\"type\":\"SECURITY_GROUPS_COMMON\",\"revertManualSecurityGroupChanges\":false,\"exclusiveResourceSecurityGroupManagement\":false, \"applyToAllEC2InstanceENIs\":false,\"includeSharedVPC\":true,\"securityGroups\":[{\"id\":\" sg-000e55995d61a06bd\"}]}"
        ///
        /// * Example: SECURITY_GROUPS_CONTENT_AUDIT"{\"type\":\"SECURITY_GROUPS_CONTENT_AUDIT\",\"securityGroups\":[{\"id\":\"sg-000e55995d61a06bd\"}],\"securityGroupAction\":{\"type\":\"ALLOW\"}}" The security group action for content audit can be ALLOW or DENY. For ALLOW, all in-scope security group rules must be within the allowed range of the policy's security group rules. For DENY, all in-scope security group rules must not contain a value or a range that matches a rule value or range in the policy security group.
        ///
        /// * Example: SECURITY_GROUPS_USAGE_AUDIT"{\"type\":\"SECURITY_GROUPS_USAGE_AUDIT\",\"deleteUnusedSecurityGroups\":true,\"coalesceRedundantSecurityGroups\":true}"
        public var managedServiceData: Swift.String?
        /// The service that the policy is using to protect the resources. This specifies the type of policy that is created, either an WAF policy, a Shield Advanced policy, or a security group policy. For security group policies, Firewall Manager supports one security group for each common policy and for each content audit policy. This is an adjustable limit that you can increase by contacting Amazon Web Services Support.
        /// This member is required.
        public var type: FmsClientTypes.SecurityServiceType?

        public init (
            managedServiceData: Swift.String? = nil,
            type: FmsClientTypes.SecurityServiceType? = nil
        )
        {
            self.managedServiceData = managedServiceData
            self.type = type
        }
    }

}

extension FmsClientTypes {
    public enum SecurityServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dnsFirewall
        case networkFirewall
        case securityGroupsCommon
        case securityGroupsContentAudit
        case securityGroupsUsageAudit
        case shieldAdvanced
        case waf
        case wafv2
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityServiceType] {
            return [
                .dnsFirewall,
                .networkFirewall,
                .securityGroupsCommon,
                .securityGroupsContentAudit,
                .securityGroupsUsageAudit,
                .shieldAdvanced,
                .waf,
                .wafv2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dnsFirewall: return "DNS_FIREWALL"
            case .networkFirewall: return "NETWORK_FIREWALL"
            case .securityGroupsCommon: return "SECURITY_GROUPS_COMMON"
            case .securityGroupsContentAudit: return "SECURITY_GROUPS_CONTENT_AUDIT"
            case .securityGroupsUsageAudit: return "SECURITY_GROUPS_USAGE_AUDIT"
            case .shieldAdvanced: return "SHIELD_ADVANCED"
            case .waf: return "WAF"
            case .wafv2: return "WAFV2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SecurityServiceType(rawValue: rawValue) ?? SecurityServiceType.sdkUnknown(rawValue)
        }
    }
}

extension FmsClientTypes.StatefulRuleGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case ruleGroupName = "RuleGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let ruleGroupName = ruleGroupName {
            try encodeContainer.encode(ruleGroupName, forKey: .ruleGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleGroupName)
        ruleGroupName = ruleGroupNameDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension FmsClientTypes {
    /// Network Firewall stateful rule group, used in a [NetworkFirewallPolicyDescription].
    public struct StatefulRuleGroup: Swift.Equatable {
        /// The resource ID of the rule group.
        public var resourceId: Swift.String?
        /// The name of the rule group.
        public var ruleGroupName: Swift.String?

        public init (
            resourceId: Swift.String? = nil,
            ruleGroupName: Swift.String? = nil
        )
        {
            self.resourceId = resourceId
            self.ruleGroupName = ruleGroupName
        }
    }

}

extension FmsClientTypes.StatelessRuleGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case priority = "Priority"
        case resourceId = "ResourceId"
        case ruleGroupName = "RuleGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let ruleGroupName = ruleGroupName {
            try encodeContainer.encode(ruleGroupName, forKey: .ruleGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleGroupName)
        ruleGroupName = ruleGroupNameDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension FmsClientTypes {
    /// Network Firewall stateless rule group, used in a [NetworkFirewallPolicyDescription].
    public struct StatelessRuleGroup: Swift.Equatable {
        /// The priority of the rule group. Network Firewall evaluates the stateless rule groups in a firewall policy starting from the lowest priority setting.
        public var priority: Swift.Int
        /// The resource ID of the rule group.
        public var resourceId: Swift.String?
        /// The name of the rule group.
        public var ruleGroupName: Swift.String?

        public init (
            priority: Swift.Int = 0,
            resourceId: Swift.String? = nil,
            ruleGroupName: Swift.String? = nil
        )
        {
            self.priority = priority
            self.resourceId = resourceId
            self.ruleGroupName = ruleGroupName
        }
    }

}

extension FmsClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FmsClientTypes {
    /// A collection of key:value pairs associated with an Amazon Web Services resource. The key:value pair can be anything you define. Typically, the tag key represents a category (such as "environment") and the tag value represents a specific value within that category (such as "test," "development," or "production"). You can add up to 50 tags to each Amazon Web Services resource.
    public struct Tag: Swift.Equatable {
        /// Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to return tags for. The Firewall Manager resources that support tagging are policies, applications lists, and protocols lists.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tagList: [FmsClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tagList: [FmsClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagList = tagList
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagList: [FmsClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagListContainer = try containerValues.decodeIfPresent([FmsClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[FmsClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [FmsClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension FmsClientTypes {
    public enum TargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case carriergateway
        case egressonlyinternetgateway
        case gateway
        case instance
        case localgateway
        case natgateway
        case networkinterface
        case transitgateway
        case vpcendpoint
        case vpcpeeringconnection
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .carriergateway,
                .egressonlyinternetgateway,
                .gateway,
                .instance,
                .localgateway,
                .natgateway,
                .networkinterface,
                .transitgateway,
                .vpcendpoint,
                .vpcpeeringconnection,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .carriergateway: return "CARRIER_GATEWAY"
            case .egressonlyinternetgateway: return "EGRESS_ONLY_INTERNET_GATEWAY"
            case .gateway: return "GATEWAY"
            case .instance: return "INSTANCE"
            case .localgateway: return "LOCAL_GATEWAY"
            case .natgateway: return "NAT_GATEWAY"
            case .networkinterface: return "NETWORK_INTERFACE"
            case .transitgateway: return "TRANSIT_GATEWAY"
            case .vpcendpoint: return "VPC_ENDPOINT"
            case .vpcpeeringconnection: return "VPC_PEERING_CONNECTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to return tags for. The Firewall Manager resources that support tagging are policies, applications lists, and protocols lists.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension FmsClientTypes.ViolationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
        case resourceDescription = "ResourceDescription"
        case resourceId = "ResourceId"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case resourceViolations = "ResourceViolations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccount = memberAccount {
            try encodeContainer.encode(memberAccount, forKey: .memberAccount)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let resourceDescription = resourceDescription {
            try encodeContainer.encode(resourceDescription, forKey: .resourceDescription)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for taglist0 in resourceTags {
                try resourceTagsContainer.encode(taglist0)
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let resourceViolations = resourceViolations {
            var resourceViolationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceViolations)
            for resourceviolations0 in resourceViolations {
                try resourceViolationsContainer.encode(resourceviolations0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let memberAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccount)
        memberAccount = memberAccountDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceViolationsContainer = try containerValues.decodeIfPresent([FmsClientTypes.ResourceViolation?].self, forKey: .resourceViolations)
        var resourceViolationsDecoded0:[FmsClientTypes.ResourceViolation]? = nil
        if let resourceViolationsContainer = resourceViolationsContainer {
            resourceViolationsDecoded0 = [FmsClientTypes.ResourceViolation]()
            for structure0 in resourceViolationsContainer {
                if let structure0 = structure0 {
                    resourceViolationsDecoded0?.append(structure0)
                }
            }
        }
        resourceViolations = resourceViolationsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([FmsClientTypes.Tag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[FmsClientTypes.Tag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [FmsClientTypes.Tag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let resourceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceDescription)
        resourceDescription = resourceDescriptionDecoded
    }
}

extension FmsClientTypes {
    /// Violations for a resource based on the specified Firewall Manager policy and Amazon Web Services account.
    public struct ViolationDetail: Swift.Equatable {
        /// The Amazon Web Services account that the violation details were requested for.
        /// This member is required.
        public var memberAccount: Swift.String?
        /// The ID of the Firewall Manager policy that the violation details were requested for.
        /// This member is required.
        public var policyId: Swift.String?
        /// Brief description for the requested resource.
        public var resourceDescription: Swift.String?
        /// The resource ID that the violation details were requested for.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The ResourceTag objects associated with the resource.
        public var resourceTags: [FmsClientTypes.Tag]?
        /// The resource type that the violation details were requested for.
        /// This member is required.
        public var resourceType: Swift.String?
        /// List of violations for the requested resource.
        /// This member is required.
        public var resourceViolations: [FmsClientTypes.ResourceViolation]?

        public init (
            memberAccount: Swift.String? = nil,
            policyId: Swift.String? = nil,
            resourceDescription: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceTags: [FmsClientTypes.Tag]? = nil,
            resourceType: Swift.String? = nil,
            resourceViolations: [FmsClientTypes.ResourceViolation]? = nil
        )
        {
            self.memberAccount = memberAccount
            self.policyId = policyId
            self.resourceDescription = resourceDescription
            self.resourceId = resourceId
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.resourceViolations = resourceViolations
        }
    }

}

extension FmsClientTypes {
    public enum ViolationReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case blackholeroutedetected
        case blackholeroutedetectedinfirewallsubnet
        case fmscreatedsecuritygroupedited
        case firewallsubnetmissingexpectedroute
        case internetgatewaymissingexpectedroute
        case internettrafficnotinspected
        case invalidrouteconfiguration
        case missingexpectedroutetable
        case missingfirewall
        case missingfirewallsubnetinaz
        case missingtargetgateway
        case networkfirewallpolicymodified
        case resourceincorrectwebacl
        case resourcemissingdnsfirewall
        case resourcemissingsecuritygroup
        case resourcemissingshieldprotection
        case resourcemissingwebacl
        case resourcemissingwebaclorshieldprotection
        case resourceviolatesauditsecuritygroup
        case securitygroupredundant
        case securitygroupunused
        case trafficinspectioncrossesazboundary
        case unexpectedfirewallroutes
        case unexpectedtargetgatewayroutes
        case webaclmissingrulegroup
        case sdkUnknown(Swift.String)

        public static var allCases: [ViolationReason] {
            return [
                .blackholeroutedetected,
                .blackholeroutedetectedinfirewallsubnet,
                .fmscreatedsecuritygroupedited,
                .firewallsubnetmissingexpectedroute,
                .internetgatewaymissingexpectedroute,
                .internettrafficnotinspected,
                .invalidrouteconfiguration,
                .missingexpectedroutetable,
                .missingfirewall,
                .missingfirewallsubnetinaz,
                .missingtargetgateway,
                .networkfirewallpolicymodified,
                .resourceincorrectwebacl,
                .resourcemissingdnsfirewall,
                .resourcemissingsecuritygroup,
                .resourcemissingshieldprotection,
                .resourcemissingwebacl,
                .resourcemissingwebaclorshieldprotection,
                .resourceviolatesauditsecuritygroup,
                .securitygroupredundant,
                .securitygroupunused,
                .trafficinspectioncrossesazboundary,
                .unexpectedfirewallroutes,
                .unexpectedtargetgatewayroutes,
                .webaclmissingrulegroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .blackholeroutedetected: return "BLACK_HOLE_ROUTE_DETECTED"
            case .blackholeroutedetectedinfirewallsubnet: return "BLACK_HOLE_ROUTE_DETECTED_IN_FIREWALL_SUBNET"
            case .fmscreatedsecuritygroupedited: return "FMS_CREATED_SECURITY_GROUP_EDITED"
            case .firewallsubnetmissingexpectedroute: return "FIREWALL_SUBNET_MISSING_EXPECTED_ROUTE"
            case .internetgatewaymissingexpectedroute: return "INTERNET_GATEWAY_MISSING_EXPECTED_ROUTE"
            case .internettrafficnotinspected: return "INTERNET_TRAFFIC_NOT_INSPECTED"
            case .invalidrouteconfiguration: return "INVALID_ROUTE_CONFIGURATION"
            case .missingexpectedroutetable: return "MISSING_EXPECTED_ROUTE_TABLE"
            case .missingfirewall: return "MISSING_FIREWALL"
            case .missingfirewallsubnetinaz: return "MISSING_FIREWALL_SUBNET_IN_AZ"
            case .missingtargetgateway: return "MISSING_TARGET_GATEWAY"
            case .networkfirewallpolicymodified: return "NETWORK_FIREWALL_POLICY_MODIFIED"
            case .resourceincorrectwebacl: return "RESOURCE_INCORRECT_WEB_ACL"
            case .resourcemissingdnsfirewall: return "RESOURCE_MISSING_DNS_FIREWALL"
            case .resourcemissingsecuritygroup: return "RESOURCE_MISSING_SECURITY_GROUP"
            case .resourcemissingshieldprotection: return "RESOURCE_MISSING_SHIELD_PROTECTION"
            case .resourcemissingwebacl: return "RESOURCE_MISSING_WEB_ACL"
            case .resourcemissingwebaclorshieldprotection: return "RESOURCE_MISSING_WEB_ACL_OR_SHIELD_PROTECTION"
            case .resourceviolatesauditsecuritygroup: return "RESOURCE_VIOLATES_AUDIT_SECURITY_GROUP"
            case .securitygroupredundant: return "SECURITY_GROUP_REDUNDANT"
            case .securitygroupunused: return "SECURITY_GROUP_UNUSED"
            case .trafficinspectioncrossesazboundary: return "TRAFFIC_INSPECTION_CROSSES_AZ_BOUNDARY"
            case .unexpectedfirewallroutes: return "UNEXPECTED_FIREWALL_ROUTES"
            case .unexpectedtargetgatewayroutes: return "UNEXPECTED_TARGET_GATEWAY_ROUTES"
            case .webaclmissingrulegroup: return "WEB_ACL_MISSING_RULE_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ViolationReason(rawValue: rawValue) ?? ViolationReason.sdkUnknown(rawValue)
        }
    }
}
