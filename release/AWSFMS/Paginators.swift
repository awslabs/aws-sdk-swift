// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListAppsListsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAppsListsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAppsListsOutputResponse`
extension FmsClient {
    public func listAppsListsPaginated(input: ListAppsListsInput) -> ClientRuntime.PaginatorSequence<ListAppsListsInput, ListAppsListsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAppsListsInput, ListAppsListsOutputResponse>(input: input, inputKey: \ListAppsListsInput.nextToken, outputKey: \ListAppsListsOutputResponse.nextToken, paginationFunction: self.listAppsLists(input:))
    }
}

extension ListAppsListsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAppsListsInput {
        return ListAppsListsInput(
            defaultLists: self.defaultLists,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAppsListsPaginated`
/// to access the nested member `[FmsClientTypes.AppsListDataSummary]`
/// - Returns: `[FmsClientTypes.AppsListDataSummary]`
extension PaginatorSequence where Input == ListAppsListsInput, Output == ListAppsListsOutputResponse {
    public func appsLists() async throws -> [FmsClientTypes.AppsListDataSummary] {
        return try await self.asyncCompactMap { item in item.appsLists }
    }
}

/// Paginate over `[ListComplianceStatusOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListComplianceStatusInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListComplianceStatusOutputResponse`
extension FmsClient {
    public func listComplianceStatusPaginated(input: ListComplianceStatusInput) -> ClientRuntime.PaginatorSequence<ListComplianceStatusInput, ListComplianceStatusOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListComplianceStatusInput, ListComplianceStatusOutputResponse>(input: input, inputKey: \ListComplianceStatusInput.nextToken, outputKey: \ListComplianceStatusOutputResponse.nextToken, paginationFunction: self.listComplianceStatus(input:))
    }
}

extension ListComplianceStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListComplianceStatusInput {
        return ListComplianceStatusInput(
            maxResults: self.maxResults,
            nextToken: token,
            policyId: self.policyId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listComplianceStatusPaginated`
/// to access the nested member `[FmsClientTypes.PolicyComplianceStatus]`
/// - Returns: `[FmsClientTypes.PolicyComplianceStatus]`
extension PaginatorSequence where Input == ListComplianceStatusInput, Output == ListComplianceStatusOutputResponse {
    public func policyComplianceStatusList() async throws -> [FmsClientTypes.PolicyComplianceStatus] {
        return try await self.asyncCompactMap { item in item.policyComplianceStatusList }
    }
}

/// Paginate over `[ListMemberAccountsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListMemberAccountsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListMemberAccountsOutputResponse`
extension FmsClient {
    public func listMemberAccountsPaginated(input: ListMemberAccountsInput) -> ClientRuntime.PaginatorSequence<ListMemberAccountsInput, ListMemberAccountsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListMemberAccountsInput, ListMemberAccountsOutputResponse>(input: input, inputKey: \ListMemberAccountsInput.nextToken, outputKey: \ListMemberAccountsOutputResponse.nextToken, paginationFunction: self.listMemberAccounts(input:))
    }
}

extension ListMemberAccountsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMemberAccountsInput {
        return ListMemberAccountsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listMemberAccountsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListMemberAccountsInput, Output == ListMemberAccountsOutputResponse {
    public func memberAccounts() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.memberAccounts }
    }
}

/// Paginate over `[ListPoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPoliciesOutputResponse`
extension FmsClient {
    public func listPoliciesPaginated(input: ListPoliciesInput) -> ClientRuntime.PaginatorSequence<ListPoliciesInput, ListPoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPoliciesInput, ListPoliciesOutputResponse>(input: input, inputKey: \ListPoliciesInput.nextToken, outputKey: \ListPoliciesOutputResponse.nextToken, paginationFunction: self.listPolicies(input:))
    }
}

extension ListPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPoliciesInput {
        return ListPoliciesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPoliciesPaginated`
/// to access the nested member `[FmsClientTypes.PolicySummary]`
/// - Returns: `[FmsClientTypes.PolicySummary]`
extension PaginatorSequence where Input == ListPoliciesInput, Output == ListPoliciesOutputResponse {
    public func policyList() async throws -> [FmsClientTypes.PolicySummary] {
        return try await self.asyncCompactMap { item in item.policyList }
    }
}

/// Paginate over `[ListProtocolsListsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListProtocolsListsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListProtocolsListsOutputResponse`
extension FmsClient {
    public func listProtocolsListsPaginated(input: ListProtocolsListsInput) -> ClientRuntime.PaginatorSequence<ListProtocolsListsInput, ListProtocolsListsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListProtocolsListsInput, ListProtocolsListsOutputResponse>(input: input, inputKey: \ListProtocolsListsInput.nextToken, outputKey: \ListProtocolsListsOutputResponse.nextToken, paginationFunction: self.listProtocolsLists(input:))
    }
}

extension ListProtocolsListsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProtocolsListsInput {
        return ListProtocolsListsInput(
            defaultLists: self.defaultLists,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listProtocolsListsPaginated`
/// to access the nested member `[FmsClientTypes.ProtocolsListDataSummary]`
/// - Returns: `[FmsClientTypes.ProtocolsListDataSummary]`
extension PaginatorSequence where Input == ListProtocolsListsInput, Output == ListProtocolsListsOutputResponse {
    public func protocolsLists() async throws -> [FmsClientTypes.ProtocolsListDataSummary] {
        return try await self.asyncCompactMap { item in item.protocolsLists }
    }
}

/// Paginate over `[ListThirdPartyFirewallFirewallPoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListThirdPartyFirewallFirewallPoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListThirdPartyFirewallFirewallPoliciesOutputResponse`
extension FmsClient {
    public func listThirdPartyFirewallFirewallPoliciesPaginated(input: ListThirdPartyFirewallFirewallPoliciesInput) -> ClientRuntime.PaginatorSequence<ListThirdPartyFirewallFirewallPoliciesInput, ListThirdPartyFirewallFirewallPoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListThirdPartyFirewallFirewallPoliciesInput, ListThirdPartyFirewallFirewallPoliciesOutputResponse>(input: input, inputKey: \ListThirdPartyFirewallFirewallPoliciesInput.nextToken, outputKey: \ListThirdPartyFirewallFirewallPoliciesOutputResponse.nextToken, paginationFunction: self.listThirdPartyFirewallFirewallPolicies(input:))
    }
}

extension ListThirdPartyFirewallFirewallPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThirdPartyFirewallFirewallPoliciesInput {
        return ListThirdPartyFirewallFirewallPoliciesInput(
            maxResults: self.maxResults,
            nextToken: token,
            thirdPartyFirewall: self.thirdPartyFirewall
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listThirdPartyFirewallFirewallPoliciesPaginated`
/// to access the nested member `[FmsClientTypes.ThirdPartyFirewallFirewallPolicy]`
/// - Returns: `[FmsClientTypes.ThirdPartyFirewallFirewallPolicy]`
extension PaginatorSequence where Input == ListThirdPartyFirewallFirewallPoliciesInput, Output == ListThirdPartyFirewallFirewallPoliciesOutputResponse {
    public func thirdPartyFirewallFirewallPolicies() async throws -> [FmsClientTypes.ThirdPartyFirewallFirewallPolicy] {
        return try await self.asyncCompactMap { item in item.thirdPartyFirewallFirewallPolicies }
    }
}
