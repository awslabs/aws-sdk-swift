// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SsmContactsClientTypes {
    public enum AcceptCodeValidation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enforce
        case ignore
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceptCodeValidation] {
            return [
                .enforce,
                .ignore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enforce: return "ENFORCE"
            case .ignore: return "IGNORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AcceptCodeValidation(rawValue: rawValue) ?? AcceptCodeValidation.sdkUnknown(rawValue)
        }
    }
}

extension AcceptPageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptCode = "AcceptCode"
        case acceptCodeValidation = "AcceptCodeValidation"
        case acceptType = "AcceptType"
        case contactChannelId = "ContactChannelId"
        case note = "Note"
        case pageId = "PageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptCode = acceptCode {
            try encodeContainer.encode(acceptCode, forKey: .acceptCode)
        }
        if let acceptCodeValidation = acceptCodeValidation {
            try encodeContainer.encode(acceptCodeValidation.rawValue, forKey: .acceptCodeValidation)
        }
        if let acceptType = acceptType {
            try encodeContainer.encode(acceptType.rawValue, forKey: .acceptType)
        }
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let pageId = pageId {
            try encodeContainer.encode(pageId, forKey: .pageId)
        }
    }
}

extension AcceptPageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AcceptPageInput: Swift.Equatable {
    /// The accept code is a 6-digit code used to acknowledge the page.
    /// This member is required.
    public var acceptCode: Swift.String?
    /// An optional field that Incident Manager uses to ENFORCEAcceptCode validation when acknowledging an page. Acknowledgement can occur by replying to a page, or when entering the AcceptCode in the console. Enforcing AcceptCode validation causes Incident Manager to verify that the code entered by the user matches the code sent by Incident Manager with the page. Incident Manager can also IGNOREAcceptCode validation. Ignoring AcceptCode validation causes Incident Manager to accept any value entered for the AcceptCode.
    public var acceptCodeValidation: SsmContactsClientTypes.AcceptCodeValidation?
    /// The type indicates if the page was DELIVERED or READ.
    /// This member is required.
    public var acceptType: SsmContactsClientTypes.AcceptType?
    /// The ARN of the contact channel.
    public var contactChannelId: Swift.String?
    /// Information provided by the user when the user acknowledges the page.
    public var note: Swift.String?
    /// The Amazon Resource Name (ARN) of the engagement to a contact channel.
    /// This member is required.
    public var pageId: Swift.String?

    public init (
        acceptCode: Swift.String? = nil,
        acceptCodeValidation: SsmContactsClientTypes.AcceptCodeValidation? = nil,
        acceptType: SsmContactsClientTypes.AcceptType? = nil,
        contactChannelId: Swift.String? = nil,
        note: Swift.String? = nil,
        pageId: Swift.String? = nil
    )
    {
        self.acceptCode = acceptCode
        self.acceptCodeValidation = acceptCodeValidation
        self.acceptType = acceptType
        self.contactChannelId = contactChannelId
        self.note = note
        self.pageId = pageId
    }
}

struct AcceptPageInputBody: Swift.Equatable {
    let pageId: Swift.String?
    let contactChannelId: Swift.String?
    let acceptType: SsmContactsClientTypes.AcceptType?
    let note: Swift.String?
    let acceptCode: Swift.String?
    let acceptCodeValidation: SsmContactsClientTypes.AcceptCodeValidation?
}

extension AcceptPageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptCode = "AcceptCode"
        case acceptCodeValidation = "AcceptCodeValidation"
        case acceptType = "AcceptType"
        case contactChannelId = "ContactChannelId"
        case note = "Note"
        case pageId = "PageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageId)
        pageId = pageIdDecoded
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let acceptTypeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.AcceptType.self, forKey: .acceptType)
        acceptType = acceptTypeDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
        let acceptCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptCode)
        acceptCode = acceptCodeDecoded
        let acceptCodeValidationDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.AcceptCodeValidation.self, forKey: .acceptCodeValidation)
        acceptCodeValidation = acceptCodeValidationDecoded
    }
}

extension AcceptPageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptPageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptPageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptPageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AcceptPageOutputResponse: Swift.Equatable {

}

extension SsmContactsClientTypes {
    public enum AcceptType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delivered
        case read
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceptType] {
            return [
                .delivered,
                .read,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delivered: return "DELIVERED"
            case .read: return "READ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AcceptType(rawValue: rawValue) ?? AcceptType.sdkUnknown(rawValue)
        }
    }
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have sufficient access to perform this operation.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ActivateContactChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationCode = "ActivationCode"
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationCode = activationCode {
            try encodeContainer.encode(activationCode, forKey: .activationCode)
        }
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

extension ActivateContactChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ActivateContactChannelInput: Swift.Equatable {
    /// The code sent to the contact channel when it was created in the contact.
    /// This member is required.
    public var activationCode: Swift.String?
    /// The Amazon Resource Name (ARN) of the contact channel.
    /// This member is required.
    public var contactChannelId: Swift.String?

    public init (
        activationCode: Swift.String? = nil,
        contactChannelId: Swift.String? = nil
    )
    {
        self.activationCode = activationCode
        self.contactChannelId = contactChannelId
    }
}

struct ActivateContactChannelInputBody: Swift.Equatable {
    let contactChannelId: Swift.String?
    let activationCode: Swift.String?
}

extension ActivateContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationCode = "ActivationCode"
        case contactChannelId = "ContactChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let activationCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationCode)
        activationCode = activationCodeDecoded
    }
}

extension ActivateContactChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateContactChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ActivateContactChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateContactChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ActivateContactChannelOutputResponse: Swift.Equatable {

}

extension SsmContactsClientTypes {
    public enum ActivationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activated
        case notActivated
        case sdkUnknown(Swift.String)

        public static var allCases: [ActivationStatus] {
            return [
                .activated,
                .notActivated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .notActivated: return "NOT_ACTIVATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActivationStatus(rawValue: rawValue) ?? ActivationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmContactsClientTypes.ChannelTargetInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
        case retryIntervalInMinutes = "RetryIntervalInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
        if let retryIntervalInMinutes = retryIntervalInMinutes {
            try encodeContainer.encode(retryIntervalInMinutes, forKey: .retryIntervalInMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let retryIntervalInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryIntervalInMinutes)
        retryIntervalInMinutes = retryIntervalInMinutesDecoded
    }
}

extension SsmContactsClientTypes {
    /// Information about the contact channel that Incident Manager uses to engage the contact.
    public struct ChannelTargetInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the contact channel.
        /// This member is required.
        public var contactChannelId: Swift.String?
        /// The number of minutes to wait to retry sending engagement in the case the engagement initially fails.
        public var retryIntervalInMinutes: Swift.Int?

        public init (
            contactChannelId: Swift.String? = nil,
            retryIntervalInMinutes: Swift.Int? = nil
        )
        {
            self.contactChannelId = contactChannelId
            self.retryIntervalInMinutes = retryIntervalInMinutes
        }
    }

}

extension SsmContactsClientTypes {
    public enum ChannelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelType] {
            return [
                .email,
                .sms,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .sms: return "SMS"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelType(rawValue: rawValue) ?? ChannelType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Updating or deleting a resource causes an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Identifier of the resource in use
    /// This member is required.
    public var resourceId: Swift.String?
    /// ype of the resource in use
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SsmContactsClientTypes.Contact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SsmContactsClientTypes {
    /// A personal contact or escalation plan that Incident Manager engages during an incident.
    public struct Contact: Swift.Equatable {
        /// The unique and identifiable alias of the contact or escalation plan.
        /// This member is required.
        public var alias: Swift.String?
        /// The Amazon Resource Name (ARN) of the contact or escalation plan.
        /// This member is required.
        public var contactArn: Swift.String?
        /// The full name of the contact or escalation plan.
        public var displayName: Swift.String?
        /// Refers to the type of contact. A single contact is type PERSONAL and an escalation plan is type ESCALATION.
        /// This member is required.
        public var type: SsmContactsClientTypes.ContactType?

        public init (
            alias: Swift.String? = nil,
            contactArn: Swift.String? = nil,
            displayName: Swift.String? = nil,
            type: SsmContactsClientTypes.ContactType? = nil
        )
        {
            self.alias = alias
            self.contactArn = contactArn
            self.displayName = displayName
            self.type = type
        }
    }

}

extension SsmContactsClientTypes.ContactChannel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationStatus = "ActivationStatus"
        case contactArn = "ContactArn"
        case contactChannelArn = "ContactChannelArn"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationStatus = activationStatus {
            try encodeContainer.encode(activationStatus.rawValue, forKey: .activationStatus)
        }
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let contactChannelArn = contactChannelArn {
            try encodeContainer.encode(contactChannelArn, forKey: .contactChannelArn)
        }
        if let deliveryAddress = deliveryAddress {
            try encodeContainer.encode(deliveryAddress, forKey: .deliveryAddress)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
        let activationStatusDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ActivationStatus.self, forKey: .activationStatus)
        activationStatus = activationStatusDecoded
    }
}

extension SsmContactsClientTypes {
    /// The method that Incident Manager uses to engage a contact.
    public struct ContactChannel: Swift.Equatable {
        /// A Boolean value describing if the contact channel has been activated or not. If the contact channel isn't activated, Incident Manager can't engage the contact through it.
        /// This member is required.
        public var activationStatus: SsmContactsClientTypes.ActivationStatus?
        /// The ARN of the contact that contains the contact channel.
        /// This member is required.
        public var contactArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the contact channel.
        /// This member is required.
        public var contactChannelArn: Swift.String?
        /// The details that Incident Manager uses when trying to engage the contact channel.
        /// This member is required.
        public var deliveryAddress: SsmContactsClientTypes.ContactChannelAddress?
        /// The name of the contact channel.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the contact channel. Incident Manager supports three contact methods:
        ///
        /// * SMS
        ///
        /// * VOICE
        ///
        /// * EMAIL
        public var type: SsmContactsClientTypes.ChannelType?

        public init (
            activationStatus: SsmContactsClientTypes.ActivationStatus? = nil,
            contactArn: Swift.String? = nil,
            contactChannelArn: Swift.String? = nil,
            deliveryAddress: SsmContactsClientTypes.ContactChannelAddress? = nil,
            name: Swift.String? = nil,
            type: SsmContactsClientTypes.ChannelType? = nil
        )
        {
            self.activationStatus = activationStatus
            self.contactArn = contactArn
            self.contactChannelArn = contactChannelArn
            self.deliveryAddress = deliveryAddress
            self.name = name
            self.type = type
        }
    }

}

extension SsmContactsClientTypes.ContactChannelAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simpleAddress = "SimpleAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleAddress = simpleAddress {
            try encodeContainer.encode(simpleAddress, forKey: .simpleAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simpleAddress)
        simpleAddress = simpleAddressDecoded
    }
}

extension SsmContactsClientTypes {
    /// The details that Incident Manager uses when trying to engage the contact channel.
    public struct ContactChannelAddress: Swift.Equatable {
        /// The format is dependent on the type of the contact channel. The following are the expected formats:
        ///
        /// * SMS - '+' followed by the country code and phone number
        ///
        /// * VOICE - '+' followed by the country code and phone number
        ///
        /// * EMAIL - any standard email format
        public var simpleAddress: Swift.String?

        public init (
            simpleAddress: Swift.String? = nil
        )
        {
            self.simpleAddress = simpleAddress
        }
    }

}

extension SsmContactsClientTypes.ContactTargetInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case isEssential = "IsEssential"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let isEssential = isEssential {
            try encodeContainer.encode(isEssential, forKey: .isEssential)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let isEssentialDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEssential)
        isEssential = isEssentialDecoded
    }
}

extension SsmContactsClientTypes {
    /// The contact that Incident Manager is engaging during an incident.
    public struct ContactTargetInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the contact.
        public var contactId: Swift.String?
        /// A Boolean value determining if the contact's acknowledgement stops the progress of stages in the plan.
        /// This member is required.
        public var isEssential: Swift.Bool?

        public init (
            contactId: Swift.String? = nil,
            isEssential: Swift.Bool? = nil
        )
        {
            self.contactId = contactId
            self.isEssential = isEssential
        }
    }

}

extension SsmContactsClientTypes {
    public enum ContactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case escalation
        case personal
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactType] {
            return [
                .escalation,
                .personal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .escalation: return "ESCALATION"
            case .personal: return "PERSONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactType(rawValue: rawValue) ?? ContactType.sdkUnknown(rawValue)
        }
    }
}

extension CreateContactChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case deferActivation = "DeferActivation"
        case deliveryAddress = "DeliveryAddress"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let deferActivation = deferActivation {
            try encodeContainer.encode(deferActivation, forKey: .deferActivation)
        }
        if let deliveryAddress = deliveryAddress {
            try encodeContainer.encode(deliveryAddress, forKey: .deliveryAddress)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateContactChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateContactChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact you are adding the contact channel to.
    /// This member is required.
    public var contactId: Swift.String?
    /// If you want to activate the channel at a later time, you can choose to defer activation. Incident Manager can't engage your contact channel until it has been activated.
    public var deferActivation: Swift.Bool?
    /// The details that Incident Manager uses when trying to engage the contact channel. The format is dependent on the type of the contact channel. The following are the expected formats:
    ///
    /// * SMS - '+' followed by the country code and phone number
    ///
    /// * VOICE - '+' followed by the country code and phone number
    ///
    /// * EMAIL - any standard email format
    /// This member is required.
    public var deliveryAddress: SsmContactsClientTypes.ContactChannelAddress?
    /// A token ensuring that the operation is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// The name of the contact channel.
    /// This member is required.
    public var name: Swift.String?
    /// Incident Manager supports three types of contact channels:
    ///
    /// * SMS
    ///
    /// * VOICE
    ///
    /// * EMAIL
    /// This member is required.
    public var type: SsmContactsClientTypes.ChannelType?

    public init (
        contactId: Swift.String? = nil,
        deferActivation: Swift.Bool? = nil,
        deliveryAddress: SsmContactsClientTypes.ContactChannelAddress? = nil,
        idempotencyToken: Swift.String? = nil,
        name: Swift.String? = nil,
        type: SsmContactsClientTypes.ChannelType? = nil
    )
    {
        self.contactId = contactId
        self.deferActivation = deferActivation
        self.deliveryAddress = deliveryAddress
        self.idempotencyToken = idempotencyToken
        self.name = name
        self.type = type
    }
}

struct CreateContactChannelInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let name: Swift.String?
    let type: SsmContactsClientTypes.ChannelType?
    let deliveryAddress: SsmContactsClientTypes.ContactChannelAddress?
    let deferActivation: Swift.Bool?
    let idempotencyToken: Swift.String?
}

extension CreateContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case deferActivation = "DeferActivation"
        case deliveryAddress = "DeliveryAddress"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
        let deferActivationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deferActivation)
        deferActivation = deferActivationDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateContactChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContactChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContactChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContactChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateContactChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactChannelArn = output.contactChannelArn
        } else {
            self.contactChannelArn = nil
        }
    }
}

public struct CreateContactChannelOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel.
    /// This member is required.
    public var contactChannelArn: Swift.String?

    public init (
        contactChannelArn: Swift.String? = nil
    )
    {
        self.contactChannelArn = contactChannelArn
    }
}

struct CreateContactChannelOutputResponseBody: Swift.Equatable {
    let contactChannelArn: Swift.String?
}

extension CreateContactChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelArn = "ContactChannelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
    }
}

extension CreateContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case displayName = "DisplayName"
        case idempotencyToken = "IdempotencyToken"
        case plan = "Plan"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let plan = plan {
            try encodeContainer.encode(plan, forKey: .plan)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagslist0 in tags {
                try tagsContainer.encode(tagslist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateContactInput: Swift.Equatable {
    /// The short name to quickly identify a contact or escalation plan. The contact alias must be unique and identifiable.
    /// This member is required.
    public var alias: Swift.String?
    /// The full name of the contact or escalation plan.
    public var displayName: Swift.String?
    /// A token ensuring that the operation is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// A list of stages. A contact has an engagement plan with stages that contact specified contact channels. An escalation plan uses stages that contact specified contacts.
    /// This member is required.
    public var plan: SsmContactsClientTypes.Plan?
    /// Adds a tag to the target. You can only tag resources created in the first Region of your replication set.
    public var tags: [SsmContactsClientTypes.Tag]?
    /// To create an escalation plan use ESCALATION. To create a contact use PERSONAL.
    /// This member is required.
    public var type: SsmContactsClientTypes.ContactType?

    public init (
        alias: Swift.String? = nil,
        displayName: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        plan: SsmContactsClientTypes.Plan? = nil,
        tags: [SsmContactsClientTypes.Tag]? = nil,
        type: SsmContactsClientTypes.ContactType? = nil
    )
    {
        self.alias = alias
        self.displayName = displayName
        self.idempotencyToken = idempotencyToken
        self.plan = plan
        self.tags = tags
        self.type = type
    }
}

struct CreateContactInputBody: Swift.Equatable {
    let alias: Swift.String?
    let displayName: Swift.String?
    let type: SsmContactsClientTypes.ContactType?
    let plan: SsmContactsClientTypes.Plan?
    let tags: [SsmContactsClientTypes.Tag]?
    let idempotencyToken: Swift.String?
}

extension CreateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case displayName = "DisplayName"
        case idempotencyToken = "IdempotencyToken"
        case plan = "Plan"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactType.self, forKey: .type)
        type = typeDecoded
        let planDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.Plan.self, forKey: .plan)
        plan = planDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmContactsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmContactsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
        } else {
            self.contactArn = nil
        }
    }
}

public struct CreateContactOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created contact or escalation plan.
    /// This member is required.
    public var contactArn: Swift.String?

    public init (
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct CreateContactOutputResponseBody: Swift.Equatable {
    let contactArn: Swift.String?
}

extension CreateContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension DataEncryptionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DataEncryptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed to due an encryption key error.
public struct DataEncryptionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DataEncryptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DataEncryptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeactivateContactChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

extension DeactivateContactChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeactivateContactChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel you're deactivating.
    /// This member is required.
    public var contactChannelId: Swift.String?

    public init (
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct DeactivateContactChannelInputBody: Swift.Equatable {
    let contactChannelId: Swift.String?
}

extension DeactivateContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension DeactivateContactChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeactivateContactChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeactivateContactChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeactivateContactChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeactivateContactChannelOutputResponse: Swift.Equatable {

}

extension DeleteContactChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

extension DeleteContactChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteContactChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel.
    /// This member is required.
    public var contactChannelId: Swift.String?

    public init (
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct DeleteContactChannelInputBody: Swift.Equatable {
    let contactChannelId: Swift.String?
}

extension DeleteContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension DeleteContactChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContactChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContactChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContactChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContactChannelOutputResponse: Swift.Equatable {

}

extension DeleteContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
    }
}

extension DeleteContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteContactInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact that you're deleting.
    /// This member is required.
    public var contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct DeleteContactInputBody: Swift.Equatable {
    let contactId: Swift.String?
}

extension DeleteContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension DeleteContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContactOutputResponse: Swift.Equatable {

}

extension DescribeEngagementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engagementId = engagementId {
            try encodeContainer.encode(engagementId, forKey: .engagementId)
        }
    }
}

extension DescribeEngagementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEngagementInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the engagement you want the details of.
    /// This member is required.
    public var engagementId: Swift.String?

    public init (
        engagementId: Swift.String? = nil
    )
    {
        self.engagementId = engagementId
    }
}

struct DescribeEngagementInputBody: Swift.Equatable {
    let engagementId: Swift.String?
}

extension DescribeEngagementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementId)
        engagementId = engagementIdDecoded
    }
}

extension DescribeEngagementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEngagementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEngagementOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEngagementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEngagementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
            self.content = output.content
            self.engagementArn = output.engagementArn
            self.incidentId = output.incidentId
            self.publicContent = output.publicContent
            self.publicSubject = output.publicSubject
            self.sender = output.sender
            self.startTime = output.startTime
            self.stopTime = output.stopTime
            self.subject = output.subject
        } else {
            self.contactArn = nil
            self.content = nil
            self.engagementArn = nil
            self.incidentId = nil
            self.publicContent = nil
            self.publicSubject = nil
            self.sender = nil
            self.startTime = nil
            self.stopTime = nil
            self.subject = nil
        }
    }
}

public struct DescribeEngagementOutputResponse: Swift.Equatable {
    /// The ARN of the escalation plan or contacts involved in the engagement.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The secure content of the message that was sent to the contact. Use this field for engagements to VOICE and EMAIL.
    /// This member is required.
    public var content: Swift.String?
    /// The ARN of the engagement.
    /// This member is required.
    public var engagementArn: Swift.String?
    /// The ARN of the incident in which the engagement occurred.
    public var incidentId: Swift.String?
    /// The insecure content of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicContent: Swift.String?
    /// The insecure subject of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicSubject: Swift.String?
    /// The user that started the engagement.
    /// This member is required.
    public var sender: Swift.String?
    /// The time that the engagement started.
    public var startTime: ClientRuntime.Date?
    /// The time that the engagement ended.
    public var stopTime: ClientRuntime.Date?
    /// The secure subject of the message that was sent to the contact. Use this field for engagements to VOICE and EMAIL.
    /// This member is required.
    public var subject: Swift.String?

    public init (
        contactArn: Swift.String? = nil,
        content: Swift.String? = nil,
        engagementArn: Swift.String? = nil,
        incidentId: Swift.String? = nil,
        publicContent: Swift.String? = nil,
        publicSubject: Swift.String? = nil,
        sender: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        stopTime: ClientRuntime.Date? = nil,
        subject: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.content = content
        self.engagementArn = engagementArn
        self.incidentId = incidentId
        self.publicContent = publicContent
        self.publicSubject = publicSubject
        self.sender = sender
        self.startTime = startTime
        self.stopTime = stopTime
        self.subject = subject
    }
}

struct DescribeEngagementOutputResponseBody: Swift.Equatable {
    let contactArn: Swift.String?
    let engagementArn: Swift.String?
    let sender: Swift.String?
    let subject: Swift.String?
    let content: Swift.String?
    let publicSubject: Swift.String?
    let publicContent: Swift.String?
    let incidentId: Swift.String?
    let startTime: ClientRuntime.Date?
    let stopTime: ClientRuntime.Date?
}

extension DescribeEngagementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case content = "Content"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case sender = "Sender"
        case startTime = "StartTime"
        case stopTime = "StopTime"
        case subject = "Subject"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let engagementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sender)
        sender = senderDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let publicSubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicSubject)
        publicSubject = publicSubjectDecoded
        let publicContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicContent)
        publicContent = publicContentDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

extension DescribePageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageId = "PageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pageId = pageId {
            try encodeContainer.encode(pageId, forKey: .pageId)
        }
    }
}

extension DescribePageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePageInput: Swift.Equatable {
    /// The ID of the engagement to a contact channel.
    /// This member is required.
    public var pageId: Swift.String?

    public init (
        pageId: Swift.String? = nil
    )
    {
        self.pageId = pageId
    }
}

struct DescribePageInputBody: Swift.Equatable {
    let pageId: Swift.String?
}

extension DescribePageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageId = "PageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageId)
        pageId = pageIdDecoded
    }
}

extension DescribePageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
            self.content = output.content
            self.deliveryTime = output.deliveryTime
            self.engagementArn = output.engagementArn
            self.incidentId = output.incidentId
            self.pageArn = output.pageArn
            self.publicContent = output.publicContent
            self.publicSubject = output.publicSubject
            self.readTime = output.readTime
            self.sender = output.sender
            self.sentTime = output.sentTime
            self.subject = output.subject
        } else {
            self.contactArn = nil
            self.content = nil
            self.deliveryTime = nil
            self.engagementArn = nil
            self.incidentId = nil
            self.pageArn = nil
            self.publicContent = nil
            self.publicSubject = nil
            self.readTime = nil
            self.sender = nil
            self.sentTime = nil
            self.subject = nil
        }
    }
}

public struct DescribePageOutputResponse: Swift.Equatable {
    /// The ARN of the contact that was engaged.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The secure content of the message that was sent to the contact. Use this field for engagements to VOICE and EMAIL.
    /// This member is required.
    public var content: Swift.String?
    /// The time that the contact channel received the engagement.
    public var deliveryTime: ClientRuntime.Date?
    /// The ARN of the engagement that engaged the contact channel.
    /// This member is required.
    public var engagementArn: Swift.String?
    /// The ARN of the incident that engaged the contact channel.
    public var incidentId: Swift.String?
    /// The Amazon Resource Name (ARN) of the engagement to a contact channel.
    /// This member is required.
    public var pageArn: Swift.String?
    /// The insecure content of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicContent: Swift.String?
    /// The insecure subject of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicSubject: Swift.String?
    /// The time that the contact channel acknowledged the engagement.
    public var readTime: ClientRuntime.Date?
    /// The user that started the engagement.
    /// This member is required.
    public var sender: Swift.String?
    /// The time the engagement was sent to the contact channel.
    public var sentTime: ClientRuntime.Date?
    /// The secure subject of the message that was sent to the contact. Use this field for engagements to VOICE and EMAIL.
    /// This member is required.
    public var subject: Swift.String?

    public init (
        contactArn: Swift.String? = nil,
        content: Swift.String? = nil,
        deliveryTime: ClientRuntime.Date? = nil,
        engagementArn: Swift.String? = nil,
        incidentId: Swift.String? = nil,
        pageArn: Swift.String? = nil,
        publicContent: Swift.String? = nil,
        publicSubject: Swift.String? = nil,
        readTime: ClientRuntime.Date? = nil,
        sender: Swift.String? = nil,
        sentTime: ClientRuntime.Date? = nil,
        subject: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.content = content
        self.deliveryTime = deliveryTime
        self.engagementArn = engagementArn
        self.incidentId = incidentId
        self.pageArn = pageArn
        self.publicContent = publicContent
        self.publicSubject = publicSubject
        self.readTime = readTime
        self.sender = sender
        self.sentTime = sentTime
        self.subject = subject
    }
}

struct DescribePageOutputResponseBody: Swift.Equatable {
    let pageArn: Swift.String?
    let engagementArn: Swift.String?
    let contactArn: Swift.String?
    let sender: Swift.String?
    let subject: Swift.String?
    let content: Swift.String?
    let publicSubject: Swift.String?
    let publicContent: Swift.String?
    let incidentId: Swift.String?
    let sentTime: ClientRuntime.Date?
    let readTime: ClientRuntime.Date?
    let deliveryTime: ClientRuntime.Date?
}

extension DescribePageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case content = "Content"
        case deliveryTime = "DeliveryTime"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case pageArn = "PageArn"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case readTime = "ReadTime"
        case sender = "Sender"
        case sentTime = "SentTime"
        case subject = "Subject"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageArn)
        pageArn = pageArnDecoded
        let engagementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sender)
        sender = senderDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let publicSubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicSubject)
        publicSubject = publicSubjectDecoded
        let publicContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicContent)
        publicContent = publicContentDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let sentTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .sentTime)
        sentTime = sentTimeDecoded
        let readTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .readTime)
        readTime = readTimeDecoded
        let deliveryTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deliveryTime)
        deliveryTime = deliveryTimeDecoded
    }
}

extension SsmContactsClientTypes.Engagement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case sender = "Sender"
        case startTime = "StartTime"
        case stopTime = "StopTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let engagementArn = engagementArn {
            try encodeContainer.encode(engagementArn, forKey: .engagementArn)
        }
        if let incidentId = incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let sender = sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let stopTime = stopTime {
            try encodeContainer.encode(stopTime.timeIntervalSince1970, forKey: .stopTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sender)
        sender = senderDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

extension SsmContactsClientTypes {
    /// Incident Manager reaching out to a contact or escalation plan to engage contact during an incident.
    public struct Engagement: Swift.Equatable {
        /// The ARN of the escalation plan or contact that Incident Manager is engaging.
        /// This member is required.
        public var contactArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the engagement.
        /// This member is required.
        public var engagementArn: Swift.String?
        /// The ARN of the incident that's engaging the contact.
        public var incidentId: Swift.String?
        /// The user that started the engagement.
        /// This member is required.
        public var sender: Swift.String?
        /// The time that the engagement began.
        public var startTime: ClientRuntime.Date?
        /// The time that the engagement ended.
        public var stopTime: ClientRuntime.Date?

        public init (
            contactArn: Swift.String? = nil,
            engagementArn: Swift.String? = nil,
            incidentId: Swift.String? = nil,
            sender: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            stopTime: ClientRuntime.Date? = nil
        )
        {
            self.contactArn = contactArn
            self.engagementArn = engagementArn
            self.incidentId = incidentId
            self.sender = sender
            self.startTime = startTime
            self.stopTime = stopTime
        }
    }

}

extension GetContactChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

extension GetContactChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetContactChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel you want information about.
    /// This member is required.
    public var contactChannelId: Swift.String?

    public init (
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct GetContactChannelInputBody: Swift.Equatable {
    let contactChannelId: Swift.String?
}

extension GetContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension GetContactChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetContactChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activationStatus = output.activationStatus
            self.contactArn = output.contactArn
            self.contactChannelArn = output.contactChannelArn
            self.deliveryAddress = output.deliveryAddress
            self.name = output.name
            self.type = output.type
        } else {
            self.activationStatus = nil
            self.contactArn = nil
            self.contactChannelArn = nil
            self.deliveryAddress = nil
            self.name = nil
            self.type = nil
        }
    }
}

public struct GetContactChannelOutputResponse: Swift.Equatable {
    /// A Boolean value indicating if the contact channel has been activated or not.
    public var activationStatus: SsmContactsClientTypes.ActivationStatus?
    /// The ARN of the contact that the channel belongs to.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The ARN of the contact channel.
    /// This member is required.
    public var contactChannelArn: Swift.String?
    /// The details that Incident Manager uses when trying to engage the contact channel.
    /// This member is required.
    public var deliveryAddress: SsmContactsClientTypes.ContactChannelAddress?
    /// The name of the contact channel
    /// This member is required.
    public var name: Swift.String?
    /// The type of contact channel. The type is SMS, VOICE, or EMAIL.
    /// This member is required.
    public var type: SsmContactsClientTypes.ChannelType?

    public init (
        activationStatus: SsmContactsClientTypes.ActivationStatus? = nil,
        contactArn: Swift.String? = nil,
        contactChannelArn: Swift.String? = nil,
        deliveryAddress: SsmContactsClientTypes.ContactChannelAddress? = nil,
        name: Swift.String? = nil,
        type: SsmContactsClientTypes.ChannelType? = nil
    )
    {
        self.activationStatus = activationStatus
        self.contactArn = contactArn
        self.contactChannelArn = contactChannelArn
        self.deliveryAddress = deliveryAddress
        self.name = name
        self.type = type
    }
}

struct GetContactChannelOutputResponseBody: Swift.Equatable {
    let contactArn: Swift.String?
    let contactChannelArn: Swift.String?
    let name: Swift.String?
    let type: SsmContactsClientTypes.ChannelType?
    let deliveryAddress: SsmContactsClientTypes.ContactChannelAddress?
    let activationStatus: SsmContactsClientTypes.ActivationStatus?
}

extension GetContactChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationStatus = "ActivationStatus"
        case contactArn = "ContactArn"
        case contactChannelArn = "ContactChannelArn"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
        let activationStatusDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ActivationStatus.self, forKey: .activationStatus)
        activationStatus = activationStatusDecoded
    }
}

extension GetContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
    }
}

extension GetContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetContactInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct GetContactInputBody: Swift.Equatable {
    let contactId: Swift.String?
}

extension GetContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension GetContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.contactArn = output.contactArn
            self.displayName = output.displayName
            self.plan = output.plan
            self.type = output.type
        } else {
            self.alias = nil
            self.contactArn = nil
            self.displayName = nil
            self.plan = nil
            self.type = nil
        }
    }
}

public struct GetContactOutputResponse: Swift.Equatable {
    /// The alias of the contact or escalation plan. The alias is unique and identifiable.
    /// This member is required.
    public var alias: Swift.String?
    /// The ARN of the contact or escalation plan.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The full name of the contact or escalation plan.
    public var displayName: Swift.String?
    /// Details about the specific timing or stages and targets of the escalation plan or engagement plan.
    /// This member is required.
    public var plan: SsmContactsClientTypes.Plan?
    /// The type of contact, either PERSONAL or ESCALATION.
    /// This member is required.
    public var type: SsmContactsClientTypes.ContactType?

    public init (
        alias: Swift.String? = nil,
        contactArn: Swift.String? = nil,
        displayName: Swift.String? = nil,
        plan: SsmContactsClientTypes.Plan? = nil,
        type: SsmContactsClientTypes.ContactType? = nil
    )
    {
        self.alias = alias
        self.contactArn = contactArn
        self.displayName = displayName
        self.plan = plan
        self.type = type
    }
}

struct GetContactOutputResponseBody: Swift.Equatable {
    let contactArn: Swift.String?
    let alias: Swift.String?
    let displayName: Swift.String?
    let type: SsmContactsClientTypes.ContactType?
    let plan: SsmContactsClientTypes.Plan?
}

extension GetContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case plan = "Plan"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactType.self, forKey: .type)
        type = typeDecoded
        let planDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.Plan.self, forKey: .plan)
        plan = planDecoded
    }
}

extension GetContactPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

extension GetContactPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetContactPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var contactArn: Swift.String?

    public init (
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct GetContactPolicyInputBody: Swift.Equatable {
    let contactArn: Swift.String?
}

extension GetContactPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension GetContactPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetContactPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
            self.policy = output.policy
        } else {
            self.contactArn = nil
            self.policy = nil
        }
    }
}

public struct GetContactPolicyOutputResponse: Swift.Equatable {
    /// The ARN of the contact or escalation plan.
    public var contactArn: Swift.String?
    /// Details about the resource policy attached to the contact or escalation plan.
    public var policy: Swift.String?

    public init (
        contactArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.policy = policy
    }
}

struct GetContactPolicyOutputResponseBody: Swift.Equatable {
    let contactArn: Swift.String?
    let policy: Swift.String?
}

extension GetContactPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Unexpected error occurred while processing the request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// Advice to clients on when the call can be safely retried
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListContactChannelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListContactChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListContactChannelsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The maximum number of contact channels per page.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init (
        contactId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListContactChannelsInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListContactChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListContactChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContactChannelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListContactChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactChannels = output.contactChannels
            self.nextToken = output.nextToken
        } else {
            self.contactChannels = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactChannelsOutputResponse: Swift.Equatable {
    /// A list of contact channels related to the specified contact.
    /// This member is required.
    public var contactChannels: [SsmContactsClientTypes.ContactChannel]?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init (
        contactChannels: [SsmContactsClientTypes.ContactChannel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactChannels = contactChannels
        self.nextToken = nextToken
    }
}

struct ListContactChannelsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let contactChannels: [SsmContactsClientTypes.ContactChannel]?
}

extension ListContactChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannels = "ContactChannels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let contactChannelsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.ContactChannel?].self, forKey: .contactChannels)
        var contactChannelsDecoded0:[SsmContactsClientTypes.ContactChannel]? = nil
        if let contactChannelsContainer = contactChannelsContainer {
            contactChannelsDecoded0 = [SsmContactsClientTypes.ContactChannel]()
            for structure0 in contactChannelsContainer {
                if let structure0 = structure0 {
                    contactChannelsDecoded0?.append(structure0)
                }
            }
        }
        contactChannels = contactChannelsDecoded0
    }
}

extension ListContactsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasPrefix = "AliasPrefix"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasPrefix = aliasPrefix {
            try encodeContainer.encode(aliasPrefix, forKey: .aliasPrefix)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension ListContactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListContactsInput: Swift.Equatable {
    /// Used to list only contacts who's aliases start with the specified prefix.
    public var aliasPrefix: Swift.String?
    /// The maximum number of contacts and escalation plans per page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The type of contact. A contact is type PERSONAL and an escalation plan is type ESCALATION.
    public var type: SsmContactsClientTypes.ContactType?

    public init (
        aliasPrefix: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: SsmContactsClientTypes.ContactType? = nil
    )
    {
        self.aliasPrefix = aliasPrefix
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListContactsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let aliasPrefix: Swift.String?
    let type: SsmContactsClientTypes.ContactType?
}

extension ListContactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasPrefix = "AliasPrefix"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let aliasPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasPrefix)
        aliasPrefix = aliasPrefixDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ListContactsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContactsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListContactsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contacts = output.contacts
            self.nextToken = output.nextToken
        } else {
            self.contacts = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactsOutputResponse: Swift.Equatable {
    /// A list of the contacts and escalation plans in your Incident Manager account.
    public var contacts: [SsmContactsClientTypes.Contact]?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init (
        contacts: [SsmContactsClientTypes.Contact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contacts = contacts
        self.nextToken = nextToken
    }
}

struct ListContactsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let contacts: [SsmContactsClientTypes.Contact]?
}

extension ListContactsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contacts = "Contacts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let contactsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Contact?].self, forKey: .contacts)
        var contactsDecoded0:[SsmContactsClientTypes.Contact]? = nil
        if let contactsContainer = contactsContainer {
            contactsDecoded0 = [SsmContactsClientTypes.Contact]()
            for structure0 in contactsContainer {
                if let structure0 = structure0 {
                    contactsDecoded0?.append(structure0)
                }
            }
        }
        contacts = contactsDecoded0
    }
}

extension ListEngagementsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case incidentId = "IncidentId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timeRangeValue = "TimeRangeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let incidentId = incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timeRangeValue = timeRangeValue {
            try encodeContainer.encode(timeRangeValue, forKey: .timeRangeValue)
        }
    }
}

extension ListEngagementsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEngagementsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the incident you're listing engagements for.
    public var incidentId: Swift.String?
    /// The maximum number of engagements per page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The time range to lists engagements for an incident.
    public var timeRangeValue: SsmContactsClientTypes.TimeRange?

    public init (
        incidentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timeRangeValue: SsmContactsClientTypes.TimeRange? = nil
    )
    {
        self.incidentId = incidentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timeRangeValue = timeRangeValue
    }
}

struct ListEngagementsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let incidentId: Swift.String?
    let timeRangeValue: SsmContactsClientTypes.TimeRange?
}

extension ListEngagementsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case incidentId = "IncidentId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timeRangeValue = "TimeRangeValue"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let timeRangeValueDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.TimeRange.self, forKey: .timeRangeValue)
        timeRangeValue = timeRangeValueDecoded
    }
}

extension ListEngagementsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEngagementsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEngagementsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEngagementsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEngagementsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engagements = output.engagements
            self.nextToken = output.nextToken
        } else {
            self.engagements = nil
            self.nextToken = nil
        }
    }
}

public struct ListEngagementsOutputResponse: Swift.Equatable {
    /// A list of each engagement that occurred during the specified time range of an incident.
    /// This member is required.
    public var engagements: [SsmContactsClientTypes.Engagement]?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init (
        engagements: [SsmContactsClientTypes.Engagement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engagements = engagements
        self.nextToken = nextToken
    }
}

struct ListEngagementsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let engagements: [SsmContactsClientTypes.Engagement]?
}

extension ListEngagementsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagements = "Engagements"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let engagementsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Engagement?].self, forKey: .engagements)
        var engagementsDecoded0:[SsmContactsClientTypes.Engagement]? = nil
        if let engagementsContainer = engagementsContainer {
            engagementsDecoded0 = [SsmContactsClientTypes.Engagement]()
            for structure0 in engagementsContainer {
                if let structure0 = structure0 {
                    engagementsDecoded0?.append(structure0)
                }
            }
        }
        engagements = engagementsDecoded0
    }
}

extension ListPageReceiptsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pageId = "PageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pageId = pageId {
            try encodeContainer.encode(pageId, forKey: .pageId)
        }
    }
}

extension ListPageReceiptsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPageReceiptsInput: Swift.Equatable {
    /// The maximum number of acknowledgements per page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the engagement to a specific contact channel.
    /// This member is required.
    public var pageId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pageId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pageId = pageId
    }
}

struct ListPageReceiptsInputBody: Swift.Equatable {
    let pageId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPageReceiptsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pageId = "PageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageId)
        pageId = pageIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPageReceiptsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPageReceiptsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPageReceiptsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPageReceiptsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPageReceiptsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.receipts = output.receipts
        } else {
            self.nextToken = nil
            self.receipts = nil
        }
    }
}

public struct ListPageReceiptsOutputResponse: Swift.Equatable {
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// A list of each acknowledgement.
    public var receipts: [SsmContactsClientTypes.Receipt]?

    public init (
        nextToken: Swift.String? = nil,
        receipts: [SsmContactsClientTypes.Receipt]? = nil
    )
    {
        self.nextToken = nextToken
        self.receipts = receipts
    }
}

struct ListPageReceiptsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let receipts: [SsmContactsClientTypes.Receipt]?
}

extension ListPageReceiptsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case receipts = "Receipts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let receiptsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Receipt?].self, forKey: .receipts)
        var receiptsDecoded0:[SsmContactsClientTypes.Receipt]? = nil
        if let receiptsContainer = receiptsContainer {
            receiptsDecoded0 = [SsmContactsClientTypes.Receipt]()
            for structure0 in receiptsContainer {
                if let structure0 = structure0 {
                    receiptsDecoded0?.append(structure0)
                }
            }
        }
        receipts = receiptsDecoded0
    }
}

extension ListPagesByContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPagesByContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPagesByContactInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact you are retrieving engagements for.
    /// This member is required.
    public var contactId: Swift.String?
    /// The maximum number of engagements to contact channels to list per page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init (
        contactId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPagesByContactInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPagesByContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPagesByContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPagesByContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPagesByContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPagesByContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPagesByContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pages = output.pages
        } else {
            self.nextToken = nil
            self.pages = nil
        }
    }
}

public struct ListPagesByContactOutputResponse: Swift.Equatable {
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The list of engagements to a contact's contact channel.
    /// This member is required.
    public var pages: [SsmContactsClientTypes.Page]?

    public init (
        nextToken: Swift.String? = nil,
        pages: [SsmContactsClientTypes.Page]? = nil
    )
    {
        self.nextToken = nextToken
        self.pages = pages
    }
}

struct ListPagesByContactOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let pages: [SsmContactsClientTypes.Page]?
}

extension ListPagesByContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pages = "Pages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let pagesContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Page?].self, forKey: .pages)
        var pagesDecoded0:[SsmContactsClientTypes.Page]? = nil
        if let pagesContainer = pagesContainer {
            pagesDecoded0 = [SsmContactsClientTypes.Page]()
            for structure0 in pagesContainer {
                if let structure0 = structure0 {
                    pagesDecoded0?.append(structure0)
                }
            }
        }
        pages = pagesDecoded0
    }
}

extension ListPagesByEngagementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engagementId = engagementId {
            try encodeContainer.encode(engagementId, forKey: .engagementId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPagesByEngagementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPagesByEngagementInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the engagement.
    /// This member is required.
    public var engagementId: Swift.String?
    /// The maximum number of engagements to contact channels to list per page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init (
        engagementId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engagementId = engagementId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPagesByEngagementInputBody: Swift.Equatable {
    let engagementId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPagesByEngagementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementId)
        engagementId = engagementIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPagesByEngagementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPagesByEngagementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPagesByEngagementOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPagesByEngagementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPagesByEngagementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pages = output.pages
        } else {
            self.nextToken = nil
            self.pages = nil
        }
    }
}

public struct ListPagesByEngagementOutputResponse: Swift.Equatable {
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The list of engagements to contact channels.
    /// This member is required.
    public var pages: [SsmContactsClientTypes.Page]?

    public init (
        nextToken: Swift.String? = nil,
        pages: [SsmContactsClientTypes.Page]? = nil
    )
    {
        self.nextToken = nextToken
        self.pages = pages
    }
}

struct ListPagesByEngagementOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let pages: [SsmContactsClientTypes.Page]?
}

extension ListPagesByEngagementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pages = "Pages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let pagesContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Page?].self, forKey: .pages)
        var pagesDecoded0:[SsmContactsClientTypes.Page]? = nil
        if let pagesContainer = pagesContainer {
            pagesDecoded0 = [SsmContactsClientTypes.Page]()
            for structure0 in pagesContainer {
                if let structure0 = structure0 {
                    pagesDecoded0?.append(structure0)
                }
            }
        }
        pages = pagesDecoded0
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags related to the contact or escalation plan.
    public var tags: [SsmContactsClientTypes.Tag]?

    public init (
        tags: [SsmContactsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [SsmContactsClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmContactsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmContactsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SsmContactsClientTypes.Page: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case deliveryTime = "DeliveryTime"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case pageArn = "PageArn"
        case readTime = "ReadTime"
        case sender = "Sender"
        case sentTime = "SentTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let deliveryTime = deliveryTime {
            try encodeContainer.encode(deliveryTime.timeIntervalSince1970, forKey: .deliveryTime)
        }
        if let engagementArn = engagementArn {
            try encodeContainer.encode(engagementArn, forKey: .engagementArn)
        }
        if let incidentId = incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let pageArn = pageArn {
            try encodeContainer.encode(pageArn, forKey: .pageArn)
        }
        if let readTime = readTime {
            try encodeContainer.encode(readTime.timeIntervalSince1970, forKey: .readTime)
        }
        if let sender = sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let sentTime = sentTime {
            try encodeContainer.encode(sentTime.timeIntervalSince1970, forKey: .sentTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageArn)
        pageArn = pageArnDecoded
        let engagementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sender)
        sender = senderDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let sentTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .sentTime)
        sentTime = sentTimeDecoded
        let deliveryTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deliveryTime)
        deliveryTime = deliveryTimeDecoded
        let readTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .readTime)
        readTime = readTimeDecoded
    }
}

extension SsmContactsClientTypes {
    /// Incident Manager engaging a contact's contact channel.
    public struct Page: Swift.Equatable {
        /// The ARN of the contact that Incident Manager is engaging.
        /// This member is required.
        public var contactArn: Swift.String?
        /// The time the message was delivered to the contact channel.
        public var deliveryTime: ClientRuntime.Date?
        /// The ARN of the engagement that this page is part of.
        /// This member is required.
        public var engagementArn: Swift.String?
        /// The ARN of the incident that's engaging the contact channel.
        public var incidentId: Swift.String?
        /// The Amazon Resource Name (ARN) of the page to the contact channel.
        /// This member is required.
        public var pageArn: Swift.String?
        /// The time that the contact channel acknowledged engagement.
        public var readTime: ClientRuntime.Date?
        /// The user that started the engagement.
        /// This member is required.
        public var sender: Swift.String?
        /// The time that Incident Manager engaged the contact channel.
        public var sentTime: ClientRuntime.Date?

        public init (
            contactArn: Swift.String? = nil,
            deliveryTime: ClientRuntime.Date? = nil,
            engagementArn: Swift.String? = nil,
            incidentId: Swift.String? = nil,
            pageArn: Swift.String? = nil,
            readTime: ClientRuntime.Date? = nil,
            sender: Swift.String? = nil,
            sentTime: ClientRuntime.Date? = nil
        )
        {
            self.contactArn = contactArn
            self.deliveryTime = deliveryTime
            self.engagementArn = engagementArn
            self.incidentId = incidentId
            self.pageArn = pageArn
            self.readTime = readTime
            self.sender = sender
            self.sentTime = sentTime
        }
    }

}

extension SsmContactsClientTypes.Plan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stages = "Stages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stages = stages {
            var stagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stages)
            for stageslist0 in stages {
                try stagesContainer.encode(stageslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagesContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Stage?].self, forKey: .stages)
        var stagesDecoded0:[SsmContactsClientTypes.Stage]? = nil
        if let stagesContainer = stagesContainer {
            stagesDecoded0 = [SsmContactsClientTypes.Stage]()
            for structure0 in stagesContainer {
                if let structure0 = structure0 {
                    stagesDecoded0?.append(structure0)
                }
            }
        }
        stages = stagesDecoded0
    }
}

extension SsmContactsClientTypes {
    /// The stages that an escalation plan or engagement plan engages contacts and contact methods in.
    public struct Plan: Swift.Equatable {
        /// A list of stages that the escalation plan or engagement plan uses to engage contacts and contact methods.
        /// This member is required.
        public var stages: [SsmContactsClientTypes.Stage]?

        public init (
            stages: [SsmContactsClientTypes.Stage]? = nil
        )
        {
            self.stages = stages
        }
    }

}

extension PutContactPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutContactPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutContactPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var contactArn: Swift.String?
    /// Details of the resource policy.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        contactArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.policy = policy
    }
}

struct PutContactPolicyInputBody: Swift.Equatable {
    let contactArn: Swift.String?
    let policy: Swift.String?
}

extension PutContactPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutContactPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutContactPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutContactPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutContactPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutContactPolicyOutputResponse: Swift.Equatable {

}

extension SsmContactsClientTypes.Receipt: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelArn = "ContactChannelArn"
        case receiptInfo = "ReceiptInfo"
        case receiptTime = "ReceiptTime"
        case receiptType = "ReceiptType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelArn = contactChannelArn {
            try encodeContainer.encode(contactChannelArn, forKey: .contactChannelArn)
        }
        if let receiptInfo = receiptInfo {
            try encodeContainer.encode(receiptInfo, forKey: .receiptInfo)
        }
        if let receiptTime = receiptTime {
            try encodeContainer.encode(receiptTime.timeIntervalSince1970, forKey: .receiptTime)
        }
        if let receiptType = receiptType {
            try encodeContainer.encode(receiptType.rawValue, forKey: .receiptType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
        let receiptTypeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ReceiptType.self, forKey: .receiptType)
        receiptType = receiptTypeDecoded
        let receiptInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .receiptInfo)
        receiptInfo = receiptInfoDecoded
        let receiptTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .receiptTime)
        receiptTime = receiptTimeDecoded
    }
}

extension SsmContactsClientTypes {
    /// Records events during an engagement.
    public struct Receipt: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the contact channel Incident Manager engaged.
        public var contactChannelArn: Swift.String?
        /// Information provided during the page acknowledgement.
        public var receiptInfo: Swift.String?
        /// The time receipt was SENT, DELIVERED, or READ.
        /// This member is required.
        public var receiptTime: ClientRuntime.Date?
        /// The type follows the engagement cycle, SENT, DELIVERED, and READ.
        /// This member is required.
        public var receiptType: SsmContactsClientTypes.ReceiptType?

        public init (
            contactChannelArn: Swift.String? = nil,
            receiptInfo: Swift.String? = nil,
            receiptTime: ClientRuntime.Date? = nil,
            receiptType: SsmContactsClientTypes.ReceiptType? = nil
        )
        {
            self.contactChannelArn = contactChannelArn
            self.receiptInfo = receiptInfo
            self.receiptTime = receiptTime
            self.receiptType = receiptType
        }
    }

}

extension SsmContactsClientTypes {
    public enum ReceiptType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delivered
        case error
        case read
        case sent
        case stop
        case sdkUnknown(Swift.String)

        public static var allCases: [ReceiptType] {
            return [
                .delivered,
                .error,
                .read,
                .sent,
                .stop,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delivered: return "DELIVERED"
            case .error: return "ERROR"
            case .read: return "READ"
            case .sent: return "SENT"
            case .stop: return "STOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReceiptType(rawValue: rawValue) ?? ReceiptType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request references a resource that doesn't exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Hypothetical resource identifier that was not found
    /// This member is required.
    public var resourceId: Swift.String?
    /// Hypothetical resource type that was not found
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SendActivationCodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

extension SendActivationCodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendActivationCodeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel.
    /// This member is required.
    public var contactChannelId: Swift.String?

    public init (
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct SendActivationCodeInputBody: Swift.Equatable {
    let contactChannelId: Swift.String?
}

extension SendActivationCodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension SendActivationCodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendActivationCodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendActivationCodeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendActivationCodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SendActivationCodeOutputResponse: Swift.Equatable {

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Service Quotas requirement to identify originating service
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Identifier of the resource affected
    public var resourceId: Swift.String?
    /// Type of the resource affected
    public var resourceType: Swift.String?
    /// Service Quotas requirement to identify originating quota
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension SsmContactsClientTypes.Stage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInMinutes = "DurationInMinutes"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInMinutes = durationInMinutes {
            try encodeContainer.encode(durationInMinutes, forKey: .durationInMinutes)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targetslist0 in targets {
                try targetsContainer.encode(targetslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmContactsClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmContactsClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension SsmContactsClientTypes {
    /// A set amount of time that an escalation plan or engagement plan engages the specified contacts or contact methods.
    public struct Stage: Swift.Equatable {
        /// The time to wait until beginning the next stage. The duration can only be set to 0 if a target is specified.
        /// This member is required.
        public var durationInMinutes: Swift.Int?
        /// The contacts or contact methods that the escalation plan or engagement plan is engaging.
        /// This member is required.
        public var targets: [SsmContactsClientTypes.Target]?

        public init (
            durationInMinutes: Swift.Int? = nil,
            targets: [SsmContactsClientTypes.Target]? = nil
        )
        {
            self.durationInMinutes = durationInMinutes
            self.targets = targets
        }
    }

}

extension StartEngagementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case content = "Content"
        case idempotencyToken = "IdempotencyToken"
        case incidentId = "IncidentId"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case sender = "Sender"
        case subject = "Subject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let incidentId = incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let publicContent = publicContent {
            try encodeContainer.encode(publicContent, forKey: .publicContent)
        }
        if let publicSubject = publicSubject {
            try encodeContainer.encode(publicSubject, forKey: .publicSubject)
        }
        if let sender = sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }
}

extension StartEngagementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartEngagementInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact being engaged.
    /// This member is required.
    public var contactId: Swift.String?
    /// The secure content of the message that was sent to the contact. Use this field for engagements to VOICE or EMAIL.
    /// This member is required.
    public var content: Swift.String?
    /// A token ensuring that the operation is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// The ARN of the incident that the engagement is part of.
    public var incidentId: Swift.String?
    /// The insecure content of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicContent: Swift.String?
    /// The insecure subject of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicSubject: Swift.String?
    /// The user that started the engagement.
    /// This member is required.
    public var sender: Swift.String?
    /// The secure subject of the message that was sent to the contact. Use this field for engagements to VOICE or EMAIL.
    /// This member is required.
    public var subject: Swift.String?

    public init (
        contactId: Swift.String? = nil,
        content: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        incidentId: Swift.String? = nil,
        publicContent: Swift.String? = nil,
        publicSubject: Swift.String? = nil,
        sender: Swift.String? = nil,
        subject: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.content = content
        self.idempotencyToken = idempotencyToken
        self.incidentId = incidentId
        self.publicContent = publicContent
        self.publicSubject = publicSubject
        self.sender = sender
        self.subject = subject
    }
}

struct StartEngagementInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let sender: Swift.String?
    let subject: Swift.String?
    let content: Swift.String?
    let publicSubject: Swift.String?
    let publicContent: Swift.String?
    let incidentId: Swift.String?
    let idempotencyToken: Swift.String?
}

extension StartEngagementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case content = "Content"
        case idempotencyToken = "IdempotencyToken"
        case incidentId = "IncidentId"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case sender = "Sender"
        case subject = "Subject"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let senderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sender)
        sender = senderDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let publicSubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicSubject)
        publicSubject = publicSubjectDecoded
        let publicContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicContent)
        publicContent = publicContentDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension StartEngagementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartEngagementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartEngagementOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartEngagementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartEngagementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engagementArn = output.engagementArn
        } else {
            self.engagementArn = nil
        }
    }
}

public struct StartEngagementOutputResponse: Swift.Equatable {
    /// The ARN of the engagement.
    /// This member is required.
    public var engagementArn: Swift.String?

    public init (
        engagementArn: Swift.String? = nil
    )
    {
        self.engagementArn = engagementArn
    }
}

struct StartEngagementOutputResponseBody: Swift.Equatable {
    let engagementArn: Swift.String?
}

extension StartEngagementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementArn = "EngagementArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
    }
}

extension StopEngagementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
        case reason = "Reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engagementId = engagementId {
            try encodeContainer.encode(engagementId, forKey: .engagementId)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

extension StopEngagementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopEngagementInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the engagement.
    /// This member is required.
    public var engagementId: Swift.String?
    /// The reason that you're stopping the engagement.
    public var reason: Swift.String?

    public init (
        engagementId: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.engagementId = engagementId
        self.reason = reason
    }
}

struct StopEngagementInputBody: Swift.Equatable {
    let engagementId: Swift.String?
    let reason: Swift.String?
}

extension StopEngagementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementId)
        engagementId = engagementIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension StopEngagementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopEngagementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopEngagementOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopEngagementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopEngagementOutputResponse: Swift.Equatable {

}

extension SsmContactsClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmContactsClientTypes {
    /// A container of a key-value name pair.
    public struct Tag: Swift.Equatable {
        /// Name of the object key.
        public var key: Swift.String?
        /// Value of the tag.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagslist0 in tags {
                try tagsContainer.encode(tagslist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags that you are adding to the contact or escalation plan.
    /// This member is required.
    public var tags: [SsmContactsClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [SsmContactsClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [SsmContactsClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmContactsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmContactsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension SsmContactsClientTypes.Target: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelTargetInfo = "ChannelTargetInfo"
        case contactTargetInfo = "ContactTargetInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelTargetInfo = channelTargetInfo {
            try encodeContainer.encode(channelTargetInfo, forKey: .channelTargetInfo)
        }
        if let contactTargetInfo = contactTargetInfo {
            try encodeContainer.encode(contactTargetInfo, forKey: .contactTargetInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelTargetInfoDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ChannelTargetInfo.self, forKey: .channelTargetInfo)
        channelTargetInfo = channelTargetInfoDecoded
        let contactTargetInfoDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactTargetInfo.self, forKey: .contactTargetInfo)
        contactTargetInfo = contactTargetInfoDecoded
    }
}

extension SsmContactsClientTypes {
    /// The contact or contact channel that's being engaged.
    public struct Target: Swift.Equatable {
        /// Information about the contact channel Incident Manager is engaging.
        public var channelTargetInfo: SsmContactsClientTypes.ChannelTargetInfo?
        /// Information about the contact that Incident Manager is engaging.
        public var contactTargetInfo: SsmContactsClientTypes.ContactTargetInfo?

        public init (
            channelTargetInfo: SsmContactsClientTypes.ChannelTargetInfo? = nil,
            contactTargetInfo: SsmContactsClientTypes.ContactTargetInfo? = nil
        )
        {
            self.channelTargetInfo = channelTargetInfo
            self.contactTargetInfo = contactTargetInfo
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Service Quotas requirement to identify originating service
    public var quotaCode: Swift.String?
    /// Advice to clients on when the call can be safely retried
    public var retryAfterSeconds: Swift.Int
    /// Service Quotas requirement to identify originating quota
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension SsmContactsClientTypes.TimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension SsmContactsClientTypes {
    /// A range of between two set times
    public struct TimeRange: Swift.Equatable {
        /// The end of the time range.
        public var endTime: ClientRuntime.Date?
        /// The start of the time range.
        public var startTime: ClientRuntime.Date?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The key of the tag that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateContactChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
        if let deliveryAddress = deliveryAddress {
            try encodeContainer.encode(deliveryAddress, forKey: .deliveryAddress)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateContactChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateContactChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel you want to update.
    /// This member is required.
    public var contactChannelId: Swift.String?
    /// The details that Incident Manager uses when trying to engage the contact channel.
    public var deliveryAddress: SsmContactsClientTypes.ContactChannelAddress?
    /// The name of the contact channel.
    public var name: Swift.String?

    public init (
        contactChannelId: Swift.String? = nil,
        deliveryAddress: SsmContactsClientTypes.ContactChannelAddress? = nil,
        name: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
        self.deliveryAddress = deliveryAddress
        self.name = name
    }
}

struct UpdateContactChannelInputBody: Swift.Equatable {
    let contactChannelId: Swift.String?
    let name: Swift.String?
    let deliveryAddress: SsmContactsClientTypes.ContactChannelAddress?
}

extension UpdateContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
    }
}

extension UpdateContactChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactChannelOutputResponse: Swift.Equatable {

}

extension UpdateContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case displayName = "DisplayName"
        case plan = "Plan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let plan = plan {
            try encodeContainer.encode(plan, forKey: .plan)
        }
    }
}

extension UpdateContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateContactInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan you're updating.
    /// This member is required.
    public var contactId: Swift.String?
    /// The full name of the contact or escalation plan.
    public var displayName: Swift.String?
    /// A list of stages. A contact has an engagement plan with stages for specified contact channels. An escalation plan uses these stages to contact specified contacts.
    public var plan: SsmContactsClientTypes.Plan?

    public init (
        contactId: Swift.String? = nil,
        displayName: Swift.String? = nil,
        plan: SsmContactsClientTypes.Plan? = nil
    )
    {
        self.contactId = contactId
        self.displayName = displayName
        self.plan = plan
    }
}

struct UpdateContactInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let displayName: Swift.String?
    let plan: SsmContactsClientTypes.Plan?
}

extension UpdateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case displayName = "DisplayName"
        case plan = "Plan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let planDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.Plan.self, forKey: .plan)
        plan = planDecoded
    }
}

extension UpdateContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactOutputResponse: Swift.Equatable {

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The fields that caused the error
    public var fields: [SsmContactsClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// Reason the request failed validation
    public var reason: SsmContactsClientTypes.ValidationExceptionReason?

    public init (
        fields: [SsmContactsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: SsmContactsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: SsmContactsClientTypes.ValidationExceptionReason?
    let fields: [SsmContactsClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[SsmContactsClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [SsmContactsClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension SsmContactsClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmContactsClientTypes {
    /// Provides information about which field caused the exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Information about what caused the field to cause an exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that caused the exception.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension SsmContactsClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
