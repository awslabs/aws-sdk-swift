// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ClientLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClientLimitExceededException(message: \(String(describing: message)))"}
}

extension ClientLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ClientLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request was throttled because you have exceeded the limit of allowed client
///             calls. Try making the call later.</p>
public struct ClientLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClientLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ClientLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetIceServerConfigInputBodyMiddleware: Middleware {
    public let id: String = "GetIceServerConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIceServerConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIceServerConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIceServerConfigInput>
    public typealias MOutput = OperationOutput<GetIceServerConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIceServerConfigOutputError>
}

extension GetIceServerConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIceServerConfigInput(channelARN: \(String(describing: channelARN)), clientId: \(String(describing: clientId)), service: \(String(describing: service)), username: \(String(describing: username)))"}
}

extension GetIceServerConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelARN = "ChannelARN"
        case clientId = "ClientId"
        case service = "Service"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let service = service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct GetIceServerConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetIceServerConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIceServerConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIceServerConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIceServerConfigInput>
    public typealias MOutput = OperationOutput<GetIceServerConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIceServerConfigOutputError>
}

public struct GetIceServerConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIceServerConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIceServerConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIceServerConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIceServerConfigInput>
    public typealias MOutput = OperationOutput<GetIceServerConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIceServerConfigOutputError>
}

public struct GetIceServerConfigInput: Equatable {
    /// <p>The ARN of the signaling channel to be used for the peer-to-peer connection between
    ///             configured peers. </p>
    public let channelARN: String?
    /// <p>Unique identifier for the viewer. Must be unique within the signaling channel.</p>
    public let clientId: String?
    /// <p>Specifies the desired service. Currently, <code>TURN</code> is the only valid
    ///             value.</p>
    public let service: Service?
    /// <p>An optional user ID to be associated with the credentials.</p>
    public let username: String?

    public init (
        channelARN: String? = nil,
        clientId: String? = nil,
        service: Service? = nil,
        username: String? = nil
    )
    {
        self.channelARN = channelARN
        self.clientId = clientId
        self.service = service
        self.username = username
    }
}

struct GetIceServerConfigInputBody: Equatable {
    public let channelARN: String?
    public let clientId: String?
    public let service: Service?
    public let username: String?
}

extension GetIceServerConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelARN = "ChannelARN"
        case clientId = "ClientId"
        case service = "Service"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Service.self, forKey: .service)
        service = serviceDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension GetIceServerConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIceServerConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientException" : self = .invalidClientException(try InvalidClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SessionExpiredException" : self = .sessionExpiredException(try SessionExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIceServerConfigOutputError: Swift.Error, Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidClientException(InvalidClientException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case sessionExpiredException(SessionExpiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIceServerConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIceServerConfigOutputResponse(iceServerList: \(String(describing: iceServerList)))"}
}

extension GetIceServerConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetIceServerConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.iceServerList = output.iceServerList
        } else {
            self.iceServerList = nil
        }
    }
}

public struct GetIceServerConfigOutputResponse: Equatable {
    /// <p>The list of ICE server information objects.</p>
    public let iceServerList: [IceServer]?

    public init (
        iceServerList: [IceServer]? = nil
    )
    {
        self.iceServerList = iceServerList
    }
}

struct GetIceServerConfigOutputResponseBody: Equatable {
    public let iceServerList: [IceServer]?
}

extension GetIceServerConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iceServerList = "IceServerList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iceServerListContainer = try containerValues.decodeIfPresent([IceServer?].self, forKey: .iceServerList)
        var iceServerListDecoded0:[IceServer]? = nil
        if let iceServerListContainer = iceServerListContainer {
            iceServerListDecoded0 = [IceServer]()
            for structure0 in iceServerListContainer {
                if let structure0 = structure0 {
                    iceServerListDecoded0?.append(structure0)
                }
            }
        }
        iceServerList = iceServerListDecoded0
    }
}

extension IceServer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case password = "Password"
        case ttl = "Ttl"
        case uris = "Uris"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if ttl != 0 {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
        if let uris = uris {
            var urisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .uris)
            for uris0 in uris {
                try urisContainer.encode(uris0)
            }
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urisContainer = try containerValues.decodeIfPresent([String?].self, forKey: .uris)
        var urisDecoded0:[String]? = nil
        if let urisContainer = urisContainer {
            urisDecoded0 = [String]()
            for string0 in urisContainer {
                if let string0 = string0 {
                    urisDecoded0?.append(string0)
                }
            }
        }
        uris = urisDecoded0
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let ttlDecoded = try containerValues.decode(Int.self, forKey: .ttl)
        ttl = ttlDecoded
    }
}

extension IceServer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IceServer(password: \(String(describing: password)), ttl: \(String(describing: ttl)), uris: \(String(describing: uris)), username: \(String(describing: username)))"}
}

/// <p>A structure for the ICE server connection data.</p>
public struct IceServer: Equatable {
    /// <p>A password to login to the ICE server.</p>
    public let password: String?
    /// <p>The period of time, in seconds, during which the username and password are
    ///             valid.</p>
    public let ttl: Int
    /// <p>An array of URIs, in the form specified in the <a href="https://tools.ietf.org/html/draft-petithuguenin-behave-turn-uris-03">I-D.petithuguenin-behave-turn-uris</a> spec. These URIs provide the different
    ///             addresses and/or protocols that can be used to reach the TURN server.</p>
    public let uris: [String]?
    /// <p>A username to login to the ICE server.</p>
    public let username: String?

    public init (
        password: String? = nil,
        ttl: Int = 0,
        uris: [String]? = nil,
        username: String? = nil
    )
    {
        self.password = password
        self.ttl = ttl
        self.uris = uris
        self.username = username
    }
}

extension InvalidArgumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArgumentException(message: \(String(describing: message)))"}
}

extension InvalidArgumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value for this input parameter is invalid.</p>
public struct InvalidArgumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArgumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClientException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClientException(message: \(String(describing: message)))"}
}

extension InvalidClientException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified client is invalid.</p>
public struct InvalidClientException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClientExceptionBody: Equatable {
    public let message: String?
}

extension InvalidClientExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotAuthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotAuthorizedException(message: \(String(describing: message)))"}
}

extension NotAuthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The caller is not authorized to perform this operation.</p>
public struct NotAuthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Equatable {
    public let message: String?
}

extension NotAuthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource is not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SendAlexaOfferToMasterInputBodyMiddleware: Middleware {
    public let id: String = "SendAlexaOfferToMasterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendAlexaOfferToMasterInput>,
                  next: H) -> Swift.Result<OperationOutput<SendAlexaOfferToMasterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendAlexaOfferToMasterInput>
    public typealias MOutput = OperationOutput<SendAlexaOfferToMasterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendAlexaOfferToMasterOutputError>
}

extension SendAlexaOfferToMasterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendAlexaOfferToMasterInput(channelARN: \(String(describing: channelARN)), messagePayload: \(String(describing: messagePayload)), senderClientId: \(String(describing: senderClientId)))"}
}

extension SendAlexaOfferToMasterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelARN = "ChannelARN"
        case messagePayload = "MessagePayload"
        case senderClientId = "SenderClientId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let messagePayload = messagePayload {
            try encodeContainer.encode(messagePayload, forKey: .messagePayload)
        }
        if let senderClientId = senderClientId {
            try encodeContainer.encode(senderClientId, forKey: .senderClientId)
        }
    }
}

public struct SendAlexaOfferToMasterInputHeadersMiddleware: Middleware {
    public let id: String = "SendAlexaOfferToMasterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendAlexaOfferToMasterInput>,
                  next: H) -> Swift.Result<OperationOutput<SendAlexaOfferToMasterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendAlexaOfferToMasterInput>
    public typealias MOutput = OperationOutput<SendAlexaOfferToMasterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendAlexaOfferToMasterOutputError>
}

public struct SendAlexaOfferToMasterInputQueryItemMiddleware: Middleware {
    public let id: String = "SendAlexaOfferToMasterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendAlexaOfferToMasterInput>,
                  next: H) -> Swift.Result<OperationOutput<SendAlexaOfferToMasterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendAlexaOfferToMasterInput>
    public typealias MOutput = OperationOutput<SendAlexaOfferToMasterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendAlexaOfferToMasterOutputError>
}

public struct SendAlexaOfferToMasterInput: Equatable {
    /// <p>The ARN of the signaling channel by which Alexa and the master peer
    ///             communicate.</p>
    public let channelARN: String?
    /// <p>The base64-encoded SDP offer content.</p>
    public let messagePayload: String?
    /// <p>The unique identifier for the sender client.</p>
    public let senderClientId: String?

    public init (
        channelARN: String? = nil,
        messagePayload: String? = nil,
        senderClientId: String? = nil
    )
    {
        self.channelARN = channelARN
        self.messagePayload = messagePayload
        self.senderClientId = senderClientId
    }
}

struct SendAlexaOfferToMasterInputBody: Equatable {
    public let channelARN: String?
    public let senderClientId: String?
    public let messagePayload: String?
}

extension SendAlexaOfferToMasterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelARN = "ChannelARN"
        case messagePayload = "MessagePayload"
        case senderClientId = "SenderClientId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let senderClientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .senderClientId)
        senderClientId = senderClientIdDecoded
        let messagePayloadDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messagePayload)
        messagePayload = messagePayloadDecoded
    }
}

extension SendAlexaOfferToMasterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendAlexaOfferToMasterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendAlexaOfferToMasterOutputError: Swift.Error, Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendAlexaOfferToMasterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendAlexaOfferToMasterOutputResponse(answer: \(String(describing: answer)))"}
}

extension SendAlexaOfferToMasterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendAlexaOfferToMasterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.answer = output.answer
        } else {
            self.answer = nil
        }
    }
}

public struct SendAlexaOfferToMasterOutputResponse: Equatable {
    /// <p>The base64-encoded SDP answer content.</p>
    public let answer: String?

    public init (
        answer: String? = nil
    )
    {
        self.answer = answer
    }
}

struct SendAlexaOfferToMasterOutputResponseBody: Equatable {
    public let answer: String?
}

extension SendAlexaOfferToMasterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case answer = "Answer"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let answerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .answer)
        answer = answerDecoded
    }
}

public enum Service {
    case turn
    case sdkUnknown(String)
}

extension Service : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Service] {
        return [
            .turn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .turn: return "TURN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Service(rawValue: rawValue) ?? Service.sdkUnknown(rawValue)
    }
}

extension SessionExpiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SessionExpiredException(message: \(String(describing: message)))"}
}

extension SessionExpiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SessionExpiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>If the client session is expired. Once the client is connected, the session is valid
///             for 45 minutes. Client should reconnect to the channel to continue sending/receiving
///             messages.</p>
public struct SessionExpiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SessionExpiredExceptionBody: Equatable {
    public let message: String?
}

extension SessionExpiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
