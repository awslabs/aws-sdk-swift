// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AddPermissionInputBodyMiddleware: Middleware {
    public let id: String = "AddPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddPermissionInput>
    public typealias MOutput = OperationOutput<AddPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddPermissionOutputError>
}

extension AddPermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddPermissionInput(aWSAccountId: \(String(describing: aWSAccountId)), actionName: \(String(describing: actionName)), label: \(String(describing: label)), topicArn: \(String(describing: topicArn)))"}
}

extension AddPermissionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let aWSAccountId = aWSAccountId {
            var aWSAccountIdContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AWSAccountId"))
            for (index0, delegate0) in aWSAccountId.enumerated() {
                try aWSAccountIdContainer.encode(delegate0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let actionName = actionName {
            var actionNameContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ActionName"))
            for (index0, action0) in actionName.enumerated() {
                try actionNameContainer.encode(action0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let label = label {
            try container.encode(label, forKey: Key("Label"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
        try container.encode("AddPermission", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct AddPermissionInputHeadersMiddleware: Middleware {
    public let id: String = "AddPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddPermissionInput>
    public typealias MOutput = OperationOutput<AddPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddPermissionOutputError>
}

public struct AddPermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "AddPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddPermissionInput>
    public typealias MOutput = OperationOutput<AddPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddPermissionOutputError>
}

public struct AddPermissionInput: Equatable {
    /// <p>The AWS account IDs of the users (principals) who will be given access to the
    ///             specified actions. The users must have AWS accounts, but do not need to be signed up for
    ///             this service.</p>
    public let aWSAccountId: [String]?
    /// <p>The action you want to allow for the specified principal(s).</p>
    ///         <p>Valid values: Any Amazon SNS action name, for example <code>Publish</code>.</p>
    public let actionName: [String]?
    /// <p>A unique identifier for the new policy statement.</p>
    public let label: String?
    /// <p>The ARN of the topic whose access control policy you wish to modify.</p>
    public let topicArn: String?

    public init (
        aWSAccountId: [String]? = nil,
        actionName: [String]? = nil,
        label: String? = nil,
        topicArn: String? = nil
    )
    {
        self.aWSAccountId = aWSAccountId
        self.actionName = actionName
        self.label = label
        self.topicArn = topicArn
    }
}

extension AddPermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddPermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddPermissionOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddPermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddPermissionOutputResponse()"}
}

extension AddPermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddPermissionOutputResponse: Equatable {

    public init() {}
}

struct AddPermissionOutputResponseBody: Equatable {
}

extension AddPermissionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AuthorizationErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizationErrorException(message: \(String(describing: message)))"}
}

extension AuthorizationErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AuthorizationErrorExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the user has been denied access to the requested resource.</p>
public struct AuthorizationErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationErrorExceptionBody: Equatable {
    public let message: String?
}

extension AuthorizationErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CheckIfPhoneNumberIsOptedOutInputBodyMiddleware: Middleware {
    public let id: String = "CheckIfPhoneNumberIsOptedOutInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckIfPhoneNumberIsOptedOutInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckIfPhoneNumberIsOptedOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckIfPhoneNumberIsOptedOutInput>
    public typealias MOutput = OperationOutput<CheckIfPhoneNumberIsOptedOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckIfPhoneNumberIsOptedOutOutputError>
}

extension CheckIfPhoneNumberIsOptedOutInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckIfPhoneNumberIsOptedOutInput(phoneNumber: \(String(describing: phoneNumber)))"}
}

extension CheckIfPhoneNumberIsOptedOutInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: Key("phoneNumber"))
        }
        try container.encode("CheckIfPhoneNumberIsOptedOut", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct CheckIfPhoneNumberIsOptedOutInputHeadersMiddleware: Middleware {
    public let id: String = "CheckIfPhoneNumberIsOptedOutInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckIfPhoneNumberIsOptedOutInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckIfPhoneNumberIsOptedOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckIfPhoneNumberIsOptedOutInput>
    public typealias MOutput = OperationOutput<CheckIfPhoneNumberIsOptedOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckIfPhoneNumberIsOptedOutOutputError>
}

public struct CheckIfPhoneNumberIsOptedOutInputQueryItemMiddleware: Middleware {
    public let id: String = "CheckIfPhoneNumberIsOptedOutInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckIfPhoneNumberIsOptedOutInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckIfPhoneNumberIsOptedOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckIfPhoneNumberIsOptedOutInput>
    public typealias MOutput = OperationOutput<CheckIfPhoneNumberIsOptedOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckIfPhoneNumberIsOptedOutOutputError>
}

/// <p>The input for the <code>CheckIfPhoneNumberIsOptedOut</code> action.</p>
public struct CheckIfPhoneNumberIsOptedOutInput: Equatable {
    /// <p>The phone number for which you want to check the opt out status.</p>
    public let phoneNumber: String?

    public init (
        phoneNumber: String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

extension CheckIfPhoneNumberIsOptedOutOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CheckIfPhoneNumberIsOptedOutOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CheckIfPhoneNumberIsOptedOutOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckIfPhoneNumberIsOptedOutOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckIfPhoneNumberIsOptedOutOutputResponse(isOptedOut: \(String(describing: isOptedOut)))"}
}

extension CheckIfPhoneNumberIsOptedOutOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CheckIfPhoneNumberIsOptedOutOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isOptedOut = output.isOptedOut
        } else {
            self.isOptedOut = false
        }
    }
}

/// <p>The response from the <code>CheckIfPhoneNumberIsOptedOut</code> action.</p>
public struct CheckIfPhoneNumberIsOptedOutOutputResponse: Equatable {
    /// <p>Indicates whether the phone number is opted out:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>true</code> – The phone number is opted out, meaning you cannot publish
    ///                     SMS messages to it.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>false</code> – The phone number is opted in, meaning you can publish SMS
    ///                     messages to it.</p>
    ///             </li>
    ///          </ul>
    public let isOptedOut: Bool

    public init (
        isOptedOut: Bool = false
    )
    {
        self.isOptedOut = isOptedOut
    }
}

struct CheckIfPhoneNumberIsOptedOutOutputResponseBody: Equatable {
    public let isOptedOut: Bool
}

extension CheckIfPhoneNumberIsOptedOutOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isOptedOut
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CheckIfPhoneNumberIsOptedOutResult"))
        let isOptedOutDecoded = try containerValues.decode(Bool.self, forKey: .isOptedOut)
        isOptedOut = isOptedOutDecoded
    }
}

extension ConcurrentAccessException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentAccessException(message: \(String(describing: message)))"}
}

extension ConcurrentAccessException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ConcurrentAccessExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Can't perform multiple operations on a tag simultaneously. Perform the operations
///             sequentially.</p>
public struct ConcurrentAccessException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentAccessExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentAccessExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ConfirmSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "ConfirmSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmSubscriptionInput>
    public typealias MOutput = OperationOutput<ConfirmSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmSubscriptionOutputError>
}

extension ConfirmSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmSubscriptionInput(authenticateOnUnsubscribe: \(String(describing: authenticateOnUnsubscribe)), token: \(String(describing: token)), topicArn: \(String(describing: topicArn)))"}
}

extension ConfirmSubscriptionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let authenticateOnUnsubscribe = authenticateOnUnsubscribe {
            try container.encode(authenticateOnUnsubscribe, forKey: Key("AuthenticateOnUnsubscribe"))
        }
        if let token = token {
            try container.encode(token, forKey: Key("Token"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
        try container.encode("ConfirmSubscription", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct ConfirmSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "ConfirmSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmSubscriptionInput>
    public typealias MOutput = OperationOutput<ConfirmSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmSubscriptionOutputError>
}

public struct ConfirmSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "ConfirmSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmSubscriptionInput>
    public typealias MOutput = OperationOutput<ConfirmSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmSubscriptionOutputError>
}

/// <p>Input for ConfirmSubscription action.</p>
public struct ConfirmSubscriptionInput: Equatable {
    /// <p>Disallows unauthenticated unsubscribes of the subscription. If the value of this
    ///             parameter is <code>true</code> and the request has an AWS signature, then only the topic
    ///             owner and the subscription owner can unsubscribe the endpoint. The unsubscribe action
    ///             requires AWS authentication. </p>
    public let authenticateOnUnsubscribe: String?
    /// <p>Short-lived token sent to an endpoint during the <code>Subscribe</code> action.</p>
    public let token: String?
    /// <p>The ARN of the topic for which you wish to confirm a subscription.</p>
    public let topicArn: String?

    public init (
        authenticateOnUnsubscribe: String? = nil,
        token: String? = nil,
        topicArn: String? = nil
    )
    {
        self.authenticateOnUnsubscribe = authenticateOnUnsubscribe
        self.token = token
        self.topicArn = topicArn
    }
}

extension ConfirmSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ConfirmSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterPolicyLimitExceededException" : self = .filterPolicyLimitExceededException(try FilterPolicyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionLimitExceededException" : self = .subscriptionLimitExceededException(try SubscriptionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfirmSubscriptionOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case filterPolicyLimitExceededException(FilterPolicyLimitExceededException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case subscriptionLimitExceededException(SubscriptionLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmSubscriptionOutputResponse(subscriptionArn: \(String(describing: subscriptionArn)))"}
}

extension ConfirmSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConfirmSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.subscriptionArn = output.subscriptionArn
        } else {
            self.subscriptionArn = nil
        }
    }
}

/// <p>Response for ConfirmSubscriptions action.</p>
public struct ConfirmSubscriptionOutputResponse: Equatable {
    /// <p>The ARN of the created subscription.</p>
    public let subscriptionArn: String?

    public init (
        subscriptionArn: String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct ConfirmSubscriptionOutputResponseBody: Equatable {
    public let subscriptionArn: String?
}

extension ConfirmSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ConfirmSubscriptionResult"))
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

public struct CreatePlatformApplicationInputBodyMiddleware: Middleware {
    public let id: String = "CreatePlatformApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePlatformApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePlatformApplicationInput>
    public typealias MOutput = OperationOutput<CreatePlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePlatformApplicationOutputError>
}

extension CreatePlatformApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePlatformApplicationInput(attributes: \(String(describing: attributes)), name: \(String(describing: name)), platform: \(String(describing: platform)))"}
}

extension CreatePlatformApplicationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("key"))
                try keyContainer0.encode(stringKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("value"))
                try valueContainer0.encode(stringValue0, forKey: Key(""))
            }
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let platform = platform {
            try container.encode(platform, forKey: Key("Platform"))
        }
        try container.encode("CreatePlatformApplication", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct CreatePlatformApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePlatformApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePlatformApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePlatformApplicationInput>
    public typealias MOutput = OperationOutput<CreatePlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePlatformApplicationOutputError>
}

public struct CreatePlatformApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePlatformApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePlatformApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePlatformApplicationInput>
    public typealias MOutput = OperationOutput<CreatePlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePlatformApplicationOutputError>
}

/// <p>Input for CreatePlatformApplication action.</p>
public struct CreatePlatformApplicationInput: Equatable {
    /// <p>For a list of attributes, see <a href="https://docs.aws.amazon.com/sns/latest/api/API_SetPlatformApplicationAttributes.html">SetPlatformApplicationAttributes</a>.</p>
    public let attributes: [String:String]?
    /// <p>Application names must be made up of only uppercase and lowercase ASCII letters,
    ///             numbers, underscores, hyphens, and periods, and must be between 1 and 256 characters
    ///             long.</p>
    public let name: String?
    /// <p>The following platforms are supported: ADM (Amazon Device Messaging), APNS (Apple Push
    ///             Notification Service), APNS_SANDBOX, and GCM (Firebase Cloud Messaging).</p>
    public let platform: String?

    public init (
        attributes: [String:String]? = nil,
        name: String? = nil,
        platform: String? = nil
    )
    {
        self.attributes = attributes
        self.name = name
        self.platform = platform
    }
}

extension CreatePlatformApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreatePlatformApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePlatformApplicationOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePlatformApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePlatformApplicationOutputResponse(platformApplicationArn: \(String(describing: platformApplicationArn)))"}
}

extension CreatePlatformApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePlatformApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.platformApplicationArn = output.platformApplicationArn
        } else {
            self.platformApplicationArn = nil
        }
    }
}

/// <p>Response from CreatePlatformApplication action.</p>
public struct CreatePlatformApplicationOutputResponse: Equatable {
    /// <p>PlatformApplicationArn is returned.</p>
    public let platformApplicationArn: String?

    public init (
        platformApplicationArn: String? = nil
    )
    {
        self.platformApplicationArn = platformApplicationArn
    }
}

struct CreatePlatformApplicationOutputResponseBody: Equatable {
    public let platformApplicationArn: String?
}

extension CreatePlatformApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case platformApplicationArn = "PlatformApplicationArn"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreatePlatformApplicationResult"))
        let platformApplicationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformApplicationArn)
        platformApplicationArn = platformApplicationArnDecoded
    }
}

public struct CreatePlatformEndpointInputBodyMiddleware: Middleware {
    public let id: String = "CreatePlatformEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePlatformEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePlatformEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePlatformEndpointInput>
    public typealias MOutput = OperationOutput<CreatePlatformEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePlatformEndpointOutputError>
}

extension CreatePlatformEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePlatformEndpointInput(attributes: \(String(describing: attributes)), customUserData: \(String(describing: customUserData)), platformApplicationArn: \(String(describing: platformApplicationArn)), token: \(String(describing: token)))"}
}

extension CreatePlatformEndpointInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("key"))
                try keyContainer0.encode(stringKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("value"))
                try valueContainer0.encode(stringValue0, forKey: Key(""))
            }
        }
        if let customUserData = customUserData {
            try container.encode(customUserData, forKey: Key("CustomUserData"))
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: Key("PlatformApplicationArn"))
        }
        if let token = token {
            try container.encode(token, forKey: Key("Token"))
        }
        try container.encode("CreatePlatformEndpoint", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct CreatePlatformEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePlatformEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePlatformEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePlatformEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePlatformEndpointInput>
    public typealias MOutput = OperationOutput<CreatePlatformEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePlatformEndpointOutputError>
}

public struct CreatePlatformEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePlatformEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePlatformEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePlatformEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePlatformEndpointInput>
    public typealias MOutput = OperationOutput<CreatePlatformEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePlatformEndpointOutputError>
}

/// <p>Input for CreatePlatformEndpoint action.</p>
public struct CreatePlatformEndpointInput: Equatable {
    /// <p>For a list of attributes, see <a href="https://docs.aws.amazon.com/sns/latest/api/API_SetEndpointAttributes.html">SetEndpointAttributes</a>.</p>
    public let attributes: [String:String]?
    /// <p>Arbitrary user data to associate with the endpoint. Amazon SNS does not use this data. The
    ///             data must be in UTF-8 format and less than 2KB.</p>
    public let customUserData: String?
    /// <p>PlatformApplicationArn returned from CreatePlatformApplication is used to create a an
    ///             endpoint.</p>
    public let platformApplicationArn: String?
    /// <p>Unique identifier created by the notification service for an app on a device. The
    ///             specific name for Token will vary, depending on which notification service is being
    ///             used. For example, when using APNS as the notification service, you need the device
    ///             token. Alternatively, when using GCM (Firebase Cloud Messaging) or ADM, the device token
    ///             equivalent is called the registration ID.</p>
    public let token: String?

    public init (
        attributes: [String:String]? = nil,
        customUserData: String? = nil,
        platformApplicationArn: String? = nil,
        token: String? = nil
    )
    {
        self.attributes = attributes
        self.customUserData = customUserData
        self.platformApplicationArn = platformApplicationArn
        self.token = token
    }
}

extension CreatePlatformEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreatePlatformEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePlatformEndpointOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePlatformEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePlatformEndpointOutputResponse(endpointArn: \(String(describing: endpointArn)))"}
}

extension CreatePlatformEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePlatformEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointArn = output.endpointArn
        } else {
            self.endpointArn = nil
        }
    }
}

/// <p>Response from CreateEndpoint action.</p>
public struct CreatePlatformEndpointOutputResponse: Equatable {
    /// <p>EndpointArn returned from CreateEndpoint action.</p>
    public let endpointArn: String?

    public init (
        endpointArn: String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct CreatePlatformEndpointOutputResponseBody: Equatable {
    public let endpointArn: String?
}

extension CreatePlatformEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreatePlatformEndpointResult"))
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

public struct CreateSMSSandboxPhoneNumberInputBodyMiddleware: Middleware {
    public let id: String = "CreateSMSSandboxPhoneNumberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSMSSandboxPhoneNumberInput>
    public typealias MOutput = OperationOutput<CreateSMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSMSSandboxPhoneNumberOutputError>
}

extension CreateSMSSandboxPhoneNumberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSMSSandboxPhoneNumberInput(languageCode: \(String(describing: languageCode)), phoneNumber: \(String(describing: phoneNumber)))"}
}

extension CreateSMSSandboxPhoneNumberInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let languageCode = languageCode {
            try container.encode(languageCode, forKey: Key("LanguageCode"))
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: Key("PhoneNumber"))
        }
        try container.encode("CreateSMSSandboxPhoneNumber", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct CreateSMSSandboxPhoneNumberInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSMSSandboxPhoneNumberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSMSSandboxPhoneNumberInput>
    public typealias MOutput = OperationOutput<CreateSMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSMSSandboxPhoneNumberOutputError>
}

public struct CreateSMSSandboxPhoneNumberInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSMSSandboxPhoneNumberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSMSSandboxPhoneNumberInput>
    public typealias MOutput = OperationOutput<CreateSMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSMSSandboxPhoneNumberOutputError>
}

public struct CreateSMSSandboxPhoneNumberInput: Equatable {
    /// <p>The language to use for sending the OTP. The default value is
    ///             <code>en-US</code>.</p>
    public let languageCode: LanguageCodeString?
    /// <p>The destination phone number to verify. On verification, Amazon SNS adds this phone number
    ///             to the list of verified phone numbers that you can send SMS messages to.</p>
    public let phoneNumber: String?

    public init (
        languageCode: LanguageCodeString? = nil,
        phoneNumber: String? = nil
    )
    {
        self.languageCode = languageCode
        self.phoneNumber = phoneNumber
    }
}

extension CreateSMSSandboxPhoneNumberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateSMSSandboxPhoneNumberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptedOutException" : self = .optedOutException(try OptedOutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserErrorException" : self = .userErrorException(try UserErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSMSSandboxPhoneNumberOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case optedOutException(OptedOutException)
    case throttledException(ThrottledException)
    case userErrorException(UserErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSMSSandboxPhoneNumberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSMSSandboxPhoneNumberOutputResponse()"}
}

extension CreateSMSSandboxPhoneNumberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateSMSSandboxPhoneNumberOutputResponse: Equatable {

    public init() {}
}

struct CreateSMSSandboxPhoneNumberOutputResponseBody: Equatable {
}

extension CreateSMSSandboxPhoneNumberOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateTopicInputBodyMiddleware: Middleware {
    public let id: String = "CreateTopicInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTopicInput>
    public typealias MOutput = OperationOutput<CreateTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTopicOutputError>
}

extension CreateTopicInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTopicInput(attributes: \(String(describing: attributes)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateTopicInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let attributenameKey0 = element0.key
                let attributevalueValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("key"))
                try keyContainer0.encode(attributenameKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("value"))
                try valueContainer0.encode(attributevalueValue0, forKey: Key(""))
            }
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateTopic", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct CreateTopicInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTopicInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTopicInput>
    public typealias MOutput = OperationOutput<CreateTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTopicOutputError>
}

public struct CreateTopicInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTopicInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTopicInput>
    public typealias MOutput = OperationOutput<CreateTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTopicOutputError>
}

/// <p>Input for CreateTopic action.</p>
public struct CreateTopicInput: Equatable {
    /// <p>A map of attributes with their corresponding values.</p>
    ///         <p>The following lists the names, descriptions, and values of the special request
    ///             parameters that the <code>CreateTopic</code> action uses:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>DeliveryPolicy</code> – The policy that defines how Amazon SNS retries
    ///                     failed deliveries to HTTP/S endpoints.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DisplayName</code> – The display name to use for a topic with SMS
    ///                     subscriptions.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FifoTopic</code> – Set to true to create a FIFO topic.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Policy</code> – The policy that defines who can access your
    ///                     topic. By default, only the topic owner can publish or subscribe to the
    ///                     topic.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>The following attribute applies only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html">server-side
    ///             encryption</a>:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>KmsMasterKeyId</code> – The ID of an AWS managed customer master
    ///                     key (CMK) for Amazon SNS or a custom CMK. For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms">Key
    ///                         Terms</a>. For more examples, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters">KeyId</a> in the <i>AWS Key Management Service API
    ///                         Reference</i>. </p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///         <p>The following attributes apply only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html">FIFO topics</a>:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>FifoTopic</code> – When this is set to <code>true</code>, a FIFO
    ///                 topic is created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                     <code>ContentBasedDeduplication</code> –  Enables content-based deduplication for
    ///                     FIFO topics.</p>
    ///
    ///                 <ul>
    ///                   <li>
    ///                         <p>By default, <code>ContentBasedDeduplication</code> is set to <code>false</code>.
    ///                             If you create a FIFO topic and this attribute is <code>false</code>, you must
    ///                             specify a value for the <code>MessageDeduplicationId</code> parameter for the
    ///                             <a href="https://docs.aws.amazon.com/sns/latest/api/API_Publish.html">Publish</a> action. </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>When you set <code>ContentBasedDeduplication</code> to <code>true</code>,
    ///                             Amazon SNS uses a SHA-256 hash to generate the <code>MessageDeduplicationId</code> using
    ///                             the body of the message (but not the attributes of the message).</p>
    ///                         <p>(Optional) To override the generated value, you can specify a value
    ///                             for the <code>MessageDeduplicationId</code> parameter for the <code>Publish</code>
    ///                             action.</p>
    ///                      </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let attributes: [String:String]?
    /// <p>The name of the topic you want to create.</p>
    ///         <p>Constraints: Topic names must be made up of only uppercase and lowercase ASCII
    ///             letters, numbers, underscores, and hyphens, and must be between 1 and 256 characters
    ///             long.</p>
    ///         <p>For a FIFO (first-in-first-out) topic, the name must end with the <code>.fifo</code>
    ///             suffix. </p>
    public let name: String?
    /// <p>The list of tags to add to a new topic.</p>
    ///         <note>
    ///             <p>To be able to tag a topic on creation, you must have the
    ///                     <code>sns:CreateTopic</code> and <code>sns:TagResource</code>
    ///                 permissions.</p>
    ///         </note>
    public let tags: [Tag]?

    public init (
        attributes: [String:String]? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.attributes = attributes
        self.name = name
        self.tags = tags
    }
}

extension CreateTopicOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateTopicOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccessException" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityException" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleTagException" : self = .staleTagException(try StaleTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededException" : self = .tagLimitExceededException(try TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TopicLimitExceededException" : self = .topicLimitExceededException(try TopicLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTopicOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case concurrentAccessException(ConcurrentAccessException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSecurityException(InvalidSecurityException)
    case staleTagException(StaleTagException)
    case tagLimitExceededException(TagLimitExceededException)
    case tagPolicyException(TagPolicyException)
    case topicLimitExceededException(TopicLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTopicOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTopicOutputResponse(topicArn: \(String(describing: topicArn)))"}
}

extension CreateTopicOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTopicOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.topicArn = output.topicArn
        } else {
            self.topicArn = nil
        }
    }
}

/// <p>Response from CreateTopic action.</p>
public struct CreateTopicOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) assigned to the created topic.</p>
    public let topicArn: String?

    public init (
        topicArn: String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

struct CreateTopicOutputResponseBody: Equatable {
    public let topicArn: String?
}

extension CreateTopicOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case topicArn = "TopicArn"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateTopicResult"))
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

public struct DeleteEndpointInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointOutputError>
}

extension DeleteEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEndpointInput(endpointArn: \(String(describing: endpointArn)))"}
}

extension DeleteEndpointInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: Key("EndpointArn"))
        }
        try container.encode("DeleteEndpoint", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct DeleteEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointOutputError>
}

public struct DeleteEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointOutputError>
}

/// <p>Input for DeleteEndpoint action.</p>
public struct DeleteEndpointInput: Equatable {
    /// <p>EndpointArn of endpoint to delete.</p>
    public let endpointArn: String?

    public init (
        endpointArn: String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

extension DeleteEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEndpointOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEndpointOutputResponse()"}
}

extension DeleteEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEndpointOutputResponse: Equatable {

    public init() {}
}

struct DeleteEndpointOutputResponseBody: Equatable {
}

extension DeleteEndpointOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePlatformApplicationInputBodyMiddleware: Middleware {
    public let id: String = "DeletePlatformApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePlatformApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePlatformApplicationInput>
    public typealias MOutput = OperationOutput<DeletePlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePlatformApplicationOutputError>
}

extension DeletePlatformApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePlatformApplicationInput(platformApplicationArn: \(String(describing: platformApplicationArn)))"}
}

extension DeletePlatformApplicationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: Key("PlatformApplicationArn"))
        }
        try container.encode("DeletePlatformApplication", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct DeletePlatformApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePlatformApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePlatformApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePlatformApplicationInput>
    public typealias MOutput = OperationOutput<DeletePlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePlatformApplicationOutputError>
}

public struct DeletePlatformApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePlatformApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePlatformApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePlatformApplicationInput>
    public typealias MOutput = OperationOutput<DeletePlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePlatformApplicationOutputError>
}

/// <p>Input for DeletePlatformApplication action.</p>
public struct DeletePlatformApplicationInput: Equatable {
    /// <p>PlatformApplicationArn of platform application object to delete.</p>
    public let platformApplicationArn: String?

    public init (
        platformApplicationArn: String? = nil
    )
    {
        self.platformApplicationArn = platformApplicationArn
    }
}

extension DeletePlatformApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePlatformApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePlatformApplicationOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePlatformApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePlatformApplicationOutputResponse()"}
}

extension DeletePlatformApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePlatformApplicationOutputResponse: Equatable {

    public init() {}
}

struct DeletePlatformApplicationOutputResponseBody: Equatable {
}

extension DeletePlatformApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSMSSandboxPhoneNumberInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSMSSandboxPhoneNumberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSMSSandboxPhoneNumberInput>
    public typealias MOutput = OperationOutput<DeleteSMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSMSSandboxPhoneNumberOutputError>
}

extension DeleteSMSSandboxPhoneNumberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSMSSandboxPhoneNumberInput(phoneNumber: \(String(describing: phoneNumber)))"}
}

extension DeleteSMSSandboxPhoneNumberInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: Key("PhoneNumber"))
        }
        try container.encode("DeleteSMSSandboxPhoneNumber", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct DeleteSMSSandboxPhoneNumberInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSMSSandboxPhoneNumberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSMSSandboxPhoneNumberInput>
    public typealias MOutput = OperationOutput<DeleteSMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSMSSandboxPhoneNumberOutputError>
}

public struct DeleteSMSSandboxPhoneNumberInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSMSSandboxPhoneNumberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSMSSandboxPhoneNumberInput>
    public typealias MOutput = OperationOutput<DeleteSMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSMSSandboxPhoneNumberOutputError>
}

public struct DeleteSMSSandboxPhoneNumberInput: Equatable {
    /// <p>The destination phone number to delete.</p>
    public let phoneNumber: String?

    public init (
        phoneNumber: String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

extension DeleteSMSSandboxPhoneNumberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSMSSandboxPhoneNumberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserErrorException" : self = .userErrorException(try UserErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSMSSandboxPhoneNumberOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttledException(ThrottledException)
    case userErrorException(UserErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSMSSandboxPhoneNumberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSMSSandboxPhoneNumberOutputResponse()"}
}

extension DeleteSMSSandboxPhoneNumberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSMSSandboxPhoneNumberOutputResponse: Equatable {

    public init() {}
}

struct DeleteSMSSandboxPhoneNumberOutputResponseBody: Equatable {
}

extension DeleteSMSSandboxPhoneNumberOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteTopicInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTopicInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTopicInput>
    public typealias MOutput = OperationOutput<DeleteTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTopicOutputError>
}

extension DeleteTopicInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTopicInput(topicArn: \(String(describing: topicArn)))"}
}

extension DeleteTopicInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
        try container.encode("DeleteTopic", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct DeleteTopicInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTopicInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTopicInput>
    public typealias MOutput = OperationOutput<DeleteTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTopicOutputError>
}

public struct DeleteTopicInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTopicInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTopicInput>
    public typealias MOutput = OperationOutput<DeleteTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTopicOutputError>
}

public struct DeleteTopicInput: Equatable {
    /// <p>The ARN of the topic you want to delete.</p>
    public let topicArn: String?

    public init (
        topicArn: String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

extension DeleteTopicOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteTopicOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccessException" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleTagException" : self = .staleTagException(try StaleTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTopicOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case concurrentAccessException(ConcurrentAccessException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case staleTagException(StaleTagException)
    case tagPolicyException(TagPolicyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTopicOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTopicOutputResponse()"}
}

extension DeleteTopicOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTopicOutputResponse: Equatable {

    public init() {}
}

struct DeleteTopicOutputResponseBody: Equatable {
}

extension DeleteTopicOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Endpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("key"))
                try keyContainer0.encode(stringKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("value"))
                try valueContainer0.encode(stringValue0, forKey: Key(""))
            }
        }
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: Key("EndpointArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([MapKeyValue<String, String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [String:String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [String:String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension Endpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Endpoint(attributes: \(String(describing: attributes)), endpointArn: \(String(describing: endpointArn)))"}
}

/// <p>Endpoint for mobile app and device.</p>
public struct Endpoint: Equatable {
    /// <p>Attributes for endpoint.</p>
    public let attributes: [String:String]?
    /// <p>EndpointArn for mobile app and device.</p>
    public let endpointArn: String?

    public init (
        attributes: [String:String]? = nil,
        endpointArn: String? = nil
    )
    {
        self.attributes = attributes
        self.endpointArn = endpointArn
    }
}

extension EndpointDisabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointDisabledException(message: \(String(describing: message)))"}
}

extension EndpointDisabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<EndpointDisabledExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception error indicating endpoint disabled.</p>
public struct EndpointDisabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Message for endpoint disabled.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointDisabledExceptionBody: Equatable {
    public let message: String?
}

extension EndpointDisabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FilterPolicyLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FilterPolicyLimitExceededException(message: \(String(describing: message)))"}
}

extension FilterPolicyLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<FilterPolicyLimitExceededExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the number of filter polices in your AWS account exceeds the limit. To
///             add more filter polices, submit an SNS Limit Increase case in the AWS Support
///             Center.</p>
public struct FilterPolicyLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FilterPolicyLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension FilterPolicyLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetEndpointAttributesInputBodyMiddleware: Middleware {
    public let id: String = "GetEndpointAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEndpointAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEndpointAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEndpointAttributesInput>
    public typealias MOutput = OperationOutput<GetEndpointAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEndpointAttributesOutputError>
}

extension GetEndpointAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEndpointAttributesInput(endpointArn: \(String(describing: endpointArn)))"}
}

extension GetEndpointAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: Key("EndpointArn"))
        }
        try container.encode("GetEndpointAttributes", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct GetEndpointAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "GetEndpointAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEndpointAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEndpointAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEndpointAttributesInput>
    public typealias MOutput = OperationOutput<GetEndpointAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEndpointAttributesOutputError>
}

public struct GetEndpointAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEndpointAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEndpointAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEndpointAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEndpointAttributesInput>
    public typealias MOutput = OperationOutput<GetEndpointAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEndpointAttributesOutputError>
}

/// <p>Input for GetEndpointAttributes action.</p>
public struct GetEndpointAttributesInput: Equatable {
    /// <p>EndpointArn for GetEndpointAttributes input.</p>
    public let endpointArn: String?

    public init (
        endpointArn: String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

extension GetEndpointAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetEndpointAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEndpointAttributesOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEndpointAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEndpointAttributesOutputResponse(attributes: \(String(describing: attributes)))"}
}

extension GetEndpointAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEndpointAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

/// <p>Response from GetEndpointAttributes of the EndpointArn.</p>
public struct GetEndpointAttributesOutputResponse: Equatable {
    /// <p>Attributes include the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>CustomUserData</code> – arbitrary user data to associate with the
    ///                     endpoint. Amazon SNS does not use this data. The data must be in UTF-8 format and
    ///                     less than 2KB.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>Enabled</code> – flag that enables/disables delivery to the
    ///                     endpoint. Amazon SNS will set this to false when a notification service indicates to
    ///                     Amazon SNS that the endpoint is invalid. Users can set it back to true, typically
    ///                     after updating Token.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>Token</code> – device token, also referred to as a registration id,
    ///                     for an app and mobile device. This is returned from the notification service
    ///                     when an app and mobile device are registered with the notification
    ///                     service.</p>
    ///                 <note>
    ///                     <p>The device token for the iOS platform is returned in lowercase.</p>
    ///                 </note>
    ///             </li>
    ///          </ul>
    public let attributes: [String:String]?

    public init (
        attributes: [String:String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetEndpointAttributesOutputResponseBody: Equatable {
    public let attributes: [String:String]?
}

extension GetEndpointAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetEndpointAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([MapKeyValue<String, String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [String:String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [String:String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

public struct GetPlatformApplicationAttributesInputBodyMiddleware: Middleware {
    public let id: String = "GetPlatformApplicationAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPlatformApplicationAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPlatformApplicationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPlatformApplicationAttributesInput>
    public typealias MOutput = OperationOutput<GetPlatformApplicationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPlatformApplicationAttributesOutputError>
}

extension GetPlatformApplicationAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPlatformApplicationAttributesInput(platformApplicationArn: \(String(describing: platformApplicationArn)))"}
}

extension GetPlatformApplicationAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: Key("PlatformApplicationArn"))
        }
        try container.encode("GetPlatformApplicationAttributes", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct GetPlatformApplicationAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "GetPlatformApplicationAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPlatformApplicationAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPlatformApplicationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPlatformApplicationAttributesInput>
    public typealias MOutput = OperationOutput<GetPlatformApplicationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPlatformApplicationAttributesOutputError>
}

public struct GetPlatformApplicationAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPlatformApplicationAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPlatformApplicationAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPlatformApplicationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPlatformApplicationAttributesInput>
    public typealias MOutput = OperationOutput<GetPlatformApplicationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPlatformApplicationAttributesOutputError>
}

/// <p>Input for GetPlatformApplicationAttributes action.</p>
public struct GetPlatformApplicationAttributesInput: Equatable {
    /// <p>PlatformApplicationArn for GetPlatformApplicationAttributesInput.</p>
    public let platformApplicationArn: String?

    public init (
        platformApplicationArn: String? = nil
    )
    {
        self.platformApplicationArn = platformApplicationArn
    }
}

extension GetPlatformApplicationAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPlatformApplicationAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPlatformApplicationAttributesOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPlatformApplicationAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPlatformApplicationAttributesOutputResponse(attributes: \(String(describing: attributes)))"}
}

extension GetPlatformApplicationAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPlatformApplicationAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

/// <p>Response for GetPlatformApplicationAttributes action.</p>
public struct GetPlatformApplicationAttributesOutputResponse: Equatable {
    /// <p>Attributes include the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>EventEndpointCreated</code> – Topic ARN to which EndpointCreated
    ///                     event notifications should be sent.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EventEndpointDeleted</code> – Topic ARN to which EndpointDeleted
    ///                     event notifications should be sent.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EventEndpointUpdated</code> – Topic ARN to which EndpointUpdate
    ///                     event notifications should be sent.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EventDeliveryFailure</code> – Topic ARN to which DeliveryFailure
    ///                     event notifications should be sent upon Direct Publish delivery failure
    ///                     (permanent) to one of the application's endpoints.</p>
    ///             </li>
    ///          </ul>
    public let attributes: [String:String]?

    public init (
        attributes: [String:String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetPlatformApplicationAttributesOutputResponseBody: Equatable {
    public let attributes: [String:String]?
}

extension GetPlatformApplicationAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetPlatformApplicationAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([MapKeyValue<String, String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [String:String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [String:String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

public struct GetSMSAttributesInputBodyMiddleware: Middleware {
    public let id: String = "GetSMSAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSMSAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSMSAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSMSAttributesInput>
    public typealias MOutput = OperationOutput<GetSMSAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSMSAttributesOutputError>
}

extension GetSMSAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSMSAttributesInput(attributes: \(String(describing: attributes)))"}
}

extension GetSMSAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("attributes"))
            for (index0, string0) in attributes.enumerated() {
                try attributesContainer.encode(string0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("GetSMSAttributes", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct GetSMSAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "GetSMSAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSMSAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSMSAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSMSAttributesInput>
    public typealias MOutput = OperationOutput<GetSMSAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSMSAttributesOutputError>
}

public struct GetSMSAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSMSAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSMSAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSMSAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSMSAttributesInput>
    public typealias MOutput = OperationOutput<GetSMSAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSMSAttributesOutputError>
}

/// <p>The input for the <code>GetSMSAttributes</code> request.</p>
public struct GetSMSAttributesInput: Equatable {
    /// <p>A list of the individual attribute names, such as <code>MonthlySpendLimit</code>, for
    ///             which you want values.</p>
    ///         <p>For all attribute names, see <a href="https://docs.aws.amazon.com/sns/latest/api/API_SetSMSAttributes.html">SetSMSAttributes</a>.</p>
    ///         <p>If you don't use this parameter, Amazon SNS returns all SMS attributes.</p>
    public let attributes: [String]?

    public init (
        attributes: [String]? = nil
    )
    {
        self.attributes = attributes
    }
}

extension GetSMSAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSMSAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSMSAttributesOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSMSAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSMSAttributesOutputResponse(attributes: \(String(describing: attributes)))"}
}

extension GetSMSAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSMSAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

/// <p>The response from the <code>GetSMSAttributes</code> request.</p>
public struct GetSMSAttributesOutputResponse: Equatable {
    /// <p>The SMS attribute names and their values.</p>
    public let attributes: [String:String]?

    public init (
        attributes: [String:String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetSMSAttributesOutputResponseBody: Equatable {
    public let attributes: [String:String]?
}

extension GetSMSAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetSMSAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([MapKeyValue<String, String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [String:String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [String:String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

public struct GetSMSSandboxAccountStatusInputBodyMiddleware: Middleware {
    public let id: String = "GetSMSSandboxAccountStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSMSSandboxAccountStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSMSSandboxAccountStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSMSSandboxAccountStatusInput>
    public typealias MOutput = OperationOutput<GetSMSSandboxAccountStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSMSSandboxAccountStatusOutputError>
}

extension GetSMSSandboxAccountStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSMSSandboxAccountStatusInput()"}
}

extension GetSMSSandboxAccountStatusInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("GetSMSSandboxAccountStatus", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct GetSMSSandboxAccountStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetSMSSandboxAccountStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSMSSandboxAccountStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSMSSandboxAccountStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSMSSandboxAccountStatusInput>
    public typealias MOutput = OperationOutput<GetSMSSandboxAccountStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSMSSandboxAccountStatusOutputError>
}

public struct GetSMSSandboxAccountStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSMSSandboxAccountStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSMSSandboxAccountStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSMSSandboxAccountStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSMSSandboxAccountStatusInput>
    public typealias MOutput = OperationOutput<GetSMSSandboxAccountStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSMSSandboxAccountStatusOutputError>
}

public struct GetSMSSandboxAccountStatusInput: Equatable {

    public init() {}
}

extension GetSMSSandboxAccountStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSMSSandboxAccountStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSMSSandboxAccountStatusOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSMSSandboxAccountStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSMSSandboxAccountStatusOutputResponse(isInSandbox: \(String(describing: isInSandbox)))"}
}

extension GetSMSSandboxAccountStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSMSSandboxAccountStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isInSandbox = output.isInSandbox
        } else {
            self.isInSandbox = false
        }
    }
}

public struct GetSMSSandboxAccountStatusOutputResponse: Equatable {
    /// <p>Indicates whether the calling account is in the SMS sandbox.</p>
    public let isInSandbox: Bool

    public init (
        isInSandbox: Bool = false
    )
    {
        self.isInSandbox = isInSandbox
    }
}

struct GetSMSSandboxAccountStatusOutputResponseBody: Equatable {
    public let isInSandbox: Bool
}

extension GetSMSSandboxAccountStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isInSandbox = "IsInSandbox"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetSMSSandboxAccountStatusResult"))
        let isInSandboxDecoded = try containerValues.decode(Bool.self, forKey: .isInSandbox)
        isInSandbox = isInSandboxDecoded
    }
}

public struct GetSubscriptionAttributesInputBodyMiddleware: Middleware {
    public let id: String = "GetSubscriptionAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSubscriptionAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSubscriptionAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSubscriptionAttributesInput>
    public typealias MOutput = OperationOutput<GetSubscriptionAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSubscriptionAttributesOutputError>
}

extension GetSubscriptionAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSubscriptionAttributesInput(subscriptionArn: \(String(describing: subscriptionArn)))"}
}

extension GetSubscriptionAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: Key("SubscriptionArn"))
        }
        try container.encode("GetSubscriptionAttributes", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct GetSubscriptionAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "GetSubscriptionAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSubscriptionAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSubscriptionAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSubscriptionAttributesInput>
    public typealias MOutput = OperationOutput<GetSubscriptionAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSubscriptionAttributesOutputError>
}

public struct GetSubscriptionAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSubscriptionAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSubscriptionAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSubscriptionAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSubscriptionAttributesInput>
    public typealias MOutput = OperationOutput<GetSubscriptionAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSubscriptionAttributesOutputError>
}

/// <p>Input for GetSubscriptionAttributes.</p>
public struct GetSubscriptionAttributesInput: Equatable {
    /// <p>The ARN of the subscription whose properties you want to get.</p>
    public let subscriptionArn: String?

    public init (
        subscriptionArn: String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

extension GetSubscriptionAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSubscriptionAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSubscriptionAttributesOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSubscriptionAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSubscriptionAttributesOutputResponse(attributes: \(String(describing: attributes)))"}
}

extension GetSubscriptionAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSubscriptionAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

/// <p>Response for GetSubscriptionAttributes action.</p>
public struct GetSubscriptionAttributesOutputResponse: Equatable {
    /// <p>A map of the subscription's attributes. Attributes in this map include the
    ///             following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>ConfirmationWasAuthenticated</code> – <code>true</code> if the
    ///                     subscription confirmation request was authenticated.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>DeliveryPolicy</code> – The JSON serialization of the
    ///                     subscription's delivery policy.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EffectiveDeliveryPolicy</code> – The JSON serialization of the
    ///                     effective delivery policy that takes into account the topic delivery policy and
    ///                     account system defaults.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>FilterPolicy</code> – The filter policy JSON that is assigned to
    ///                     the subscription. For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-message-filtering.html">Amazon SNS Message
    ///                         Filtering</a> in the <i>Amazon SNS Developer Guide</i>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>Owner</code> – The AWS account ID of the subscription's
    ///                     owner.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>PendingConfirmation</code> – <code>true</code> if the subscription
    ///                     hasn't been confirmed. To confirm a pending subscription, call the
    ///                         <code>ConfirmSubscription</code> action with a confirmation token.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>RawMessageDelivery</code> – <code>true</code> if raw message
    ///                     delivery is enabled for the subscription. Raw messages are free of JSON
    ///                     formatting and can be sent to HTTP/S and Amazon SQS endpoints.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>RedrivePolicy</code> – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue.
    ///     Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable)
    ///     or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held
    ///     in the dead-letter queue for further analysis or reprocessing.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>SubscriptionArn</code> – The subscription's ARN.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>TopicArn</code> – The topic ARN that the subscription is associated
    ///                     with.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>The following attribute applies only to Amazon Kinesis Data Firehose delivery stream subscriptions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SubscriptionRoleArn</code> – The ARN of the IAM role that has the following:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>Permission to write to the Kinesis Data Firehose delivery stream</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>Amazon SNS listed as a trusted entity</p>
    ///                     </li>
    ///                </ul>
    ///                 <p>Specifying a valid ARN for this attribute is required for Kinesis Data Firehose delivery stream subscriptions.
    ///                 For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html">Fanout
    ///                     to Kinesis Data Firehose delivery streams</a> in the <i>Amazon SNS Developer Guide</i>.</p>
    ///                     </li>
    ///          </ul>
    public let attributes: [String:String]?

    public init (
        attributes: [String:String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetSubscriptionAttributesOutputResponseBody: Equatable {
    public let attributes: [String:String]?
}

extension GetSubscriptionAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetSubscriptionAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([MapKeyValue<String, String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [String:String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [String:String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

public struct GetTopicAttributesInputBodyMiddleware: Middleware {
    public let id: String = "GetTopicAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTopicAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTopicAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTopicAttributesInput>
    public typealias MOutput = OperationOutput<GetTopicAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTopicAttributesOutputError>
}

extension GetTopicAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTopicAttributesInput(topicArn: \(String(describing: topicArn)))"}
}

extension GetTopicAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
        try container.encode("GetTopicAttributes", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct GetTopicAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "GetTopicAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTopicAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTopicAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTopicAttributesInput>
    public typealias MOutput = OperationOutput<GetTopicAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTopicAttributesOutputError>
}

public struct GetTopicAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTopicAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTopicAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTopicAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTopicAttributesInput>
    public typealias MOutput = OperationOutput<GetTopicAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTopicAttributesOutputError>
}

/// <p>Input for GetTopicAttributes action.</p>
public struct GetTopicAttributesInput: Equatable {
    /// <p>The ARN of the topic whose properties you want to get.</p>
    public let topicArn: String?

    public init (
        topicArn: String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

extension GetTopicAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetTopicAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityException" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTopicAttributesOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSecurityException(InvalidSecurityException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTopicAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTopicAttributesOutputResponse(attributes: \(String(describing: attributes)))"}
}

extension GetTopicAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTopicAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

/// <p>Response for GetTopicAttributes action.</p>
public struct GetTopicAttributesOutputResponse: Equatable {
    /// <p>A map of the topic's attributes. Attributes in this map include the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>DeliveryPolicy</code> – The JSON serialization of the topic's
    ///                     delivery policy.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DisplayName</code> – The human-readable name used in the
    ///                         <code>From</code> field for notifications to <code>email</code> and
    ///                         <code>email-json</code> endpoints.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Owner</code> – The AWS account ID of the topic's owner.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Policy</code> – The JSON serialization of the topic's access
    ///                     control policy.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SubscriptionsConfirmed</code> – The number of confirmed
    ///                     subscriptions for the topic.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SubscriptionsDeleted</code> – The number of deleted subscriptions
    ///                     for the topic.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SubscriptionsPending</code> – The number of subscriptions pending
    ///                     confirmation for the topic.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>TopicArn</code> – The topic's ARN.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>EffectiveDeliveryPolicy</code> – The JSON serialization of the
    ///                     effective delivery policy, taking system defaults into account.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>The following attribute applies only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html">server-side-encryption</a>:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>KmsMasterKeyId</code> - The ID of an AWS-managed customer master key
    ///                     (CMK) for Amazon SNS or a custom CMK. For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms">Key
    ///                         Terms</a>. For more examples, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters">KeyId</a> in the <i>AWS Key Management Service API
    ///                         Reference</i>.</p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///         <p>The following attributes apply only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html">FIFO topics</a>:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>FifoTopic</code> – When this is set to <code>true</code>, a FIFO
    ///                 topic is created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                     <code>ContentBasedDeduplication</code> –  Enables content-based deduplication for
    ///                     FIFO topics.</p>
    ///
    ///                 <ul>
    ///                   <li>
    ///                         <p>By default, <code>ContentBasedDeduplication</code> is set to <code>false</code>.
    ///                             If you create a FIFO topic and this attribute is <code>false</code>, you must
    ///                             specify a value for the <code>MessageDeduplicationId</code> parameter for the
    ///                             <a href="https://docs.aws.amazon.com/sns/latest/api/API_Publish.html">Publish</a> action. </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>When you set <code>ContentBasedDeduplication</code> to <code>true</code>,
    ///                             Amazon SNS uses a SHA-256 hash to generate the <code>MessageDeduplicationId</code> using
    ///                             the body of the message (but not the attributes of the message).</p>
    ///                         <p>(Optional) To override the generated value, you can specify a value
    ///                             for the <code>MessageDeduplicationId</code> parameter for the <code>Publish</code>
    ///                             action.</p>
    ///                      </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let attributes: [String:String]?

    public init (
        attributes: [String:String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetTopicAttributesOutputResponseBody: Equatable {
    public let attributes: [String:String]?
}

extension GetTopicAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetTopicAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([MapKeyValue<String, String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [String:String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [String:String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension InternalErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalErrorException(message: \(String(describing: message)))"}
}

extension InternalErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InternalErrorExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates an internal service error.</p>
public struct InternalErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidParameterExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a request parameter does not comply with the associated
///             constraints.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterValueException(message: \(String(describing: message)))"}
}

extension InvalidParameterValueException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidParameterValueExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a request parameter does not comply with the associated
///             constraints.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The parameter value is invalid.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterValueExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSecurityException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSecurityException(message: \(String(describing: message)))"}
}

extension InvalidSecurityException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidSecurityExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The credential signature isn't valid. You must use an HTTPS endpoint and sign your
///             request using Signature Version 4.</p>
public struct InvalidSecurityException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSecurityExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSecurityExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSAccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSAccessDeniedException(message: \(String(describing: message)))"}
}

extension KMSAccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<KMSAccessDeniedExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The ciphertext references a key that doesn't exist or that you don't have access
///             to.</p>
public struct KMSAccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSAccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension KMSAccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSDisabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSDisabledException(message: \(String(describing: message)))"}
}

extension KMSDisabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<KMSDisabledExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified customer master key (CMK) isn't
///             enabled.</p>
public struct KMSDisabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSDisabledExceptionBody: Equatable {
    public let message: String?
}

extension KMSDisabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSInvalidStateException(message: \(String(describing: message)))"}
}

extension KMSInvalidStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<KMSInvalidStateExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the state of the specified resource isn't valid for
///             this request. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
///                 Customer Master Key</a> in the <i>AWS Key Management Service Developer
///                 Guide</i>.</p>
public struct KMSInvalidStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSInvalidStateExceptionBody: Equatable {
    public let message: String?
}

extension KMSInvalidStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSNotFoundException(message: \(String(describing: message)))"}
}

extension KMSNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<KMSNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified entity or resource can't be
///             found.</p>
public struct KMSNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension KMSNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSOptInRequired: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSOptInRequired(message: \(String(describing: message)))"}
}

extension KMSOptInRequired: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<KMSOptInRequiredBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS access key ID needs a subscription for the service.</p>
public struct KMSOptInRequired: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSOptInRequiredBody: Equatable {
    public let message: String?
}

extension KMSOptInRequiredBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSThrottlingException(message: \(String(describing: message)))"}
}

extension KMSThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<KMSThrottlingExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling. For more information about
///             throttling, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html#requests-per-second">Limits</a> in
///             the <i>AWS Key Management Service Developer Guide.</i>
///          </p>
public struct KMSThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension KMSThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

/// Supported language code for sending OTP message
public enum LanguageCodeString {
    case deDe
    case enGb
    case enUs
    case es419
    case esEs
    case frCa
    case frFr
    case itIt
    case jpJp
    case krKr
    case ptBr
    case zhCn
    case zhTw
    case sdkUnknown(String)
}

extension LanguageCodeString : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LanguageCodeString] {
        return [
            .deDe,
            .enGb,
            .enUs,
            .es419,
            .esEs,
            .frCa,
            .frFr,
            .itIt,
            .jpJp,
            .krKr,
            .ptBr,
            .zhCn,
            .zhTw,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deDe: return "de-DE"
        case .enGb: return "en-GB"
        case .enUs: return "en-US"
        case .es419: return "es-419"
        case .esEs: return "es-ES"
        case .frCa: return "fr-CA"
        case .frFr: return "fr-FR"
        case .itIt: return "it-IT"
        case .jpJp: return "ja-JP"
        case .krKr: return "kr-KR"
        case .ptBr: return "pt-BR"
        case .zhCn: return "zh-CN"
        case .zhTw: return "zh-TW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LanguageCodeString(rawValue: rawValue) ?? LanguageCodeString.sdkUnknown(rawValue)
    }
}

public struct ListEndpointsByPlatformApplicationInputBodyMiddleware: Middleware {
    public let id: String = "ListEndpointsByPlatformApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEndpointsByPlatformApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEndpointsByPlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEndpointsByPlatformApplicationInput>
    public typealias MOutput = OperationOutput<ListEndpointsByPlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEndpointsByPlatformApplicationOutputError>
}

extension ListEndpointsByPlatformApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEndpointsByPlatformApplicationInput(nextToken: \(String(describing: nextToken)), platformApplicationArn: \(String(describing: platformApplicationArn)))"}
}

extension ListEndpointsByPlatformApplicationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: Key("PlatformApplicationArn"))
        }
        try container.encode("ListEndpointsByPlatformApplication", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct ListEndpointsByPlatformApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "ListEndpointsByPlatformApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEndpointsByPlatformApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEndpointsByPlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEndpointsByPlatformApplicationInput>
    public typealias MOutput = OperationOutput<ListEndpointsByPlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEndpointsByPlatformApplicationOutputError>
}

public struct ListEndpointsByPlatformApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEndpointsByPlatformApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEndpointsByPlatformApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEndpointsByPlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEndpointsByPlatformApplicationInput>
    public typealias MOutput = OperationOutput<ListEndpointsByPlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEndpointsByPlatformApplicationOutputError>
}

/// <p>Input for ListEndpointsByPlatformApplication action.</p>
public struct ListEndpointsByPlatformApplicationInput: Equatable {
    /// <p>NextToken string is used when calling ListEndpointsByPlatformApplication action to
    ///             retrieve additional records that are available after the first page results.</p>
    public let nextToken: String?
    /// <p>PlatformApplicationArn for ListEndpointsByPlatformApplicationInput action.</p>
    public let platformApplicationArn: String?

    public init (
        nextToken: String? = nil,
        platformApplicationArn: String? = nil
    )
    {
        self.nextToken = nextToken
        self.platformApplicationArn = platformApplicationArn
    }
}

extension ListEndpointsByPlatformApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListEndpointsByPlatformApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEndpointsByPlatformApplicationOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEndpointsByPlatformApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEndpointsByPlatformApplicationOutputResponse(endpoints: \(String(describing: endpoints)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEndpointsByPlatformApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEndpointsByPlatformApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpoints = output.endpoints
            self.nextToken = output.nextToken
        } else {
            self.endpoints = nil
            self.nextToken = nil
        }
    }
}

/// <p>Response for ListEndpointsByPlatformApplication action.</p>
public struct ListEndpointsByPlatformApplicationOutputResponse: Equatable {
    /// <p>Endpoints returned for ListEndpointsByPlatformApplication action.</p>
    public let endpoints: [Endpoint]?
    /// <p>NextToken string is returned when calling ListEndpointsByPlatformApplication action if
    ///             additional records are available after the first page results.</p>
    public let nextToken: String?

    public init (
        endpoints: [Endpoint]? = nil,
        nextToken: String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

struct ListEndpointsByPlatformApplicationOutputResponseBody: Equatable {
    public let endpoints: [Endpoint]?
    public let nextToken: String?
}

extension ListEndpointsByPlatformApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpoints = "Endpoints"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListEndpointsByPlatformApplicationResult"))
        if containerValues.contains(.endpoints) {
            struct KeyVal0{struct member{}}
            let endpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endpoints)
            if let endpointsWrappedContainer = endpointsWrappedContainer {
                let endpointsContainer = try endpointsWrappedContainer.decodeIfPresent([Endpoint].self, forKey: .member)
                var endpointsBuffer:[Endpoint]? = nil
                if let endpointsContainer = endpointsContainer {
                    endpointsBuffer = [Endpoint]()
                    for structureContainer0 in endpointsContainer {
                        endpointsBuffer?.append(structureContainer0)
                    }
                }
                endpoints = endpointsBuffer
            } else {
                endpoints = []
            }
        } else {
            endpoints = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOriginationNumbersInputBodyMiddleware: Middleware {
    public let id: String = "ListOriginationNumbersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOriginationNumbersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOriginationNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOriginationNumbersInput>
    public typealias MOutput = OperationOutput<ListOriginationNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOriginationNumbersOutputError>
}

extension ListOriginationNumbersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOriginationNumbersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListOriginationNumbersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("ListOriginationNumbers", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct ListOriginationNumbersInputHeadersMiddleware: Middleware {
    public let id: String = "ListOriginationNumbersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOriginationNumbersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOriginationNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOriginationNumbersInput>
    public typealias MOutput = OperationOutput<ListOriginationNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOriginationNumbersOutputError>
}

public struct ListOriginationNumbersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOriginationNumbersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOriginationNumbersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOriginationNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOriginationNumbersInput>
    public typealias MOutput = OperationOutput<ListOriginationNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOriginationNumbersOutputError>
}

public struct ListOriginationNumbersInput: Equatable {
    /// <p>The maximum number of origination numbers to return.</p>
    public let maxResults: Int?
    /// <p>Token that the previous <code>ListOriginationNumbers</code> request returns.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListOriginationNumbersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListOriginationNumbersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOriginationNumbersOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOriginationNumbersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOriginationNumbersOutputResponse(nextToken: \(String(describing: nextToken)), phoneNumbers: \(String(describing: phoneNumbers)))"}
}

extension ListOriginationNumbersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOriginationNumbersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

public struct ListOriginationNumbersOutputResponse: Equatable {
    /// <p>A <code>NextToken</code> string is returned when you call the
    ///                 <code>ListOriginationNumbers</code> operation if additional pages of records are
    ///             available.</p>
    public let nextToken: String?
    /// <p>A list of the calling account's verified and pending origination numbers.</p>
    public let phoneNumbers: [PhoneNumberInformation]?

    public init (
        nextToken: String? = nil,
        phoneNumbers: [PhoneNumberInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct ListOriginationNumbersOutputResponseBody: Equatable {
    public let nextToken: String?
    public let phoneNumbers: [PhoneNumberInformation]?
}

extension ListOriginationNumbersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case phoneNumbers = "PhoneNumbers"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListOriginationNumbersResult"))
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        if containerValues.contains(.phoneNumbers) {
            struct KeyVal0{struct member{}}
            let phoneNumbersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .phoneNumbers)
            if let phoneNumbersWrappedContainer = phoneNumbersWrappedContainer {
                let phoneNumbersContainer = try phoneNumbersWrappedContainer.decodeIfPresent([PhoneNumberInformation].self, forKey: .member)
                var phoneNumbersBuffer:[PhoneNumberInformation]? = nil
                if let phoneNumbersContainer = phoneNumbersContainer {
                    phoneNumbersBuffer = [PhoneNumberInformation]()
                    for structureContainer0 in phoneNumbersContainer {
                        phoneNumbersBuffer?.append(structureContainer0)
                    }
                }
                phoneNumbers = phoneNumbersBuffer
            } else {
                phoneNumbers = []
            }
        } else {
            phoneNumbers = nil
        }
    }
}

public struct ListPhoneNumbersOptedOutInputBodyMiddleware: Middleware {
    public let id: String = "ListPhoneNumbersOptedOutInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPhoneNumbersOptedOutInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPhoneNumbersOptedOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPhoneNumbersOptedOutInput>
    public typealias MOutput = OperationOutput<ListPhoneNumbersOptedOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPhoneNumbersOptedOutOutputError>
}

extension ListPhoneNumbersOptedOutInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPhoneNumbersOptedOutInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListPhoneNumbersOptedOutInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("nextToken"))
        }
        try container.encode("ListPhoneNumbersOptedOut", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct ListPhoneNumbersOptedOutInputHeadersMiddleware: Middleware {
    public let id: String = "ListPhoneNumbersOptedOutInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPhoneNumbersOptedOutInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPhoneNumbersOptedOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPhoneNumbersOptedOutInput>
    public typealias MOutput = OperationOutput<ListPhoneNumbersOptedOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPhoneNumbersOptedOutOutputError>
}

public struct ListPhoneNumbersOptedOutInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPhoneNumbersOptedOutInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPhoneNumbersOptedOutInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPhoneNumbersOptedOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPhoneNumbersOptedOutInput>
    public typealias MOutput = OperationOutput<ListPhoneNumbersOptedOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPhoneNumbersOptedOutOutputError>
}

/// <p>The input for the <code>ListPhoneNumbersOptedOut</code> action.</p>
public struct ListPhoneNumbersOptedOutInput: Equatable {
    /// <p>A <code>NextToken</code> string is used when you call the
    ///                 <code>ListPhoneNumbersOptedOut</code> action to retrieve additional records that are
    ///             available after the first page of results.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListPhoneNumbersOptedOutOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPhoneNumbersOptedOutOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPhoneNumbersOptedOutOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPhoneNumbersOptedOutOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPhoneNumbersOptedOutOutputResponse(nextToken: \(String(describing: nextToken)), phoneNumbers: \(String(describing: phoneNumbers)))"}
}

extension ListPhoneNumbersOptedOutOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPhoneNumbersOptedOutOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

/// <p>The response from the <code>ListPhoneNumbersOptedOut</code> action.</p>
public struct ListPhoneNumbersOptedOutOutputResponse: Equatable {
    /// <p>A <code>NextToken</code> string is returned when you call the
    ///                 <code>ListPhoneNumbersOptedOut</code> action if additional records are available
    ///             after the first page of results.</p>
    public let nextToken: String?
    /// <p>A list of phone numbers that are opted out of receiving SMS messages. The list is
    ///             paginated, and each page can contain up to 100 phone numbers.</p>
    public let phoneNumbers: [String]?

    public init (
        nextToken: String? = nil,
        phoneNumbers: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct ListPhoneNumbersOptedOutOutputResponseBody: Equatable {
    public let phoneNumbers: [String]?
    public let nextToken: String?
}

extension ListPhoneNumbersOptedOutOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case phoneNumbers
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListPhoneNumbersOptedOutResult"))
        if containerValues.contains(.phoneNumbers) {
            struct KeyVal0{struct member{}}
            let phoneNumbersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .phoneNumbers)
            if let phoneNumbersWrappedContainer = phoneNumbersWrappedContainer {
                let phoneNumbersContainer = try phoneNumbersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var phoneNumbersBuffer:[String]? = nil
                if let phoneNumbersContainer = phoneNumbersContainer {
                    phoneNumbersBuffer = [String]()
                    for stringContainer0 in phoneNumbersContainer {
                        phoneNumbersBuffer?.append(stringContainer0)
                    }
                }
                phoneNumbers = phoneNumbersBuffer
            } else {
                phoneNumbers = []
            }
        } else {
            phoneNumbers = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPlatformApplicationsInputBodyMiddleware: Middleware {
    public let id: String = "ListPlatformApplicationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlatformApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlatformApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlatformApplicationsInput>
    public typealias MOutput = OperationOutput<ListPlatformApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlatformApplicationsOutputError>
}

extension ListPlatformApplicationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPlatformApplicationsInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListPlatformApplicationsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("ListPlatformApplications", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct ListPlatformApplicationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPlatformApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlatformApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlatformApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlatformApplicationsInput>
    public typealias MOutput = OperationOutput<ListPlatformApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlatformApplicationsOutputError>
}

public struct ListPlatformApplicationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPlatformApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlatformApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlatformApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlatformApplicationsInput>
    public typealias MOutput = OperationOutput<ListPlatformApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlatformApplicationsOutputError>
}

/// <p>Input for ListPlatformApplications action.</p>
public struct ListPlatformApplicationsInput: Equatable {
    /// <p>NextToken string is used when calling ListPlatformApplications action to retrieve
    ///             additional records that are available after the first page results.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListPlatformApplicationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPlatformApplicationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPlatformApplicationsOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPlatformApplicationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPlatformApplicationsOutputResponse(nextToken: \(String(describing: nextToken)), platformApplications: \(String(describing: platformApplications)))"}
}

extension ListPlatformApplicationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPlatformApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.platformApplications = output.platformApplications
        } else {
            self.nextToken = nil
            self.platformApplications = nil
        }
    }
}

/// <p>Response for ListPlatformApplications action.</p>
public struct ListPlatformApplicationsOutputResponse: Equatable {
    /// <p>NextToken string is returned when calling ListPlatformApplications action if
    ///             additional records are available after the first page results.</p>
    public let nextToken: String?
    /// <p>Platform applications returned when calling ListPlatformApplications action.</p>
    public let platformApplications: [PlatformApplication]?

    public init (
        nextToken: String? = nil,
        platformApplications: [PlatformApplication]? = nil
    )
    {
        self.nextToken = nextToken
        self.platformApplications = platformApplications
    }
}

struct ListPlatformApplicationsOutputResponseBody: Equatable {
    public let platformApplications: [PlatformApplication]?
    public let nextToken: String?
}

extension ListPlatformApplicationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case platformApplications = "PlatformApplications"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListPlatformApplicationsResult"))
        if containerValues.contains(.platformApplications) {
            struct KeyVal0{struct member{}}
            let platformApplicationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .platformApplications)
            if let platformApplicationsWrappedContainer = platformApplicationsWrappedContainer {
                let platformApplicationsContainer = try platformApplicationsWrappedContainer.decodeIfPresent([PlatformApplication].self, forKey: .member)
                var platformApplicationsBuffer:[PlatformApplication]? = nil
                if let platformApplicationsContainer = platformApplicationsContainer {
                    platformApplicationsBuffer = [PlatformApplication]()
                    for structureContainer0 in platformApplicationsContainer {
                        platformApplicationsBuffer?.append(structureContainer0)
                    }
                }
                platformApplications = platformApplicationsBuffer
            } else {
                platformApplications = []
            }
        } else {
            platformApplications = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSMSSandboxPhoneNumbersInputBodyMiddleware: Middleware {
    public let id: String = "ListSMSSandboxPhoneNumbersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSMSSandboxPhoneNumbersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSMSSandboxPhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSMSSandboxPhoneNumbersInput>
    public typealias MOutput = OperationOutput<ListSMSSandboxPhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSMSSandboxPhoneNumbersOutputError>
}

extension ListSMSSandboxPhoneNumbersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSMSSandboxPhoneNumbersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSMSSandboxPhoneNumbersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("ListSMSSandboxPhoneNumbers", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct ListSMSSandboxPhoneNumbersInputHeadersMiddleware: Middleware {
    public let id: String = "ListSMSSandboxPhoneNumbersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSMSSandboxPhoneNumbersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSMSSandboxPhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSMSSandboxPhoneNumbersInput>
    public typealias MOutput = OperationOutput<ListSMSSandboxPhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSMSSandboxPhoneNumbersOutputError>
}

public struct ListSMSSandboxPhoneNumbersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSMSSandboxPhoneNumbersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSMSSandboxPhoneNumbersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSMSSandboxPhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSMSSandboxPhoneNumbersInput>
    public typealias MOutput = OperationOutput<ListSMSSandboxPhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSMSSandboxPhoneNumbersOutputError>
}

public struct ListSMSSandboxPhoneNumbersInput: Equatable {
    /// <p>The maximum number of phone numbers to return.</p>
    public let maxResults: Int?
    /// <p>Token that the previous <code>ListSMSSandboxPhoneNumbersInput</code> request
    ///             returns.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListSMSSandboxPhoneNumbersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSMSSandboxPhoneNumbersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSMSSandboxPhoneNumbersOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSMSSandboxPhoneNumbersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSMSSandboxPhoneNumbersOutputResponse(nextToken: \(String(describing: nextToken)), phoneNumbers: \(String(describing: phoneNumbers)))"}
}

extension ListSMSSandboxPhoneNumbersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSMSSandboxPhoneNumbersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

public struct ListSMSSandboxPhoneNumbersOutputResponse: Equatable {
    /// <p>A <code>NextToken</code> string is returned when you call the
    ///             <code>ListSMSSandboxPhoneNumbersInput</code> operation if additional pages of
    ///             records are available.</p>
    public let nextToken: String?
    /// <p>A list of the calling account's pending and verified phone numbers.</p>
    public let phoneNumbers: [SMSSandboxPhoneNumber]?

    public init (
        nextToken: String? = nil,
        phoneNumbers: [SMSSandboxPhoneNumber]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct ListSMSSandboxPhoneNumbersOutputResponseBody: Equatable {
    public let phoneNumbers: [SMSSandboxPhoneNumber]?
    public let nextToken: String?
}

extension ListSMSSandboxPhoneNumbersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case phoneNumbers = "PhoneNumbers"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListSMSSandboxPhoneNumbersResult"))
        if containerValues.contains(.phoneNumbers) {
            struct KeyVal0{struct member{}}
            let phoneNumbersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .phoneNumbers)
            if let phoneNumbersWrappedContainer = phoneNumbersWrappedContainer {
                let phoneNumbersContainer = try phoneNumbersWrappedContainer.decodeIfPresent([SMSSandboxPhoneNumber].self, forKey: .member)
                var phoneNumbersBuffer:[SMSSandboxPhoneNumber]? = nil
                if let phoneNumbersContainer = phoneNumbersContainer {
                    phoneNumbersBuffer = [SMSSandboxPhoneNumber]()
                    for structureContainer0 in phoneNumbersContainer {
                        phoneNumbersBuffer?.append(structureContainer0)
                    }
                }
                phoneNumbers = phoneNumbersBuffer
            } else {
                phoneNumbers = []
            }
        } else {
            phoneNumbers = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSubscriptionsByTopicInputBodyMiddleware: Middleware {
    public let id: String = "ListSubscriptionsByTopicInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSubscriptionsByTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSubscriptionsByTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSubscriptionsByTopicInput>
    public typealias MOutput = OperationOutput<ListSubscriptionsByTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSubscriptionsByTopicOutputError>
}

extension ListSubscriptionsByTopicInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSubscriptionsByTopicInput(nextToken: \(String(describing: nextToken)), topicArn: \(String(describing: topicArn)))"}
}

extension ListSubscriptionsByTopicInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
        try container.encode("ListSubscriptionsByTopic", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct ListSubscriptionsByTopicInputHeadersMiddleware: Middleware {
    public let id: String = "ListSubscriptionsByTopicInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSubscriptionsByTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSubscriptionsByTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSubscriptionsByTopicInput>
    public typealias MOutput = OperationOutput<ListSubscriptionsByTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSubscriptionsByTopicOutputError>
}

public struct ListSubscriptionsByTopicInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSubscriptionsByTopicInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSubscriptionsByTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSubscriptionsByTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSubscriptionsByTopicInput>
    public typealias MOutput = OperationOutput<ListSubscriptionsByTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSubscriptionsByTopicOutputError>
}

/// <p>Input for ListSubscriptionsByTopic action.</p>
public struct ListSubscriptionsByTopicInput: Equatable {
    /// <p>Token returned by the previous <code>ListSubscriptionsByTopic</code> request.</p>
    public let nextToken: String?
    /// <p>The ARN of the topic for which you wish to find subscriptions.</p>
    public let topicArn: String?

    public init (
        nextToken: String? = nil,
        topicArn: String? = nil
    )
    {
        self.nextToken = nextToken
        self.topicArn = topicArn
    }
}

extension ListSubscriptionsByTopicOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSubscriptionsByTopicOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSubscriptionsByTopicOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSubscriptionsByTopicOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSubscriptionsByTopicOutputResponse(nextToken: \(String(describing: nextToken)), subscriptions: \(String(describing: subscriptions)))"}
}

extension ListSubscriptionsByTopicOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSubscriptionsByTopicOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.subscriptions = output.subscriptions
        } else {
            self.nextToken = nil
            self.subscriptions = nil
        }
    }
}

/// <p>Response for ListSubscriptionsByTopic action.</p>
public struct ListSubscriptionsByTopicOutputResponse: Equatable {
    /// <p>Token to pass along to the next <code>ListSubscriptionsByTopic</code> request. This
    ///             element is returned if there are more subscriptions to retrieve.</p>
    public let nextToken: String?
    /// <p>A list of subscriptions.</p>
    public let subscriptions: [Subscription]?

    public init (
        nextToken: String? = nil,
        subscriptions: [Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

struct ListSubscriptionsByTopicOutputResponseBody: Equatable {
    public let subscriptions: [Subscription]?
    public let nextToken: String?
}

extension ListSubscriptionsByTopicOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case subscriptions = "Subscriptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListSubscriptionsByTopicResult"))
        if containerValues.contains(.subscriptions) {
            struct KeyVal0{struct member{}}
            let subscriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subscriptions)
            if let subscriptionsWrappedContainer = subscriptionsWrappedContainer {
                let subscriptionsContainer = try subscriptionsWrappedContainer.decodeIfPresent([Subscription].self, forKey: .member)
                var subscriptionsBuffer:[Subscription]? = nil
                if let subscriptionsContainer = subscriptionsContainer {
                    subscriptionsBuffer = [Subscription]()
                    for structureContainer0 in subscriptionsContainer {
                        subscriptionsBuffer?.append(structureContainer0)
                    }
                }
                subscriptions = subscriptionsBuffer
            } else {
                subscriptions = []
            }
        } else {
            subscriptions = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSubscriptionsInputBodyMiddleware: Middleware {
    public let id: String = "ListSubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSubscriptionsInput>
    public typealias MOutput = OperationOutput<ListSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSubscriptionsOutputError>
}

extension ListSubscriptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSubscriptionsInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListSubscriptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("ListSubscriptions", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct ListSubscriptionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSubscriptionsInput>
    public typealias MOutput = OperationOutput<ListSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSubscriptionsOutputError>
}

public struct ListSubscriptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSubscriptionsInput>
    public typealias MOutput = OperationOutput<ListSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSubscriptionsOutputError>
}

/// <p>Input for ListSubscriptions action.</p>
public struct ListSubscriptionsInput: Equatable {
    /// <p>Token returned by the previous <code>ListSubscriptions</code> request.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListSubscriptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSubscriptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSubscriptionsOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSubscriptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSubscriptionsOutputResponse(nextToken: \(String(describing: nextToken)), subscriptions: \(String(describing: subscriptions)))"}
}

extension ListSubscriptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.subscriptions = output.subscriptions
        } else {
            self.nextToken = nil
            self.subscriptions = nil
        }
    }
}

/// <p>Response for ListSubscriptions action</p>
public struct ListSubscriptionsOutputResponse: Equatable {
    /// <p>Token to pass along to the next <code>ListSubscriptions</code> request. This element
    ///             is returned if there are more subscriptions to retrieve.</p>
    public let nextToken: String?
    /// <p>A list of subscriptions.</p>
    public let subscriptions: [Subscription]?

    public init (
        nextToken: String? = nil,
        subscriptions: [Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

struct ListSubscriptionsOutputResponseBody: Equatable {
    public let subscriptions: [Subscription]?
    public let nextToken: String?
}

extension ListSubscriptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case subscriptions = "Subscriptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListSubscriptionsResult"))
        if containerValues.contains(.subscriptions) {
            struct KeyVal0{struct member{}}
            let subscriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subscriptions)
            if let subscriptionsWrappedContainer = subscriptionsWrappedContainer {
                let subscriptionsContainer = try subscriptionsWrappedContainer.decodeIfPresent([Subscription].self, forKey: .member)
                var subscriptionsBuffer:[Subscription]? = nil
                if let subscriptionsContainer = subscriptionsContainer {
                    subscriptionsBuffer = [Subscription]()
                    for structureContainer0 in subscriptionsContainer {
                        subscriptionsBuffer?.append(structureContainer0)
                    }
                }
                subscriptions = subscriptionsBuffer
            } else {
                subscriptions = []
            }
        } else {
            subscriptions = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: Key("ResourceArn"))
        }
        try container.encode("ListTagsForResource", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the topic for which to list tags.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccessException" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case concurrentAccessException(ConcurrentAccessException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagPolicyException(TagPolicyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags associated with the specified topic.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListTagsForResourceResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

public struct ListTopicsInputBodyMiddleware: Middleware {
    public let id: String = "ListTopicsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTopicsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTopicsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTopicsInput>
    public typealias MOutput = OperationOutput<ListTopicsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTopicsOutputError>
}

extension ListTopicsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTopicsInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListTopicsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("ListTopics", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct ListTopicsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTopicsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTopicsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTopicsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTopicsInput>
    public typealias MOutput = OperationOutput<ListTopicsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTopicsOutputError>
}

public struct ListTopicsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTopicsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTopicsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTopicsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTopicsInput>
    public typealias MOutput = OperationOutput<ListTopicsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTopicsOutputError>
}

public struct ListTopicsInput: Equatable {
    /// <p>Token returned by the previous <code>ListTopics</code> request.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListTopicsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTopicsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTopicsOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTopicsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTopicsOutputResponse(nextToken: \(String(describing: nextToken)), topics: \(String(describing: topics)))"}
}

extension ListTopicsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTopicsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.topics = output.topics
        } else {
            self.nextToken = nil
            self.topics = nil
        }
    }
}

/// <p>Response for ListTopics action.</p>
public struct ListTopicsOutputResponse: Equatable {
    /// <p>Token to pass along to the next <code>ListTopics</code> request. This element is
    ///             returned if there are additional topics to retrieve.</p>
    public let nextToken: String?
    /// <p>A list of topic ARNs.</p>
    public let topics: [Topic]?

    public init (
        nextToken: String? = nil,
        topics: [Topic]? = nil
    )
    {
        self.nextToken = nextToken
        self.topics = topics
    }
}

struct ListTopicsOutputResponseBody: Equatable {
    public let topics: [Topic]?
    public let nextToken: String?
}

extension ListTopicsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case topics = "Topics"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListTopicsResult"))
        if containerValues.contains(.topics) {
            struct KeyVal0{struct member{}}
            let topicsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .topics)
            if let topicsWrappedContainer = topicsWrappedContainer {
                let topicsContainer = try topicsWrappedContainer.decodeIfPresent([Topic].self, forKey: .member)
                var topicsBuffer:[Topic]? = nil
                if let topicsContainer = topicsContainer {
                    topicsBuffer = [Topic]()
                    for structureContainer0 in topicsContainer {
                        topicsBuffer?.append(structureContainer0)
                    }
                }
                topics = topicsBuffer
            } else {
                topics = []
            }
        } else {
            topics = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MessageAttributeValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case binaryValue = "BinaryValue"
        case dataType = "DataType"
        case stringValue = "StringValue"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let binaryValue = binaryValue {
            try container.encode(binaryValue.base64EncodedString(), forKey: Key("BinaryValue"))
        }
        if let dataType = dataType {
            try container.encode(dataType, forKey: Key("DataType"))
        }
        if let stringValue = stringValue {
            try container.encode(stringValue, forKey: Key("StringValue"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let stringValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        if containerValues.contains(.binaryValue) {
            do {
                let binaryValueDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .binaryValue)
                binaryValue = binaryValueDecoded
            } catch {
                binaryValue = "".data(using: .utf8)
            }
        } else {
            binaryValue = nil
        }
    }
}

extension MessageAttributeValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageAttributeValue(binaryValue: \(String(describing: binaryValue)), dataType: \(String(describing: dataType)), stringValue: \(String(describing: stringValue)))"}
}

/// <p>The user-specified message attribute value. For string data types, the value attribute
///             has the same restrictions on the content as the message body. For more information, see
///                 <a href="https://docs.aws.amazon.com/sns/latest/api/API_Publish.html">Publish</a>.</p>
///         <p>Name, type, and value must not be empty or null. In addition, the message body should
///             not be empty or null. All parts of the message attribute, including name, type, and
///             value, are included in the message size restriction, which is currently 256 KB (262,144
///             bytes). For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/SNSMessageAttributes.html">Amazon SNS message attributes</a> and
///                 <a href="https://docs.aws.amazon.com/sns/latest/dg/sms_publish-to-phone.html">Publishing
///                 to a mobile phone</a> in the <i>Amazon SNS Developer Guide.</i>
///          </p>
public struct MessageAttributeValue: Equatable {
    /// <p>Binary type attributes can store any binary data, for example, compressed data,
    ///             encrypted data, or images.</p>
    public let binaryValue: Data?
    /// <p>Amazon SNS supports the following logical data types: String, String.Array, Number, and
    ///             Binary. For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/SNSMessageAttributes.html#SNSMessageAttributes.DataTypes">Message
    ///                 Attribute Data Types</a>.</p>
    public let dataType: String?
    /// <p>Strings are Unicode with UTF8 binary encoding. For a list of code values, see <a href="https://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters">ASCII Printable
    ///                 Characters</a>.</p>
    public let stringValue: String?

    public init (
        binaryValue: Data? = nil,
        dataType: String? = nil,
        stringValue: String? = nil
    )
    {
        self.binaryValue = binaryValue
        self.dataType = dataType
        self.stringValue = stringValue
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the requested resource does not exist.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

/// Enum listing out all supported number capabilities.
public enum NumberCapability {
    case mms
    case sms
    case voice
    case sdkUnknown(String)
}

extension NumberCapability : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NumberCapability] {
        return [
            .mms,
            .sms,
            .voice,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .mms: return "MMS"
        case .sms: return "SMS"
        case .voice: return "VOICE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NumberCapability(rawValue: rawValue) ?? NumberCapability.sdkUnknown(rawValue)
    }
}

public struct OptInPhoneNumberInputBodyMiddleware: Middleware {
    public let id: String = "OptInPhoneNumberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<OptInPhoneNumberInput>,
                  next: H) -> Swift.Result<OperationOutput<OptInPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<OptInPhoneNumberInput>
    public typealias MOutput = OperationOutput<OptInPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<OptInPhoneNumberOutputError>
}

extension OptInPhoneNumberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptInPhoneNumberInput(phoneNumber: \(String(describing: phoneNumber)))"}
}

extension OptInPhoneNumberInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: Key("phoneNumber"))
        }
        try container.encode("OptInPhoneNumber", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct OptInPhoneNumberInputHeadersMiddleware: Middleware {
    public let id: String = "OptInPhoneNumberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<OptInPhoneNumberInput>,
                  next: H) -> Swift.Result<OperationOutput<OptInPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<OptInPhoneNumberInput>
    public typealias MOutput = OperationOutput<OptInPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<OptInPhoneNumberOutputError>
}

public struct OptInPhoneNumberInputQueryItemMiddleware: Middleware {
    public let id: String = "OptInPhoneNumberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<OptInPhoneNumberInput>,
                  next: H) -> Swift.Result<OperationOutput<OptInPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<OptInPhoneNumberInput>
    public typealias MOutput = OperationOutput<OptInPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<OptInPhoneNumberOutputError>
}

/// <p>Input for the OptInPhoneNumber action.</p>
public struct OptInPhoneNumberInput: Equatable {
    /// <p>The phone number to opt in. Use E.164 format.</p>
    public let phoneNumber: String?

    public init (
        phoneNumber: String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

extension OptInPhoneNumberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension OptInPhoneNumberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum OptInPhoneNumberOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension OptInPhoneNumberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptInPhoneNumberOutputResponse()"}
}

extension OptInPhoneNumberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The response for the OptInPhoneNumber action.</p>
public struct OptInPhoneNumberOutputResponse: Equatable {

    public init() {}
}

struct OptInPhoneNumberOutputResponseBody: Equatable {
}

extension OptInPhoneNumberOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension OptedOutException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptedOutException(message: \(String(describing: message)))"}
}

extension OptedOutException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<OptedOutExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the specified phone number opted out of receiving SMS messages from
///             your AWS account. You can't send SMS messages to phone numbers that opt out.</p>
public struct OptedOutException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OptedOutExceptionBody: Equatable {
    public let message: String?
}

extension OptedOutExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PhoneNumberInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case iso2CountryCode = "Iso2CountryCode"
        case numberCapabilities = "NumberCapabilities"
        case phoneNumber = "PhoneNumber"
        case routeType = "RouteType"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let createdAt = createdAt {
            try container.encode(TimestampWrapper(createdAt, format: .dateTime), forKey: Key("createdAt"))
        }
        if let iso2CountryCode = iso2CountryCode {
            try container.encode(iso2CountryCode, forKey: Key("Iso2CountryCode"))
        }
        if let numberCapabilities = numberCapabilities {
            var numberCapabilitiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("NumberCapabilities"))
            for (index0, numbercapability0) in numberCapabilities.enumerated() {
                try numberCapabilitiesContainer.encode(numbercapability0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: Key("PhoneNumber"))
        }
        if let routeType = routeType {
            try container.encode(routeType, forKey: Key("RouteType"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        var createdAtBuffer:Date? = nil
        if let createdAtDecoded = createdAtDecoded {
            createdAtBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdAtDecoded, format: .dateTime)
        }
        createdAt = createdAtBuffer
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let iso2CountryCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iso2CountryCode)
        iso2CountryCode = iso2CountryCodeDecoded
        let routeTypeDecoded = try containerValues.decodeIfPresent(RouteType.self, forKey: .routeType)
        routeType = routeTypeDecoded
        if containerValues.contains(.numberCapabilities) {
            struct KeyVal0{struct member{}}
            let numberCapabilitiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .numberCapabilities)
            if let numberCapabilitiesWrappedContainer = numberCapabilitiesWrappedContainer {
                let numberCapabilitiesContainer = try numberCapabilitiesWrappedContainer.decodeIfPresent([NumberCapability].self, forKey: .member)
                var numberCapabilitiesBuffer:[NumberCapability]? = nil
                if let numberCapabilitiesContainer = numberCapabilitiesContainer {
                    numberCapabilitiesBuffer = [NumberCapability]()
                    for stringContainer0 in numberCapabilitiesContainer {
                        numberCapabilitiesBuffer?.append(stringContainer0)
                    }
                }
                numberCapabilities = numberCapabilitiesBuffer
            } else {
                numberCapabilities = []
            }
        } else {
            numberCapabilities = nil
        }
    }
}

extension PhoneNumberInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PhoneNumberInformation(createdAt: \(String(describing: createdAt)), iso2CountryCode: \(String(describing: iso2CountryCode)), numberCapabilities: \(String(describing: numberCapabilities)), phoneNumber: \(String(describing: phoneNumber)), routeType: \(String(describing: routeType)), status: \(String(describing: status)))"}
}

/// <p>A list of phone numbers and their metadata.</p>
public struct PhoneNumberInformation: Equatable {
    /// <p>The date and time when the phone number was created.</p>
    public let createdAt: Date?
    /// <p>The two-character code for the country or region, in ISO 3166-1 alpha-2 format.</p>
    public let iso2CountryCode: String?
    /// <p>The capabilities of each phone number.</p>
    public let numberCapabilities: [NumberCapability]?
    /// <p>The phone number.</p>
    public let phoneNumber: String?
    /// <p>The list of supported routes.</p>
    public let routeType: RouteType?
    /// <p>The status of the phone number.</p>
    public let status: String?

    public init (
        createdAt: Date? = nil,
        iso2CountryCode: String? = nil,
        numberCapabilities: [NumberCapability]? = nil,
        phoneNumber: String? = nil,
        routeType: RouteType? = nil,
        status: String? = nil
    )
    {
        self.createdAt = createdAt
        self.iso2CountryCode = iso2CountryCode
        self.numberCapabilities = numberCapabilities
        self.phoneNumber = phoneNumber
        self.routeType = routeType
        self.status = status
    }
}

extension PlatformApplication: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case platformApplicationArn = "PlatformApplicationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("key"))
                try keyContainer0.encode(stringKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("value"))
                try valueContainer0.encode(stringValue0, forKey: Key(""))
            }
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: Key("PlatformApplicationArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformApplicationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformApplicationArn)
        platformApplicationArn = platformApplicationArnDecoded
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([MapKeyValue<String, String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [String:String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [String:String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension PlatformApplication: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlatformApplication(attributes: \(String(describing: attributes)), platformApplicationArn: \(String(describing: platformApplicationArn)))"}
}

/// <p>Platform application object.</p>
public struct PlatformApplication: Equatable {
    /// <p>Attributes for platform application object.</p>
    public let attributes: [String:String]?
    /// <p>PlatformApplicationArn for platform application object.</p>
    public let platformApplicationArn: String?

    public init (
        attributes: [String:String]? = nil,
        platformApplicationArn: String? = nil
    )
    {
        self.attributes = attributes
        self.platformApplicationArn = platformApplicationArn
    }
}

extension PlatformApplicationDisabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlatformApplicationDisabledException(message: \(String(describing: message)))"}
}

extension PlatformApplicationDisabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<PlatformApplicationDisabledExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception error indicating platform application disabled.</p>
public struct PlatformApplicationDisabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Message for platform application disabled.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PlatformApplicationDisabledExceptionBody: Equatable {
    public let message: String?
}

extension PlatformApplicationDisabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PublishInputBodyMiddleware: Middleware {
    public let id: String = "PublishInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishInput>
    public typealias MOutput = OperationOutput<PublishOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishOutputError>
}

extension PublishInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishInput(message: \(String(describing: message)), messageAttributes: \(String(describing: messageAttributes)), messageDeduplicationId: \(String(describing: messageDeduplicationId)), messageGroupId: \(String(describing: messageGroupId)), messageStructure: \(String(describing: messageStructure)), phoneNumber: \(String(describing: phoneNumber)), subject: \(String(describing: subject)), targetArn: \(String(describing: targetArn)), topicArn: \(String(describing: topicArn)))"}
}

extension PublishInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let message = message {
            try container.encode(message, forKey: Key("Message"))
        }
        if let messageAttributes = messageAttributes {
            var messageAttributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("MessageAttributes"))
            for (index0, element0) in messageAttributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let messageattributevalueValue0 = element0.value
                var entryContainer0 = messageAttributesContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("Name"))
                try keyContainer0.encode(stringKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("Value"))
                try valueContainer0.encode(messageattributevalueValue0, forKey: Key(""))
            }
        }
        if let messageDeduplicationId = messageDeduplicationId {
            try container.encode(messageDeduplicationId, forKey: Key("MessageDeduplicationId"))
        }
        if let messageGroupId = messageGroupId {
            try container.encode(messageGroupId, forKey: Key("MessageGroupId"))
        }
        if let messageStructure = messageStructure {
            try container.encode(messageStructure, forKey: Key("MessageStructure"))
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: Key("PhoneNumber"))
        }
        if let subject = subject {
            try container.encode(subject, forKey: Key("Subject"))
        }
        if let targetArn = targetArn {
            try container.encode(targetArn, forKey: Key("TargetArn"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
        try container.encode("Publish", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct PublishInputHeadersMiddleware: Middleware {
    public let id: String = "PublishInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishInput>
    public typealias MOutput = OperationOutput<PublishOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishOutputError>
}

public struct PublishInputQueryItemMiddleware: Middleware {
    public let id: String = "PublishInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishInput>
    public typealias MOutput = OperationOutput<PublishOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishOutputError>
}

/// <p>Input for Publish action.</p>
public struct PublishInput: Equatable {
    /// <p>The message you want to send.</p>
    ///         <p>If you are publishing to a topic and you want to send the same message to all
    ///             transport protocols, include the text of the message as a String value. If you want to
    ///             send different messages for each transport protocol, set the value of the
    ///                 <code>MessageStructure</code> parameter to <code>json</code> and use a JSON object
    ///             for the <code>Message</code> parameter.
    ///         </p>
    ///         <p></p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>With the exception of SMS, messages must be UTF-8 encoded strings and at most
    ///                     256 KB in size (262,144 bytes, not 262,144 characters).</p>
    ///             </li>
    ///             <li>
    ///                 <p>For SMS, each message can contain up to 140 characters. This character limit
    ///                     depends on the encoding schema. For example, an SMS message can contain 160 GSM
    ///                     characters, 140 ASCII characters, or 70 UCS-2 characters.</p>
    ///                 <p>If you publish a message that exceeds this size limit, Amazon SNS sends the message
    ///                     as multiple messages, each fitting within the size limit. Messages aren't
    ///                     truncated mid-word but are cut off at whole-word boundaries.</p>
    ///                 <p>The total size limit for a single SMS <code>Publish</code> action is 1,600
    ///                     characters.</p>
    ///             </li>
    ///          </ul>
    ///         <p>JSON-specific constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Keys in the JSON object that correspond to supported transport protocols must
    ///                     have simple JSON string values.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The values will be parsed (unescaped) before they are used in outgoing
    ///                     messages.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Outbound notifications are JSON encoded (meaning that the characters will be
    ///                     reescaped for sending).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Values have a minimum length of 0 (the empty string, "", is allowed).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Values have a maximum length bounded by the overall message size (so,
    ///                     including multiple protocols may limit message sizes).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Non-string values will cause the key to be ignored.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Keys that do not correspond to supported transport protocols are
    ///                     ignored.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Duplicate keys are not allowed.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Failure to parse or validate any key or value in the message will cause the
    ///                         <code>Publish</code> call to return an error (no partial delivery).</p>
    ///             </li>
    ///          </ul>
    public let message: String?
    /// <p>Message attributes for Publish action.</p>
    public let messageAttributes: [String:MessageAttributeValue]?
    /// <p>This parameter applies only to FIFO (first-in-first-out) topics. The
    ///                 <code>MessageDeduplicationId</code> can contain up to 128 alphanumeric characters
    ///             (a-z, A-Z, 0-9) and punctuation
    ///             <code>(!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~)</code>.</p>
    ///         <p>Every message must have a unique <code>MessageDeduplicationId</code>, which is a token
    ///             used for deduplication of sent messages. If a message with a particular
    ///                 <code>MessageDeduplicationId</code> is sent successfully, any message sent with the
    ///             same <code>MessageDeduplicationId</code> during the 5-minute deduplication interval is
    ///             treated as a duplicate. </p>
    ///         <p>If the topic has <code>ContentBasedDeduplication</code> set, the system generates a
    ///                 <code>MessageDeduplicationId</code> based on the contents of the message. Your
    ///                 <code>MessageDeduplicationId</code> overrides the generated one.</p>
    public let messageDeduplicationId: String?
    /// <p>This parameter applies only to FIFO (first-in-first-out) topics. The
    ///                 <code>MessageGroupId</code> can contain up to 128 alphanumeric characters (a-z, A-Z,
    ///             0-9) and punctuation <code>(!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~)</code>.</p>
    ///         <p>The <code>MessageGroupId</code> is a tag that specifies that a message belongs to a
    ///             specific message group. Messages that belong to the same message group are processed in
    ///             a FIFO manner (however, messages in different message groups might be processed out of
    ///             order). Every message must include a <code>MessageGroupId</code>.</p>
    public let messageGroupId: String?
    /// <p>Set <code>MessageStructure</code> to <code>json</code> if you want to send a different
    ///             message for each protocol. For example, using one publish action, you can send a short
    ///             message to your SMS subscribers and a longer message to your email subscribers. If you
    ///             set <code>MessageStructure</code> to <code>json</code>, the value of the
    ///                 <code>Message</code> parameter must: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>be a syntactically valid JSON object; and</p>
    ///             </li>
    ///             <li>
    ///                 <p>contain at least a top-level JSON key of "default" with a value that is a
    ///                     string.</p>
    ///             </li>
    ///          </ul>
    ///         <p>You can define other top-level keys that define the message you want to send to a
    ///             specific transport protocol (e.g., "http").</p>
    ///         <p>Valid value: <code>json</code>
    ///         </p>
    public let messageStructure: String?
    /// <p>The phone number to which you want to deliver an SMS message. Use E.164 format.</p>
    ///         <p>If you don't specify a value for the <code>PhoneNumber</code> parameter, you must
    ///             specify a value for the <code>TargetArn</code> or <code>TopicArn</code>
    ///             parameters.</p>
    public let phoneNumber: String?
    /// <p>Optional parameter to be used as the "Subject" line when the message is delivered to
    ///             email endpoints. This field will also be included, if present, in the standard JSON
    ///             messages delivered to other endpoints.</p>
    ///         <p>Constraints: Subjects must be ASCII text that begins with a letter, number, or
    ///             punctuation mark; must not include line breaks or control characters; and must be less
    ///             than 100 characters long.</p>
    public let subject: String?
    /// <p>If you don't specify a value for the <code>TargetArn</code> parameter, you must
    ///             specify a value for the <code>PhoneNumber</code> or <code>TopicArn</code>
    ///             parameters.</p>
    public let targetArn: String?
    /// <p>The topic you want to publish to.</p>
    ///         <p>If you don't specify a value for the <code>TopicArn</code> parameter, you must specify
    ///             a value for the <code>PhoneNumber</code> or <code>TargetArn</code> parameters.</p>
    public let topicArn: String?

    public init (
        message: String? = nil,
        messageAttributes: [String:MessageAttributeValue]? = nil,
        messageDeduplicationId: String? = nil,
        messageGroupId: String? = nil,
        messageStructure: String? = nil,
        phoneNumber: String? = nil,
        subject: String? = nil,
        targetArn: String? = nil,
        topicArn: String? = nil
    )
    {
        self.message = message
        self.messageAttributes = messageAttributes
        self.messageDeduplicationId = messageDeduplicationId
        self.messageGroupId = messageGroupId
        self.messageStructure = messageStructure
        self.phoneNumber = phoneNumber
        self.subject = subject
        self.targetArn = targetArn
        self.topicArn = topicArn
    }
}

extension PublishOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PublishOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointDisabledException" : self = .endpointDisabledException(try EndpointDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityException" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedException" : self = .kMSAccessDeniedException(try KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledException" : self = .kMSDisabledException(try KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundException" : self = .kMSNotFoundException(try KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSOptInRequired" : self = .kMSOptInRequired(try KMSOptInRequired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingException" : self = .kMSThrottlingException(try KMSThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PlatformApplicationDisabledException" : self = .platformApplicationDisabledException(try PlatformApplicationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case endpointDisabledException(EndpointDisabledException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidSecurityException(InvalidSecurityException)
    case kMSAccessDeniedException(KMSAccessDeniedException)
    case kMSDisabledException(KMSDisabledException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case kMSNotFoundException(KMSNotFoundException)
    case kMSOptInRequired(KMSOptInRequired)
    case kMSThrottlingException(KMSThrottlingException)
    case notFoundException(NotFoundException)
    case platformApplicationDisabledException(PlatformApplicationDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishOutputResponse(messageId: \(String(describing: messageId)), sequenceNumber: \(String(describing: sequenceNumber)))"}
}

extension PublishOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PublishOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.messageId = output.messageId
            self.sequenceNumber = output.sequenceNumber
        } else {
            self.messageId = nil
            self.sequenceNumber = nil
        }
    }
}

/// <p>Response for Publish action.</p>
public struct PublishOutputResponse: Equatable {
    /// <p>Unique identifier assigned to the published message.</p>
    ///         <p>Length Constraint: Maximum 100 characters</p>
    public let messageId: String?
    /// <p>This response element applies only to FIFO (first-in-first-out) topics. </p>
    ///         <p>The sequence number is a large, non-consecutive number that Amazon SNS assigns to each
    ///             message. The length of <code>SequenceNumber</code> is 128 bits.
    ///                 <code>SequenceNumber</code> continues to increase for each
    ///                 <code>MessageGroupId</code>.</p>
    public let sequenceNumber: String?

    public init (
        messageId: String? = nil,
        sequenceNumber: String? = nil
    )
    {
        self.messageId = messageId
        self.sequenceNumber = sequenceNumber
    }
}

struct PublishOutputResponseBody: Equatable {
    public let messageId: String?
    public let sequenceNumber: String?
}

extension PublishOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageId = "MessageId"
        case sequenceNumber = "SequenceNumber"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("PublishResult"))
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
    }
}

public struct RemovePermissionInputBodyMiddleware: Middleware {
    public let id: String = "RemovePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemovePermissionOutputError>
}

extension RemovePermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemovePermissionInput(label: \(String(describing: label)), topicArn: \(String(describing: topicArn)))"}
}

extension RemovePermissionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let label = label {
            try container.encode(label, forKey: Key("Label"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
        try container.encode("RemovePermission", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct RemovePermissionInputHeadersMiddleware: Middleware {
    public let id: String = "RemovePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemovePermissionOutputError>
}

public struct RemovePermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "RemovePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemovePermissionOutputError>
}

/// <p>Input for RemovePermission action.</p>
public struct RemovePermissionInput: Equatable {
    /// <p>The unique label of the statement you want to remove.</p>
    public let label: String?
    /// <p>The ARN of the topic whose access control policy you wish to modify.</p>
    public let topicArn: String?

    public init (
        label: String? = nil,
        topicArn: String? = nil
    )
    {
        self.label = label
        self.topicArn = topicArn
    }
}

extension RemovePermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemovePermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemovePermissionOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemovePermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemovePermissionOutputResponse()"}
}

extension RemovePermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemovePermissionOutputResponse: Equatable {

    public init() {}
}

struct RemovePermissionOutputResponseBody: Equatable {
}

extension RemovePermissionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ResourceNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Can’t perform the action on the specified resource. Make sure that the resource
///             exists.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

/// Enum listing out all supported route types. The following enum values are supported.
///         1. Transactional : Non-marketing traffic
///         2. Promotional : Marketing
///         3. Premium : Premium routes for OTP delivery to the carriers
public enum RouteType {
    case premium
    case promotional
    case transactional
    case sdkUnknown(String)
}

extension RouteType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RouteType] {
        return [
            .premium,
            .promotional,
            .transactional,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .premium: return "Premium"
        case .promotional: return "Promotional"
        case .transactional: return "Transactional"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RouteType(rawValue: rawValue) ?? RouteType.sdkUnknown(rawValue)
    }
}

extension SMSSandboxPhoneNumber: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case phoneNumber = "PhoneNumber"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: Key("PhoneNumber"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SMSSandboxPhoneNumberVerificationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SMSSandboxPhoneNumber: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SMSSandboxPhoneNumber(phoneNumber: \(String(describing: phoneNumber)), status: \(String(describing: status)))"}
}

/// <p>A verified or pending destination phone number in the SMS sandbox.</p>
///         <p>When you start using Amazon SNS to send SMS messages, your AWS account is in the
///                 <i>SMS sandbox</i>. The SMS sandbox provides a safe environment for
///                 you to try Amazon SNS features without risking your reputation as an SMS sender. While your
///                 account is in the SMS sandbox, you can use all of the features of Amazon SNS. However, you can send
///                 SMS messages only to verified destination phone numbers. For more information, including how to
///                 move out of the sandbox to send messages without restrictions,
///                 see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">SMS sandbox</a> in
///                 the <i>Amazon SNS Developer Guide</i>.</p>
public struct SMSSandboxPhoneNumber: Equatable {
    /// <p>The destination phone number.</p>
    public let phoneNumber: String?
    /// <p>The destination phone number's verification status.</p>
    public let status: SMSSandboxPhoneNumberVerificationStatus?

    public init (
        phoneNumber: String? = nil,
        status: SMSSandboxPhoneNumberVerificationStatus? = nil
    )
    {
        self.phoneNumber = phoneNumber
        self.status = status
    }
}

/// Enum listing out all supported destination phone number verification statuses. The following enum values are
///         supported.
///         1. PENDING : The destination phone number is pending verification.
///         2. VERIFIED : The destination phone number is verified.
public enum SMSSandboxPhoneNumberVerificationStatus {
    case pending
    case verified
    case sdkUnknown(String)
}

extension SMSSandboxPhoneNumberVerificationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SMSSandboxPhoneNumberVerificationStatus] {
        return [
            .pending,
            .verified,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .pending: return "Pending"
        case .verified: return "Verified"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SMSSandboxPhoneNumberVerificationStatus(rawValue: rawValue) ?? SMSSandboxPhoneNumberVerificationStatus.sdkUnknown(rawValue)
    }
}

public struct SetEndpointAttributesInputBodyMiddleware: Middleware {
    public let id: String = "SetEndpointAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetEndpointAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetEndpointAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetEndpointAttributesInput>
    public typealias MOutput = OperationOutput<SetEndpointAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetEndpointAttributesOutputError>
}

extension SetEndpointAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetEndpointAttributesInput(attributes: \(String(describing: attributes)), endpointArn: \(String(describing: endpointArn)))"}
}

extension SetEndpointAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("key"))
                try keyContainer0.encode(stringKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("value"))
                try valueContainer0.encode(stringValue0, forKey: Key(""))
            }
        }
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: Key("EndpointArn"))
        }
        try container.encode("SetEndpointAttributes", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct SetEndpointAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "SetEndpointAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetEndpointAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetEndpointAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetEndpointAttributesInput>
    public typealias MOutput = OperationOutput<SetEndpointAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetEndpointAttributesOutputError>
}

public struct SetEndpointAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "SetEndpointAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetEndpointAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetEndpointAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetEndpointAttributesInput>
    public typealias MOutput = OperationOutput<SetEndpointAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetEndpointAttributesOutputError>
}

/// <p>Input for SetEndpointAttributes action.</p>
public struct SetEndpointAttributesInput: Equatable {
    /// <p>A map of the endpoint attributes. Attributes in this map include the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>CustomUserData</code> – arbitrary user data to associate with the
    ///                     endpoint. Amazon SNS does not use this data. The data must be in UTF-8 format and
    ///                     less than 2KB.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>Enabled</code> – flag that enables/disables delivery to the
    ///                     endpoint. Amazon SNS will set this to false when a notification service indicates to
    ///                     Amazon SNS that the endpoint is invalid. Users can set it back to true, typically
    ///                     after updating Token.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>Token</code> – device token, also referred to as a registration id,
    ///                     for an app and mobile device. This is returned from the notification service
    ///                     when an app and mobile device are registered with the notification
    ///                     service.</p>
    ///             </li>
    ///          </ul>
    public let attributes: [String:String]?
    /// <p>EndpointArn used for SetEndpointAttributes action.</p>
    public let endpointArn: String?

    public init (
        attributes: [String:String]? = nil,
        endpointArn: String? = nil
    )
    {
        self.attributes = attributes
        self.endpointArn = endpointArn
    }
}

extension SetEndpointAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetEndpointAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetEndpointAttributesOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetEndpointAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetEndpointAttributesOutputResponse()"}
}

extension SetEndpointAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetEndpointAttributesOutputResponse: Equatable {

    public init() {}
}

struct SetEndpointAttributesOutputResponseBody: Equatable {
}

extension SetEndpointAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetPlatformApplicationAttributesInputBodyMiddleware: Middleware {
    public let id: String = "SetPlatformApplicationAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetPlatformApplicationAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetPlatformApplicationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetPlatformApplicationAttributesInput>
    public typealias MOutput = OperationOutput<SetPlatformApplicationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetPlatformApplicationAttributesOutputError>
}

extension SetPlatformApplicationAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetPlatformApplicationAttributesInput(attributes: \(String(describing: attributes)), platformApplicationArn: \(String(describing: platformApplicationArn)))"}
}

extension SetPlatformApplicationAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("key"))
                try keyContainer0.encode(stringKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("value"))
                try valueContainer0.encode(stringValue0, forKey: Key(""))
            }
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: Key("PlatformApplicationArn"))
        }
        try container.encode("SetPlatformApplicationAttributes", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct SetPlatformApplicationAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "SetPlatformApplicationAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetPlatformApplicationAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetPlatformApplicationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetPlatformApplicationAttributesInput>
    public typealias MOutput = OperationOutput<SetPlatformApplicationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetPlatformApplicationAttributesOutputError>
}

public struct SetPlatformApplicationAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "SetPlatformApplicationAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetPlatformApplicationAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetPlatformApplicationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetPlatformApplicationAttributesInput>
    public typealias MOutput = OperationOutput<SetPlatformApplicationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetPlatformApplicationAttributesOutputError>
}

/// <p>Input for SetPlatformApplicationAttributes action.</p>
public struct SetPlatformApplicationAttributesInput: Equatable {
    /// <p>A map of the platform application attributes. Attributes in this map include the
    ///             following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>PlatformCredential</code> – The credential received from the
    ///                     notification service. For <code>APNS</code> and <code>APNS_SANDBOX</code>,
    ///                         <code>PlatformCredential</code> is <code>private key</code>. For
    ///                         <code>GCM</code> (Firebase Cloud Messaging), <code>PlatformCredential</code>
    ///                     is <code>API key</code>. For <code>ADM</code>, <code>PlatformCredential</code>
    ///                     is <code>client secret</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>PlatformPrincipal</code> – The principal received from the
    ///                     notification service. For <code>APNS</code> and <code>APNS_SANDBOX</code>,
    ///                         <code>PlatformPrincipal</code> is <code>SSL certificate</code>. For
    ///                         <code>GCM</code> (Firebase Cloud Messaging), there is no
    ///                         <code>PlatformPrincipal</code>. For <code>ADM</code>,
    ///                         <code>PlatformPrincipal</code> is <code>client id</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EventEndpointCreated</code> – Topic ARN to which
    ///                         <code>EndpointCreated</code> event notifications are sent.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EventEndpointDeleted</code> – Topic ARN to which
    ///                         <code>EndpointDeleted</code> event notifications are sent.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EventEndpointUpdated</code> – Topic ARN to which
    ///                         <code>EndpointUpdate</code> event notifications are sent.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EventDeliveryFailure</code> – Topic ARN to which
    ///                         <code>DeliveryFailure</code> event notifications are sent upon Direct
    ///                     Publish delivery failure (permanent) to one of the application's
    ///                     endpoints.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>SuccessFeedbackRoleArn</code> – IAM role ARN used to give Amazon SNS
    ///                     write access to use CloudWatch Logs on your behalf.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>FailureFeedbackRoleArn</code> – IAM role ARN used to give Amazon SNS
    ///                     write access to use CloudWatch Logs on your behalf.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>SuccessFeedbackSampleRate</code> – Sample rate percentage (0-100)
    ///                     of successfully delivered messages.</p>
    ///             </li>
    ///          </ul>
    public let attributes: [String:String]?
    /// <p>PlatformApplicationArn for SetPlatformApplicationAttributes action.</p>
    public let platformApplicationArn: String?

    public init (
        attributes: [String:String]? = nil,
        platformApplicationArn: String? = nil
    )
    {
        self.attributes = attributes
        self.platformApplicationArn = platformApplicationArn
    }
}

extension SetPlatformApplicationAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetPlatformApplicationAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetPlatformApplicationAttributesOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetPlatformApplicationAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetPlatformApplicationAttributesOutputResponse()"}
}

extension SetPlatformApplicationAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetPlatformApplicationAttributesOutputResponse: Equatable {

    public init() {}
}

struct SetPlatformApplicationAttributesOutputResponseBody: Equatable {
}

extension SetPlatformApplicationAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetSMSAttributesInputBodyMiddleware: Middleware {
    public let id: String = "SetSMSAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSMSAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSMSAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSMSAttributesInput>
    public typealias MOutput = OperationOutput<SetSMSAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSMSAttributesOutputError>
}

extension SetSMSAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetSMSAttributesInput(attributes: \(String(describing: attributes)))"}
}

extension SetSMSAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("key"))
                try keyContainer0.encode(stringKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("value"))
                try valueContainer0.encode(stringValue0, forKey: Key(""))
            }
        }
        try container.encode("SetSMSAttributes", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct SetSMSAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "SetSMSAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSMSAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSMSAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSMSAttributesInput>
    public typealias MOutput = OperationOutput<SetSMSAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSMSAttributesOutputError>
}

public struct SetSMSAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "SetSMSAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSMSAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSMSAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSMSAttributesInput>
    public typealias MOutput = OperationOutput<SetSMSAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSMSAttributesOutputError>
}

/// <p>The input for the SetSMSAttributes action.</p>
public struct SetSMSAttributesInput: Equatable {
    /// <p>The default settings for sending SMS messages from your account. You can set values
    ///             for the following attribute names:</p>
    ///         <p>
    ///             <code>MonthlySpendLimit</code> – The maximum amount in USD that you are willing to spend
    ///             each month to send SMS messages. When Amazon SNS determines that sending an SMS message would
    ///             incur a cost that exceeds this limit, it stops sending SMS messages within
    ///             minutes.</p>
    ///         <important>
    ///             <p>Amazon SNS stops sending SMS messages within minutes of the limit being crossed. During
    ///                 that interval, if you continue to send SMS messages, you will incur costs that
    ///                 exceed your limit.</p>
    ///         </important>
    ///         <p>By default, the spend limit is set to the maximum allowed by Amazon SNS. If you want to
    ///             raise the limit, submit an <a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-sns">SNS Limit Increase case</a>. For <b>New limit
    ///                 value</b>, enter your desired monthly spend limit. In the <b>Use Case Description</b> field, explain that you are requesting
    ///             an SMS monthly spend limit increase.</p>
    ///         <p>
    ///             <code>DeliveryStatusIAMRole</code> – The ARN of the IAM role that allows Amazon SNS to write
    ///             logs about SMS deliveries in CloudWatch Logs. For each SMS message that you send, Amazon SNS
    ///             writes a log that includes the message price, the success or failure status, the reason
    ///             for failure (if the message failed), the message dwell time, and other
    ///             information.</p>
    ///         <p>
    ///             <code>DeliveryStatusSuccessSamplingRate</code> – The percentage of successful SMS
    ///             deliveries for which Amazon SNS will write logs in CloudWatch Logs. The value can be an
    ///             integer from 0 - 100. For example, to write logs only for failed deliveries, set this
    ///             value to <code>0</code>. To write logs for 10% of your successful deliveries, set it to
    ///                 <code>10</code>.</p>
    ///         <p>
    ///             <code>DefaultSenderID</code> – A string, such as your business brand, that is displayed
    ///             as the sender on the receiving device. Support for sender IDs varies by country. The
    ///             sender ID can be 1 - 11 alphanumeric characters, and it must contain at least one
    ///             letter.</p>
    ///         <p>
    ///             <code>DefaultSMSType</code> – The type of SMS message that you will send by default. You
    ///             can assign the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>Promotional</code> – (Default) Noncritical messages, such as marketing
    ///                     messages. Amazon SNS optimizes the message delivery to incur the lowest cost.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>Transactional</code> – Critical messages that support customer
    ///                     transactions, such as one-time passcodes for multi-factor authentication. Amazon
    ///                     SNS optimizes the message delivery to achieve the highest reliability.</p>
    ///             </li>
    ///          </ul>
    ///         <p>
    ///             <code>UsageReportS3Bucket</code> – The name of the Amazon S3 bucket to receive daily SMS
    ///             usage reports from Amazon SNS. Each day, Amazon SNS will deliver a usage report as a CSV file to
    ///             the bucket. The report includes the following information for each SMS message that was
    ///             successfully delivered by your account:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Time that the message was published (in UTC)</p>
    ///             </li>
    ///             <li>
    ///                 <p>Message ID</p>
    ///             </li>
    ///             <li>
    ///                 <p>Destination phone number</p>
    ///             </li>
    ///             <li>
    ///                 <p>Message type</p>
    ///             </li>
    ///             <li>
    ///                 <p>Delivery status</p>
    ///             </li>
    ///             <li>
    ///                 <p>Message price (in USD)</p>
    ///             </li>
    ///             <li>
    ///                 <p>Part number (a message is split into multiple parts if it is too long for a
    ///                     single message)</p>
    ///             </li>
    ///             <li>
    ///                 <p>Total number of parts</p>
    ///             </li>
    ///          </ul>
    ///         <p>To receive the report, the bucket must have a policy that allows the Amazon SNS service
    ///             principle to perform the <code>s3:PutObject</code> and <code>s3:GetBucketLocation</code>
    ///             actions.</p>
    ///         <p>For an example bucket policy and usage report, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sms_stats.html">Monitoring SMS Activity</a> in the
    ///                 <i>Amazon SNS Developer Guide</i>.</p>
    public let attributes: [String:String]?

    public init (
        attributes: [String:String]? = nil
    )
    {
        self.attributes = attributes
    }
}

extension SetSMSAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetSMSAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetSMSAttributesOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetSMSAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetSMSAttributesOutputResponse()"}
}

extension SetSMSAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The response for the SetSMSAttributes action.</p>
public struct SetSMSAttributesOutputResponse: Equatable {

    public init() {}
}

struct SetSMSAttributesOutputResponseBody: Equatable {
}

extension SetSMSAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetSubscriptionAttributesInputBodyMiddleware: Middleware {
    public let id: String = "SetSubscriptionAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSubscriptionAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSubscriptionAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSubscriptionAttributesInput>
    public typealias MOutput = OperationOutput<SetSubscriptionAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSubscriptionAttributesOutputError>
}

extension SetSubscriptionAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetSubscriptionAttributesInput(attributeName: \(String(describing: attributeName)), attributeValue: \(String(describing: attributeValue)), subscriptionArn: \(String(describing: subscriptionArn)))"}
}

extension SetSubscriptionAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: Key("AttributeName"))
        }
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: Key("AttributeValue"))
        }
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: Key("SubscriptionArn"))
        }
        try container.encode("SetSubscriptionAttributes", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct SetSubscriptionAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "SetSubscriptionAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSubscriptionAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSubscriptionAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSubscriptionAttributesInput>
    public typealias MOutput = OperationOutput<SetSubscriptionAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSubscriptionAttributesOutputError>
}

public struct SetSubscriptionAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "SetSubscriptionAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSubscriptionAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSubscriptionAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSubscriptionAttributesInput>
    public typealias MOutput = OperationOutput<SetSubscriptionAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSubscriptionAttributesOutputError>
}

/// <p>Input for SetSubscriptionAttributes action.</p>
public struct SetSubscriptionAttributesInput: Equatable {
    /// <p>A map of attributes with their corresponding values.</p>
    ///         <p>The following lists the names, descriptions, and values of the special request
    ///             parameters that this action uses:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>DeliveryPolicy</code> – The policy that defines how Amazon SNS retries
    ///                     failed deliveries to HTTP/S endpoints.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FilterPolicy</code> – The simple JSON object that lets your
    ///                     subscriber receive only a subset of messages, rather than receiving every
    ///                     message published to the topic.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>RawMessageDelivery</code> – When set to <code>true</code>,
    ///                     enables raw message delivery to Amazon SQS or HTTP/S endpoints. This eliminates the
    ///                     need for the endpoints to process JSON formatting, which is otherwise created
    ///                     for Amazon SNS metadata.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>RedrivePolicy</code> – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue.
    ///     Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable)
    ///     or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held
    ///     in the dead-letter queue for further analysis or reprocessing.</p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///         <p>The following attribute applies only to Amazon Kinesis Data Firehose delivery stream subscriptions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SubscriptionRoleArn</code> – The ARN of the IAM role that has the following:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>Permission to write to the Kinesis Data Firehose delivery stream</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>Amazon SNS listed as a trusted entity</p>
    ///                     </li>
    ///                </ul>
    ///                 <p>Specifying a valid ARN for this attribute is required for Kinesis Data Firehose delivery stream subscriptions.
    ///                 For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html">Fanout
    ///                     to Kinesis Data Firehose delivery streams</a> in the <i>Amazon SNS Developer Guide</i>.</p>
    ///                     </li>
    ///          </ul>
    public let attributeName: String?
    /// <p>The new value for the attribute in JSON format.</p>
    public let attributeValue: String?
    /// <p>The ARN of the subscription to modify.</p>
    public let subscriptionArn: String?

    public init (
        attributeName: String? = nil,
        attributeValue: String? = nil,
        subscriptionArn: String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.subscriptionArn = subscriptionArn
    }
}

extension SetSubscriptionAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetSubscriptionAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterPolicyLimitExceededException" : self = .filterPolicyLimitExceededException(try FilterPolicyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetSubscriptionAttributesOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case filterPolicyLimitExceededException(FilterPolicyLimitExceededException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetSubscriptionAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetSubscriptionAttributesOutputResponse()"}
}

extension SetSubscriptionAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetSubscriptionAttributesOutputResponse: Equatable {

    public init() {}
}

struct SetSubscriptionAttributesOutputResponseBody: Equatable {
}

extension SetSubscriptionAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetTopicAttributesInputBodyMiddleware: Middleware {
    public let id: String = "SetTopicAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetTopicAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetTopicAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetTopicAttributesInput>
    public typealias MOutput = OperationOutput<SetTopicAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetTopicAttributesOutputError>
}

extension SetTopicAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetTopicAttributesInput(attributeName: \(String(describing: attributeName)), attributeValue: \(String(describing: attributeValue)), topicArn: \(String(describing: topicArn)))"}
}

extension SetTopicAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: Key("AttributeName"))
        }
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: Key("AttributeValue"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
        try container.encode("SetTopicAttributes", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct SetTopicAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "SetTopicAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetTopicAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetTopicAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetTopicAttributesInput>
    public typealias MOutput = OperationOutput<SetTopicAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetTopicAttributesOutputError>
}

public struct SetTopicAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "SetTopicAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetTopicAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetTopicAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetTopicAttributesInput>
    public typealias MOutput = OperationOutput<SetTopicAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetTopicAttributesOutputError>
}

/// <p>Input for SetTopicAttributes action.</p>
public struct SetTopicAttributesInput: Equatable {
    /// <p>A map of attributes with their corresponding values.</p>
    ///         <p>The following lists the names, descriptions, and values of the special request
    ///             parameters that the <code>SetTopicAttributes</code> action uses:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>DeliveryPolicy</code> – The policy that defines how Amazon SNS retries
    ///                     failed deliveries to HTTP/S endpoints.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DisplayName</code> – The display name to use for a topic with SMS
    ///                     subscriptions.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Policy</code> – The policy that defines who can access your
    ///                     topic. By default, only the topic owner can publish or subscribe to the
    ///                     topic.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>The following attribute applies only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html">server-side-encryption</a>:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>KmsMasterKeyId</code> – The ID of an AWS-managed customer master
    ///                     key (CMK) for Amazon SNS or a custom CMK. For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms">Key
    ///                         Terms</a>. For more examples, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters">KeyId</a> in the <i>AWS Key Management Service API
    ///                         Reference</i>. </p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///         <p>The following attribute applies only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html">FIFO topics</a>:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                     <code>ContentBasedDeduplication</code> –  Enables content-based deduplication for
    ///                     FIFO topics.</p>
    ///
    ///                 <ul>
    ///                   <li>
    ///                         <p>By default, <code>ContentBasedDeduplication</code> is set to <code>false</code>.
    ///                             If you create a FIFO topic and this attribute is <code>false</code>, you must
    ///                             specify a value for the <code>MessageDeduplicationId</code> parameter for the
    ///                             <a href="https://docs.aws.amazon.com/sns/latest/api/API_Publish.html">Publish</a> action. </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>When you set <code>ContentBasedDeduplication</code> to <code>true</code>,
    ///                             Amazon SNS uses a SHA-256 hash to generate the <code>MessageDeduplicationId</code> using
    ///                             the body of the message (but not the attributes of the message).</p>
    ///                         <p>(Optional) To override the generated value, you can specify a value
    ///                             for the <code>MessageDeduplicationId</code> parameter for the <code>Publish</code>
    ///                             action.</p>
    ///                      </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let attributeName: String?
    /// <p>The new value for the attribute.</p>
    public let attributeValue: String?
    /// <p>The ARN of the topic to modify.</p>
    public let topicArn: String?

    public init (
        attributeName: String? = nil,
        attributeValue: String? = nil,
        topicArn: String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.topicArn = topicArn
    }
}

extension SetTopicAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetTopicAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityException" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetTopicAttributesOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSecurityException(InvalidSecurityException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetTopicAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetTopicAttributesOutputResponse()"}
}

extension SetTopicAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetTopicAttributesOutputResponse: Equatable {

    public init() {}
}

struct SetTopicAttributesOutputResponseBody: Equatable {
}

extension SetTopicAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StaleTagException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StaleTagException(message: \(String(describing: message)))"}
}

extension StaleTagException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<StaleTagExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A tag has been added to a resource with the same ARN as a deleted resource. Wait a
///             short while and then retry the operation.</p>
public struct StaleTagException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StaleTagExceptionBody: Equatable {
    public let message: String?
}

extension StaleTagExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SubscribeInputBodyMiddleware: Middleware {
    public let id: String = "SubscribeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubscribeInput>,
                  next: H) -> Swift.Result<OperationOutput<SubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubscribeInput>
    public typealias MOutput = OperationOutput<SubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubscribeOutputError>
}

extension SubscribeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscribeInput(attributes: \(String(describing: attributes)), endpoint: \(String(describing: endpoint)), protocol: \(String(describing: `protocol`)), returnSubscriptionArn: \(String(describing: returnSubscriptionArn)), topicArn: \(String(describing: topicArn)))"}
}

extension SubscribeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let attributenameKey0 = element0.key
                let attributevalueValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("key"))
                try keyContainer0.encode(attributenameKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("value"))
                try valueContainer0.encode(attributevalueValue0, forKey: Key(""))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: Key("Protocol"))
        }
        if returnSubscriptionArn != false {
            try container.encode(returnSubscriptionArn, forKey: Key("ReturnSubscriptionArn"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
        try container.encode("Subscribe", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct SubscribeInputHeadersMiddleware: Middleware {
    public let id: String = "SubscribeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubscribeInput>,
                  next: H) -> Swift.Result<OperationOutput<SubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubscribeInput>
    public typealias MOutput = OperationOutput<SubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubscribeOutputError>
}

public struct SubscribeInputQueryItemMiddleware: Middleware {
    public let id: String = "SubscribeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubscribeInput>,
                  next: H) -> Swift.Result<OperationOutput<SubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubscribeInput>
    public typealias MOutput = OperationOutput<SubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubscribeOutputError>
}

/// <p>Input for Subscribe action.</p>
public struct SubscribeInput: Equatable {
    /// <p>The protocol that you want to use. Supported protocols include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>http</code> – delivery of JSON-encoded message via HTTP
    ///                     POST</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>https</code> – delivery of JSON-encoded message via HTTPS
    ///                     POST</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>email</code> – delivery of message via SMTP</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>email-json</code> – delivery of JSON-encoded message via
    ///                     SMTP</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>sms</code> – delivery of message via SMS</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>sqs</code> – delivery of JSON-encoded message to an Amazon SQS
    ///                     queue</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>application</code> – delivery of JSON-encoded message to an
    ///                     EndpointArn for a mobile app and device</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>lambda</code> – delivery of JSON-encoded message to an AWS Lambda
    ///                     function</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>firehose</code> – delivery of JSON-encoded message to an Amazon
    ///                     Kinesis Data Firehose delivery stream.</p>
    ///             </li>
    ///          </ul>
    public let `protocol`: String?
    /// <p>A map of attributes with their corresponding values.</p>
    ///         <p>The following lists the names, descriptions, and values of the special request
    ///             parameters that the <code>SetTopicAttributes</code> action uses:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>DeliveryPolicy</code> – The policy that defines how Amazon SNS retries
    ///                     failed deliveries to HTTP/S endpoints.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FilterPolicy</code> – The simple JSON object that lets your
    ///                     subscriber receive only a subset of messages, rather than receiving every
    ///                     message published to the topic.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>RawMessageDelivery</code> – When set to <code>true</code>,
    ///                     enables raw message delivery to Amazon SQS or HTTP/S endpoints. This eliminates the
    ///                     need for the endpoints to process JSON formatting, which is otherwise created
    ///                     for Amazon SNS metadata.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>RedrivePolicy</code> – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue.
    ///     Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable)
    ///     or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held
    ///     in the dead-letter queue for further analysis or reprocessing.</p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///         <p>The following attribute applies only to Amazon Kinesis Data Firehose delivery stream subscriptions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SubscriptionRoleArn</code> – The ARN of the IAM role that has the following:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>Permission to write to the Kinesis Data Firehose delivery stream</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>Amazon SNS listed as a trusted entity</p>
    ///                     </li>
    ///                </ul>
    ///                 <p>Specifying a valid ARN for this attribute is required for Kinesis Data Firehose delivery stream subscriptions.
    ///                 For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html">Fanout
    ///                     to Kinesis Data Firehose delivery streams</a> in the <i>Amazon SNS Developer Guide</i>.</p>
    ///                     </li>
    ///          </ul>
    public let attributes: [String:String]?
    /// <p>The endpoint that you want to receive notifications. Endpoints vary by
    ///             protocol:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>For the <code>http</code> protocol, the (public) endpoint is a URL beginning
    ///                     with <code>http://</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>https</code> protocol, the (public) endpoint is a URL beginning
    ///                     with <code>https://</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>email</code> protocol, the endpoint is an email address.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>email-json</code> protocol, the endpoint is an email
    ///                     address.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>sms</code> protocol, the endpoint is a phone number of an
    ///                     SMS-enabled device.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>sqs</code> protocol, the endpoint is the ARN of an Amazon SQS
    ///                     queue.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>application</code> protocol, the endpoint is the EndpointArn of
    ///                     a mobile app and device.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>lambda</code> protocol, the endpoint is the ARN of an AWS Lambda
    ///                     function.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>firehose</code> protocol, the endpoint is the ARN of an Amazon
    ///                     Kinesis Data Firehose delivery stream.</p>
    ///             </li>
    ///          </ul>
    public let endpoint: String?
    /// <p>Sets whether the response from the <code>Subscribe</code> request includes the
    ///             subscription ARN, even if the subscription is not yet confirmed.</p>
    ///         <p>If you set this parameter to <code>true</code>, the response includes the ARN in all
    ///             cases, even if the subscription is not yet confirmed. In addition to the ARN for
    ///             confirmed subscriptions, the response also includes the <code>pending
    ///                 subscription</code> ARN value for subscriptions that aren't yet confirmed. A
    ///             subscription becomes confirmed when the subscriber calls the
    ///                 <code>ConfirmSubscription</code> action with a confirmation token.</p>
    ///         <p></p>
    ///         <p>The default value is <code>false</code>.</p>
    public let returnSubscriptionArn: Bool
    /// <p>The ARN of the topic you want to subscribe to.</p>
    public let topicArn: String?

    public init (
        `protocol`: String? = nil,
        attributes: [String:String]? = nil,
        endpoint: String? = nil,
        returnSubscriptionArn: Bool = false,
        topicArn: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.attributes = attributes
        self.endpoint = endpoint
        self.returnSubscriptionArn = returnSubscriptionArn
        self.topicArn = topicArn
    }
}

extension SubscribeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SubscribeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterPolicyLimitExceededException" : self = .filterPolicyLimitExceededException(try FilterPolicyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityException" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionLimitExceededException" : self = .subscriptionLimitExceededException(try SubscriptionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SubscribeOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case filterPolicyLimitExceededException(FilterPolicyLimitExceededException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSecurityException(InvalidSecurityException)
    case notFoundException(NotFoundException)
    case subscriptionLimitExceededException(SubscriptionLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SubscribeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscribeOutputResponse(subscriptionArn: \(String(describing: subscriptionArn)))"}
}

extension SubscribeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SubscribeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.subscriptionArn = output.subscriptionArn
        } else {
            self.subscriptionArn = nil
        }
    }
}

/// <p>Response for Subscribe action.</p>
public struct SubscribeOutputResponse: Equatable {
    /// <p>The ARN of the subscription if it is confirmed, or the string "pending confirmation"
    ///             if the subscription requires confirmation. However, if the API request parameter
    ///                 <code>ReturnSubscriptionArn</code> is true, then the value is always the
    ///             subscription ARN, even if the subscription requires confirmation.</p>
    public let subscriptionArn: String?

    public init (
        subscriptionArn: String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct SubscribeOutputResponseBody: Equatable {
    public let subscriptionArn: String?
}

extension SubscribeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("SubscribeResult"))
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

extension Subscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpoint = "Endpoint"
        case owner = "Owner"
        case `protocol` = "Protocol"
        case subscriptionArn = "SubscriptionArn"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: Key("Endpoint"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: Key("Owner"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: Key("Protocol"))
        }
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: Key("SubscriptionArn"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension Subscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Subscription(endpoint: \(String(describing: endpoint)), owner: \(String(describing: owner)), protocol: \(String(describing: `protocol`)), subscriptionArn: \(String(describing: subscriptionArn)), topicArn: \(String(describing: topicArn)))"}
}

/// <p>A wrapper type for the attributes of an Amazon SNS subscription.</p>
public struct Subscription: Equatable {
    /// <p>The subscription's protocol.</p>
    public let `protocol`: String?
    /// <p>The subscription's endpoint (format depends on the protocol).</p>
    public let endpoint: String?
    /// <p>The subscription's owner.</p>
    public let owner: String?
    /// <p>The subscription's ARN.</p>
    public let subscriptionArn: String?
    /// <p>The ARN of the subscription's topic.</p>
    public let topicArn: String?

    public init (
        `protocol`: String? = nil,
        endpoint: String? = nil,
        owner: String? = nil,
        subscriptionArn: String? = nil,
        topicArn: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.endpoint = endpoint
        self.owner = owner
        self.subscriptionArn = subscriptionArn
        self.topicArn = topicArn
    }
}

extension SubscriptionLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscriptionLimitExceededException(message: \(String(describing: message)))"}
}

extension SubscriptionLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubscriptionLimitExceededExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the customer already owns the maximum allowed number of
///             subscriptions.</p>
public struct SubscriptionLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension SubscriptionLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>The list of tags to be added to the specified topic.</p>
public struct Tag: Equatable {
    /// <p>The required key portion of the tag.</p>
    public let key: String?
    /// <p>The optional value portion of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagLimitExceededException(message: \(String(describing: message)))"}
}

extension TagLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TagLimitExceededExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Can't add more than 50 tags to a topic.</p>
public struct TagLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension TagLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagPolicyException(message: \(String(describing: message)))"}
}

extension TagPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TagPolicyExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request doesn't comply with the IAM tag policy. Correct your request and then
///             retry it.</p>
public struct TagPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagPolicyExceptionBody: Equatable {
    public let message: String?
}

extension TagPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: Key("ResourceArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("TagResource", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the topic to which to add tags.</p>
    public let resourceArn: String?
    /// <p>The tags to be added to the specified topic. A tag consists of a required key and an
    ///             optional value.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccessException" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleTagException" : self = .staleTagException(try StaleTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededException" : self = .tagLimitExceededException(try TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case concurrentAccessException(ConcurrentAccessException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case staleTagException(StaleTagException)
    case tagLimitExceededException(TagLimitExceededException)
    case tagPolicyException(TagPolicyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottledException(message: \(String(describing: message)))"}
}

extension ThrottledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ThrottledExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the rate at which requests have been submitted for this action exceeds
///             the limit for your account.</p>
public struct ThrottledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Throttled request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottledExceptionBody: Equatable {
    public let message: String?
}

extension ThrottledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Topic: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension Topic: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Topic(topicArn: \(String(describing: topicArn)))"}
}

/// <p>A wrapper type for the topic's Amazon Resource Name (ARN). To retrieve a topic's
///             attributes, use <code>GetTopicAttributes</code>.</p>
public struct Topic: Equatable {
    /// <p>The topic's ARN.</p>
    public let topicArn: String?

    public init (
        topicArn: String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

extension TopicLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TopicLimitExceededException(message: \(String(describing: message)))"}
}

extension TopicLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TopicLimitExceededExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the customer already owns the maximum allowed number of topics.</p>
public struct TopicLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TopicLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension TopicLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UnsubscribeInputBodyMiddleware: Middleware {
    public let id: String = "UnsubscribeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnsubscribeInput>,
                  next: H) -> Swift.Result<OperationOutput<UnsubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnsubscribeInput>
    public typealias MOutput = OperationOutput<UnsubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnsubscribeOutputError>
}

extension UnsubscribeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsubscribeInput(subscriptionArn: \(String(describing: subscriptionArn)))"}
}

extension UnsubscribeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: Key("SubscriptionArn"))
        }
        try container.encode("Unsubscribe", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct UnsubscribeInputHeadersMiddleware: Middleware {
    public let id: String = "UnsubscribeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnsubscribeInput>,
                  next: H) -> Swift.Result<OperationOutput<UnsubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnsubscribeInput>
    public typealias MOutput = OperationOutput<UnsubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnsubscribeOutputError>
}

public struct UnsubscribeInputQueryItemMiddleware: Middleware {
    public let id: String = "UnsubscribeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnsubscribeInput>,
                  next: H) -> Swift.Result<OperationOutput<UnsubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnsubscribeInput>
    public typealias MOutput = OperationOutput<UnsubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnsubscribeOutputError>
}

/// <p>Input for Unsubscribe action.</p>
public struct UnsubscribeInput: Equatable {
    /// <p>The ARN of the subscription to be deleted.</p>
    public let subscriptionArn: String?

    public init (
        subscriptionArn: String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

extension UnsubscribeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UnsubscribeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityException" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnsubscribeOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSecurityException(InvalidSecurityException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnsubscribeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsubscribeOutputResponse()"}
}

extension UnsubscribeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UnsubscribeOutputResponse: Equatable {

    public init() {}
}

struct UnsubscribeOutputResponseBody: Equatable {
}

extension UnsubscribeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: Key("ResourceArn"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, tagkey0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(tagkey0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("UntagResource", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the topic from which to remove tags.</p>
    public let resourceArn: String?
    /// <p>The list of tag keys to remove from the specified topic.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccessException" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleTagException" : self = .staleTagException(try StaleTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededException" : self = .tagLimitExceededException(try TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case concurrentAccessException(ConcurrentAccessException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case staleTagException(StaleTagException)
    case tagLimitExceededException(TagLimitExceededException)
    case tagPolicyException(TagPolicyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UserErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserErrorException(message: \(String(describing: message)))"}
}

extension UserErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<UserErrorExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a request parameter does not comply with the associated
///             constraints.</p>
public struct UserErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UserErrorExceptionBody: Equatable {
    public let message: String?
}

extension UserErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ValidationExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a parameter in the request is invalid.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VerificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerificationException(message: \(String(describing: message)), status: \(String(describing: status)))"}
}

extension VerificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<VerificationExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
            self.status = output.error.status
        } else {
            self.message = nil
            self.status = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the one-time password (OTP) used for verification is invalid.</p>
public struct VerificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The status of the verification error.</p>
    public var status: String?

    public init (
        message: String? = nil,
        status: String? = nil
    )
    {
        self.message = message
        self.status = status
    }
}

struct VerificationExceptionBody: Equatable {
    public let message: String?
    public let status: String?
}

extension VerificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct VerifySMSSandboxPhoneNumberInputBodyMiddleware: Middleware {
    public let id: String = "VerifySMSSandboxPhoneNumberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifySMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifySMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifySMSSandboxPhoneNumberInput>
    public typealias MOutput = OperationOutput<VerifySMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifySMSSandboxPhoneNumberOutputError>
}

extension VerifySMSSandboxPhoneNumberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifySMSSandboxPhoneNumberInput(oneTimePassword: \(String(describing: oneTimePassword)), phoneNumber: \(String(describing: phoneNumber)))"}
}

extension VerifySMSSandboxPhoneNumberInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let oneTimePassword = oneTimePassword {
            try container.encode(oneTimePassword, forKey: Key("OneTimePassword"))
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: Key("PhoneNumber"))
        }
        try container.encode("VerifySMSSandboxPhoneNumber", forKey:Key("Action"))
        try container.encode("2010-03-31", forKey:Key("Version"))
    }
}

public struct VerifySMSSandboxPhoneNumberInputHeadersMiddleware: Middleware {
    public let id: String = "VerifySMSSandboxPhoneNumberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifySMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifySMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifySMSSandboxPhoneNumberInput>
    public typealias MOutput = OperationOutput<VerifySMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifySMSSandboxPhoneNumberOutputError>
}

public struct VerifySMSSandboxPhoneNumberInputQueryItemMiddleware: Middleware {
    public let id: String = "VerifySMSSandboxPhoneNumberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifySMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifySMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifySMSSandboxPhoneNumberInput>
    public typealias MOutput = OperationOutput<VerifySMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifySMSSandboxPhoneNumberOutputError>
}

public struct VerifySMSSandboxPhoneNumberInput: Equatable {
    /// <p>The OTP sent to the destination number from the
    ///                 <code>CreateSMSSandBoxPhoneNumber</code> call.</p>
    public let oneTimePassword: String?
    /// <p>The destination phone number to verify.</p>
    public let phoneNumber: String?

    public init (
        oneTimePassword: String? = nil,
        phoneNumber: String? = nil
    )
    {
        self.oneTimePassword = oneTimePassword
        self.phoneNumber = phoneNumber
    }
}

extension VerifySMSSandboxPhoneNumberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension VerifySMSSandboxPhoneNumberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VerificationException" : self = .verificationException(try VerificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum VerifySMSSandboxPhoneNumberOutputError: Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttledException(ThrottledException)
    case verificationException(VerificationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension VerifySMSSandboxPhoneNumberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifySMSSandboxPhoneNumberOutputResponse()"}
}

extension VerifySMSSandboxPhoneNumberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The destination phone number's verification status.</p>
public struct VerifySMSSandboxPhoneNumberOutputResponse: Equatable {

    public init() {}
}

struct VerifySMSSandboxPhoneNumberOutputResponseBody: Equatable {
}

extension VerifySMSSandboxPhoneNumberOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
