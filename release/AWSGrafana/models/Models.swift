// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient permissions to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GrafanaClientTypes {
    public enum AccountAccessType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates that the customer is using Grafana to monitor resources in their current account.
        case currentAccount
        /// Indicates that the customer is using Grafana to monitor resources in organizational units.
        case organization
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountAccessType] {
            return [
                .currentAccount,
                .organization,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .currentAccount: return "CURRENT_ACCOUNT"
            case .organization: return "ORGANIZATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountAccessType(rawValue: rawValue) ?? AccountAccessType.sdkUnknown(rawValue)
        }
    }
}

extension GrafanaClientTypes.AssertionAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email
        case groups
        case login
        case name
        case org
        case role
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let groups = groups {
            try encodeContainer.encode(groups, forKey: .groups)
        }
        if let login = login {
            try encodeContainer.encode(login, forKey: .login)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let org = org {
            try encodeContainer.encode(org, forKey: .org)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let loginDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .login)
        login = loginDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let groupsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groups)
        groups = groupsDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let orgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .org)
        org = orgDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure that defines which attributes in the IdP assertion are to be used to define information about the users authenticated by the IdP to use the workspace.
    public struct AssertionAttributes: Swift.Equatable {
        /// The name of the attribute within the SAML assertion to use as the email names for SAML users.
        public var email: Swift.String?
        /// The name of the attribute within the SAML assertion to use as the user full "friendly" names for user groups.
        public var groups: Swift.String?
        /// The name of the attribute within the SAML assertion to use as the login names for SAML users.
        public var login: Swift.String?
        /// The name of the attribute within the SAML assertion to use as the user full "friendly" names for SAML users.
        public var name: Swift.String?
        /// The name of the attribute within the SAML assertion to use as the user full "friendly" names for the users' organizations.
        public var org: Swift.String?
        /// The name of the attribute within the SAML assertion to use as the user roles.
        public var role: Swift.String?

        public init (
            email: Swift.String? = nil,
            groups: Swift.String? = nil,
            login: Swift.String? = nil,
            name: Swift.String? = nil,
            org: Swift.String? = nil,
            role: Swift.String? = nil
        )
        {
            self.email = email
            self.groups = groups
            self.login = login
            self.name = name
            self.org = org
            self.role = role
        }
    }

}

extension AssociateLicenseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let licenseType = licenseType else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/licenses/\(licenseType.rawValue.urlPercentEncoding())"
    }
}

public struct AssociateLicenseInput: Swift.Equatable {
    /// The type of license to associate with the workspace.
    /// This member is required.
    public var licenseType: GrafanaClientTypes.LicenseType?
    /// The ID of the workspace to associate the license with.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        licenseType: GrafanaClientTypes.LicenseType? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.licenseType = licenseType
        self.workspaceId = workspaceId
    }
}

struct AssociateLicenseInputBody: Swift.Equatable {
}

extension AssociateLicenseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateLicenseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateLicenseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateLicenseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateLicenseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateLicenseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workspace = output.workspace
        } else {
            self.workspace = nil
        }
    }
}

public struct AssociateLicenseOutputResponse: Swift.Equatable {
    /// A structure containing data about the workspace.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init (
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

struct AssociateLicenseOutputResponseBody: Swift.Equatable {
    let workspace: GrafanaClientTypes.WorkspaceDescription?
}

extension AssociateLicenseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspace
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceDescription.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

extension GrafanaClientTypes.AuthenticationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsSso
        case providers
        case saml
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsSso = awsSso {
            try encodeContainer.encode(awsSso, forKey: .awsSso)
        }
        if let providers = providers {
            var providersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .providers)
            for authenticationproviders0 in providers {
                try providersContainer.encode(authenticationproviders0.rawValue)
            }
        }
        if let saml = saml {
            try encodeContainer.encode(saml, forKey: .saml)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providersContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.AuthenticationProviderTypes?].self, forKey: .providers)
        var providersDecoded0:[GrafanaClientTypes.AuthenticationProviderTypes]? = nil
        if let providersContainer = providersContainer {
            providersDecoded0 = [GrafanaClientTypes.AuthenticationProviderTypes]()
            for string0 in providersContainer {
                if let string0 = string0 {
                    providersDecoded0?.append(string0)
                }
            }
        }
        providers = providersDecoded0
        let samlDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.SamlAuthentication.self, forKey: .saml)
        saml = samlDecoded
        let awsSsoDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AwsSsoAuthentication.self, forKey: .awsSso)
        awsSso = awsSsoDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure containing information about the user authentication methods used by the workspace.
    public struct AuthenticationDescription: Swift.Equatable {
        /// A structure containing information about how this workspace works with Amazon Web Services SSO.
        public var awsSso: GrafanaClientTypes.AwsSsoAuthentication?
        /// Specifies whether this workspace uses Amazon Web Services SSO, SAML, or both methods to authenticate users to use the Grafana console in the Amazon Managed Grafana workspace.
        /// This member is required.
        public var providers: [GrafanaClientTypes.AuthenticationProviderTypes]?
        /// A structure containing information about how this workspace works with SAML, including what attributes within the assertion are to be mapped to user information in the workspace.
        public var saml: GrafanaClientTypes.SamlAuthentication?

        public init (
            awsSso: GrafanaClientTypes.AwsSsoAuthentication? = nil,
            providers: [GrafanaClientTypes.AuthenticationProviderTypes]? = nil,
            saml: GrafanaClientTypes.SamlAuthentication? = nil
        )
        {
            self.awsSso = awsSso
            self.providers = providers
            self.saml = saml
        }
    }

}

extension GrafanaClientTypes {
    public enum AuthenticationProviderTypes: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates that AMG workspace has AWS SSO enabled as its authentication provider.
        case awsSso
        /// Indicates that the AMG workspace has SAML enabled as its authentication provider.
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationProviderTypes] {
            return [
                .awsSso,
                .saml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsSso: return "AWS_SSO"
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationProviderTypes(rawValue: rawValue) ?? AuthenticationProviderTypes.sdkUnknown(rawValue)
        }
    }
}

extension GrafanaClientTypes.AuthenticationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case providers
        case samlConfigurationStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let providers = providers {
            var providersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .providers)
            for authenticationproviders0 in providers {
                try providersContainer.encode(authenticationproviders0.rawValue)
            }
        }
        if let samlConfigurationStatus = samlConfigurationStatus {
            try encodeContainer.encode(samlConfigurationStatus.rawValue, forKey: .samlConfigurationStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providersContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.AuthenticationProviderTypes?].self, forKey: .providers)
        var providersDecoded0:[GrafanaClientTypes.AuthenticationProviderTypes]? = nil
        if let providersContainer = providersContainer {
            providersDecoded0 = [GrafanaClientTypes.AuthenticationProviderTypes]()
            for string0 in providersContainer {
                if let string0 = string0 {
                    providersDecoded0?.append(string0)
                }
            }
        }
        providers = providersDecoded0
        let samlConfigurationStatusDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.SamlConfigurationStatus.self, forKey: .samlConfigurationStatus)
        samlConfigurationStatus = samlConfigurationStatusDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure that describes whether the workspace uses SAML, Amazon Web Services SSO, or both methods for user authentication, and whether that authentication is fully configured.
    public struct AuthenticationSummary: Swift.Equatable {
        /// Specifies whether the workspace uses SAML, Amazon Web Services SSO, or both methods for user authentication.
        /// This member is required.
        public var providers: [GrafanaClientTypes.AuthenticationProviderTypes]?
        /// Specifies whether the workplace's user authentication method is fully configured.
        public var samlConfigurationStatus: GrafanaClientTypes.SamlConfigurationStatus?

        public init (
            providers: [GrafanaClientTypes.AuthenticationProviderTypes]? = nil,
            samlConfigurationStatus: GrafanaClientTypes.SamlConfigurationStatus? = nil
        )
        {
            self.providers = providers
            self.samlConfigurationStatus = samlConfigurationStatus
        }
    }

}

extension GrafanaClientTypes.AwsSsoAuthentication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ssoClientId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ssoClientId = ssoClientId {
            try encodeContainer.encode(ssoClientId, forKey: .ssoClientId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ssoClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssoClientId)
        ssoClientId = ssoClientIdDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure containing information about how this workspace works with Amazon Web Services SSO.
    public struct AwsSsoAuthentication: Swift.Equatable {
        /// The ID of the Amazon Web Services SSO-managed application that is created by Amazon Managed Grafana.
        public var ssoClientId: Swift.String?

        public init (
            ssoClientId: Swift.String? = nil
        )
        {
            self.ssoClientId = ssoClientId
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource was in an inconsistent state during an update or a deletion.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource that is associated with the error.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the resource that is associated with the error.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAccessType
        case authenticationProviders
        case clientToken
        case organizationRoleName
        case permissionType
        case stackSetName
        case workspaceDataSources
        case workspaceDescription
        case workspaceName
        case workspaceNotificationDestinations
        case workspaceOrganizationalUnits
        case workspaceRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAccessType = accountAccessType {
            try encodeContainer.encode(accountAccessType.rawValue, forKey: .accountAccessType)
        }
        if let authenticationProviders = authenticationProviders {
            var authenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authenticationProviders)
            for authenticationproviders0 in authenticationProviders {
                try authenticationProvidersContainer.encode(authenticationproviders0.rawValue)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let organizationRoleName = organizationRoleName {
            try encodeContainer.encode(organizationRoleName, forKey: .organizationRoleName)
        }
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let stackSetName = stackSetName {
            try encodeContainer.encode(stackSetName, forKey: .stackSetName)
        }
        if let workspaceDataSources = workspaceDataSources {
            var workspaceDataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceDataSources)
            for datasourcetypeslist0 in workspaceDataSources {
                try workspaceDataSourcesContainer.encode(datasourcetypeslist0.rawValue)
            }
        }
        if let workspaceDescription = workspaceDescription {
            try encodeContainer.encode(workspaceDescription, forKey: .workspaceDescription)
        }
        if let workspaceName = workspaceName {
            try encodeContainer.encode(workspaceName, forKey: .workspaceName)
        }
        if let workspaceNotificationDestinations = workspaceNotificationDestinations {
            var workspaceNotificationDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceNotificationDestinations)
            for notificationdestinationslist0 in workspaceNotificationDestinations {
                try workspaceNotificationDestinationsContainer.encode(notificationdestinationslist0.rawValue)
            }
        }
        if let workspaceOrganizationalUnits = workspaceOrganizationalUnits {
            var workspaceOrganizationalUnitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceOrganizationalUnits)
            for organizationalunitlist0 in workspaceOrganizationalUnits {
                try workspaceOrganizationalUnitsContainer.encode(organizationalunitlist0)
            }
        }
        if let workspaceRoleArn = workspaceRoleArn {
            try encodeContainer.encode(workspaceRoleArn, forKey: .workspaceRoleArn)
        }
    }
}

extension CreateWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workspaces"
    }
}

public struct CreateWorkspaceInput: Swift.Equatable {
    /// Specifies whether the workspace can access Amazon Web Services resources in this Amazon Web Services account only, or whether it can also access Amazon Web Services resources in other accounts in the same organization. If you specify ORGANIZATION, you must specify which organizational units the workspace can access in the workspaceOrganizationalUnits parameter.
    /// This member is required.
    public var accountAccessType: GrafanaClientTypes.AccountAccessType?
    /// Specifies whether this workspace uses SAML 2.0, Amazon Web Services Single Sign On, or both to authenticate users for using the Grafana console within a workspace. For more information, see [User authentication in Amazon Managed Grafana](https://docs.aws.amazon.com/grafana/latest/userguide/authentication-in-AMG.html).
    /// This member is required.
    public var authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]?
    /// A unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of an IAM role that already exists to use with Organizations to access Amazon Web Services data sources and notification channels in other accounts in an organization.
    public var organizationRoleName: Swift.String?
    /// If you specify Service Managed, Amazon Managed Grafana automatically creates the IAM roles and provisions the permissions that the workspace needs to use Amazon Web Services data sources and notification channels. If you specify CUSTOMER_MANAGED, you will manage those roles and permissions yourself. If you are creating this workspace in a member account of an organization that is not a delegated administrator account, and you want the workspace to access data sources in other Amazon Web Services accounts in the organization, you must choose CUSTOMER_MANAGED. For more information, see [Amazon Managed Grafana permissions and policies for Amazon Web Services data sources and notification channels](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-manage-permissions.html)
    /// This member is required.
    public var permissionType: GrafanaClientTypes.PermissionType?
    /// The name of the CloudFormation stack set to use to generate IAM roles to be used for this workspace.
    public var stackSetName: Swift.String?
    /// Specify the Amazon Web Services data sources that you want to be queried in this workspace. Specifying these data sources here enables Amazon Managed Grafana to create IAM roles and permissions that allow Amazon Managed Grafana to read data from these sources. You must still add them as data sources in the Grafana console in the workspace. If you don't specify a data source here, you can still add it as a data source in the workspace console later. However, you will then have to manually configure permissions for it.
    public var workspaceDataSources: [GrafanaClientTypes.DataSourceType]?
    /// A description for the workspace. This is used only to help you identify this workspace.
    public var workspaceDescription: Swift.String?
    /// The name for the workspace. It does not have to be unique.
    public var workspaceName: Swift.String?
    /// Specify the Amazon Web Services notification channels that you plan to use in this workspace. Specifying these data sources here enables Amazon Managed Grafana to create IAM roles and permissions that allow Amazon Managed Grafana to use these channels.
    public var workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
    /// Specifies the organizational units that this workspace is allowed to use data sources from, if this workspace is in an account that is part of an organization.
    public var workspaceOrganizationalUnits: [Swift.String]?
    /// The workspace needs an IAM role that grants permissions to the Amazon Web Services resources that the workspace will view data from. If you already have a role that you want to use, specify it here. If you omit this field and you specify some Amazon Web Services resources in workspaceDataSources or workspaceNotificationDestinations, a new IAM role with the necessary permissions is automatically created.
    public var workspaceRoleArn: Swift.String?

    public init (
        accountAccessType: GrafanaClientTypes.AccountAccessType? = nil,
        authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]? = nil,
        clientToken: Swift.String? = nil,
        organizationRoleName: Swift.String? = nil,
        permissionType: GrafanaClientTypes.PermissionType? = nil,
        stackSetName: Swift.String? = nil,
        workspaceDataSources: [GrafanaClientTypes.DataSourceType]? = nil,
        workspaceDescription: Swift.String? = nil,
        workspaceName: Swift.String? = nil,
        workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]? = nil,
        workspaceOrganizationalUnits: [Swift.String]? = nil,
        workspaceRoleArn: Swift.String? = nil
    )
    {
        self.accountAccessType = accountAccessType
        self.authenticationProviders = authenticationProviders
        self.clientToken = clientToken
        self.organizationRoleName = organizationRoleName
        self.permissionType = permissionType
        self.stackSetName = stackSetName
        self.workspaceDataSources = workspaceDataSources
        self.workspaceDescription = workspaceDescription
        self.workspaceName = workspaceName
        self.workspaceNotificationDestinations = workspaceNotificationDestinations
        self.workspaceOrganizationalUnits = workspaceOrganizationalUnits
        self.workspaceRoleArn = workspaceRoleArn
    }
}

struct CreateWorkspaceInputBody: Swift.Equatable {
    let accountAccessType: GrafanaClientTypes.AccountAccessType?
    let clientToken: Swift.String?
    let organizationRoleName: Swift.String?
    let permissionType: GrafanaClientTypes.PermissionType?
    let stackSetName: Swift.String?
    let workspaceDataSources: [GrafanaClientTypes.DataSourceType]?
    let workspaceDescription: Swift.String?
    let workspaceName: Swift.String?
    let workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
    let workspaceOrganizationalUnits: [Swift.String]?
    let workspaceRoleArn: Swift.String?
    let authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]?
}

extension CreateWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAccessType
        case authenticationProviders
        case clientToken
        case organizationRoleName
        case permissionType
        case stackSetName
        case workspaceDataSources
        case workspaceDescription
        case workspaceName
        case workspaceNotificationDestinations
        case workspaceOrganizationalUnits
        case workspaceRoleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAccessTypeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AccountAccessType.self, forKey: .accountAccessType)
        accountAccessType = accountAccessTypeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationRoleName)
        organizationRoleName = organizationRoleNameDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let stackSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackSetName)
        stackSetName = stackSetNameDecoded
        let workspaceDataSourcesContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.DataSourceType?].self, forKey: .workspaceDataSources)
        var workspaceDataSourcesDecoded0:[GrafanaClientTypes.DataSourceType]? = nil
        if let workspaceDataSourcesContainer = workspaceDataSourcesContainer {
            workspaceDataSourcesDecoded0 = [GrafanaClientTypes.DataSourceType]()
            for string0 in workspaceDataSourcesContainer {
                if let string0 = string0 {
                    workspaceDataSourcesDecoded0?.append(string0)
                }
            }
        }
        workspaceDataSources = workspaceDataSourcesDecoded0
        let workspaceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceDescription)
        workspaceDescription = workspaceDescriptionDecoded
        let workspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceName)
        workspaceName = workspaceNameDecoded
        let workspaceNotificationDestinationsContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.NotificationDestinationType?].self, forKey: .workspaceNotificationDestinations)
        var workspaceNotificationDestinationsDecoded0:[GrafanaClientTypes.NotificationDestinationType]? = nil
        if let workspaceNotificationDestinationsContainer = workspaceNotificationDestinationsContainer {
            workspaceNotificationDestinationsDecoded0 = [GrafanaClientTypes.NotificationDestinationType]()
            for string0 in workspaceNotificationDestinationsContainer {
                if let string0 = string0 {
                    workspaceNotificationDestinationsDecoded0?.append(string0)
                }
            }
        }
        workspaceNotificationDestinations = workspaceNotificationDestinationsDecoded0
        let workspaceOrganizationalUnitsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .workspaceOrganizationalUnits)
        var workspaceOrganizationalUnitsDecoded0:[Swift.String]? = nil
        if let workspaceOrganizationalUnitsContainer = workspaceOrganizationalUnitsContainer {
            workspaceOrganizationalUnitsDecoded0 = [Swift.String]()
            for string0 in workspaceOrganizationalUnitsContainer {
                if let string0 = string0 {
                    workspaceOrganizationalUnitsDecoded0?.append(string0)
                }
            }
        }
        workspaceOrganizationalUnits = workspaceOrganizationalUnitsDecoded0
        let workspaceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceRoleArn)
        workspaceRoleArn = workspaceRoleArnDecoded
        let authenticationProvidersContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.AuthenticationProviderTypes?].self, forKey: .authenticationProviders)
        var authenticationProvidersDecoded0:[GrafanaClientTypes.AuthenticationProviderTypes]? = nil
        if let authenticationProvidersContainer = authenticationProvidersContainer {
            authenticationProvidersDecoded0 = [GrafanaClientTypes.AuthenticationProviderTypes]()
            for string0 in authenticationProvidersContainer {
                if let string0 = string0 {
                    authenticationProvidersDecoded0?.append(string0)
                }
            }
        }
        authenticationProviders = authenticationProvidersDecoded0
    }
}

extension CreateWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workspace = output.workspace
        } else {
            self.workspace = nil
        }
    }
}

public struct CreateWorkspaceOutputResponse: Swift.Equatable {
    /// A structure containing data about the workspace that was created.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init (
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

struct CreateWorkspaceOutputResponseBody: Swift.Equatable {
    let workspace: GrafanaClientTypes.WorkspaceDescription?
}

extension CreateWorkspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspace
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceDescription.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

extension GrafanaClientTypes {
    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Amazon OpenSearch Service
        case amazonOpensearchService
        /// CloudWatch Logs
        case cloudwatch
        /// Managed Prometheus
        case prometheus
        /// IoT SiteWise
        case sitewise
        /// Timestream
        case timestream
        /// X-Ray
        case xray
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .amazonOpensearchService,
                .cloudwatch,
                .prometheus,
                .sitewise,
                .timestream,
                .xray,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonOpensearchService: return "AMAZON_OPENSEARCH_SERVICE"
            case .cloudwatch: return "CLOUDWATCH"
            case .prometheus: return "PROMETHEUS"
            case .sitewise: return "SITEWISE"
            case .timestream: return "TIMESTREAM"
            case .xray: return "XRAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct DeleteWorkspaceInput: Swift.Equatable {
    /// The ID of the workspace to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DeleteWorkspaceInputBody: Swift.Equatable {
}

extension DeleteWorkspaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workspace = output.workspace
        } else {
            self.workspace = nil
        }
    }
}

public struct DeleteWorkspaceOutputResponse: Swift.Equatable {
    /// A structure containing information about the workspace that was deleted.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init (
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

struct DeleteWorkspaceOutputResponseBody: Swift.Equatable {
    let workspace: GrafanaClientTypes.WorkspaceDescription?
}

extension DeleteWorkspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspace
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceDescription.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

extension DescribeWorkspaceAuthenticationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/authentication"
    }
}

public struct DescribeWorkspaceAuthenticationInput: Swift.Equatable {
    /// The ID of the workspace to return authentication information about.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DescribeWorkspaceAuthenticationInputBody: Swift.Equatable {
}

extension DescribeWorkspaceAuthenticationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeWorkspaceAuthenticationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceAuthenticationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspaceAuthenticationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceAuthenticationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorkspaceAuthenticationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authentication = output.authentication
        } else {
            self.authentication = nil
        }
    }
}

public struct DescribeWorkspaceAuthenticationOutputResponse: Swift.Equatable {
    /// A structure containing information about the authentication methods used in the workspace.
    /// This member is required.
    public var authentication: GrafanaClientTypes.AuthenticationDescription?

    public init (
        authentication: GrafanaClientTypes.AuthenticationDescription? = nil
    )
    {
        self.authentication = authentication
    }
}

struct DescribeWorkspaceAuthenticationOutputResponseBody: Swift.Equatable {
    let authentication: GrafanaClientTypes.AuthenticationDescription?
}

extension DescribeWorkspaceAuthenticationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authentication
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AuthenticationDescription.self, forKey: .authentication)
        authentication = authenticationDecoded
    }
}

extension DescribeWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct DescribeWorkspaceInput: Swift.Equatable {
    /// The ID of the workspace to display information about.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DescribeWorkspaceInputBody: Swift.Equatable {
}

extension DescribeWorkspaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workspace = output.workspace
        } else {
            self.workspace = nil
        }
    }
}

public struct DescribeWorkspaceOutputResponse: Swift.Equatable {
    /// A structure containing information about the workspace.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init (
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

struct DescribeWorkspaceOutputResponseBody: Swift.Equatable {
    let workspace: GrafanaClientTypes.WorkspaceDescription?
}

extension DescribeWorkspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspace
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceDescription.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

extension DisassociateLicenseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let licenseType = licenseType else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/licenses/\(licenseType.rawValue.urlPercentEncoding())"
    }
}

public struct DisassociateLicenseInput: Swift.Equatable {
    /// The type of license to remove from the workspace.
    /// This member is required.
    public var licenseType: GrafanaClientTypes.LicenseType?
    /// The ID of the workspace to remove the Grafana Enterprise license from.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        licenseType: GrafanaClientTypes.LicenseType? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.licenseType = licenseType
        self.workspaceId = workspaceId
    }
}

struct DisassociateLicenseInputBody: Swift.Equatable {
}

extension DisassociateLicenseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateLicenseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateLicenseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateLicenseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateLicenseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateLicenseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workspace = output.workspace
        } else {
            self.workspace = nil
        }
    }
}

public struct DisassociateLicenseOutputResponse: Swift.Equatable {
    /// A structure containing information about the workspace.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init (
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

struct DisassociateLicenseOutputResponseBody: Swift.Equatable {
    let workspace: GrafanaClientTypes.WorkspaceDescription?
}

extension DisassociateLicenseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspace
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceDescription.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

extension GrafanaClientTypes.IdpMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case url
        case xml
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .url(url):
                try container.encode(url, forKey: .url)
            case let .xml(xml):
                try container.encode(xml, forKey: .xml)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .url)
        if let url = urlDecoded {
            self = .url(url)
            return
        }
        let xmlDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .xml)
        if let xml = xmlDecoded {
            self = .xml(xml)
            return
        }
        self = .sdkUnknown("")
    }
}

extension GrafanaClientTypes {
    /// A structure containing the identity provider (IdP) metadata used to integrate the identity provider with this workspace. You can specify the metadata either by providing a URL to its location in the url parameter, or by specifying the full metadata in XML format in the xml parameter.
    public enum IdpMetadata: Swift.Equatable, Swift.Hashable {
        /// The URL of the location containing the metadata.
        case url(Swift.String)
        /// The actual full metadata file, in XML format.
        case xml(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Unexpected error while processing the request. Retry the request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// A description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// How long to wait before you retry this operation.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GrafanaClientTypes {
    public enum LicenseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Grafana Enterprise License.
        case enterprise
        /// Grafana Enterprise Free Trial License.
        case enterpriseFreeTrial
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseType] {
            return [
                .enterprise,
                .enterpriseFreeTrial,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enterprise: return "ENTERPRISE"
            case .enterpriseFreeTrial: return "ENTERPRISE_FREE_TRIAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LicenseType(rawValue: rawValue) ?? LicenseType.sdkUnknown(rawValue)
        }
    }
}

extension ListPermissionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let groupId = groupId {
            let groupIdQueryItem = ClientRuntime.URLQueryItem(name: "groupId".urlPercentEncoding(), value: Swift.String(groupId).urlPercentEncoding())
            items.append(groupIdQueryItem)
        }
        if let userType = userType {
            let userTypeQueryItem = ClientRuntime.URLQueryItem(name: "userType".urlPercentEncoding(), value: Swift.String(userType.rawValue).urlPercentEncoding())
            items.append(userTypeQueryItem)
        }
        if let userId = userId {
            let userIdQueryItem = ClientRuntime.URLQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
        }
        return items
    }
}

extension ListPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/permissions"
    }
}

public struct ListPermissionsInput: Swift.Equatable {
    /// (Optional) Limits the results to only the group that matches this ID.
    public var groupId: Swift.String?
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListPermissions operation.
    public var nextToken: Swift.String?
    /// (Optional) Limits the results to only the user that matches this ID.
    public var userId: Swift.String?
    /// (Optional) If you specify SSO_USER, then only the permissions of Amazon Web Services SSO users are returned. If you specify SSO_GROUP, only the permissions of Amazon Web Services SSO groups are returned.
    public var userType: GrafanaClientTypes.UserType?
    /// The ID of the workspace to list permissions for. This parameter is required.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userId: Swift.String? = nil,
        userType: GrafanaClientTypes.UserType? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userId = userId
        self.userType = userType
        self.workspaceId = workspaceId
    }
}

struct ListPermissionsInputBody: Swift.Equatable {
}

extension ListPermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListPermissionsOutputResponse: Swift.Equatable {
    /// The token to use in a subsequent ListPermissions operation to return the next set of results.
    public var nextToken: Swift.String?
    /// The permissions returned by the operation.
    /// This member is required.
    public var permissions: [GrafanaClientTypes.PermissionEntry]?

    public init (
        nextToken: Swift.String? = nil,
        permissions: [GrafanaClientTypes.PermissionEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListPermissionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let permissions: [GrafanaClientTypes.PermissionEntry]?
}

extension ListPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.PermissionEntry?].self, forKey: .permissions)
        var permissionsDecoded0:[GrafanaClientTypes.PermissionEntry]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [GrafanaClientTypes.PermissionEntry]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

extension ListWorkspacesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workspaces"
    }
}

public struct ListWorkspacesInput: Swift.Equatable {
    /// The maximum number of workspaces to include in the results.
    public var maxResults: Swift.Int?
    /// The token for the next set of workspaces to return. (You receive this token from a previous ListWorkspaces operation.)
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkspacesInputBody: Swift.Equatable {
}

extension ListWorkspacesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workspaces = output.workspaces
        } else {
            self.nextToken = nil
            self.workspaces = nil
        }
    }
}

public struct ListWorkspacesOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of workspaces.
    public var nextToken: Swift.String?
    /// An array of structures that contain some information about the workspaces in the account.
    /// This member is required.
    public var workspaces: [GrafanaClientTypes.WorkspaceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        workspaces: [GrafanaClientTypes.WorkspaceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaces = workspaces
    }
}

struct ListWorkspacesOutputResponseBody: Swift.Equatable {
    let workspaces: [GrafanaClientTypes.WorkspaceSummary]?
    let nextToken: Swift.String?
}

extension ListWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workspaces
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.WorkspaceSummary?].self, forKey: .workspaces)
        var workspacesDecoded0:[GrafanaClientTypes.WorkspaceSummary]? = nil
        if let workspacesContainer = workspacesContainer {
            workspacesDecoded0 = [GrafanaClientTypes.WorkspaceSummary]()
            for structure0 in workspacesContainer {
                if let structure0 = structure0 {
                    workspacesDecoded0?.append(structure0)
                }
            }
        }
        workspaces = workspacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GrafanaClientTypes {
    public enum NotificationDestinationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// AWS Simple Notification Service
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationDestinationType] {
            return [
                .sns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationDestinationType(rawValue: rawValue) ?? NotificationDestinationType.sdkUnknown(rawValue)
        }
    }
}

extension GrafanaClientTypes.PermissionEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role
        case user
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let user = user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.User.self, forKey: .user)
        user = userDecoded
        let roleDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.Role.self, forKey: .role)
        role = roleDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure containing the identity of one user or group and the Admin or Editor role that they have.
    public struct PermissionEntry: Swift.Equatable {
        /// Specifies whether the user or group has the Admin or Editor role.
        /// This member is required.
        public var role: GrafanaClientTypes.Role?
        /// A structure with the ID of the user or group with this role.
        /// This member is required.
        public var user: GrafanaClientTypes.User?

        public init (
            role: GrafanaClientTypes.Role? = nil,
            user: GrafanaClientTypes.User? = nil
        )
        {
            self.role = role
            self.user = user
        }
    }

}

extension GrafanaClientTypes {
    public enum PermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Customer Managed
        case customerManaged
        /// Service Managed
        case serviceManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionType] {
            return [
                .customerManaged,
                .serviceManaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customerManaged: return "CUSTOMER_MANAGED"
            case .serviceManaged: return "SERVICE_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionType(rawValue: rawValue) ?? PermissionType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The value of a parameter in the request caused an error.
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource that is associated with the error.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the resource that is associated with the error.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension GrafanaClientTypes {
    public enum Role: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Role Admin.
        case admin
        /// Role Editor.
        case editor
        case sdkUnknown(Swift.String)

        public static var allCases: [Role] {
            return [
                .admin,
                .editor,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .admin: return "ADMIN"
            case .editor: return "EDITOR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Role(rawValue: rawValue) ?? Role.sdkUnknown(rawValue)
        }
    }
}

extension GrafanaClientTypes.RoleValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case admin
        case editor
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let admin = admin {
            var adminContainer = encodeContainer.nestedUnkeyedContainer(forKey: .admin)
            for rolevaluelist0 in admin {
                try adminContainer.encode(rolevaluelist0)
            }
        }
        if let editor = editor {
            var editorContainer = encodeContainer.nestedUnkeyedContainer(forKey: .editor)
            for rolevaluelist0 in editor {
                try editorContainer.encode(rolevaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let editorContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .editor)
        var editorDecoded0:[Swift.String]? = nil
        if let editorContainer = editorContainer {
            editorDecoded0 = [Swift.String]()
            for string0 in editorContainer {
                if let string0 = string0 {
                    editorDecoded0?.append(string0)
                }
            }
        }
        editor = editorDecoded0
        let adminContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .admin)
        var adminDecoded0:[Swift.String]? = nil
        if let adminContainer = adminContainer {
            adminDecoded0 = [Swift.String]()
            for string0 in adminContainer {
                if let string0 = string0 {
                    adminDecoded0?.append(string0)
                }
            }
        }
        admin = adminDecoded0
    }
}

extension GrafanaClientTypes {
    /// This structure defines which groups defined in the SAML assertion attribute are to be mapped to the Grafana Admin and Editor roles in the workspace.
    public struct RoleValues: Swift.Equatable {
        /// A list of groups from the SAML assertion attribute to grant the Grafana Admin role to.
        public var admin: [Swift.String]?
        /// A list of groups from the SAML assertion attribute to grant the Grafana Editor role to.
        public var editor: [Swift.String]?

        public init (
            admin: [Swift.String]? = nil,
            editor: [Swift.String]? = nil
        )
        {
            self.admin = admin
            self.editor = editor
        }
    }

}

extension GrafanaClientTypes.SamlAuthentication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.SamlConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.SamlConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure containing information about how this workspace works with SAML.
    public struct SamlAuthentication: Swift.Equatable {
        /// A structure containing details about how this workspace works with SAML.
        public var configuration: GrafanaClientTypes.SamlConfiguration?
        /// Specifies whether the workspace's SAML configuration is complete.
        /// This member is required.
        public var status: GrafanaClientTypes.SamlConfigurationStatus?

        public init (
            configuration: GrafanaClientTypes.SamlConfiguration? = nil,
            status: GrafanaClientTypes.SamlConfigurationStatus? = nil
        )
        {
            self.configuration = configuration
            self.status = status
        }
    }

}

extension GrafanaClientTypes.SamlConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedOrganizations
        case assertionAttributes
        case idpMetadata
        case loginValidityDuration
        case roleValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedOrganizations = allowedOrganizations {
            var allowedOrganizationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOrganizations)
            for allowedorganizations0 in allowedOrganizations {
                try allowedOrganizationsContainer.encode(allowedorganizations0)
            }
        }
        if let assertionAttributes = assertionAttributes {
            try encodeContainer.encode(assertionAttributes, forKey: .assertionAttributes)
        }
        if let idpMetadata = idpMetadata {
            try encodeContainer.encode(idpMetadata, forKey: .idpMetadata)
        }
        if loginValidityDuration != 0 {
            try encodeContainer.encode(loginValidityDuration, forKey: .loginValidityDuration)
        }
        if let roleValues = roleValues {
            try encodeContainer.encode(roleValues, forKey: .roleValues)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idpMetadataDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.IdpMetadata.self, forKey: .idpMetadata)
        idpMetadata = idpMetadataDecoded
        let assertionAttributesDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AssertionAttributes.self, forKey: .assertionAttributes)
        assertionAttributes = assertionAttributesDecoded
        let roleValuesDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.RoleValues.self, forKey: .roleValues)
        roleValues = roleValuesDecoded
        let allowedOrganizationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedOrganizations)
        var allowedOrganizationsDecoded0:[Swift.String]? = nil
        if let allowedOrganizationsContainer = allowedOrganizationsContainer {
            allowedOrganizationsDecoded0 = [Swift.String]()
            for string0 in allowedOrganizationsContainer {
                if let string0 = string0 {
                    allowedOrganizationsDecoded0?.append(string0)
                }
            }
        }
        allowedOrganizations = allowedOrganizationsDecoded0
        let loginValidityDurationDecoded = try containerValues.decode(Swift.Int.self, forKey: .loginValidityDuration)
        loginValidityDuration = loginValidityDurationDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure containing information about how this workspace works with SAML.
    public struct SamlConfiguration: Swift.Equatable {
        /// Lists which organizations defined in the SAML assertion are allowed to use the Amazon Managed Grafana workspace. If this is empty, all organizations in the assertion attribute have access.
        public var allowedOrganizations: [Swift.String]?
        /// A structure that defines which attributes in the SAML assertion are to be used to define information about the users authenticated by that IdP to use the workspace.
        public var assertionAttributes: GrafanaClientTypes.AssertionAttributes?
        /// A structure containing the identity provider (IdP) metadata used to integrate the identity provider with this workspace.
        /// This member is required.
        public var idpMetadata: GrafanaClientTypes.IdpMetadata?
        /// How long a sign-on session by a SAML user is valid, before the user has to sign on again.
        public var loginValidityDuration: Swift.Int
        /// A structure containing arrays that map group names in the SAML assertion to the Grafana Admin and Editor roles in the workspace.
        public var roleValues: GrafanaClientTypes.RoleValues?

        public init (
            allowedOrganizations: [Swift.String]? = nil,
            assertionAttributes: GrafanaClientTypes.AssertionAttributes? = nil,
            idpMetadata: GrafanaClientTypes.IdpMetadata? = nil,
            loginValidityDuration: Swift.Int = 0,
            roleValues: GrafanaClientTypes.RoleValues? = nil
        )
        {
            self.allowedOrganizations = allowedOrganizations
            self.assertionAttributes = assertionAttributes
            self.idpMetadata = idpMetadata
            self.loginValidityDuration = loginValidityDuration
            self.roleValues = roleValues
        }
    }

}

extension GrafanaClientTypes {
    public enum SamlConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates that SAML on an AMG workspace is enabled and has been configured.
        case configured
        /// Indicates that SAML on an AMG workspace is enabled but has not been configured.
        case notConfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [SamlConfigurationStatus] {
            return [
                .configured,
                .notConfigured,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configured: return "CONFIGURED"
            case .notConfigured: return "NOT_CONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SamlConfigurationStatus(rawValue: rawValue) ?? SamlConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the service quota that was exceeded.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// The ID of the resource that is associated with the error.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the resource that is associated with the error.
    /// This member is required.
    public var resourceType: Swift.String?
    /// The value of a parameter in the request caused an error.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied because of request throttling. Retry the request.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the service quota that was exceeded.
    public var quotaCode: Swift.String?
    /// The value of a parameter in the request caused an error.
    public var retryAfterSeconds: Swift.Int?
    /// The ID of the service that is associated with the error.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension GrafanaClientTypes {
    public enum UpdateAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Add permissions.
        case add
        /// Revoke permissions.
        case revoke
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateAction] {
            return [
                .add,
                .revoke,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .revoke: return "REVOKE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateAction(rawValue: rawValue) ?? UpdateAction.sdkUnknown(rawValue)
        }
    }
}

extension GrafanaClientTypes.UpdateError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case causedBy
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let causedBy = causedBy {
            try encodeContainer.encode(causedBy, forKey: .causedBy)
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let causedByDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.UpdateInstruction.self, forKey: .causedBy)
        causedBy = causedByDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure containing information about one error encountered while performing an [UpdatePermissions](https://docs.aws.amazon.com/grafana/latest/APIReference/API_UpdatePermissions.html) operation.
    public struct UpdateError: Swift.Equatable {
        /// Specifies which permission update caused the error.
        /// This member is required.
        public var causedBy: GrafanaClientTypes.UpdateInstruction?
        /// The error code.
        /// This member is required.
        public var code: Swift.Int?
        /// The message for this error.
        /// This member is required.
        public var message: Swift.String?

        public init (
            causedBy: GrafanaClientTypes.UpdateInstruction? = nil,
            code: Swift.Int? = nil,
            message: Swift.String? = nil
        )
        {
            self.causedBy = causedBy
            self.code = code
            self.message = message
        }
    }

}

extension GrafanaClientTypes.UpdateInstruction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case role
        case users
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for userlist0 in users {
                try usersContainer.encode(userlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.UpdateAction.self, forKey: .action)
        action = actionDecoded
        let roleDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.Role.self, forKey: .role)
        role = roleDecoded
        let usersContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[GrafanaClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [GrafanaClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension GrafanaClientTypes {
    /// Contains the instructions for one Grafana role permission update in a [UpdatePermissions](https://docs.aws.amazon.com/grafana/latest/APIReference/API_UpdatePermissions.html) operation.
    public struct UpdateInstruction: Swift.Equatable {
        /// Specifies whether this update is to add or revoke role permissions.
        /// This member is required.
        public var action: GrafanaClientTypes.UpdateAction?
        /// The role to add or revoke for the user or the group specified in users.
        /// This member is required.
        public var role: GrafanaClientTypes.Role?
        /// A structure that specifies the user or group to add or revoke the role for.
        /// This member is required.
        public var users: [GrafanaClientTypes.User]?

        public init (
            action: GrafanaClientTypes.UpdateAction? = nil,
            role: GrafanaClientTypes.Role? = nil,
            users: [GrafanaClientTypes.User]? = nil
        )
        {
            self.action = action
            self.role = role
            self.users = users
        }
    }

}

extension UpdatePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateInstructionBatch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updateInstructionBatch = updateInstructionBatch {
            var updateInstructionBatchContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updateInstructionBatch)
            for updateinstructionbatch0 in updateInstructionBatch {
                try updateInstructionBatchContainer.encode(updateinstructionbatch0)
            }
        }
    }
}

extension UpdatePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/permissions"
    }
}

public struct UpdatePermissionsInput: Swift.Equatable {
    /// An array of structures that contain the permission updates to make.
    /// This member is required.
    public var updateInstructionBatch: [GrafanaClientTypes.UpdateInstruction]?
    /// The ID of the workspace to update.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        updateInstructionBatch: [GrafanaClientTypes.UpdateInstruction]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.updateInstructionBatch = updateInstructionBatch
        self.workspaceId = workspaceId
    }
}

struct UpdatePermissionsInputBody: Swift.Equatable {
    let updateInstructionBatch: [GrafanaClientTypes.UpdateInstruction]?
}

extension UpdatePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateInstructionBatch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateInstructionBatchContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.UpdateInstruction?].self, forKey: .updateInstructionBatch)
        var updateInstructionBatchDecoded0:[GrafanaClientTypes.UpdateInstruction]? = nil
        if let updateInstructionBatchContainer = updateInstructionBatchContainer {
            updateInstructionBatchDecoded0 = [GrafanaClientTypes.UpdateInstruction]()
            for structure0 in updateInstructionBatchContainer {
                if let structure0 = structure0 {
                    updateInstructionBatchDecoded0?.append(structure0)
                }
            }
        }
        updateInstructionBatch = updateInstructionBatchDecoded0
    }
}

extension UpdatePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct UpdatePermissionsOutputResponse: Swift.Equatable {
    /// An array of structures that contain the errors from the operation, if any.
    /// This member is required.
    public var errors: [GrafanaClientTypes.UpdateError]?

    public init (
        errors: [GrafanaClientTypes.UpdateError]? = nil
    )
    {
        self.errors = errors
    }
}

struct UpdatePermissionsOutputResponseBody: Swift.Equatable {
    let errors: [GrafanaClientTypes.UpdateError]?
}

extension UpdatePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.UpdateError?].self, forKey: .errors)
        var errorsDecoded0:[GrafanaClientTypes.UpdateError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [GrafanaClientTypes.UpdateError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension UpdateWorkspaceAuthenticationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationProviders
        case samlConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationProviders = authenticationProviders {
            var authenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authenticationProviders)
            for authenticationproviders0 in authenticationProviders {
                try authenticationProvidersContainer.encode(authenticationproviders0.rawValue)
            }
        }
        if let samlConfiguration = samlConfiguration {
            try encodeContainer.encode(samlConfiguration, forKey: .samlConfiguration)
        }
    }
}

extension UpdateWorkspaceAuthenticationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/authentication"
    }
}

public struct UpdateWorkspaceAuthenticationInput: Swift.Equatable {
    /// Specifies whether this workspace uses SAML 2.0, Amazon Web Services Single Sign On, or both to authenticate users for using the Grafana console within a workspace. For more information, see [User authentication in Amazon Managed Grafana](https://docs.aws.amazon.com/grafana/latest/userguide/authentication-in-AMG.html).
    /// This member is required.
    public var authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]?
    /// If the workspace uses SAML, use this structure to map SAML assertion attributes to workspace user information and define which groups in the assertion attribute are to have the Admin and Editor roles in the workspace.
    public var samlConfiguration: GrafanaClientTypes.SamlConfiguration?
    /// The ID of the workspace to update the authentication for.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]? = nil,
        samlConfiguration: GrafanaClientTypes.SamlConfiguration? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.authenticationProviders = authenticationProviders
        self.samlConfiguration = samlConfiguration
        self.workspaceId = workspaceId
    }
}

struct UpdateWorkspaceAuthenticationInputBody: Swift.Equatable {
    let authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]?
    let samlConfiguration: GrafanaClientTypes.SamlConfiguration?
}

extension UpdateWorkspaceAuthenticationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationProviders
        case samlConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationProvidersContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.AuthenticationProviderTypes?].self, forKey: .authenticationProviders)
        var authenticationProvidersDecoded0:[GrafanaClientTypes.AuthenticationProviderTypes]? = nil
        if let authenticationProvidersContainer = authenticationProvidersContainer {
            authenticationProvidersDecoded0 = [GrafanaClientTypes.AuthenticationProviderTypes]()
            for string0 in authenticationProvidersContainer {
                if let string0 = string0 {
                    authenticationProvidersDecoded0?.append(string0)
                }
            }
        }
        authenticationProviders = authenticationProvidersDecoded0
        let samlConfigurationDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.SamlConfiguration.self, forKey: .samlConfiguration)
        samlConfiguration = samlConfigurationDecoded
    }
}

extension UpdateWorkspaceAuthenticationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkspaceAuthenticationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkspaceAuthenticationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkspaceAuthenticationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateWorkspaceAuthenticationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authentication = output.authentication
        } else {
            self.authentication = nil
        }
    }
}

public struct UpdateWorkspaceAuthenticationOutputResponse: Swift.Equatable {
    /// A structure that describes the user authentication for this workspace after the update is made.
    /// This member is required.
    public var authentication: GrafanaClientTypes.AuthenticationDescription?

    public init (
        authentication: GrafanaClientTypes.AuthenticationDescription? = nil
    )
    {
        self.authentication = authentication
    }
}

struct UpdateWorkspaceAuthenticationOutputResponseBody: Swift.Equatable {
    let authentication: GrafanaClientTypes.AuthenticationDescription?
}

extension UpdateWorkspaceAuthenticationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authentication
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AuthenticationDescription.self, forKey: .authentication)
        authentication = authenticationDecoded
    }
}

extension UpdateWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAccessType
        case organizationRoleName
        case permissionType
        case stackSetName
        case workspaceDataSources
        case workspaceDescription
        case workspaceName
        case workspaceNotificationDestinations
        case workspaceOrganizationalUnits
        case workspaceRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAccessType = accountAccessType {
            try encodeContainer.encode(accountAccessType.rawValue, forKey: .accountAccessType)
        }
        if let organizationRoleName = organizationRoleName {
            try encodeContainer.encode(organizationRoleName, forKey: .organizationRoleName)
        }
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let stackSetName = stackSetName {
            try encodeContainer.encode(stackSetName, forKey: .stackSetName)
        }
        if let workspaceDataSources = workspaceDataSources {
            var workspaceDataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceDataSources)
            for datasourcetypeslist0 in workspaceDataSources {
                try workspaceDataSourcesContainer.encode(datasourcetypeslist0.rawValue)
            }
        }
        if let workspaceDescription = workspaceDescription {
            try encodeContainer.encode(workspaceDescription, forKey: .workspaceDescription)
        }
        if let workspaceName = workspaceName {
            try encodeContainer.encode(workspaceName, forKey: .workspaceName)
        }
        if let workspaceNotificationDestinations = workspaceNotificationDestinations {
            var workspaceNotificationDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceNotificationDestinations)
            for notificationdestinationslist0 in workspaceNotificationDestinations {
                try workspaceNotificationDestinationsContainer.encode(notificationdestinationslist0.rawValue)
            }
        }
        if let workspaceOrganizationalUnits = workspaceOrganizationalUnits {
            var workspaceOrganizationalUnitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceOrganizationalUnits)
            for organizationalunitlist0 in workspaceOrganizationalUnits {
                try workspaceOrganizationalUnitsContainer.encode(organizationalunitlist0)
            }
        }
        if let workspaceRoleArn = workspaceRoleArn {
            try encodeContainer.encode(workspaceRoleArn, forKey: .workspaceRoleArn)
        }
    }
}

extension UpdateWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct UpdateWorkspaceInput: Swift.Equatable {
    /// Specifies whether the workspace can access Amazon Web Services resources in this Amazon Web Services account only, or whether it can also access Amazon Web Services resources in other accounts in the same organization. If you specify ORGANIZATION, you must specify which organizational units the workspace can access in the workspaceOrganizationalUnits parameter.
    public var accountAccessType: GrafanaClientTypes.AccountAccessType?
    /// The name of an IAM role that already exists to use to access resources through Organizations.
    public var organizationRoleName: Swift.String?
    /// If you specify Service Managed, Amazon Managed Grafana automatically creates the IAM roles and provisions the permissions that the workspace needs to use Amazon Web Services data sources and notification channels. If you specify CUSTOMER_MANAGED, you will manage those roles and permissions yourself. If you are creating this workspace in a member account of an organization and that account is not a delegated administrator account, and you want the workspace to access data sources in other Amazon Web Services accounts in the organization, you must choose CUSTOMER_MANAGED. For more information, see [Amazon Managed Grafana permissions and policies for Amazon Web Services data sources and notification channels](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-manage-permissions.html)
    public var permissionType: GrafanaClientTypes.PermissionType?
    /// The name of the CloudFormation stack set to use to generate IAM roles to be used for this workspace.
    public var stackSetName: Swift.String?
    /// Specify the Amazon Web Services data sources that you want to be queried in this workspace. Specifying these data sources here enables Amazon Managed Grafana to create IAM roles and permissions that allow Amazon Managed Grafana to read data from these sources. You must still add them as data sources in the Grafana console in the workspace. If you don't specify a data source here, you can still add it as a data source later in the workspace console. However, you will then have to manually configure permissions for it.
    public var workspaceDataSources: [GrafanaClientTypes.DataSourceType]?
    /// A description for the workspace. This is used only to help you identify this workspace.
    public var workspaceDescription: Swift.String?
    /// The ID of the workspace to update.
    /// This member is required.
    public var workspaceId: Swift.String?
    /// A new name for the workspace to update.
    public var workspaceName: Swift.String?
    /// Specify the Amazon Web Services notification channels that you plan to use in this workspace. Specifying these data sources here enables Amazon Managed Grafana to create IAM roles and permissions that allow Amazon Managed Grafana to use these channels.
    public var workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
    /// Specifies the organizational units that this workspace is allowed to use data sources from, if this workspace is in an account that is part of an organization.
    public var workspaceOrganizationalUnits: [Swift.String]?
    /// The workspace needs an IAM role that grants permissions to the Amazon Web Services resources that the workspace will view data from. If you already have a role that you want to use, specify it here. If you omit this field and you specify some Amazon Web Services resources in workspaceDataSources or workspaceNotificationDestinations, a new IAM role with the necessary permissions is automatically created.
    public var workspaceRoleArn: Swift.String?

    public init (
        accountAccessType: GrafanaClientTypes.AccountAccessType? = nil,
        organizationRoleName: Swift.String? = nil,
        permissionType: GrafanaClientTypes.PermissionType? = nil,
        stackSetName: Swift.String? = nil,
        workspaceDataSources: [GrafanaClientTypes.DataSourceType]? = nil,
        workspaceDescription: Swift.String? = nil,
        workspaceId: Swift.String? = nil,
        workspaceName: Swift.String? = nil,
        workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]? = nil,
        workspaceOrganizationalUnits: [Swift.String]? = nil,
        workspaceRoleArn: Swift.String? = nil
    )
    {
        self.accountAccessType = accountAccessType
        self.organizationRoleName = organizationRoleName
        self.permissionType = permissionType
        self.stackSetName = stackSetName
        self.workspaceDataSources = workspaceDataSources
        self.workspaceDescription = workspaceDescription
        self.workspaceId = workspaceId
        self.workspaceName = workspaceName
        self.workspaceNotificationDestinations = workspaceNotificationDestinations
        self.workspaceOrganizationalUnits = workspaceOrganizationalUnits
        self.workspaceRoleArn = workspaceRoleArn
    }
}

struct UpdateWorkspaceInputBody: Swift.Equatable {
    let accountAccessType: GrafanaClientTypes.AccountAccessType?
    let organizationRoleName: Swift.String?
    let permissionType: GrafanaClientTypes.PermissionType?
    let stackSetName: Swift.String?
    let workspaceDataSources: [GrafanaClientTypes.DataSourceType]?
    let workspaceDescription: Swift.String?
    let workspaceName: Swift.String?
    let workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
    let workspaceOrganizationalUnits: [Swift.String]?
    let workspaceRoleArn: Swift.String?
}

extension UpdateWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAccessType
        case organizationRoleName
        case permissionType
        case stackSetName
        case workspaceDataSources
        case workspaceDescription
        case workspaceName
        case workspaceNotificationDestinations
        case workspaceOrganizationalUnits
        case workspaceRoleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAccessTypeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AccountAccessType.self, forKey: .accountAccessType)
        accountAccessType = accountAccessTypeDecoded
        let organizationRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationRoleName)
        organizationRoleName = organizationRoleNameDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let stackSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackSetName)
        stackSetName = stackSetNameDecoded
        let workspaceDataSourcesContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.DataSourceType?].self, forKey: .workspaceDataSources)
        var workspaceDataSourcesDecoded0:[GrafanaClientTypes.DataSourceType]? = nil
        if let workspaceDataSourcesContainer = workspaceDataSourcesContainer {
            workspaceDataSourcesDecoded0 = [GrafanaClientTypes.DataSourceType]()
            for string0 in workspaceDataSourcesContainer {
                if let string0 = string0 {
                    workspaceDataSourcesDecoded0?.append(string0)
                }
            }
        }
        workspaceDataSources = workspaceDataSourcesDecoded0
        let workspaceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceDescription)
        workspaceDescription = workspaceDescriptionDecoded
        let workspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceName)
        workspaceName = workspaceNameDecoded
        let workspaceNotificationDestinationsContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.NotificationDestinationType?].self, forKey: .workspaceNotificationDestinations)
        var workspaceNotificationDestinationsDecoded0:[GrafanaClientTypes.NotificationDestinationType]? = nil
        if let workspaceNotificationDestinationsContainer = workspaceNotificationDestinationsContainer {
            workspaceNotificationDestinationsDecoded0 = [GrafanaClientTypes.NotificationDestinationType]()
            for string0 in workspaceNotificationDestinationsContainer {
                if let string0 = string0 {
                    workspaceNotificationDestinationsDecoded0?.append(string0)
                }
            }
        }
        workspaceNotificationDestinations = workspaceNotificationDestinationsDecoded0
        let workspaceOrganizationalUnitsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .workspaceOrganizationalUnits)
        var workspaceOrganizationalUnitsDecoded0:[Swift.String]? = nil
        if let workspaceOrganizationalUnitsContainer = workspaceOrganizationalUnitsContainer {
            workspaceOrganizationalUnitsDecoded0 = [Swift.String]()
            for string0 in workspaceOrganizationalUnitsContainer {
                if let string0 = string0 {
                    workspaceOrganizationalUnitsDecoded0?.append(string0)
                }
            }
        }
        workspaceOrganizationalUnits = workspaceOrganizationalUnitsDecoded0
        let workspaceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceRoleArn)
        workspaceRoleArn = workspaceRoleArnDecoded
    }
}

extension UpdateWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workspace = output.workspace
        } else {
            self.workspace = nil
        }
    }
}

public struct UpdateWorkspaceOutputResponse: Swift.Equatable {
    /// A structure containing data about the workspace that was created.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init (
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

struct UpdateWorkspaceOutputResponseBody: Swift.Equatable {
    let workspace: GrafanaClientTypes.WorkspaceDescription?
}

extension UpdateWorkspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspace
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceDescription.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

extension GrafanaClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure that specifies one user or group in the workspace.
    public struct User: Swift.Equatable {
        /// The ID of the user or group.
        /// This member is required.
        public var id: Swift.String?
        /// Specifies whether this is a single user or a group.
        /// This member is required.
        public var type: GrafanaClientTypes.UserType?

        public init (
            id: Swift.String? = nil,
            type: GrafanaClientTypes.UserType? = nil
        )
        {
            self.id = id
            self.type = type
        }
    }

}

extension GrafanaClientTypes {
    public enum UserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// SSO group.
        case ssoGroup
        /// SSO user.
        case ssoUser
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .ssoGroup,
                .ssoUser,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssoGroup: return "SSO_GROUP"
            case .ssoUser: return "SSO_USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserType(rawValue: rawValue) ?? UserType.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value of a parameter in the request caused an error.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A list of fields that might be associated with the error.
    public var fieldList: [GrafanaClientTypes.ValidationExceptionField]?
    /// A description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// The reason that the operation failed.
    /// This member is required.
    public var reason: GrafanaClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [GrafanaClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: GrafanaClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: GrafanaClientTypes.ValidationExceptionReason?
    let fieldList: [GrafanaClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[GrafanaClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [GrafanaClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension GrafanaClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure that contains information about a request parameter that caused an error.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message describing why this field couldn't be validated.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that caused the validation error.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension GrafanaClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension GrafanaClientTypes.WorkspaceDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAccessType
        case authentication
        case created
        case dataSources
        case description
        case endpoint
        case freeTrialConsumed
        case freeTrialExpiration
        case grafanaVersion
        case id
        case licenseExpiration
        case licenseType
        case modified
        case name
        case notificationDestinations
        case organizationRoleName
        case organizationalUnits
        case permissionType
        case stackSetName
        case status
        case workspaceRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAccessType = accountAccessType {
            try encodeContainer.encode(accountAccessType.rawValue, forKey: .accountAccessType)
        }
        if let authentication = authentication {
            try encodeContainer.encode(authentication, forKey: .authentication)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasourcetypeslist0 in dataSources {
                try dataSourcesContainer.encode(datasourcetypeslist0.rawValue)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let freeTrialConsumed = freeTrialConsumed {
            try encodeContainer.encode(freeTrialConsumed, forKey: .freeTrialConsumed)
        }
        if let freeTrialExpiration = freeTrialExpiration {
            try encodeContainer.encode(freeTrialExpiration.timeIntervalSince1970, forKey: .freeTrialExpiration)
        }
        if let grafanaVersion = grafanaVersion {
            try encodeContainer.encode(grafanaVersion, forKey: .grafanaVersion)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let licenseExpiration = licenseExpiration {
            try encodeContainer.encode(licenseExpiration.timeIntervalSince1970, forKey: .licenseExpiration)
        }
        if let licenseType = licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let modified = modified {
            try encodeContainer.encode(modified.timeIntervalSince1970, forKey: .modified)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notificationDestinations = notificationDestinations {
            var notificationDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationDestinations)
            for notificationdestinationslist0 in notificationDestinations {
                try notificationDestinationsContainer.encode(notificationdestinationslist0.rawValue)
            }
        }
        if let organizationRoleName = organizationRoleName {
            try encodeContainer.encode(organizationRoleName, forKey: .organizationRoleName)
        }
        if let organizationalUnits = organizationalUnits {
            var organizationalUnitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnits)
            for organizationalunitlist0 in organizationalUnits {
                try organizationalUnitsContainer.encode(organizationalunitlist0)
            }
        }
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let stackSetName = stackSetName {
            try encodeContainer.encode(stackSetName, forKey: .stackSetName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workspaceRoleArn = workspaceRoleArn {
            try encodeContainer.encode(workspaceRoleArn, forKey: .workspaceRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAccessTypeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AccountAccessType.self, forKey: .accountAccessType)
        accountAccessType = accountAccessTypeDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let dataSourcesContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.DataSourceType?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[GrafanaClientTypes.DataSourceType]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [GrafanaClientTypes.DataSourceType]()
            for string0 in dataSourcesContainer {
                if let string0 = string0 {
                    dataSourcesDecoded0?.append(string0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let grafanaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grafanaVersion)
        grafanaVersion = grafanaVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let modifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modified)
        modified = modifiedDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let organizationRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationRoleName)
        organizationRoleName = organizationRoleNameDecoded
        let notificationDestinationsContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.NotificationDestinationType?].self, forKey: .notificationDestinations)
        var notificationDestinationsDecoded0:[GrafanaClientTypes.NotificationDestinationType]? = nil
        if let notificationDestinationsContainer = notificationDestinationsContainer {
            notificationDestinationsDecoded0 = [GrafanaClientTypes.NotificationDestinationType]()
            for string0 in notificationDestinationsContainer {
                if let string0 = string0 {
                    notificationDestinationsDecoded0?.append(string0)
                }
            }
        }
        notificationDestinations = notificationDestinationsDecoded0
        let organizationalUnitsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnits)
        var organizationalUnitsDecoded0:[Swift.String]? = nil
        if let organizationalUnitsContainer = organizationalUnitsContainer {
            organizationalUnitsDecoded0 = [Swift.String]()
            for string0 in organizationalUnitsContainer {
                if let string0 = string0 {
                    organizationalUnitsDecoded0?.append(string0)
                }
            }
        }
        organizationalUnits = organizationalUnitsDecoded0
        let permissionTypeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let stackSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackSetName)
        stackSetName = stackSetNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceStatus.self, forKey: .status)
        status = statusDecoded
        let workspaceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceRoleArn)
        workspaceRoleArn = workspaceRoleArnDecoded
        let licenseTypeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.LicenseType.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let freeTrialConsumedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .freeTrialConsumed)
        freeTrialConsumed = freeTrialConsumedDecoded
        let licenseExpirationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .licenseExpiration)
        licenseExpiration = licenseExpirationDecoded
        let freeTrialExpirationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .freeTrialExpiration)
        freeTrialExpiration = freeTrialExpirationDecoded
        let authenticationDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AuthenticationSummary.self, forKey: .authentication)
        authentication = authenticationDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure containing information about an Amazon Managed Grafana workspace in your account.
    public struct WorkspaceDescription: Swift.Equatable {
        /// Specifies whether the workspace can access Amazon Web Services resources in this Amazon Web Services account only, or whether it can also access Amazon Web Services resources in other accounts in the same organization. If this is ORGANIZATION, the workspaceOrganizationalUnits parameter specifies which organizational units the workspace can access.
        public var accountAccessType: GrafanaClientTypes.AccountAccessType?
        /// A structure that describes whether the workspace uses SAML, Amazon Web Services SSO, or both methods for user authentication.
        /// This member is required.
        public var authentication: GrafanaClientTypes.AuthenticationSummary?
        /// The date that the workspace was created.
        /// This member is required.
        public var created: ClientRuntime.Date?
        /// Specifies the Amazon Web Services data sources that have been configured to have IAM roles and permissions created to allow Amazon Managed Grafana to read data from these sources.
        /// This member is required.
        public var dataSources: [GrafanaClientTypes.DataSourceType]?
        /// The user-defined description of the workspace.
        public var description: Swift.String?
        /// The URL that users can use to access the Grafana console in the workspace.
        /// This member is required.
        public var endpoint: Swift.String?
        /// Specifies whether this workspace has already fully used its free trial for Grafana Enterprise.
        public var freeTrialConsumed: Swift.Bool?
        /// If this workspace is currently in the free trial period for Grafana Enterprise, this value specifies when that free trial ends.
        public var freeTrialExpiration: ClientRuntime.Date?
        /// The version of Grafana supported in this workspace.
        /// This member is required.
        public var grafanaVersion: Swift.String?
        /// The unique ID of this workspace.
        /// This member is required.
        public var id: Swift.String?
        /// If this workspace has a full Grafana Enterprise license, this specifies when the license ends and will need to be renewed.
        public var licenseExpiration: ClientRuntime.Date?
        /// Specifies whether this workspace has a full Grafana Enterprise license or a free trial license.
        public var licenseType: GrafanaClientTypes.LicenseType?
        /// The most recent date that the workspace was modified.
        /// This member is required.
        public var modified: ClientRuntime.Date?
        /// The name of the workspace.
        public var name: Swift.String?
        /// The Amazon Web Services notification channels that Amazon Managed Grafana can automatically create IAM roles and permissions for, to allow Amazon Managed Grafana to use these channels.
        public var notificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
        /// The name of the IAM role that is used to access resources through Organizations.
        public var organizationRoleName: Swift.String?
        /// Specifies the organizational units that this workspace is allowed to use data sources from, if this workspace is in an account that is part of an organization.
        public var organizationalUnits: [Swift.String]?
        /// If this is Service Managed, Amazon Managed Grafana automatically creates the IAM roles and provisions the permissions that the workspace needs to use Amazon Web Services data sources and notification channels. If this is CUSTOMER_MANAGED, you manage those roles and permissions yourself. If you are creating this workspace in a member account of an organization and that account is not a delegated administrator account, and you want the workspace to access data sources in other Amazon Web Services accounts in the organization, you must choose CUSTOMER_MANAGED. For more information, see [Amazon Managed Grafana permissions and policies for Amazon Web Services data sources and notification channels](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-manage-permissions.html)
        public var permissionType: GrafanaClientTypes.PermissionType?
        /// The name of the CloudFormation stack set that is used to generate IAM roles to be used for this workspace.
        public var stackSetName: Swift.String?
        /// The current status of the workspace.
        /// This member is required.
        public var status: GrafanaClientTypes.WorkspaceStatus?
        /// The IAM role that grants permissions to the Amazon Web Services resources that the workspace will view data from. This role must already exist.
        public var workspaceRoleArn: Swift.String?

        public init (
            accountAccessType: GrafanaClientTypes.AccountAccessType? = nil,
            authentication: GrafanaClientTypes.AuthenticationSummary? = nil,
            created: ClientRuntime.Date? = nil,
            dataSources: [GrafanaClientTypes.DataSourceType]? = nil,
            description: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            freeTrialConsumed: Swift.Bool? = nil,
            freeTrialExpiration: ClientRuntime.Date? = nil,
            grafanaVersion: Swift.String? = nil,
            id: Swift.String? = nil,
            licenseExpiration: ClientRuntime.Date? = nil,
            licenseType: GrafanaClientTypes.LicenseType? = nil,
            modified: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            notificationDestinations: [GrafanaClientTypes.NotificationDestinationType]? = nil,
            organizationRoleName: Swift.String? = nil,
            organizationalUnits: [Swift.String]? = nil,
            permissionType: GrafanaClientTypes.PermissionType? = nil,
            stackSetName: Swift.String? = nil,
            status: GrafanaClientTypes.WorkspaceStatus? = nil,
            workspaceRoleArn: Swift.String? = nil
        )
        {
            self.accountAccessType = accountAccessType
            self.authentication = authentication
            self.created = created
            self.dataSources = dataSources
            self.description = description
            self.endpoint = endpoint
            self.freeTrialConsumed = freeTrialConsumed
            self.freeTrialExpiration = freeTrialExpiration
            self.grafanaVersion = grafanaVersion
            self.id = id
            self.licenseExpiration = licenseExpiration
            self.licenseType = licenseType
            self.modified = modified
            self.name = name
            self.notificationDestinations = notificationDestinations
            self.organizationRoleName = organizationRoleName
            self.organizationalUnits = organizationalUnits
            self.permissionType = permissionType
            self.stackSetName = stackSetName
            self.status = status
            self.workspaceRoleArn = workspaceRoleArn
        }
    }

}

extension GrafanaClientTypes {
    public enum WorkspaceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Workspace is active.
        case active
        /// Workspace is being created.
        case creating
        /// Workspace creation failed.
        case creationFailed
        /// Workspace is being deleted.
        case deleting
        /// Workspace deletion failed.
        case deletionFailed
        /// Workspace is in an invalid state, it can only and should be deleted.
        case failed
        /// Failed to remove enterprise license from workspace.
        case licenseRemovalFailed
        /// Workspace update failed.
        case updateFailed
        /// Workspace is being updated.
        case updating
        /// Workspace upgrade failed.
        case upgradeFailed
        /// Workspace is being upgraded to enterprise.
        case upgrading
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceStatus] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .deletionFailed,
                .failed,
                .licenseRemovalFailed,
                .updateFailed,
                .updating,
                .upgradeFailed,
                .upgrading,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .deletionFailed: return "DELETION_FAILED"
            case .failed: return "FAILED"
            case .licenseRemovalFailed: return "LICENSE_REMOVAL_FAILED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case .upgradeFailed: return "UPGRADE_FAILED"
            case .upgrading: return "UPGRADING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceStatus(rawValue: rawValue) ?? WorkspaceStatus.sdkUnknown(rawValue)
        }
    }
}

extension GrafanaClientTypes.WorkspaceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authentication
        case created
        case description
        case endpoint
        case grafanaVersion
        case id
        case modified
        case name
        case notificationDestinations
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authentication = authentication {
            try encodeContainer.encode(authentication, forKey: .authentication)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let grafanaVersion = grafanaVersion {
            try encodeContainer.encode(grafanaVersion, forKey: .grafanaVersion)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modified = modified {
            try encodeContainer.encode(modified.timeIntervalSince1970, forKey: .modified)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notificationDestinations = notificationDestinations {
            var notificationDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationDestinations)
            for notificationdestinationslist0 in notificationDestinations {
                try notificationDestinationsContainer.encode(notificationdestinationslist0.rawValue)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let grafanaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grafanaVersion)
        grafanaVersion = grafanaVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let modifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modified)
        modified = modifiedDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let notificationDestinationsContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.NotificationDestinationType?].self, forKey: .notificationDestinations)
        var notificationDestinationsDecoded0:[GrafanaClientTypes.NotificationDestinationType]? = nil
        if let notificationDestinationsContainer = notificationDestinationsContainer {
            notificationDestinationsDecoded0 = [GrafanaClientTypes.NotificationDestinationType]()
            for string0 in notificationDestinationsContainer {
                if let string0 = string0 {
                    notificationDestinationsDecoded0?.append(string0)
                }
            }
        }
        notificationDestinations = notificationDestinationsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceStatus.self, forKey: .status)
        status = statusDecoded
        let authenticationDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AuthenticationSummary.self, forKey: .authentication)
        authentication = authenticationDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure that contains some information about one workspace in the account.
    public struct WorkspaceSummary: Swift.Equatable {
        /// A structure containing information about the authentication methods used in the workspace.
        /// This member is required.
        public var authentication: GrafanaClientTypes.AuthenticationSummary?
        /// The date that the workspace was created.
        /// This member is required.
        public var created: ClientRuntime.Date?
        /// The customer-entered description of the workspace.
        public var description: Swift.String?
        /// The URL endpoint to use to access the Grafana console in the workspace.
        /// This member is required.
        public var endpoint: Swift.String?
        /// The Grafana version that the workspace is running.
        /// This member is required.
        public var grafanaVersion: Swift.String?
        /// The unique ID of the workspace.
        /// This member is required.
        public var id: Swift.String?
        /// The most recent date that the workspace was modified.
        /// This member is required.
        public var modified: ClientRuntime.Date?
        /// The name of the workspace.
        public var name: Swift.String?
        /// The Amazon Web Services notification channels that Amazon Managed Grafana can automatically create IAM roles and permissions for, which allows Amazon Managed Grafana to use these channels.
        public var notificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
        /// The current status of the workspace.
        /// This member is required.
        public var status: GrafanaClientTypes.WorkspaceStatus?

        public init (
            authentication: GrafanaClientTypes.AuthenticationSummary? = nil,
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            grafanaVersion: Swift.String? = nil,
            id: Swift.String? = nil,
            modified: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            notificationDestinations: [GrafanaClientTypes.NotificationDestinationType]? = nil,
            status: GrafanaClientTypes.WorkspaceStatus? = nil
        )
        {
            self.authentication = authentication
            self.created = created
            self.description = description
            self.endpoint = endpoint
            self.grafanaVersion = grafanaVersion
            self.id = id
            self.modified = modified
            self.name = name
            self.notificationDestinations = notificationDestinations
            self.status = status
        }
    }

}
