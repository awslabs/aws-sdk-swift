// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class ConfigServiceClient {
    let client: SdkHttpClient
    let config: ConfigServiceClientConfiguration
    let serviceName = "Config Service"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: ConfigServiceClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class ConfigServiceClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> ConfigServiceClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try ConfigServiceClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension ConfigServiceClient: ConfigServiceClientProtocol {
    /// <p>Returns the current configuration items for resources that are present in your AWS Config aggregator. The operation also returns a list of resources that are not processed in the current request.
    /// 			If there are no unprocessed resources, the operation returns an empty <code>unprocessedResourceIdentifiers</code> list. </p>
    /// 		
    /// 		       <note>
    ///             <ul>
    ///                <li>
    ///                   <p>The API does not return results for deleted resources.</p>
    ///                </li>
    ///                <li>
    ///                   <p> The API does not return tags and relationships.</p>
    ///                </li>
    ///             </ul>
    ///          </note>
    public func batchGetAggregateResourceConfig(input: BatchGetAggregateResourceConfigInput, completion: @escaping (SdkResult<BatchGetAggregateResourceConfigOutput, BatchGetAggregateResourceConfigOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "batchGetAggregateResourceConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<BatchGetAggregateResourceConfigInput, BatchGetAggregateResourceConfigOutput, BatchGetAggregateResourceConfigOutputError>(id: "batchGetAggregateResourceConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: BatchGetAggregateResourceConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: BatchGetAggregateResourceConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<BatchGetAggregateResourceConfigInput, BatchGetAggregateResourceConfigOutput, BatchGetAggregateResourceConfigOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: BatchGetAggregateResourceConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<BatchGetAggregateResourceConfigInput, BatchGetAggregateResourceConfigOutput, BatchGetAggregateResourceConfigOutputError>(xAmzTarget: "StarlingDoveService.BatchGetAggregateResourceConfig"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the current configuration for one or more requested
    /// 			resources. The operation also returns a list of resources that are
    /// 			not processed in the current request. If there are no unprocessed
    /// 			resources, the operation returns an empty unprocessedResourceKeys
    /// 			list. </p>
    /// 		       <note>
    /// 			         <ul>
    ///                <li>
    /// 					             <p>The API does not return results for deleted
    /// 						resources.</p>
    /// 				           </li>
    ///                <li>
    /// 					             <p> The API does not return any tags for the requested
    /// 						resources. This information is filtered out of the
    /// 						supplementaryConfiguration section of the API
    /// 						response.</p>
    /// 				           </li>
    ///             </ul>
    /// 		       </note>
    public func batchGetResourceConfig(input: BatchGetResourceConfigInput, completion: @escaping (SdkResult<BatchGetResourceConfigOutput, BatchGetResourceConfigOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "batchGetResourceConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<BatchGetResourceConfigInput, BatchGetResourceConfigOutput, BatchGetResourceConfigOutputError>(id: "batchGetResourceConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: BatchGetResourceConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: BatchGetResourceConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<BatchGetResourceConfigInput, BatchGetResourceConfigOutput, BatchGetResourceConfigOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: BatchGetResourceConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<BatchGetResourceConfigInput, BatchGetResourceConfigOutput, BatchGetResourceConfigOutputError>(xAmzTarget: "StarlingDoveService.BatchGetResourceConfig"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the authorization granted to the specified
    /// 			configuration aggregator account in a specified region.</p>
    public func deleteAggregationAuthorization(input: DeleteAggregationAuthorizationInput, completion: @escaping (SdkResult<DeleteAggregationAuthorizationOutput, DeleteAggregationAuthorizationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteAggregationAuthorization")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteAggregationAuthorizationInput, DeleteAggregationAuthorizationOutput, DeleteAggregationAuthorizationOutputError>(id: "deleteAggregationAuthorization")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteAggregationAuthorizationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteAggregationAuthorizationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteAggregationAuthorizationInput, DeleteAggregationAuthorizationOutput, DeleteAggregationAuthorizationOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteAggregationAuthorizationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteAggregationAuthorizationInput, DeleteAggregationAuthorizationOutput, DeleteAggregationAuthorizationOutputError>(xAmzTarget: "StarlingDoveService.DeleteAggregationAuthorization"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified AWS Config rule and all of its evaluation
    /// 			results.</p>
    /// 		       <p>AWS Config sets the state of a rule to <code>DELETING</code>
    /// 			until the deletion is complete. You cannot update a rule while it is
    /// 			in this state. If you make a <code>PutConfigRule</code> or
    /// 				<code>DeleteConfigRule</code> request for the rule, you will
    /// 			receive a <code>ResourceInUseException</code>.</p>
    /// 		       <p>You can check the state of a rule by using the
    /// 				<code>DescribeConfigRules</code> request.</p>
    public func deleteConfigRule(input: DeleteConfigRuleInput, completion: @escaping (SdkResult<DeleteConfigRuleOutput, DeleteConfigRuleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteConfigRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteConfigRuleInput, DeleteConfigRuleOutput, DeleteConfigRuleOutputError>(id: "deleteConfigRule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteConfigRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteConfigRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteConfigRuleInput, DeleteConfigRuleOutput, DeleteConfigRuleOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteConfigRuleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteConfigRuleInput, DeleteConfigRuleOutput, DeleteConfigRuleOutputError>(xAmzTarget: "StarlingDoveService.DeleteConfigRule"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified configuration aggregator and the
    /// 			aggregated data associated with the aggregator.</p>
    public func deleteConfigurationAggregator(input: DeleteConfigurationAggregatorInput, completion: @escaping (SdkResult<DeleteConfigurationAggregatorOutput, DeleteConfigurationAggregatorOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteConfigurationAggregator")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteConfigurationAggregatorInput, DeleteConfigurationAggregatorOutput, DeleteConfigurationAggregatorOutputError>(id: "deleteConfigurationAggregator")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteConfigurationAggregatorInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteConfigurationAggregatorInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteConfigurationAggregatorInput, DeleteConfigurationAggregatorOutput, DeleteConfigurationAggregatorOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteConfigurationAggregatorInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteConfigurationAggregatorInput, DeleteConfigurationAggregatorOutput, DeleteConfigurationAggregatorOutputError>(xAmzTarget: "StarlingDoveService.DeleteConfigurationAggregator"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the configuration recorder.</p>
    /// 		       <p>After the configuration recorder is deleted, AWS Config will
    /// 			not record resource configuration changes until you create a new
    /// 			configuration recorder.</p>
    /// 		       <p>This action does not delete the configuration information that
    /// 			was previously recorded. You will be able to access the previously
    /// 			recorded information by using the
    /// 				<code>GetResourceConfigHistory</code> action, but you will not
    /// 			be able to access this information in the AWS Config console until
    /// 			you create a new configuration recorder.</p>
    public func deleteConfigurationRecorder(input: DeleteConfigurationRecorderInput, completion: @escaping (SdkResult<DeleteConfigurationRecorderOutput, DeleteConfigurationRecorderOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteConfigurationRecorder")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteConfigurationRecorderInput, DeleteConfigurationRecorderOutput, DeleteConfigurationRecorderOutputError>(id: "deleteConfigurationRecorder")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteConfigurationRecorderInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteConfigurationRecorderInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteConfigurationRecorderInput, DeleteConfigurationRecorderOutput, DeleteConfigurationRecorderOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteConfigurationRecorderInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteConfigurationRecorderInput, DeleteConfigurationRecorderOutput, DeleteConfigurationRecorderOutputError>(xAmzTarget: "StarlingDoveService.DeleteConfigurationRecorder"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified conformance pack and all the AWS Config rules, remediation actions, and all evaluation results within that
    /// 			conformance pack.</p>
    /// 		       <p>AWS Config sets the conformance pack to <code>DELETE_IN_PROGRESS</code> until the deletion is complete.
    /// 			You cannot update a conformance pack while it is in this state.</p>
    public func deleteConformancePack(input: DeleteConformancePackInput, completion: @escaping (SdkResult<DeleteConformancePackOutput, DeleteConformancePackOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteConformancePack")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteConformancePackInput, DeleteConformancePackOutput, DeleteConformancePackOutputError>(id: "deleteConformancePack")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteConformancePackInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteConformancePackInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteConformancePackInput, DeleteConformancePackOutput, DeleteConformancePackOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteConformancePackInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteConformancePackInput, DeleteConformancePackOutput, DeleteConformancePackOutputError>(xAmzTarget: "StarlingDoveService.DeleteConformancePack"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the delivery channel.</p>
    /// 		       <p>Before you can delete the delivery channel, you must stop the
    /// 			configuration recorder by using the <a>StopConfigurationRecorder</a> action.</p>
    public func deleteDeliveryChannel(input: DeleteDeliveryChannelInput, completion: @escaping (SdkResult<DeleteDeliveryChannelOutput, DeleteDeliveryChannelOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDeliveryChannel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDeliveryChannelInput, DeleteDeliveryChannelOutput, DeleteDeliveryChannelOutputError>(id: "deleteDeliveryChannel")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDeliveryChannelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDeliveryChannelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteDeliveryChannelInput, DeleteDeliveryChannelOutput, DeleteDeliveryChannelOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteDeliveryChannelInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteDeliveryChannelInput, DeleteDeliveryChannelOutput, DeleteDeliveryChannelOutputError>(xAmzTarget: "StarlingDoveService.DeleteDeliveryChannel"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the evaluation results for the specified AWS Config
    /// 			rule. You can specify one AWS Config rule per request. After you
    /// 			delete the evaluation results, you can call the <a>StartConfigRulesEvaluation</a> API to start evaluating
    /// 			your AWS resources against the rule.</p>
    public func deleteEvaluationResults(input: DeleteEvaluationResultsInput, completion: @escaping (SdkResult<DeleteEvaluationResultsOutput, DeleteEvaluationResultsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteEvaluationResults")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteEvaluationResultsInput, DeleteEvaluationResultsOutput, DeleteEvaluationResultsOutputError>(id: "deleteEvaluationResults")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteEvaluationResultsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteEvaluationResultsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteEvaluationResultsInput, DeleteEvaluationResultsOutput, DeleteEvaluationResultsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteEvaluationResultsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteEvaluationResultsInput, DeleteEvaluationResultsOutput, DeleteEvaluationResultsOutputError>(xAmzTarget: "StarlingDoveService.DeleteEvaluationResults"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified organization config rule and all of its evaluation results from all member accounts in that organization. </p>
    /// 	        <p>Only a master account and a delegated administrator account can delete an organization config rule.
    /// 		When calling this API with a delegated administrator, you must ensure AWS Organizations
    /// 			<code>ListDelegatedAdministrator</code> permissions are added.</p>
    /// 		       <p>AWS Config sets the state of a rule to DELETE_IN_PROGRESS until the deletion is complete.
    /// 			You cannot update a rule while it is in this state.</p>
    public func deleteOrganizationConfigRule(input: DeleteOrganizationConfigRuleInput, completion: @escaping (SdkResult<DeleteOrganizationConfigRuleOutput, DeleteOrganizationConfigRuleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteOrganizationConfigRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteOrganizationConfigRuleInput, DeleteOrganizationConfigRuleOutput, DeleteOrganizationConfigRuleOutputError>(id: "deleteOrganizationConfigRule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteOrganizationConfigRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteOrganizationConfigRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteOrganizationConfigRuleInput, DeleteOrganizationConfigRuleOutput, DeleteOrganizationConfigRuleOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteOrganizationConfigRuleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteOrganizationConfigRuleInput, DeleteOrganizationConfigRuleOutput, DeleteOrganizationConfigRuleOutputError>(xAmzTarget: "StarlingDoveService.DeleteOrganizationConfigRule"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified organization conformance pack and all of the config rules and remediation actions from
    /// 			all member accounts in that organization. </p>
    ///          <p> Only a master account or a delegated administrator account can delete an organization conformance pack.
    /// 	When calling this API with a delegated administrator, you must ensure AWS Organizations
    /// 		<code>ListDelegatedAdministrator</code> permissions are added.</p>
    /// 			      <p>AWS Config sets the state of a conformance pack to DELETE_IN_PROGRESS until the deletion is complete.
    /// 				You cannot update a conformance pack while it is in this state. </p>
    public func deleteOrganizationConformancePack(input: DeleteOrganizationConformancePackInput, completion: @escaping (SdkResult<DeleteOrganizationConformancePackOutput, DeleteOrganizationConformancePackOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteOrganizationConformancePack")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteOrganizationConformancePackInput, DeleteOrganizationConformancePackOutput, DeleteOrganizationConformancePackOutputError>(id: "deleteOrganizationConformancePack")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteOrganizationConformancePackInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteOrganizationConformancePackInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteOrganizationConformancePackInput, DeleteOrganizationConformancePackOutput, DeleteOrganizationConformancePackOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteOrganizationConformancePackInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteOrganizationConformancePackInput, DeleteOrganizationConformancePackOutput, DeleteOrganizationConformancePackOutputError>(xAmzTarget: "StarlingDoveService.DeleteOrganizationConformancePack"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes pending authorization requests for a specified
    /// 			aggregator account in a specified region.</p>
    public func deletePendingAggregationRequest(input: DeletePendingAggregationRequestInput, completion: @escaping (SdkResult<DeletePendingAggregationRequestOutput, DeletePendingAggregationRequestOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deletePendingAggregationRequest")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeletePendingAggregationRequestInput, DeletePendingAggregationRequestOutput, DeletePendingAggregationRequestOutputError>(id: "deletePendingAggregationRequest")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeletePendingAggregationRequestInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeletePendingAggregationRequestInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeletePendingAggregationRequestInput, DeletePendingAggregationRequestOutput, DeletePendingAggregationRequestOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeletePendingAggregationRequestInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeletePendingAggregationRequestInput, DeletePendingAggregationRequestOutput, DeletePendingAggregationRequestOutputError>(xAmzTarget: "StarlingDoveService.DeletePendingAggregationRequest"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the remediation configuration.</p>
    public func deleteRemediationConfiguration(input: DeleteRemediationConfigurationInput, completion: @escaping (SdkResult<DeleteRemediationConfigurationOutput, DeleteRemediationConfigurationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteRemediationConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteRemediationConfigurationInput, DeleteRemediationConfigurationOutput, DeleteRemediationConfigurationOutputError>(id: "deleteRemediationConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteRemediationConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteRemediationConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteRemediationConfigurationInput, DeleteRemediationConfigurationOutput, DeleteRemediationConfigurationOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteRemediationConfigurationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteRemediationConfigurationInput, DeleteRemediationConfigurationOutput, DeleteRemediationConfigurationOutputError>(xAmzTarget: "StarlingDoveService.DeleteRemediationConfiguration"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes one or more remediation exceptions mentioned in the resource keys.</p>
    /// 		       <note>
    ///             <p>AWS Config generates a remediation exception when a problem occurs executing a remediation action to a specific resource.
    /// 			Remediation exceptions blocks auto-remediation until the exception is cleared.</p>
    ///          </note>
    public func deleteRemediationExceptions(input: DeleteRemediationExceptionsInput, completion: @escaping (SdkResult<DeleteRemediationExceptionsOutput, DeleteRemediationExceptionsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteRemediationExceptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteRemediationExceptionsInput, DeleteRemediationExceptionsOutput, DeleteRemediationExceptionsOutputError>(id: "deleteRemediationExceptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteRemediationExceptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteRemediationExceptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteRemediationExceptionsInput, DeleteRemediationExceptionsOutput, DeleteRemediationExceptionsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteRemediationExceptionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteRemediationExceptionsInput, DeleteRemediationExceptionsOutput, DeleteRemediationExceptionsOutputError>(xAmzTarget: "StarlingDoveService.DeleteRemediationExceptions"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Records the configuration state for a custom resource that has been deleted.  This API records a new ConfigurationItem with a ResourceDeleted status. You can retrieve the ConfigurationItems recorded for this resource in your AWS Config History.
    /// 			 </p>
    public func deleteResourceConfig(input: DeleteResourceConfigInput, completion: @escaping (SdkResult<DeleteResourceConfigOutput, DeleteResourceConfigOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteResourceConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteResourceConfigInput, DeleteResourceConfigOutput, DeleteResourceConfigOutputError>(id: "deleteResourceConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteResourceConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteResourceConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteResourceConfigInput, DeleteResourceConfigOutput, DeleteResourceConfigOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteResourceConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteResourceConfigInput, DeleteResourceConfigOutput, DeleteResourceConfigOutputError>(xAmzTarget: "StarlingDoveService.DeleteResourceConfig"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the retention configuration.</p>
    public func deleteRetentionConfiguration(input: DeleteRetentionConfigurationInput, completion: @escaping (SdkResult<DeleteRetentionConfigurationOutput, DeleteRetentionConfigurationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteRetentionConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteRetentionConfigurationInput, DeleteRetentionConfigurationOutput, DeleteRetentionConfigurationOutputError>(id: "deleteRetentionConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteRetentionConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteRetentionConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteRetentionConfigurationInput, DeleteRetentionConfigurationOutput, DeleteRetentionConfigurationOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteRetentionConfigurationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteRetentionConfigurationInput, DeleteRetentionConfigurationOutput, DeleteRetentionConfigurationOutputError>(xAmzTarget: "StarlingDoveService.DeleteRetentionConfiguration"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the stored query for a single AWS account and a single AWS Region.</p>
    public func deleteStoredQuery(input: DeleteStoredQueryInput, completion: @escaping (SdkResult<DeleteStoredQueryOutput, DeleteStoredQueryOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteStoredQuery")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteStoredQueryInput, DeleteStoredQueryOutput, DeleteStoredQueryOutputError>(id: "deleteStoredQuery")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteStoredQueryInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteStoredQueryInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteStoredQueryInput, DeleteStoredQueryOutput, DeleteStoredQueryOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteStoredQueryInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteStoredQueryInput, DeleteStoredQueryOutput, DeleteStoredQueryOutputError>(xAmzTarget: "StarlingDoveService.DeleteStoredQuery"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Schedules delivery of a configuration snapshot to the Amazon S3
    /// 			bucket in the specified delivery channel. After the delivery has
    /// 			started, AWS Config sends the following notifications using an
    /// 			Amazon SNS topic that you have specified.</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Notification of the start of the delivery.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Notification of the completion of the delivery, if the
    /// 					delivery was successfully completed.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Notification of delivery failure, if the delivery
    /// 					failed.</p>
    /// 			         </li>
    ///          </ul>
    public func deliverConfigSnapshot(input: DeliverConfigSnapshotInput, completion: @escaping (SdkResult<DeliverConfigSnapshotOutput, DeliverConfigSnapshotOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deliverConfigSnapshot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeliverConfigSnapshotInput, DeliverConfigSnapshotOutput, DeliverConfigSnapshotOutputError>(id: "deliverConfigSnapshot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeliverConfigSnapshotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeliverConfigSnapshotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeliverConfigSnapshotInput, DeliverConfigSnapshotOutput, DeliverConfigSnapshotOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeliverConfigSnapshotInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeliverConfigSnapshotInput, DeliverConfigSnapshotOutput, DeliverConfigSnapshotOutputError>(xAmzTarget: "StarlingDoveService.DeliverConfigSnapshot"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of compliant and noncompliant rules with the
    /// 			number of resources for compliant and noncompliant rules.
    /// 			</p>
    /// 		       <note>
    /// 			         <p>The results can return an empty result page, but if you
    /// 				have a <code>nextToken</code>, the results are displayed on the next
    /// 				page.</p>
    /// 		       </note>
    public func describeAggregateComplianceByConfigRules(input: DescribeAggregateComplianceByConfigRulesInput, completion: @escaping (SdkResult<DescribeAggregateComplianceByConfigRulesOutput, DescribeAggregateComplianceByConfigRulesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAggregateComplianceByConfigRules")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAggregateComplianceByConfigRulesInput, DescribeAggregateComplianceByConfigRulesOutput, DescribeAggregateComplianceByConfigRulesOutputError>(id: "describeAggregateComplianceByConfigRules")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAggregateComplianceByConfigRulesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAggregateComplianceByConfigRulesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAggregateComplianceByConfigRulesInput, DescribeAggregateComplianceByConfigRulesOutput, DescribeAggregateComplianceByConfigRulesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeAggregateComplianceByConfigRulesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeAggregateComplianceByConfigRulesInput, DescribeAggregateComplianceByConfigRulesOutput, DescribeAggregateComplianceByConfigRulesOutputError>(xAmzTarget: "StarlingDoveService.DescribeAggregateComplianceByConfigRules"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of the conformance packs and their associated compliance status with the count of compliant and noncompliant AWS Config rules within each conformance pack.
    /// 			Also returns the total rule count which includes compliant rules, noncompliant rules, and rules that cannot be evaluated due to insufficient data.</p>
    /// 		       <note>
    ///             <p>The results can return an empty result page, but if you have a <code>nextToken</code>, the results are displayed on the next page.</p>
    ///          </note>
    public func describeAggregateComplianceByConformancePacks(input: DescribeAggregateComplianceByConformancePacksInput, completion: @escaping (SdkResult<DescribeAggregateComplianceByConformancePacksOutput, DescribeAggregateComplianceByConformancePacksOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAggregateComplianceByConformancePacks")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAggregateComplianceByConformancePacksInput, DescribeAggregateComplianceByConformancePacksOutput, DescribeAggregateComplianceByConformancePacksOutputError>(id: "describeAggregateComplianceByConformancePacks")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAggregateComplianceByConformancePacksInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAggregateComplianceByConformancePacksInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAggregateComplianceByConformancePacksInput, DescribeAggregateComplianceByConformancePacksOutput, DescribeAggregateComplianceByConformancePacksOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeAggregateComplianceByConformancePacksInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeAggregateComplianceByConformancePacksInput, DescribeAggregateComplianceByConformancePacksOutput, DescribeAggregateComplianceByConformancePacksOutputError>(xAmzTarget: "StarlingDoveService.DescribeAggregateComplianceByConformancePacks"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of authorizations granted to various aggregator
    /// 			accounts and regions.</p>
    public func describeAggregationAuthorizations(input: DescribeAggregationAuthorizationsInput, completion: @escaping (SdkResult<DescribeAggregationAuthorizationsOutput, DescribeAggregationAuthorizationsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAggregationAuthorizations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAggregationAuthorizationsInput, DescribeAggregationAuthorizationsOutput, DescribeAggregationAuthorizationsOutputError>(id: "describeAggregationAuthorizations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAggregationAuthorizationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAggregationAuthorizationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAggregationAuthorizationsInput, DescribeAggregationAuthorizationsOutput, DescribeAggregationAuthorizationsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeAggregationAuthorizationsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeAggregationAuthorizationsInput, DescribeAggregationAuthorizationsOutput, DescribeAggregationAuthorizationsOutputError>(xAmzTarget: "StarlingDoveService.DescribeAggregationAuthorizations"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Indicates whether the specified AWS Config rules are compliant.
    /// 			If a rule is noncompliant, this action returns the number of AWS
    /// 			resources that do not comply with the rule.</p>
    /// 		       <p>A rule is compliant if all of the evaluated resources comply
    /// 			with it. It is noncompliant if any of these resources do not
    /// 			comply.</p>
    /// 		       <p>If AWS Config has no current evaluation results for the rule,
    /// 			it returns <code>INSUFFICIENT_DATA</code>. This result might
    /// 			indicate one of the following conditions:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>AWS Config has never invoked an evaluation for the
    /// 					rule. To check whether it has, use the
    /// 						<code>DescribeConfigRuleEvaluationStatus</code> action
    /// 					to get the <code>LastSuccessfulInvocationTime</code> and
    /// 						<code>LastFailedInvocationTime</code>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The rule's AWS Lambda function is failing to send
    /// 					evaluation results to AWS Config. Verify that the role you
    /// 					assigned to your configuration recorder includes the
    /// 						<code>config:PutEvaluations</code> permission. If the
    /// 					rule is a custom rule, verify that the AWS Lambda execution
    /// 					role includes the <code>config:PutEvaluations</code>
    /// 					permission.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The rule's AWS Lambda function has returned
    /// 						<code>NOT_APPLICABLE</code> for all evaluation results.
    /// 					This can occur if the resources were deleted or removed from
    /// 					the rule's scope.</p>
    /// 			         </li>
    ///          </ul>
    public func describeComplianceByConfigRule(input: DescribeComplianceByConfigRuleInput, completion: @escaping (SdkResult<DescribeComplianceByConfigRuleOutput, DescribeComplianceByConfigRuleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeComplianceByConfigRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeComplianceByConfigRuleInput, DescribeComplianceByConfigRuleOutput, DescribeComplianceByConfigRuleOutputError>(id: "describeComplianceByConfigRule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeComplianceByConfigRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeComplianceByConfigRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeComplianceByConfigRuleInput, DescribeComplianceByConfigRuleOutput, DescribeComplianceByConfigRuleOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeComplianceByConfigRuleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeComplianceByConfigRuleInput, DescribeComplianceByConfigRuleOutput, DescribeComplianceByConfigRuleOutputError>(xAmzTarget: "StarlingDoveService.DescribeComplianceByConfigRule"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Indicates whether the specified AWS resources are compliant. If
    /// 			a resource is noncompliant, this action returns the number of AWS
    /// 			Config rules that the resource does not comply with.</p>
    /// 		       <p>A resource is compliant if it complies with all the AWS Config
    /// 			rules that evaluate it. It is noncompliant if it does not comply
    /// 			with one or more of these rules.</p>
    /// 		       <p>If AWS Config has no current evaluation results for the
    /// 			resource, it returns <code>INSUFFICIENT_DATA</code>. This result
    /// 			might indicate one of the following conditions about the rules that
    /// 			evaluate the resource:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>AWS Config has never invoked an evaluation for the
    /// 					rule. To check whether it has, use the
    /// 						<code>DescribeConfigRuleEvaluationStatus</code> action
    /// 					to get the <code>LastSuccessfulInvocationTime</code> and
    /// 						<code>LastFailedInvocationTime</code>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The rule's AWS Lambda function is failing to send
    /// 					evaluation results to AWS Config. Verify that the role that
    /// 					you assigned to your configuration recorder includes the
    /// 						<code>config:PutEvaluations</code> permission. If the
    /// 					rule is a custom rule, verify that the AWS Lambda execution
    /// 					role includes the <code>config:PutEvaluations</code>
    /// 					permission.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The rule's AWS Lambda function has returned
    /// 						<code>NOT_APPLICABLE</code> for all evaluation results.
    /// 					This can occur if the resources were deleted or removed from
    /// 					the rule's scope.</p>
    /// 			         </li>
    ///          </ul>
    public func describeComplianceByResource(input: DescribeComplianceByResourceInput, completion: @escaping (SdkResult<DescribeComplianceByResourceOutput, DescribeComplianceByResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeComplianceByResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeComplianceByResourceInput, DescribeComplianceByResourceOutput, DescribeComplianceByResourceOutputError>(id: "describeComplianceByResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeComplianceByResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeComplianceByResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeComplianceByResourceInput, DescribeComplianceByResourceOutput, DescribeComplianceByResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeComplianceByResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeComplianceByResourceInput, DescribeComplianceByResourceOutput, DescribeComplianceByResourceOutputError>(xAmzTarget: "StarlingDoveService.DescribeComplianceByResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns status information for each of your AWS managed Config
    /// 			rules. The status includes information such as the last time AWS
    /// 			Config invoked the rule, the last time AWS Config failed to invoke
    /// 			the rule, and the related error for the last failure.</p>
    public func describeConfigRuleEvaluationStatus(input: DescribeConfigRuleEvaluationStatusInput, completion: @escaping (SdkResult<DescribeConfigRuleEvaluationStatusOutput, DescribeConfigRuleEvaluationStatusOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeConfigRuleEvaluationStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeConfigRuleEvaluationStatusInput, DescribeConfigRuleEvaluationStatusOutput, DescribeConfigRuleEvaluationStatusOutputError>(id: "describeConfigRuleEvaluationStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigRuleEvaluationStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigRuleEvaluationStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeConfigRuleEvaluationStatusInput, DescribeConfigRuleEvaluationStatusOutput, DescribeConfigRuleEvaluationStatusOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigRuleEvaluationStatusInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeConfigRuleEvaluationStatusInput, DescribeConfigRuleEvaluationStatusOutput, DescribeConfigRuleEvaluationStatusOutputError>(xAmzTarget: "StarlingDoveService.DescribeConfigRuleEvaluationStatus"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns details about your AWS Config rules.</p>
    public func describeConfigRules(input: DescribeConfigRulesInput, completion: @escaping (SdkResult<DescribeConfigRulesOutput, DescribeConfigRulesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeConfigRules")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeConfigRulesInput, DescribeConfigRulesOutput, DescribeConfigRulesOutputError>(id: "describeConfigRules")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigRulesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigRulesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeConfigRulesInput, DescribeConfigRulesOutput, DescribeConfigRulesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigRulesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeConfigRulesInput, DescribeConfigRulesOutput, DescribeConfigRulesOutputError>(xAmzTarget: "StarlingDoveService.DescribeConfigRules"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns status information for sources within an aggregator.
    /// 			The status includes information about the last time AWS Config verified authorization between the source account and an aggregator account. In case of a failure, the status contains the related error code or message. </p>
    public func describeConfigurationAggregatorSourcesStatus(input: DescribeConfigurationAggregatorSourcesStatusInput, completion: @escaping (SdkResult<DescribeConfigurationAggregatorSourcesStatusOutput, DescribeConfigurationAggregatorSourcesStatusOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeConfigurationAggregatorSourcesStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeConfigurationAggregatorSourcesStatusInput, DescribeConfigurationAggregatorSourcesStatusOutput, DescribeConfigurationAggregatorSourcesStatusOutputError>(id: "describeConfigurationAggregatorSourcesStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigurationAggregatorSourcesStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigurationAggregatorSourcesStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeConfigurationAggregatorSourcesStatusInput, DescribeConfigurationAggregatorSourcesStatusOutput, DescribeConfigurationAggregatorSourcesStatusOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigurationAggregatorSourcesStatusInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeConfigurationAggregatorSourcesStatusInput, DescribeConfigurationAggregatorSourcesStatusOutput, DescribeConfigurationAggregatorSourcesStatusOutputError>(xAmzTarget: "StarlingDoveService.DescribeConfigurationAggregatorSourcesStatus"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the details of one or more configuration aggregators.
    /// 			If the configuration aggregator is not specified, this action
    /// 			returns the details for all the configuration aggregators associated
    /// 			with the account. </p>
    public func describeConfigurationAggregators(input: DescribeConfigurationAggregatorsInput, completion: @escaping (SdkResult<DescribeConfigurationAggregatorsOutput, DescribeConfigurationAggregatorsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeConfigurationAggregators")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeConfigurationAggregatorsInput, DescribeConfigurationAggregatorsOutput, DescribeConfigurationAggregatorsOutputError>(id: "describeConfigurationAggregators")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigurationAggregatorsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigurationAggregatorsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeConfigurationAggregatorsInput, DescribeConfigurationAggregatorsOutput, DescribeConfigurationAggregatorsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigurationAggregatorsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeConfigurationAggregatorsInput, DescribeConfigurationAggregatorsOutput, DescribeConfigurationAggregatorsOutputError>(xAmzTarget: "StarlingDoveService.DescribeConfigurationAggregators"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the current status of the specified configuration
    /// 			recorder. If a configuration recorder is not specified, this action
    /// 			returns the status of all configuration recorders associated with
    /// 			the account.</p>
    /// 		       <note>
    /// 			         <p>Currently, you can specify only one configuration recorder
    /// 				per region in your account.</p>
    /// 		       </note>
    public func describeConfigurationRecorderStatus(input: DescribeConfigurationRecorderStatusInput, completion: @escaping (SdkResult<DescribeConfigurationRecorderStatusOutput, DescribeConfigurationRecorderStatusOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeConfigurationRecorderStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeConfigurationRecorderStatusInput, DescribeConfigurationRecorderStatusOutput, DescribeConfigurationRecorderStatusOutputError>(id: "describeConfigurationRecorderStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigurationRecorderStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigurationRecorderStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeConfigurationRecorderStatusInput, DescribeConfigurationRecorderStatusOutput, DescribeConfigurationRecorderStatusOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigurationRecorderStatusInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeConfigurationRecorderStatusInput, DescribeConfigurationRecorderStatusOutput, DescribeConfigurationRecorderStatusOutputError>(xAmzTarget: "StarlingDoveService.DescribeConfigurationRecorderStatus"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the details for the specified configuration recorders.
    /// 			If the configuration recorder is not specified, this action returns
    /// 			the details for all configuration recorders associated with the
    /// 			account.</p>
    /// 		       <note>
    /// 			         <p>Currently, you can specify only one configuration recorder
    /// 				per region in your account.</p>
    /// 		       </note>
    public func describeConfigurationRecorders(input: DescribeConfigurationRecordersInput, completion: @escaping (SdkResult<DescribeConfigurationRecordersOutput, DescribeConfigurationRecordersOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeConfigurationRecorders")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeConfigurationRecordersInput, DescribeConfigurationRecordersOutput, DescribeConfigurationRecordersOutputError>(id: "describeConfigurationRecorders")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigurationRecordersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigurationRecordersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeConfigurationRecordersInput, DescribeConfigurationRecordersOutput, DescribeConfigurationRecordersOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeConfigurationRecordersInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeConfigurationRecordersInput, DescribeConfigurationRecordersOutput, DescribeConfigurationRecordersOutputError>(xAmzTarget: "StarlingDoveService.DescribeConfigurationRecorders"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns compliance details for each rule in that conformance pack.</p>
    /// 		       <note>
    ///             <p>You must provide exact rule names.</p>
    ///          </note>
    public func describeConformancePackCompliance(input: DescribeConformancePackComplianceInput, completion: @escaping (SdkResult<DescribeConformancePackComplianceOutput, DescribeConformancePackComplianceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeConformancePackCompliance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeConformancePackComplianceInput, DescribeConformancePackComplianceOutput, DescribeConformancePackComplianceOutputError>(id: "describeConformancePackCompliance")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeConformancePackComplianceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeConformancePackComplianceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeConformancePackComplianceInput, DescribeConformancePackComplianceOutput, DescribeConformancePackComplianceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeConformancePackComplianceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeConformancePackComplianceInput, DescribeConformancePackComplianceOutput, DescribeConformancePackComplianceOutputError>(xAmzTarget: "StarlingDoveService.DescribeConformancePackCompliance"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides one or more conformance packs deployment status.</p>
    /// 		       <note>
    ///             <p>If there are no conformance packs then you will see an empty result.</p>
    ///          </note>
    public func describeConformancePackStatus(input: DescribeConformancePackStatusInput, completion: @escaping (SdkResult<DescribeConformancePackStatusOutput, DescribeConformancePackStatusOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeConformancePackStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeConformancePackStatusInput, DescribeConformancePackStatusOutput, DescribeConformancePackStatusOutputError>(id: "describeConformancePackStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeConformancePackStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeConformancePackStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeConformancePackStatusInput, DescribeConformancePackStatusOutput, DescribeConformancePackStatusOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeConformancePackStatusInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeConformancePackStatusInput, DescribeConformancePackStatusOutput, DescribeConformancePackStatusOutputError>(xAmzTarget: "StarlingDoveService.DescribeConformancePackStatus"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of one or more conformance packs.</p>
    public func describeConformancePacks(input: DescribeConformancePacksInput, completion: @escaping (SdkResult<DescribeConformancePacksOutput, DescribeConformancePacksOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeConformancePacks")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeConformancePacksInput, DescribeConformancePacksOutput, DescribeConformancePacksOutputError>(id: "describeConformancePacks")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeConformancePacksInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeConformancePacksInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeConformancePacksInput, DescribeConformancePacksOutput, DescribeConformancePacksOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeConformancePacksInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeConformancePacksInput, DescribeConformancePacksOutput, DescribeConformancePacksOutputError>(xAmzTarget: "StarlingDoveService.DescribeConformancePacks"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the current status of the specified delivery channel.
    /// 			If a delivery channel is not specified, this action returns the
    /// 			current status of all delivery channels associated with the
    /// 			account.</p>
    /// 		       <note>
    /// 			         <p>Currently, you can specify only one delivery channel per
    /// 				region in your account.</p>
    /// 		       </note>
    public func describeDeliveryChannelStatus(input: DescribeDeliveryChannelStatusInput, completion: @escaping (SdkResult<DescribeDeliveryChannelStatusOutput, DescribeDeliveryChannelStatusOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeDeliveryChannelStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeDeliveryChannelStatusInput, DescribeDeliveryChannelStatusOutput, DescribeDeliveryChannelStatusOutputError>(id: "describeDeliveryChannelStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeDeliveryChannelStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeDeliveryChannelStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeDeliveryChannelStatusInput, DescribeDeliveryChannelStatusOutput, DescribeDeliveryChannelStatusOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeDeliveryChannelStatusInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeDeliveryChannelStatusInput, DescribeDeliveryChannelStatusOutput, DescribeDeliveryChannelStatusOutputError>(xAmzTarget: "StarlingDoveService.DescribeDeliveryChannelStatus"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns details about the specified delivery channel. If a
    /// 			delivery channel is not specified, this action returns the details
    /// 			of all delivery channels associated with the account.</p>
    /// 		       <note>
    /// 			         <p>Currently, you can specify only one delivery channel per
    /// 				region in your account.</p>
    /// 		       </note>
    public func describeDeliveryChannels(input: DescribeDeliveryChannelsInput, completion: @escaping (SdkResult<DescribeDeliveryChannelsOutput, DescribeDeliveryChannelsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeDeliveryChannels")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeDeliveryChannelsInput, DescribeDeliveryChannelsOutput, DescribeDeliveryChannelsOutputError>(id: "describeDeliveryChannels")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeDeliveryChannelsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeDeliveryChannelsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeDeliveryChannelsInput, DescribeDeliveryChannelsOutput, DescribeDeliveryChannelsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeDeliveryChannelsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeDeliveryChannelsInput, DescribeDeliveryChannelsOutput, DescribeDeliveryChannelsOutputError>(xAmzTarget: "StarlingDoveService.DescribeDeliveryChannels"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides organization config rule deployment status for an organization.</p>
    /// 		
    /// 		       <note>
    ///             <p>The status is not considered successful until organization config rule is successfully deployed in all the member
    /// 			accounts with an exception of excluded accounts.</p>
    /// 			         <p>When you specify the limit and the next token, you receive a paginated response.
    /// 			Limit and next token are not applicable if you specify organization config rule names.
    /// 			It is only applicable, when you request all the organization config rules.</p>
    /// 			      </note>
    public func describeOrganizationConfigRuleStatuses(input: DescribeOrganizationConfigRuleStatusesInput, completion: @escaping (SdkResult<DescribeOrganizationConfigRuleStatusesOutput, DescribeOrganizationConfigRuleStatusesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeOrganizationConfigRuleStatuses")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeOrganizationConfigRuleStatusesInput, DescribeOrganizationConfigRuleStatusesOutput, DescribeOrganizationConfigRuleStatusesOutputError>(id: "describeOrganizationConfigRuleStatuses")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeOrganizationConfigRuleStatusesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeOrganizationConfigRuleStatusesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeOrganizationConfigRuleStatusesInput, DescribeOrganizationConfigRuleStatusesOutput, DescribeOrganizationConfigRuleStatusesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeOrganizationConfigRuleStatusesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeOrganizationConfigRuleStatusesInput, DescribeOrganizationConfigRuleStatusesOutput, DescribeOrganizationConfigRuleStatusesOutputError>(xAmzTarget: "StarlingDoveService.DescribeOrganizationConfigRuleStatuses"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of organization config rules. </p>
    /// 			
    /// 		       <note>
    ///             <p>When you specify the limit and the next token, you receive a paginated response.
    /// 			Limit and next token are not applicable if you specify organization config rule names.
    /// 			It is only applicable, when you request all the organization config rules.</p>
    ///          </note>
    public func describeOrganizationConfigRules(input: DescribeOrganizationConfigRulesInput, completion: @escaping (SdkResult<DescribeOrganizationConfigRulesOutput, DescribeOrganizationConfigRulesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeOrganizationConfigRules")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeOrganizationConfigRulesInput, DescribeOrganizationConfigRulesOutput, DescribeOrganizationConfigRulesOutputError>(id: "describeOrganizationConfigRules")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeOrganizationConfigRulesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeOrganizationConfigRulesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeOrganizationConfigRulesInput, DescribeOrganizationConfigRulesOutput, DescribeOrganizationConfigRulesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeOrganizationConfigRulesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeOrganizationConfigRulesInput, DescribeOrganizationConfigRulesOutput, DescribeOrganizationConfigRulesOutputError>(xAmzTarget: "StarlingDoveService.DescribeOrganizationConfigRules"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides organization conformance pack deployment status for an organization. </p>
    /// 		       <note>
    /// 			         <p>The status is not considered successful until organization conformance pack is successfully
    /// 				deployed in all the member accounts with an exception of excluded accounts.</p>
    /// 			         <p>When you specify the limit and the next token, you receive a paginated response.
    /// 				Limit and next token are not applicable if you specify organization conformance pack names.
    /// 				They are only applicable, when you request all the organization conformance packs.</p>
    ///          </note>
    public func describeOrganizationConformancePackStatuses(input: DescribeOrganizationConformancePackStatusesInput, completion: @escaping (SdkResult<DescribeOrganizationConformancePackStatusesOutput, DescribeOrganizationConformancePackStatusesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeOrganizationConformancePackStatuses")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeOrganizationConformancePackStatusesInput, DescribeOrganizationConformancePackStatusesOutput, DescribeOrganizationConformancePackStatusesOutputError>(id: "describeOrganizationConformancePackStatuses")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeOrganizationConformancePackStatusesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeOrganizationConformancePackStatusesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeOrganizationConformancePackStatusesInput, DescribeOrganizationConformancePackStatusesOutput, DescribeOrganizationConformancePackStatusesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeOrganizationConformancePackStatusesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeOrganizationConformancePackStatusesInput, DescribeOrganizationConformancePackStatusesOutput, DescribeOrganizationConformancePackStatusesOutputError>(xAmzTarget: "StarlingDoveService.DescribeOrganizationConformancePackStatuses"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of organization conformance packs. </p>
    /// 		       <note>
    ///             <p>When you specify the limit and the next token, you receive a paginated response. </p>
    /// 			         <p>Limit and next token are not applicable if you specify organization conformance packs names. They are only applicable,
    /// 			when you request all the organization conformance packs. </p>
    ///          </note>
    public func describeOrganizationConformancePacks(input: DescribeOrganizationConformancePacksInput, completion: @escaping (SdkResult<DescribeOrganizationConformancePacksOutput, DescribeOrganizationConformancePacksOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeOrganizationConformancePacks")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeOrganizationConformancePacksInput, DescribeOrganizationConformancePacksOutput, DescribeOrganizationConformancePacksOutputError>(id: "describeOrganizationConformancePacks")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeOrganizationConformancePacksInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeOrganizationConformancePacksInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeOrganizationConformancePacksInput, DescribeOrganizationConformancePacksOutput, DescribeOrganizationConformancePacksOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeOrganizationConformancePacksInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeOrganizationConformancePacksInput, DescribeOrganizationConformancePacksOutput, DescribeOrganizationConformancePacksOutputError>(xAmzTarget: "StarlingDoveService.DescribeOrganizationConformancePacks"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of all pending aggregation requests.</p>
    public func describePendingAggregationRequests(input: DescribePendingAggregationRequestsInput, completion: @escaping (SdkResult<DescribePendingAggregationRequestsOutput, DescribePendingAggregationRequestsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describePendingAggregationRequests")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribePendingAggregationRequestsInput, DescribePendingAggregationRequestsOutput, DescribePendingAggregationRequestsOutputError>(id: "describePendingAggregationRequests")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribePendingAggregationRequestsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribePendingAggregationRequestsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribePendingAggregationRequestsInput, DescribePendingAggregationRequestsOutput, DescribePendingAggregationRequestsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribePendingAggregationRequestsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribePendingAggregationRequestsInput, DescribePendingAggregationRequestsOutput, DescribePendingAggregationRequestsOutputError>(xAmzTarget: "StarlingDoveService.DescribePendingAggregationRequests"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the details of one or more remediation configurations.</p>
    public func describeRemediationConfigurations(input: DescribeRemediationConfigurationsInput, completion: @escaping (SdkResult<DescribeRemediationConfigurationsOutput, DescribeRemediationConfigurationsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeRemediationConfigurations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeRemediationConfigurationsInput, DescribeRemediationConfigurationsOutput, DescribeRemediationConfigurationsOutputError>(id: "describeRemediationConfigurations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeRemediationConfigurationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeRemediationConfigurationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeRemediationConfigurationsInput, DescribeRemediationConfigurationsOutput, DescribeRemediationConfigurationsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeRemediationConfigurationsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeRemediationConfigurationsInput, DescribeRemediationConfigurationsOutput, DescribeRemediationConfigurationsOutputError>(xAmzTarget: "StarlingDoveService.DescribeRemediationConfigurations"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the details of one or more remediation exceptions. A detailed view of a remediation exception for a set of resources that includes an explanation of an exception and the time when the exception will be deleted.
    /// 			When you specify the limit and the next token, you receive a paginated response. </p>
    /// 		       <note>
    ///             <p>AWS Config generates a remediation exception when a problem occurs executing a remediation action to a specific resource.
    /// 				Remediation exceptions blocks auto-remediation until the exception is cleared.</p>
    /// 			         <p>When you specify the limit and the next token, you receive a paginated response. </p>
    /// 			         <p>Limit and next token are not applicable if you request resources in batch. It is only applicable, when you request all resources.</p>
    ///          </note>
    public func describeRemediationExceptions(input: DescribeRemediationExceptionsInput, completion: @escaping (SdkResult<DescribeRemediationExceptionsOutput, DescribeRemediationExceptionsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeRemediationExceptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeRemediationExceptionsInput, DescribeRemediationExceptionsOutput, DescribeRemediationExceptionsOutputError>(id: "describeRemediationExceptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeRemediationExceptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeRemediationExceptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeRemediationExceptionsInput, DescribeRemediationExceptionsOutput, DescribeRemediationExceptionsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeRemediationExceptionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeRemediationExceptionsInput, DescribeRemediationExceptionsOutput, DescribeRemediationExceptionsOutputError>(xAmzTarget: "StarlingDoveService.DescribeRemediationExceptions"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides a detailed view of a Remediation Execution for a set of resources including state, timestamps for when steps for the remediation execution occur, and any error messages for steps that have failed.
    /// 			When you specify the limit and the next token, you receive a paginated response.</p>
    public func describeRemediationExecutionStatus(input: DescribeRemediationExecutionStatusInput, completion: @escaping (SdkResult<DescribeRemediationExecutionStatusOutput, DescribeRemediationExecutionStatusOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeRemediationExecutionStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeRemediationExecutionStatusInput, DescribeRemediationExecutionStatusOutput, DescribeRemediationExecutionStatusOutputError>(id: "describeRemediationExecutionStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeRemediationExecutionStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeRemediationExecutionStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeRemediationExecutionStatusInput, DescribeRemediationExecutionStatusOutput, DescribeRemediationExecutionStatusOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeRemediationExecutionStatusInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeRemediationExecutionStatusInput, DescribeRemediationExecutionStatusOutput, DescribeRemediationExecutionStatusOutputError>(xAmzTarget: "StarlingDoveService.DescribeRemediationExecutionStatus"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the details of one or more retention configurations. If
    /// 			the retention configuration name is not specified, this action
    /// 			returns the details for all the retention configurations for that
    /// 			account.</p>
    /// 		       <note>
    /// 			         <p>Currently, AWS Config supports only one retention
    /// 				configuration per region in your account.</p>
    /// 		       </note>
    public func describeRetentionConfigurations(input: DescribeRetentionConfigurationsInput, completion: @escaping (SdkResult<DescribeRetentionConfigurationsOutput, DescribeRetentionConfigurationsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeRetentionConfigurations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeRetentionConfigurationsInput, DescribeRetentionConfigurationsOutput, DescribeRetentionConfigurationsOutputError>(id: "describeRetentionConfigurations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeRetentionConfigurationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeRetentionConfigurationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeRetentionConfigurationsInput, DescribeRetentionConfigurationsOutput, DescribeRetentionConfigurationsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeRetentionConfigurationsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeRetentionConfigurationsInput, DescribeRetentionConfigurationsOutput, DescribeRetentionConfigurationsOutputError>(xAmzTarget: "StarlingDoveService.DescribeRetentionConfigurations"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the evaluation results for the specified AWS Config
    /// 			rule for a specific resource in a rule. The results indicate which
    /// 			AWS resources were evaluated by the rule, when each resource was
    /// 			last evaluated, and whether each resource complies with the rule. </p>
    /// 		       <note>
    /// 			         <p>The results can return an empty result page. But if you
    /// 				have a <code>nextToken</code>, the results are displayed on the next
    /// 				page.</p>
    /// 		       </note>
    public func getAggregateComplianceDetailsByConfigRule(input: GetAggregateComplianceDetailsByConfigRuleInput, completion: @escaping (SdkResult<GetAggregateComplianceDetailsByConfigRuleOutput, GetAggregateComplianceDetailsByConfigRuleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAggregateComplianceDetailsByConfigRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAggregateComplianceDetailsByConfigRuleInput, GetAggregateComplianceDetailsByConfigRuleOutput, GetAggregateComplianceDetailsByConfigRuleOutputError>(id: "getAggregateComplianceDetailsByConfigRule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAggregateComplianceDetailsByConfigRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAggregateComplianceDetailsByConfigRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetAggregateComplianceDetailsByConfigRuleInput, GetAggregateComplianceDetailsByConfigRuleOutput, GetAggregateComplianceDetailsByConfigRuleOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetAggregateComplianceDetailsByConfigRuleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetAggregateComplianceDetailsByConfigRuleInput, GetAggregateComplianceDetailsByConfigRuleOutput, GetAggregateComplianceDetailsByConfigRuleOutputError>(xAmzTarget: "StarlingDoveService.GetAggregateComplianceDetailsByConfigRule"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the number of compliant and noncompliant rules for one
    /// 			or more accounts and regions in an aggregator.</p>
    /// 		       <note>
    /// 			         <p>The results can return an empty result page, but if you
    /// 				have a nextToken, the results are displayed on the next
    /// 				page.</p>
    /// 		       </note>
    public func getAggregateConfigRuleComplianceSummary(input: GetAggregateConfigRuleComplianceSummaryInput, completion: @escaping (SdkResult<GetAggregateConfigRuleComplianceSummaryOutput, GetAggregateConfigRuleComplianceSummaryOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAggregateConfigRuleComplianceSummary")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAggregateConfigRuleComplianceSummaryInput, GetAggregateConfigRuleComplianceSummaryOutput, GetAggregateConfigRuleComplianceSummaryOutputError>(id: "getAggregateConfigRuleComplianceSummary")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAggregateConfigRuleComplianceSummaryInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAggregateConfigRuleComplianceSummaryInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetAggregateConfigRuleComplianceSummaryInput, GetAggregateConfigRuleComplianceSummaryOutput, GetAggregateConfigRuleComplianceSummaryOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetAggregateConfigRuleComplianceSummaryInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetAggregateConfigRuleComplianceSummaryInput, GetAggregateConfigRuleComplianceSummaryOutput, GetAggregateConfigRuleComplianceSummaryOutputError>(xAmzTarget: "StarlingDoveService.GetAggregateConfigRuleComplianceSummary"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the count of compliant and noncompliant conformance packs across all AWS Accounts and AWS Regions in an aggregator. You can filter based on AWS Account ID or AWS Region.</p>
    /// 		       <note>
    ///             <p>The results can return an empty result page, but if you have a nextToken, the results are displayed on the next page.</p>
    ///          </note>
    public func getAggregateConformancePackComplianceSummary(input: GetAggregateConformancePackComplianceSummaryInput, completion: @escaping (SdkResult<GetAggregateConformancePackComplianceSummaryOutput, GetAggregateConformancePackComplianceSummaryOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAggregateConformancePackComplianceSummary")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAggregateConformancePackComplianceSummaryInput, GetAggregateConformancePackComplianceSummaryOutput, GetAggregateConformancePackComplianceSummaryOutputError>(id: "getAggregateConformancePackComplianceSummary")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAggregateConformancePackComplianceSummaryInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAggregateConformancePackComplianceSummaryInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetAggregateConformancePackComplianceSummaryInput, GetAggregateConformancePackComplianceSummaryOutput, GetAggregateConformancePackComplianceSummaryOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetAggregateConformancePackComplianceSummaryInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetAggregateConformancePackComplianceSummaryInput, GetAggregateConformancePackComplianceSummaryOutput, GetAggregateConformancePackComplianceSummaryOutputError>(xAmzTarget: "StarlingDoveService.GetAggregateConformancePackComplianceSummary"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the resource counts across accounts and regions that are present in your AWS Config aggregator. You can request the resource counts by providing filters and GroupByKey.</p>
    /// 		       <p>For example, if the input contains accountID 12345678910 and region us-east-1 in filters, the API returns the count of resources in account ID 12345678910 and region us-east-1.
    /// 			If the input contains ACCOUNT_ID as a GroupByKey, the API returns resource counts for all source accounts that are present in your aggregator.</p>
    public func getAggregateDiscoveredResourceCounts(input: GetAggregateDiscoveredResourceCountsInput, completion: @escaping (SdkResult<GetAggregateDiscoveredResourceCountsOutput, GetAggregateDiscoveredResourceCountsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAggregateDiscoveredResourceCounts")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAggregateDiscoveredResourceCountsInput, GetAggregateDiscoveredResourceCountsOutput, GetAggregateDiscoveredResourceCountsOutputError>(id: "getAggregateDiscoveredResourceCounts")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAggregateDiscoveredResourceCountsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAggregateDiscoveredResourceCountsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetAggregateDiscoveredResourceCountsInput, GetAggregateDiscoveredResourceCountsOutput, GetAggregateDiscoveredResourceCountsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetAggregateDiscoveredResourceCountsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetAggregateDiscoveredResourceCountsInput, GetAggregateDiscoveredResourceCountsOutput, GetAggregateDiscoveredResourceCountsOutputError>(xAmzTarget: "StarlingDoveService.GetAggregateDiscoveredResourceCounts"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns configuration item that is aggregated for your specific resource in a specific source account and region.</p>
    public func getAggregateResourceConfig(input: GetAggregateResourceConfigInput, completion: @escaping (SdkResult<GetAggregateResourceConfigOutput, GetAggregateResourceConfigOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAggregateResourceConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAggregateResourceConfigInput, GetAggregateResourceConfigOutput, GetAggregateResourceConfigOutputError>(id: "getAggregateResourceConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAggregateResourceConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAggregateResourceConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetAggregateResourceConfigInput, GetAggregateResourceConfigOutput, GetAggregateResourceConfigOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetAggregateResourceConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetAggregateResourceConfigInput, GetAggregateResourceConfigOutput, GetAggregateResourceConfigOutputError>(xAmzTarget: "StarlingDoveService.GetAggregateResourceConfig"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the evaluation results for the specified AWS Config
    /// 			rule. The results indicate which AWS resources were evaluated by the
    /// 			rule, when each resource was last evaluated, and whether each
    /// 			resource complies with the rule.</p>
    public func getComplianceDetailsByConfigRule(input: GetComplianceDetailsByConfigRuleInput, completion: @escaping (SdkResult<GetComplianceDetailsByConfigRuleOutput, GetComplianceDetailsByConfigRuleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getComplianceDetailsByConfigRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetComplianceDetailsByConfigRuleInput, GetComplianceDetailsByConfigRuleOutput, GetComplianceDetailsByConfigRuleOutputError>(id: "getComplianceDetailsByConfigRule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetComplianceDetailsByConfigRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetComplianceDetailsByConfigRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetComplianceDetailsByConfigRuleInput, GetComplianceDetailsByConfigRuleOutput, GetComplianceDetailsByConfigRuleOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetComplianceDetailsByConfigRuleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetComplianceDetailsByConfigRuleInput, GetComplianceDetailsByConfigRuleOutput, GetComplianceDetailsByConfigRuleOutputError>(xAmzTarget: "StarlingDoveService.GetComplianceDetailsByConfigRule"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the evaluation results for the specified AWS resource.
    /// 			The results indicate which AWS Config rules were used to evaluate
    /// 			the resource, when each rule was last used, and whether the resource
    /// 			complies with each rule.</p>
    public func getComplianceDetailsByResource(input: GetComplianceDetailsByResourceInput, completion: @escaping (SdkResult<GetComplianceDetailsByResourceOutput, GetComplianceDetailsByResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getComplianceDetailsByResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetComplianceDetailsByResourceInput, GetComplianceDetailsByResourceOutput, GetComplianceDetailsByResourceOutputError>(id: "getComplianceDetailsByResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetComplianceDetailsByResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetComplianceDetailsByResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetComplianceDetailsByResourceInput, GetComplianceDetailsByResourceOutput, GetComplianceDetailsByResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetComplianceDetailsByResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetComplianceDetailsByResourceInput, GetComplianceDetailsByResourceOutput, GetComplianceDetailsByResourceOutputError>(xAmzTarget: "StarlingDoveService.GetComplianceDetailsByResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the number of AWS Config rules that are compliant and
    /// 			noncompliant, up to a maximum of 25 for each.</p>
    public func getComplianceSummaryByConfigRule(input: GetComplianceSummaryByConfigRuleInput, completion: @escaping (SdkResult<GetComplianceSummaryByConfigRuleOutput, GetComplianceSummaryByConfigRuleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getComplianceSummaryByConfigRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetComplianceSummaryByConfigRuleInput, GetComplianceSummaryByConfigRuleOutput, GetComplianceSummaryByConfigRuleOutputError>(id: "getComplianceSummaryByConfigRule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetComplianceSummaryByConfigRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetComplianceSummaryByConfigRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetComplianceSummaryByConfigRuleInput, GetComplianceSummaryByConfigRuleOutput, GetComplianceSummaryByConfigRuleOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetComplianceSummaryByConfigRuleInput, GetComplianceSummaryByConfigRuleOutput, GetComplianceSummaryByConfigRuleOutputError>(xAmzTarget: "StarlingDoveService.GetComplianceSummaryByConfigRule"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the number of resources that are compliant and the
    /// 			number that are noncompliant. You can specify one or more resource
    /// 			types to get these numbers for each resource type. The maximum
    /// 			number returned is 100.</p>
    public func getComplianceSummaryByResourceType(input: GetComplianceSummaryByResourceTypeInput, completion: @escaping (SdkResult<GetComplianceSummaryByResourceTypeOutput, GetComplianceSummaryByResourceTypeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getComplianceSummaryByResourceType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetComplianceSummaryByResourceTypeInput, GetComplianceSummaryByResourceTypeOutput, GetComplianceSummaryByResourceTypeOutputError>(id: "getComplianceSummaryByResourceType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetComplianceSummaryByResourceTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetComplianceSummaryByResourceTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetComplianceSummaryByResourceTypeInput, GetComplianceSummaryByResourceTypeOutput, GetComplianceSummaryByResourceTypeOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetComplianceSummaryByResourceTypeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetComplianceSummaryByResourceTypeInput, GetComplianceSummaryByResourceTypeOutput, GetComplianceSummaryByResourceTypeOutputError>(xAmzTarget: "StarlingDoveService.GetComplianceSummaryByResourceType"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns compliance details of a conformance pack for all AWS resources that are monitered by conformance pack.</p>
    public func getConformancePackComplianceDetails(input: GetConformancePackComplianceDetailsInput, completion: @escaping (SdkResult<GetConformancePackComplianceDetailsOutput, GetConformancePackComplianceDetailsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getConformancePackComplianceDetails")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetConformancePackComplianceDetailsInput, GetConformancePackComplianceDetailsOutput, GetConformancePackComplianceDetailsOutputError>(id: "getConformancePackComplianceDetails")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetConformancePackComplianceDetailsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetConformancePackComplianceDetailsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetConformancePackComplianceDetailsInput, GetConformancePackComplianceDetailsOutput, GetConformancePackComplianceDetailsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetConformancePackComplianceDetailsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetConformancePackComplianceDetailsInput, GetConformancePackComplianceDetailsOutput, GetConformancePackComplianceDetailsOutputError>(xAmzTarget: "StarlingDoveService.GetConformancePackComplianceDetails"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns compliance details for the conformance pack based on the cumulative compliance results of all the rules in that conformance pack.</p>
    public func getConformancePackComplianceSummary(input: GetConformancePackComplianceSummaryInput, completion: @escaping (SdkResult<GetConformancePackComplianceSummaryOutput, GetConformancePackComplianceSummaryOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getConformancePackComplianceSummary")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetConformancePackComplianceSummaryInput, GetConformancePackComplianceSummaryOutput, GetConformancePackComplianceSummaryOutputError>(id: "getConformancePackComplianceSummary")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetConformancePackComplianceSummaryInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetConformancePackComplianceSummaryInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetConformancePackComplianceSummaryInput, GetConformancePackComplianceSummaryOutput, GetConformancePackComplianceSummaryOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetConformancePackComplianceSummaryInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetConformancePackComplianceSummaryInput, GetConformancePackComplianceSummaryOutput, GetConformancePackComplianceSummaryOutputError>(xAmzTarget: "StarlingDoveService.GetConformancePackComplianceSummary"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the resource types, the number of each resource type,
    /// 			and the total number of resources that AWS Config is recording in
    /// 			this region for your AWS account. </p>
    /// 		       <p class="title">
    ///             <b>Example</b>
    ///          </p>
    ///          <ol>
    ///             <li>
    /// 				           <p>AWS Config is recording three resource types in the US
    /// 					East (Ohio) Region for your account: 25 EC2 instances, 20
    /// 					IAM users, and 15 S3 buckets.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>You make a call to the
    /// 						<code>GetDiscoveredResourceCounts</code> action and
    /// 					specify that you want all resource types. </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>AWS Config returns the following:</p>
    ///
    /// 				           <ul>
    ///                   <li>
    /// 						               <p>The resource types (EC2 instances, IAM users,
    /// 							and S3 buckets).</p>
    /// 					             </li>
    ///                   <li>
    /// 						               <p>The number of each resource type (25, 20, and
    /// 							15).</p>
    /// 					             </li>
    ///                   <li>
    /// 						               <p>The total number of all resources
    /// 							(60).</p>
    /// 					             </li>
    ///                </ul>
    ///
    /// 			         </li>
    ///          </ol>
    ///
    /// 		       <p>The response is paginated. By default, AWS Config lists 100
    /// 				<a>ResourceCount</a> objects on each page. You can
    /// 			customize this number with the <code>limit</code> parameter. The
    /// 			response includes a <code>nextToken</code> string. To get the next
    /// 			page of results, run the request again and specify the string for
    /// 			the <code>nextToken</code> parameter.</p>
    ///
    /// 		       <note>
    /// 			         <p>If you make a call to the <a>GetDiscoveredResourceCounts</a> action, you might
    /// 				not immediately receive resource counts in the following
    /// 				situations:</p>
    ///
    /// 			         <ul>
    ///                <li>
    /// 					             <p>You are a new AWS Config customer.</p>
    /// 				           </li>
    ///                <li>
    /// 					             <p>You just enabled resource recording.</p>
    /// 				           </li>
    ///             </ul>
    ///
    /// 			         <p>It might take a few minutes for AWS Config to record and
    /// 				count your resources. Wait a few minutes and then retry the
    /// 					<a>GetDiscoveredResourceCounts</a> action.
    /// 			</p>
    /// 		       </note>
    public func getDiscoveredResourceCounts(input: GetDiscoveredResourceCountsInput, completion: @escaping (SdkResult<GetDiscoveredResourceCountsOutput, GetDiscoveredResourceCountsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDiscoveredResourceCounts")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDiscoveredResourceCountsInput, GetDiscoveredResourceCountsOutput, GetDiscoveredResourceCountsOutputError>(id: "getDiscoveredResourceCounts")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDiscoveredResourceCountsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDiscoveredResourceCountsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDiscoveredResourceCountsInput, GetDiscoveredResourceCountsOutput, GetDiscoveredResourceCountsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetDiscoveredResourceCountsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetDiscoveredResourceCountsInput, GetDiscoveredResourceCountsOutput, GetDiscoveredResourceCountsOutputError>(xAmzTarget: "StarlingDoveService.GetDiscoveredResourceCounts"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns detailed status for each member account within an organization for a given organization config rule.</p>
    public func getOrganizationConfigRuleDetailedStatus(input: GetOrganizationConfigRuleDetailedStatusInput, completion: @escaping (SdkResult<GetOrganizationConfigRuleDetailedStatusOutput, GetOrganizationConfigRuleDetailedStatusOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getOrganizationConfigRuleDetailedStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetOrganizationConfigRuleDetailedStatusInput, GetOrganizationConfigRuleDetailedStatusOutput, GetOrganizationConfigRuleDetailedStatusOutputError>(id: "getOrganizationConfigRuleDetailedStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetOrganizationConfigRuleDetailedStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetOrganizationConfigRuleDetailedStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetOrganizationConfigRuleDetailedStatusInput, GetOrganizationConfigRuleDetailedStatusOutput, GetOrganizationConfigRuleDetailedStatusOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetOrganizationConfigRuleDetailedStatusInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetOrganizationConfigRuleDetailedStatusInput, GetOrganizationConfigRuleDetailedStatusOutput, GetOrganizationConfigRuleDetailedStatusOutputError>(xAmzTarget: "StarlingDoveService.GetOrganizationConfigRuleDetailedStatus"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns detailed status for each member account within an organization for a given organization conformance pack.</p>
    public func getOrganizationConformancePackDetailedStatus(input: GetOrganizationConformancePackDetailedStatusInput, completion: @escaping (SdkResult<GetOrganizationConformancePackDetailedStatusOutput, GetOrganizationConformancePackDetailedStatusOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getOrganizationConformancePackDetailedStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetOrganizationConformancePackDetailedStatusInput, GetOrganizationConformancePackDetailedStatusOutput, GetOrganizationConformancePackDetailedStatusOutputError>(id: "getOrganizationConformancePackDetailedStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetOrganizationConformancePackDetailedStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetOrganizationConformancePackDetailedStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetOrganizationConformancePackDetailedStatusInput, GetOrganizationConformancePackDetailedStatusOutput, GetOrganizationConformancePackDetailedStatusOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetOrganizationConformancePackDetailedStatusInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetOrganizationConformancePackDetailedStatusInput, GetOrganizationConformancePackDetailedStatusOutput, GetOrganizationConformancePackDetailedStatusOutputError>(xAmzTarget: "StarlingDoveService.GetOrganizationConformancePackDetailedStatus"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of configuration items for the specified
    /// 			resource. The list contains details about each state of the resource
    /// 			during the specified time interval. If you specified a retention
    /// 			period to retain your <code>ConfigurationItems</code> between a
    /// 			minimum of 30 days and a maximum of 7 years (2557 days), AWS Config
    /// 			returns the <code>ConfigurationItems</code> for the specified
    /// 			retention period. </p>
    /// 		       <p>The response is paginated. By default, AWS Config returns a
    /// 			limit of 10 configuration items per page. You can customize this
    /// 			number with the <code>limit</code> parameter. The response includes
    /// 			a <code>nextToken</code> string. To get the next page of results,
    /// 			run the request again and specify the string for the
    /// 				<code>nextToken</code> parameter.</p>
    /// 		       <note>
    /// 			         <p>Each call to the API is limited to span a duration of seven
    /// 				days. It is likely that the number of records returned is
    /// 				smaller than the specified <code>limit</code>. In such cases,
    /// 				you can make another call, using the
    /// 				<code>nextToken</code>.</p>
    /// 		       </note>
    public func getResourceConfigHistory(input: GetResourceConfigHistoryInput, completion: @escaping (SdkResult<GetResourceConfigHistoryOutput, GetResourceConfigHistoryOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getResourceConfigHistory")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetResourceConfigHistoryInput, GetResourceConfigHistoryOutput, GetResourceConfigHistoryOutputError>(id: "getResourceConfigHistory")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetResourceConfigHistoryInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetResourceConfigHistoryInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetResourceConfigHistoryInput, GetResourceConfigHistoryOutput, GetResourceConfigHistoryOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetResourceConfigHistoryInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetResourceConfigHistoryInput, GetResourceConfigHistoryOutput, GetResourceConfigHistoryOutputError>(xAmzTarget: "StarlingDoveService.GetResourceConfigHistory"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the details of a specific stored query.</p>
    public func getStoredQuery(input: GetStoredQueryInput, completion: @escaping (SdkResult<GetStoredQueryOutput, GetStoredQueryOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getStoredQuery")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetStoredQueryInput, GetStoredQueryOutput, GetStoredQueryOutputError>(id: "getStoredQuery")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetStoredQueryInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetStoredQueryInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetStoredQueryInput, GetStoredQueryOutput, GetStoredQueryOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetStoredQueryInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetStoredQueryInput, GetStoredQueryOutput, GetStoredQueryOutputError>(xAmzTarget: "StarlingDoveService.GetStoredQuery"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Accepts a resource type and returns a list of resource identifiers that are aggregated for a specific resource type across accounts and regions.
    /// 			A resource identifier includes the resource type, ID, (if available) the custom resource name, source account, and source region.
    /// 			You can narrow the results to include only resources that have specific resource IDs, or a resource name, or source account ID, or source region.</p>
    /// 			      <p>For example, if the input consists of accountID 12345678910 and the region is us-east-1 for resource type <code>AWS::EC2::Instance</code> then the API returns all the EC2 instance identifiers of accountID 12345678910 and region us-east-1.</p>
    public func listAggregateDiscoveredResources(input: ListAggregateDiscoveredResourcesInput, completion: @escaping (SdkResult<ListAggregateDiscoveredResourcesOutput, ListAggregateDiscoveredResourcesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAggregateDiscoveredResources")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAggregateDiscoveredResourcesInput, ListAggregateDiscoveredResourcesOutput, ListAggregateDiscoveredResourcesOutputError>(id: "listAggregateDiscoveredResources")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAggregateDiscoveredResourcesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAggregateDiscoveredResourcesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAggregateDiscoveredResourcesInput, ListAggregateDiscoveredResourcesOutput, ListAggregateDiscoveredResourcesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListAggregateDiscoveredResourcesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListAggregateDiscoveredResourcesInput, ListAggregateDiscoveredResourcesOutput, ListAggregateDiscoveredResourcesOutputError>(xAmzTarget: "StarlingDoveService.ListAggregateDiscoveredResources"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Accepts a resource type and returns a list of resource
    /// 			identifiers for the resources of that type. A resource identifier
    /// 			includes the resource type, ID, and (if available) the custom
    /// 			resource name. The results consist of resources that AWS Config has
    /// 			discovered, including those that AWS Config is not currently
    /// 			recording. You can narrow the results to include only resources that
    /// 			have specific resource IDs or a resource name.</p>
    /// 		       <note>
    /// 			         <p>You can specify either resource IDs or a resource name, but
    /// 				not both, in the same request.</p>
    /// 		       </note>
    /// 		       <p>The response is paginated. By default, AWS Config lists 100
    /// 			resource identifiers on each page. You can customize this number
    /// 			with the <code>limit</code> parameter. The response includes a
    /// 				<code>nextToken</code> string. To get the next page of results,
    /// 			run the request again and specify the string for the
    /// 				<code>nextToken</code> parameter.</p>
    public func listDiscoveredResources(input: ListDiscoveredResourcesInput, completion: @escaping (SdkResult<ListDiscoveredResourcesOutput, ListDiscoveredResourcesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDiscoveredResources")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDiscoveredResourcesInput, ListDiscoveredResourcesOutput, ListDiscoveredResourcesOutputError>(id: "listDiscoveredResources")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDiscoveredResourcesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDiscoveredResourcesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDiscoveredResourcesInput, ListDiscoveredResourcesOutput, ListDiscoveredResourcesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListDiscoveredResourcesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListDiscoveredResourcesInput, ListDiscoveredResourcesOutput, ListDiscoveredResourcesOutputError>(xAmzTarget: "StarlingDoveService.ListDiscoveredResources"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the stored queries for a single AWS account and a single AWS Region. The default is 100. </p>
    public func listStoredQueries(input: ListStoredQueriesInput, completion: @escaping (SdkResult<ListStoredQueriesOutput, ListStoredQueriesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listStoredQueries")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListStoredQueriesInput, ListStoredQueriesOutput, ListStoredQueriesOutputError>(id: "listStoredQueries")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListStoredQueriesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListStoredQueriesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListStoredQueriesInput, ListStoredQueriesOutput, ListStoredQueriesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListStoredQueriesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListStoredQueriesInput, ListStoredQueriesOutput, ListStoredQueriesOutputError>(xAmzTarget: "StarlingDoveService.ListStoredQueries"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the tags for AWS Config resource.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutput, ListTagsForResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(xAmzTarget: "StarlingDoveService.ListTagsForResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Authorizes the aggregator account and region to collect data
    /// 			from the source account and region. </p>
    public func putAggregationAuthorization(input: PutAggregationAuthorizationInput, completion: @escaping (SdkResult<PutAggregationAuthorizationOutput, PutAggregationAuthorizationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putAggregationAuthorization")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutAggregationAuthorizationInput, PutAggregationAuthorizationOutput, PutAggregationAuthorizationOutputError>(id: "putAggregationAuthorization")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutAggregationAuthorizationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutAggregationAuthorizationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutAggregationAuthorizationInput, PutAggregationAuthorizationOutput, PutAggregationAuthorizationOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutAggregationAuthorizationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutAggregationAuthorizationInput, PutAggregationAuthorizationOutput, PutAggregationAuthorizationOutputError>(xAmzTarget: "StarlingDoveService.PutAggregationAuthorization"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds or updates an AWS Config rule for evaluating whether your
    /// 			AWS resources comply with your desired configurations.</p>
    /// 		       <p>You can use this action for custom AWS Config rules and AWS
    /// 			managed Config rules. A custom AWS Config rule is a rule that you
    /// 			develop and maintain. An AWS managed Config rule is a customizable,
    /// 			predefined rule that AWS Config provides.</p>
    /// 		       <p>If you are adding a new custom AWS Config rule, you must first
    /// 			create the AWS Lambda function that the rule invokes to evaluate
    /// 			your resources. When you use the <code>PutConfigRule</code> action
    /// 			to add the rule to AWS Config, you must specify the Amazon Resource
    /// 			Name (ARN) that AWS Lambda assigns to the function. Specify the ARN
    /// 			for the <code>SourceIdentifier</code> key. This key is part of the
    /// 				<code>Source</code> object, which is part of the
    /// 				<code>ConfigRule</code> object. </p>
    /// 		       <p>If you are adding an AWS managed Config rule, specify the
    /// 			rule's identifier for the <code>SourceIdentifier</code> key. To
    /// 			reference AWS managed Config rule identifiers, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html">About AWS Managed Config Rules</a>.</p>
    /// 		       <p>For any new rule that you add, specify the
    /// 				<code>ConfigRuleName</code> in the <code>ConfigRule</code>
    /// 			object. Do not specify the <code>ConfigRuleArn</code> or the
    /// 				<code>ConfigRuleId</code>. These values are generated by AWS
    /// 			Config for new rules.</p>
    /// 		       <p>If you are updating a rule that you added previously, you can
    /// 			specify the rule by <code>ConfigRuleName</code>,
    /// 				<code>ConfigRuleId</code>, or <code>ConfigRuleArn</code> in the
    /// 				<code>ConfigRule</code> data type that you use in this
    /// 			request.</p>
    /// 		       <p>The maximum number of rules that AWS Config supports is 150.</p>
    ///
    /// 		       <p>For information about requesting a rule limit increase, see
    /// 				<a href="http://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_config">AWS Config Limits</a> in the <i>AWS General
    /// 				Reference Guide</i>.</p>
    ///
    /// 		       <p>For more information about developing and using AWS Config
    /// 			rules, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config.html">Evaluating AWS Resource Configurations with AWS Config</a>
    /// 			in the <i>AWS Config Developer Guide</i>.</p>
    public func putConfigRule(input: PutConfigRuleInput, completion: @escaping (SdkResult<PutConfigRuleOutput, PutConfigRuleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putConfigRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutConfigRuleInput, PutConfigRuleOutput, PutConfigRuleOutputError>(id: "putConfigRule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutConfigRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutConfigRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutConfigRuleInput, PutConfigRuleOutput, PutConfigRuleOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutConfigRuleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutConfigRuleInput, PutConfigRuleOutput, PutConfigRuleOutputError>(xAmzTarget: "StarlingDoveService.PutConfigRule"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates and updates the configuration aggregator with the
    /// 			selected source accounts and regions. The source account can be
    /// 			individual account(s) or an organization.</p>
    /// 		
    /// 		       <p>
    ///             <code>accountIds</code> that are passed will be replaced with existing accounts.
    /// 			If you want to add additional accounts into the aggregator, call <code>DescribeAggregator</code> to get the previous accounts and then append new ones.</p>
    /// 		       <note>
    /// 			         <p>AWS Config should be enabled in source accounts and regions
    /// 				you want to aggregate.</p>
    /// 			
    /// 			         <p>If your source type is an organization, you must be signed in to the management account or a registered delegated administrator and all the features must be enabled in your organization.
    /// 				If the caller is a management account, AWS Config calls <code>EnableAwsServiceAccess</code> API to enable integration between AWS Config and AWS Organizations.
    /// 				If the caller is a registered delegated administrator, AWS Config calls <code>ListDelegatedAdministrators</code> API to verify whether the caller is a valid delegated administrator.</p>
    /// 			         <p>To register a delegated administrator, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/set-up-aggregator-cli.html#register-a-delegated-administrator-cli">Register a Delegated Administrator</a> in the AWS Config developer guide. </p>
    /// 		       </note>
    public func putConfigurationAggregator(input: PutConfigurationAggregatorInput, completion: @escaping (SdkResult<PutConfigurationAggregatorOutput, PutConfigurationAggregatorOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putConfigurationAggregator")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutConfigurationAggregatorInput, PutConfigurationAggregatorOutput, PutConfigurationAggregatorOutputError>(id: "putConfigurationAggregator")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationAggregatorInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationAggregatorInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutConfigurationAggregatorInput, PutConfigurationAggregatorOutput, PutConfigurationAggregatorOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationAggregatorInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutConfigurationAggregatorInput, PutConfigurationAggregatorOutput, PutConfigurationAggregatorOutputError>(xAmzTarget: "StarlingDoveService.PutConfigurationAggregator"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new configuration recorder to record the selected
    /// 			resource configurations.</p>
    /// 		       <p>You can use this action to change the role <code>roleARN</code>
    /// 			or the <code>recordingGroup</code> of an existing recorder. To
    /// 			change the role, call the action on the existing configuration
    /// 			recorder and specify a role.</p>
    /// 		       <note>
    /// 			         <p>Currently, you can specify only one configuration recorder
    /// 				per region in your account.</p>
    /// 			         <p>If <code>ConfigurationRecorder</code> does not have the
    /// 					<b>recordingGroup</b> parameter
    /// 				specified, the default is to record all supported resource
    /// 				types.</p>
    /// 		       </note>
    public func putConfigurationRecorder(input: PutConfigurationRecorderInput, completion: @escaping (SdkResult<PutConfigurationRecorderOutput, PutConfigurationRecorderOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putConfigurationRecorder")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutConfigurationRecorderInput, PutConfigurationRecorderOutput, PutConfigurationRecorderOutputError>(id: "putConfigurationRecorder")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationRecorderInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationRecorderInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutConfigurationRecorderInput, PutConfigurationRecorderOutput, PutConfigurationRecorderOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutConfigurationRecorderInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutConfigurationRecorderInput, PutConfigurationRecorderOutput, PutConfigurationRecorderOutputError>(xAmzTarget: "StarlingDoveService.PutConfigurationRecorder"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates or updates a conformance pack. A conformance pack is a collection of AWS Config rules that can be easily deployed in an account and a region and across AWS Organization.</p>
    /// 		       <p>This API creates a service linked role <code>AWSServiceRoleForConfigConforms</code> in your account.
    /// 		The service linked role is created only when the role does not exist in your account. </p>
    /// 		       <note>
    ///             <p>You must specify either the <code>TemplateS3Uri</code> or the <code>TemplateBody</code> parameter, but not both.
    /// 			If you provide both AWS Config uses the <code>TemplateS3Uri</code> parameter and ignores the <code>TemplateBody</code> parameter.</p>
    ///          </note>
    public func putConformancePack(input: PutConformancePackInput, completion: @escaping (SdkResult<PutConformancePackOutput, PutConformancePackOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putConformancePack")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutConformancePackInput, PutConformancePackOutput, PutConformancePackOutputError>(id: "putConformancePack")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutConformancePackInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutConformancePackInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutConformancePackInput, PutConformancePackOutput, PutConformancePackOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutConformancePackInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutConformancePackInput, PutConformancePackOutput, PutConformancePackOutputError>(xAmzTarget: "StarlingDoveService.PutConformancePack"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a delivery channel object to deliver configuration
    /// 			information to an Amazon S3 bucket and Amazon SNS topic.</p>
    /// 		       <p>Before you can create a delivery channel, you must create a
    /// 			configuration recorder.</p>
    /// 		       <p>You can use this action to change the Amazon S3 bucket or an
    /// 			Amazon SNS topic of the existing delivery channel. To change the
    /// 			Amazon S3 bucket or an Amazon SNS topic, call this action and
    /// 			specify the changed values for the S3 bucket and the SNS topic. If
    /// 			you specify a different value for either the S3 bucket or the SNS
    /// 			topic, this action will keep the existing value for the parameter
    /// 			that is not changed.</p>
    /// 		       <note>
    /// 			         <p>You can have only one delivery channel per region in your
    /// 				account.</p>
    /// 			
    ///
    /// 		       </note>
    public func putDeliveryChannel(input: PutDeliveryChannelInput, completion: @escaping (SdkResult<PutDeliveryChannelOutput, PutDeliveryChannelOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putDeliveryChannel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutDeliveryChannelInput, PutDeliveryChannelOutput, PutDeliveryChannelOutputError>(id: "putDeliveryChannel")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutDeliveryChannelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutDeliveryChannelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutDeliveryChannelInput, PutDeliveryChannelOutput, PutDeliveryChannelOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutDeliveryChannelInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutDeliveryChannelInput, PutDeliveryChannelOutput, PutDeliveryChannelOutputError>(xAmzTarget: "StarlingDoveService.PutDeliveryChannel"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Used by an AWS Lambda function to deliver evaluation results to
    /// 			AWS Config. This action is required in every AWS Lambda function
    /// 			that is invoked by an AWS Config rule.</p>
    public func putEvaluations(input: PutEvaluationsInput, completion: @escaping (SdkResult<PutEvaluationsOutput, PutEvaluationsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putEvaluations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutEvaluationsInput, PutEvaluationsOutput, PutEvaluationsOutputError>(id: "putEvaluations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutEvaluationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutEvaluationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutEvaluationsInput, PutEvaluationsOutput, PutEvaluationsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutEvaluationsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutEvaluationsInput, PutEvaluationsOutput, PutEvaluationsOutputError>(xAmzTarget: "StarlingDoveService.PutEvaluations"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Add or updates the evaluations for process checks.		
    /// 			This API checks if the rule is a process check when the name of the AWS Config rule is provided.</p>
    public func putExternalEvaluation(input: PutExternalEvaluationInput, completion: @escaping (SdkResult<PutExternalEvaluationOutput, PutExternalEvaluationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putExternalEvaluation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutExternalEvaluationInput, PutExternalEvaluationOutput, PutExternalEvaluationOutputError>(id: "putExternalEvaluation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutExternalEvaluationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutExternalEvaluationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutExternalEvaluationInput, PutExternalEvaluationOutput, PutExternalEvaluationOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutExternalEvaluationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutExternalEvaluationInput, PutExternalEvaluationOutput, PutExternalEvaluationOutputError>(xAmzTarget: "StarlingDoveService.PutExternalEvaluation"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds or updates organization config rule for your entire organization evaluating whether your AWS resources comply with your
    /// 			desired configurations.</p>
    /// 	        <p> Only a master account and a delegated administrator can create or update an organization config rule.
    /// 		When calling this API with a delegated administrator, you must ensure AWS Organizations
    /// 		<code>ListDelegatedAdministrator</code> permissions are added. </p>
    /// 		       <p>This API enables organization service access through the <code>EnableAWSServiceAccess</code> action and creates a service linked
    /// 			role <code>AWSServiceRoleForConfigMultiAccountSetup</code> in the master or delegated administrator account of your organization.
    /// 			The service linked role is created only when the role does not exist in the caller account.
    /// 			AWS Config verifies the existence of role with <code>GetRole</code> action.</p>
    /// 		       <p>To use this API with delegated administrator, register a delegated administrator by calling AWS Organization
    /// 			<code>register-delegated-administrator</code> for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
    /// 		       <p>You can use this action to create both custom AWS Config rules and AWS managed Config rules.
    /// 			If you are adding a new custom AWS Config rule, you must first create AWS Lambda function in the master account or a delegated
    /// 			administrator that the rule invokes to evaluate your resources.
    /// 			When you use the <code>PutOrganizationConfigRule</code> action to add the rule to AWS Config, you must
    /// 			specify the Amazon Resource Name (ARN) that AWS Lambda assigns to the function.
    /// 			If you are adding an AWS managed Config rule, specify the rule's identifier for the <code>RuleIdentifier</code> key.</p>
    /// 		       <p>The maximum number of organization config rules that AWS Config supports is 150 and 3 delegated administrator per organization. </p>
    /// 		       <note>
    ///             <p>Prerequisite: Ensure you call <code>EnableAllFeatures</code> API to enable all features in an organization.</p>
    /// 			         <p>Specify either <code>OrganizationCustomRuleMetadata</code> or <code>OrganizationManagedRuleMetadata</code>.</p>
    /// 			      </note>
    public func putOrganizationConfigRule(input: PutOrganizationConfigRuleInput, completion: @escaping (SdkResult<PutOrganizationConfigRuleOutput, PutOrganizationConfigRuleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putOrganizationConfigRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutOrganizationConfigRuleInput, PutOrganizationConfigRuleOutput, PutOrganizationConfigRuleOutputError>(id: "putOrganizationConfigRule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutOrganizationConfigRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutOrganizationConfigRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutOrganizationConfigRuleInput, PutOrganizationConfigRuleOutput, PutOrganizationConfigRuleOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutOrganizationConfigRuleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutOrganizationConfigRuleInput, PutOrganizationConfigRuleOutput, PutOrganizationConfigRuleOutputError>(xAmzTarget: "StarlingDoveService.PutOrganizationConfigRule"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deploys conformance packs across member accounts in an AWS Organization.</p>
    /// 		       <p>Only a master account and a delegated administrator can call this API.
    /// 			When calling this API with a delegated administrator, you must ensure AWS Organizations
    /// 			<code>ListDelegatedAdministrator</code> permissions are added.</p>
    /// 		       <p>This API enables organization service access for <code>config-multiaccountsetup.amazonaws.com</code>
    /// 			through the <code>EnableAWSServiceAccess</code> action and creates a
    /// 			service linked role <code>AWSServiceRoleForConfigMultiAccountSetup</code> in the master or delegated administrator account of your organization.
    /// 			The service linked role is created only when the role does not exist in the caller account.
    /// 			To use this API with delegated administrator, register a delegated administrator by calling AWS Organization
    /// 			<code>register-delegate-admin</code> for <code>config-multiaccountsetup.amazonaws.com</code>.</p>
    ///
    /// 			
    /// 			
    /// 		       <note>
    /// 			         <p>Prerequisite: Ensure you call <code>EnableAllFeatures</code> API to enable all features in an organization.</p>
    /// 			         <p>You must specify either the <code>TemplateS3Uri</code> or the <code>TemplateBody</code> parameter, but not both.
    /// 			If you provide both AWS Config uses the <code>TemplateS3Uri</code> parameter and ignores the <code>TemplateBody</code> parameter.</p>
    /// 			         <p>AWS Config sets the state of a conformance pack to CREATE_IN_PROGRESS and UPDATE_IN_PROGRESS until the conformance pack is created or updated.
    /// 				You cannot update a conformance pack while it is in this state.</p>
    /// 			         <p>You can create 50 conformance packs with 25 AWS Config rules in each pack and 3 delegated administrator per organization. </p>
    ///          </note>
    public func putOrganizationConformancePack(input: PutOrganizationConformancePackInput, completion: @escaping (SdkResult<PutOrganizationConformancePackOutput, PutOrganizationConformancePackOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putOrganizationConformancePack")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutOrganizationConformancePackInput, PutOrganizationConformancePackOutput, PutOrganizationConformancePackOutputError>(id: "putOrganizationConformancePack")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutOrganizationConformancePackInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutOrganizationConformancePackInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutOrganizationConformancePackInput, PutOrganizationConformancePackOutput, PutOrganizationConformancePackOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutOrganizationConformancePackInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutOrganizationConformancePackInput, PutOrganizationConformancePackOutput, PutOrganizationConformancePackOutputError>(xAmzTarget: "StarlingDoveService.PutOrganizationConformancePack"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds or updates the remediation configuration with a specific AWS Config rule with the
    /// 			selected target or action.
    /// 			The API creates the <code>RemediationConfiguration</code> object for the AWS Config rule.
    /// 		The AWS Config rule must already exist for you to add a remediation configuration.
    /// 		The target (SSM document) must exist and have permissions to use the target. </p>
    /// 		       <note>
    ///             <p>If you make backward incompatible changes to the SSM document,
    /// 			you must call this again to ensure the remediations can run.</p>
    /// 			         <p>This API does not support adding remediation configurations for service-linked AWS Config Rules such as Organization Config rules,
    /// 				the rules deployed by conformance packs, and rules deployed by AWS Security Hub.</p>
    ///          </note>
    public func putRemediationConfigurations(input: PutRemediationConfigurationsInput, completion: @escaping (SdkResult<PutRemediationConfigurationsOutput, PutRemediationConfigurationsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putRemediationConfigurations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutRemediationConfigurationsInput, PutRemediationConfigurationsOutput, PutRemediationConfigurationsOutputError>(id: "putRemediationConfigurations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutRemediationConfigurationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutRemediationConfigurationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutRemediationConfigurationsInput, PutRemediationConfigurationsOutput, PutRemediationConfigurationsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutRemediationConfigurationsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutRemediationConfigurationsInput, PutRemediationConfigurationsOutput, PutRemediationConfigurationsOutputError>(xAmzTarget: "StarlingDoveService.PutRemediationConfigurations"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>A remediation exception is when a specific resource is no longer considered for auto-remediation.
    /// 			This API adds a new exception or updates an existing exception for a specific resource with a specific AWS Config rule. </p>
    /// 		       <note>
    ///             <p>AWS Config generates a remediation exception when a problem occurs executing a remediation action to a specific resource.
    /// 			Remediation exceptions blocks auto-remediation until the exception is cleared.</p>
    ///          </note>
    public func putRemediationExceptions(input: PutRemediationExceptionsInput, completion: @escaping (SdkResult<PutRemediationExceptionsOutput, PutRemediationExceptionsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putRemediationExceptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutRemediationExceptionsInput, PutRemediationExceptionsOutput, PutRemediationExceptionsOutputError>(id: "putRemediationExceptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutRemediationExceptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutRemediationExceptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutRemediationExceptionsInput, PutRemediationExceptionsOutput, PutRemediationExceptionsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutRemediationExceptionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutRemediationExceptionsInput, PutRemediationExceptionsOutput, PutRemediationExceptionsOutputError>(xAmzTarget: "StarlingDoveService.PutRemediationExceptions"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Records the configuration state for the resource provided in the request.
    /// 			
    /// 			The configuration state of a resource is represented in AWS Config as Configuration Items.
    /// 			Once this API records the configuration item, you can retrieve the list of configuration items for the custom resource type using existing AWS Config APIs. </p>
    /// 		       <note>
    ///             <p>The custom resource type must be registered with AWS CloudFormation. This API accepts the configuration item registered with AWS CloudFormation.</p>
    /// 			         <p>When you call this API, AWS Config only stores configuration state of the resource provided in the request. This API does not change or remediate the configuration of the resource.
    /// 				</p>
    /// 		          <p>Write-only schema properites are not recorded as part of the published configuration item.</p>
    ///          </note>
    public func putResourceConfig(input: PutResourceConfigInput, completion: @escaping (SdkResult<PutResourceConfigOutput, PutResourceConfigOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putResourceConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutResourceConfigInput, PutResourceConfigOutput, PutResourceConfigOutputError>(id: "putResourceConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutResourceConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutResourceConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutResourceConfigInput, PutResourceConfigOutput, PutResourceConfigOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutResourceConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutResourceConfigInput, PutResourceConfigOutput, PutResourceConfigOutputError>(xAmzTarget: "StarlingDoveService.PutResourceConfig"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates and updates the retention configuration with details
    /// 			about retention period (number of days) that AWS Config stores your
    /// 			historical information. The API creates the
    /// 				<code>RetentionConfiguration</code> object and names the object
    /// 			as <b>default</b>. When you have a
    /// 				<code>RetentionConfiguration</code> object named <b>default</b>, calling the API modifies the
    /// 			default object. </p>
    /// 		       <note>
    /// 			         <p>Currently, AWS Config supports only one retention
    /// 				configuration per region in your account.</p>
    /// 		       </note>
    public func putRetentionConfiguration(input: PutRetentionConfigurationInput, completion: @escaping (SdkResult<PutRetentionConfigurationOutput, PutRetentionConfigurationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putRetentionConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutRetentionConfigurationInput, PutRetentionConfigurationOutput, PutRetentionConfigurationOutputError>(id: "putRetentionConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutRetentionConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutRetentionConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutRetentionConfigurationInput, PutRetentionConfigurationOutput, PutRetentionConfigurationOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutRetentionConfigurationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutRetentionConfigurationInput, PutRetentionConfigurationOutput, PutRetentionConfigurationOutputError>(xAmzTarget: "StarlingDoveService.PutRetentionConfiguration"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Saves a new query or updates an existing saved query. The <code>QueryName</code> must be unique for a single AWS account and a single AWS Region.
    /// 			You can create upto 300 queries in a single AWS account and a single AWS Region.</p>
    public func putStoredQuery(input: PutStoredQueryInput, completion: @escaping (SdkResult<PutStoredQueryOutput, PutStoredQueryOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putStoredQuery")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutStoredQueryInput, PutStoredQueryOutput, PutStoredQueryOutputError>(id: "putStoredQuery")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutStoredQueryInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutStoredQueryInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutStoredQueryInput, PutStoredQueryOutput, PutStoredQueryOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutStoredQueryInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutStoredQueryInput, PutStoredQueryOutput, PutStoredQueryOutputError>(xAmzTarget: "StarlingDoveService.PutStoredQuery"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Accepts a structured query language (SQL) SELECT command and an aggregator to query configuration state of AWS resources across multiple accounts and regions,
    /// 			performs the corresponding search, and returns resource configurations matching the properties.</p>
    /// 		       <p>For more information about query components, see the
    /// 			<a href="https://docs.aws.amazon.com/config/latest/developerguide/query-components.html">
    ///                <b>Query Components</b>
    ///             </a> section in the AWS Config Developer Guide.</p>
    public func selectAggregateResourceConfig(input: SelectAggregateResourceConfigInput, completion: @escaping (SdkResult<SelectAggregateResourceConfigOutput, SelectAggregateResourceConfigOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "selectAggregateResourceConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SelectAggregateResourceConfigInput, SelectAggregateResourceConfigOutput, SelectAggregateResourceConfigOutputError>(id: "selectAggregateResourceConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SelectAggregateResourceConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SelectAggregateResourceConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SelectAggregateResourceConfigInput, SelectAggregateResourceConfigOutput, SelectAggregateResourceConfigOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: SelectAggregateResourceConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<SelectAggregateResourceConfigInput, SelectAggregateResourceConfigOutput, SelectAggregateResourceConfigOutputError>(xAmzTarget: "StarlingDoveService.SelectAggregateResourceConfig"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Accepts a structured query language (SQL) <code>SELECT</code> command, performs the corresponding search, and returns resource configurations matching the properties.</p>
    /// 		       <p>For more information about query components, see the
    /// 			<a href="https://docs.aws.amazon.com/config/latest/developerguide/query-components.html">
    ///                <b>Query Components</b>
    ///             </a> section in the AWS Config Developer Guide.</p>
    public func selectResourceConfig(input: SelectResourceConfigInput, completion: @escaping (SdkResult<SelectResourceConfigOutput, SelectResourceConfigOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "selectResourceConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SelectResourceConfigInput, SelectResourceConfigOutput, SelectResourceConfigOutputError>(id: "selectResourceConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SelectResourceConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SelectResourceConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SelectResourceConfigInput, SelectResourceConfigOutput, SelectResourceConfigOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: SelectResourceConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<SelectResourceConfigInput, SelectResourceConfigOutput, SelectResourceConfigOutputError>(xAmzTarget: "StarlingDoveService.SelectResourceConfig"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Runs an on-demand evaluation for the specified AWS Config rules
    /// 			against the last known configuration state of the resources. Use
    /// 				<code>StartConfigRulesEvaluation</code> when you want to test
    /// 			that a rule you updated is working as expected.
    /// 				<code>StartConfigRulesEvaluation</code> does not re-record the
    /// 			latest configuration state for your resources. It re-runs an
    /// 			evaluation against the last known state of your resources. </p>
    /// 		       <p>You can specify up to 25 AWS Config rules per request. </p>
    ///
    /// 		
    /// 		       <p>An existing <code>StartConfigRulesEvaluation</code> call for
    /// 			the specified rules must complete before you can call the API again.
    /// 			If you chose to have AWS Config stream to an Amazon SNS topic, you
    /// 			will receive a <code>ConfigRuleEvaluationStarted</code> notification
    /// 			when the evaluation starts.</p>
    /// 		       <note>
    /// 			         <p>You don't need to call the
    /// 					<code>StartConfigRulesEvaluation</code> API to run an
    /// 				evaluation for a new rule. When you create a rule, AWS Config
    /// 				evaluates your resources against the rule automatically.
    /// 			</p>
    /// 		       </note>
    /// 		       <p>The <code>StartConfigRulesEvaluation</code> API is useful if
    /// 			you want to run on-demand evaluations, such as the following
    /// 			example:</p>
    /// 		       <ol>
    ///             <li>
    /// 				           <p>You have a custom rule that evaluates your IAM
    /// 					resources every 24 hours.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>You update your Lambda function to add additional
    /// 					conditions to your rule.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Instead of waiting for the next periodic evaluation,
    /// 					you call the <code>StartConfigRulesEvaluation</code>
    /// 					API.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>AWS Config invokes your Lambda function and evaluates
    /// 					your IAM resources.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Your custom rule will still run periodic evaluations
    /// 					every 24 hours.</p>
    /// 			         </li>
    ///          </ol>
    public func startConfigRulesEvaluation(input: StartConfigRulesEvaluationInput, completion: @escaping (SdkResult<StartConfigRulesEvaluationOutput, StartConfigRulesEvaluationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startConfigRulesEvaluation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartConfigRulesEvaluationInput, StartConfigRulesEvaluationOutput, StartConfigRulesEvaluationOutputError>(id: "startConfigRulesEvaluation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartConfigRulesEvaluationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartConfigRulesEvaluationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartConfigRulesEvaluationInput, StartConfigRulesEvaluationOutput, StartConfigRulesEvaluationOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: StartConfigRulesEvaluationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<StartConfigRulesEvaluationInput, StartConfigRulesEvaluationOutput, StartConfigRulesEvaluationOutputError>(xAmzTarget: "StarlingDoveService.StartConfigRulesEvaluation"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Starts recording configurations of the AWS resources you have
    /// 			selected to record in your AWS account.</p>
    /// 		       <p>You must have created at least one delivery channel to
    /// 			successfully start the configuration recorder.</p>
    public func startConfigurationRecorder(input: StartConfigurationRecorderInput, completion: @escaping (SdkResult<StartConfigurationRecorderOutput, StartConfigurationRecorderOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startConfigurationRecorder")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartConfigurationRecorderInput, StartConfigurationRecorderOutput, StartConfigurationRecorderOutputError>(id: "startConfigurationRecorder")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartConfigurationRecorderInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartConfigurationRecorderInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartConfigurationRecorderInput, StartConfigurationRecorderOutput, StartConfigurationRecorderOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: StartConfigurationRecorderInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<StartConfigurationRecorderInput, StartConfigurationRecorderOutput, StartConfigurationRecorderOutputError>(xAmzTarget: "StarlingDoveService.StartConfigurationRecorder"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Runs an on-demand remediation for the specified AWS Config rules against the last known remediation configuration. It runs an execution against the current state of your resources. Remediation execution is asynchronous.</p>
    /// 			      <p>You can specify up to 100 resource keys per request. An existing StartRemediationExecution call for the specified resource keys must complete before you can call the API again.</p>
    public func startRemediationExecution(input: StartRemediationExecutionInput, completion: @escaping (SdkResult<StartRemediationExecutionOutput, StartRemediationExecutionOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startRemediationExecution")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartRemediationExecutionInput, StartRemediationExecutionOutput, StartRemediationExecutionOutputError>(id: "startRemediationExecution")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartRemediationExecutionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartRemediationExecutionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartRemediationExecutionInput, StartRemediationExecutionOutput, StartRemediationExecutionOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: StartRemediationExecutionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<StartRemediationExecutionInput, StartRemediationExecutionOutput, StartRemediationExecutionOutputError>(xAmzTarget: "StarlingDoveService.StartRemediationExecution"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Stops recording configurations of the AWS resources you have selected to record in your AWS account.</p>
    public func stopConfigurationRecorder(input: StopConfigurationRecorderInput, completion: @escaping (SdkResult<StopConfigurationRecorderOutput, StopConfigurationRecorderOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "stopConfigurationRecorder")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StopConfigurationRecorderInput, StopConfigurationRecorderOutput, StopConfigurationRecorderOutputError>(id: "stopConfigurationRecorder")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StopConfigurationRecorderInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StopConfigurationRecorderInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StopConfigurationRecorderInput, StopConfigurationRecorderOutput, StopConfigurationRecorderOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: StopConfigurationRecorderInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<StopConfigurationRecorderInput, StopConfigurationRecorderOutput, StopConfigurationRecorderOutputError>(xAmzTarget: "StarlingDoveService.StopConfigurationRecorder"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Associates the specified tags to a resource with the specified resourceArn. If existing tags on a resource are not specified in the request parameters, they are not changed.
    /// 			When a resource is deleted, the tags associated with that resource are deleted as well.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutput, TagResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutput, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutput, TagResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<TagResourceInput, TagResourceOutput, TagResourceOutputError>(xAmzTarget: "StarlingDoveService.TagResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes specified tags from a resource.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutput, UntagResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "config.\(config.region).amazonaws.com")
                      .withSigningName(value: "config")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(xAmzTarget: "StarlingDoveService.UntagResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
