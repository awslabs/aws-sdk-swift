// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ConfigRuleEvaluationStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleArn = "ConfigRuleArn"
        case configRuleId = "ConfigRuleId"
        case configRuleName = "ConfigRuleName"
        case firstActivatedTime = "FirstActivatedTime"
        case firstEvaluationStarted = "FirstEvaluationStarted"
        case lastDeactivatedTime = "LastDeactivatedTime"
        case lastErrorCode = "LastErrorCode"
        case lastErrorMessage = "LastErrorMessage"
        case lastFailedEvaluationTime = "LastFailedEvaluationTime"
        case lastFailedInvocationTime = "LastFailedInvocationTime"
        case lastSuccessfulEvaluationTime = "LastSuccessfulEvaluationTime"
        case lastSuccessfulInvocationTime = "LastSuccessfulInvocationTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleArn = configRuleArn {
            try encodeContainer.encode(configRuleArn, forKey: .configRuleArn)
        }
        if let configRuleId = configRuleId {
            try encodeContainer.encode(configRuleId, forKey: .configRuleId)
        }
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let firstActivatedTime = firstActivatedTime {
            try encodeContainer.encode(firstActivatedTime.timeIntervalSince1970, forKey: .firstActivatedTime)
        }
        if firstEvaluationStarted != false {
            try encodeContainer.encode(firstEvaluationStarted, forKey: .firstEvaluationStarted)
        }
        if let lastDeactivatedTime = lastDeactivatedTime {
            try encodeContainer.encode(lastDeactivatedTime.timeIntervalSince1970, forKey: .lastDeactivatedTime)
        }
        if let lastErrorCode = lastErrorCode {
            try encodeContainer.encode(lastErrorCode, forKey: .lastErrorCode)
        }
        if let lastErrorMessage = lastErrorMessage {
            try encodeContainer.encode(lastErrorMessage, forKey: .lastErrorMessage)
        }
        if let lastFailedEvaluationTime = lastFailedEvaluationTime {
            try encodeContainer.encode(lastFailedEvaluationTime.timeIntervalSince1970, forKey: .lastFailedEvaluationTime)
        }
        if let lastFailedInvocationTime = lastFailedInvocationTime {
            try encodeContainer.encode(lastFailedInvocationTime.timeIntervalSince1970, forKey: .lastFailedInvocationTime)
        }
        if let lastSuccessfulEvaluationTime = lastSuccessfulEvaluationTime {
            try encodeContainer.encode(lastSuccessfulEvaluationTime.timeIntervalSince1970, forKey: .lastSuccessfulEvaluationTime)
        }
        if let lastSuccessfulInvocationTime = lastSuccessfulInvocationTime {
            try encodeContainer.encode(lastSuccessfulInvocationTime.timeIntervalSince1970, forKey: .lastSuccessfulInvocationTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let configRuleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleArn)
        configRuleArn = configRuleArnDecoded
        let configRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleId)
        configRuleId = configRuleIdDecoded
        let lastSuccessfulInvocationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastSuccessfulInvocationTime)
        lastSuccessfulInvocationTime = lastSuccessfulInvocationTimeDecoded
        let lastFailedInvocationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastFailedInvocationTime)
        lastFailedInvocationTime = lastFailedInvocationTimeDecoded
        let lastSuccessfulEvaluationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastSuccessfulEvaluationTime)
        lastSuccessfulEvaluationTime = lastSuccessfulEvaluationTimeDecoded
        let lastFailedEvaluationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastFailedEvaluationTime)
        lastFailedEvaluationTime = lastFailedEvaluationTimeDecoded
        let firstActivatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .firstActivatedTime)
        firstActivatedTime = firstActivatedTimeDecoded
        let lastDeactivatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastDeactivatedTime)
        lastDeactivatedTime = lastDeactivatedTimeDecoded
        let lastErrorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastErrorCode)
        lastErrorCode = lastErrorCodeDecoded
        let lastErrorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastErrorMessage)
        lastErrorMessage = lastErrorMessageDecoded
        let firstEvaluationStartedDecoded = try containerValues.decode(Bool.self, forKey: .firstEvaluationStarted)
        firstEvaluationStarted = firstEvaluationStartedDecoded
    }
}
